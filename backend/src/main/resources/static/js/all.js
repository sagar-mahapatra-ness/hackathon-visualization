/*
 ShieldX Networks Inc. CONFIDENTIAL
 ----------------------------------
 *
 Copyright (c) 2016 ShieldX Networks Inc.
 All Rights Reserved.
 *
 NOTICE: All information contained herein is, and remains
 the property of ShieldX Networks Incorporated and its suppliers,
 if any. The intellectual and technical concepts contained
 herein are proprietary to ShieldX Networks Incorporated
 and its suppliers and may be covered by U.S. and Foreign Patents,
 patents in process, and are protected by trade secret or copyright law.
 Dissemination of this information or reproduction of this material
 is strictly forbidden unless prior written permission is obtained
 from ShieldX Networks Incorporated.
 */

angular.module('shieldxApp.config', []).
        value('defaultLang', 'en').
        constant('dataServerPath', 'http://localhost:9617/');

/*
 ShieldX Networks Inc. CONFIDENTIAL
 ----------------------------------
 *
 Copyright (c) 2016 ShieldX Networks Inc.
 All Rights Reserved.
 *
 NOTICE: All information contained herein is, and remains
 the property of ShieldX Networks Incorporated and its suppliers,
 if any. The intellectual and technical concepts contained
 herein are proprietary to ShieldX Networks Incorporated
 and its suppliers and may be covered by U.S. and Foreign Patents,
 patents in process, and are protected by trade secret or copyright law.
 Dissemination of this information or reproduction of this material
 is strictly forbidden unless prior written permission is obtained
 from ShieldX Networks Incorporated.
 */
var angular;

WebFontConfig = {
    google: { families: [ 'Roboto::latin' ] }
};
(function() {
    var wf = document.createElement('script');
    wf.src = 'https://ajax.googleapis.com/ajax/libs/webfont/1/webfont.js';
    wf.type = 'text/javascript';
    wf.async = 'true';
    var s = document.getElementsByTagName('script')[0];
    s.parentNode.insertBefore(wf, s);
})();

angular
    .module('shieldxApp', [
        'ngMaterial', 
        'ngMessages',
        'ui.router', 
        'md.data.table',
        'shieldxApp.config',
        'restangular',
        'pascalprecht.translate',
        'ngAnimate',
        'vAccordion',
        'dragularModule',
        'ngStorage',
        'gridster',
        'mdPickers',
        'ngSanitize',
        'ngCsv','ngWebworker'])
    .config(function($mdThemingProvider, $mdIconProvider){
        "ngInject";

        var shieldXPrimary = {
            '50': '#fbfbfb',
            '100': '#fbfbfb', // light-grey 3
            '200': '#f7f7f7', // light-grey 2
            '300': '#ff2f3a',
            '400': '#eeeeee', // light-grey 1
            '500': '#fb000d',
            '600': '#6d6e71', // slate-grey
            '700': '#c8000a',
            '800': '#ae0009',
            '900': '#950008',
            'A100': '#ff959a',
            'A200': '#ffaeb3',
            'A400': '#ffc8cb',
            'A700': '#7b0006'
        };
        $mdThemingProvider.definePalette('shieldXPrimary',shieldXPrimary);

            var shieldXAccent = {
                '50': '#000a08',
                '100': '#00231d',
                '200': '#003d31',
                '300': '#005646',
                '400': '#4a90e2', // faded-orange
                '500': '#00896f',
                '600': '#00bc97',
                '700': '#00d6ac',
                '800': '#00efc0',
                '900': '#0affcf',
                'A100': '#f3c444', // maize
                'A200': '#01bcb1', // turquoise
                'A400': '#4a90e2', // tomato
                'A700': '#4a90e2'
            };
            $mdThemingProvider.definePalette('shieldXAccent', shieldXAccent);

        var shieldXWarn = {
            '50': '#ffb280',
            '100': '#ffa266',
            '200': '#ff934d',
            '300': '#ff8333',
            '400': '#e74c3c', // tomato 
            '500': '#ff6400',
            '600': '#ee1c25', // pinkish-red
            '700': '#cc5000',
            '800': '#b34600',
            '900': '#993c00',
            'A100': '#ffc199',
            'A200': '#ffd1b3',
            'A400': '#ffe0cc',
            'A700': '#e74c3c'
            };
        $mdThemingProvider.definePalette('shieldXWarn',shieldXWarn);

        $mdThemingProvider.theme('default')
            .primaryPalette('shieldXPrimary', {
                'default': '400', // light-grey 1
                'hue-1': '100', // light-grey 3
                'hue-2': '200', // light-grey 2
                'hue-3': '600' // slate-grey
            })
            .accentPalette('shieldXAccent', {
                'default' : '400',
                'hue-1': 'A100', 
                'hue-2': 'A200', 
                'hue-3': 'A400'
            })
            .warnPalette('shieldXWarn', {
                'default' : '400',
                'hue-1': '600',
            });

        // $mdThemingProvider.theme('default')
        // .primaryPalette('grey');
    })
    .config(['$translateProvider', function($translateProvider) {
        $translateProvider.useSanitizeValueStrategy('escape');
        $translateProvider.useStaticFilesLoader({
          prefix: '/languages/locale-',
          suffix: '.json'
        });

        $translateProvider.preferredLanguage('us');
    }])
    .config(function($stateProvider, $urlRouterProvider, $httpProvider) {
        "ngInject";

       

        $stateProvider.state('home', {
            controller: 'homeCtr',
            abstract: true,
            controllerAs: 'homeCtr',
            templateUrl: 'core/components/home.html'
        });

         $stateProvider.state('landingpage', {
            url: '/landingpage',
            controller: 'landingPageCtr',
            controllerAs: 'landingPageCtr',
            templateUrl: 'core/components/landingpage/landingpage.html'
        });

        $stateProvider.state('home.quickSetup',{
            url: '/quickSetup',
            controller: 'quickSetupCtr',
            controllerAs: 'quickSetupCtr',
            templateUrl: 'core/components/administration/quick-setup/quick-setup.html'
        });

        $stateProvider.state('home.aboutUs',{
            url: '/aboutUs',
            controller: 'aboutUsCtr',
            controllerAs: 'aboutUsCtr',
            templateUrl: 'core/components/aboutus/aboutUS.html'
        });

        $stateProvider.state('home.infrastructureConnectors',{
            url: '/infrastructureConnectors',
            controller: 'infrastructureConnectorsCtr',
            controllerAs: 'infrastructureConnectorsCtr',
            templateUrl: 'core/components/administration/infrastructure-connectors/infrastructure-connectors.html'
        });

        $stateProvider.state('home.ipPools',{
            url: '/ipPools',
            controller: 'ipPoolsCtr',
            controllerAs: 'ipPoolsCtr',
            templateUrl: 'core/components/administration/ip-pools/ip-pools.html'
        });

        $stateProvider.state('home.ipPoolId', {
            url: "/ipPools/:poolId",
            controller: 'ipPoolsCtr',
            controllerAs: 'ipPoolsCtr',
            templateUrl: 'core/components/administration/ip-pools/ip-pools.html'
        });
        
        $stateProvider.state('home.vlanPools',{
            url: '/vlanPools',
            controller: 'vlanPoolsCtr',
            controllerAs: 'vlanPoolsCtr',
            templateUrl: 'core/components/administration/vlan-pools/vlan-pools.html'
        });

        $stateProvider.state('home.vlanPoolId', {
            url: "/vlanPools/:vlanId",
            controller: 'vlanPoolsCtr',
            controllerAs: 'vlanPoolsCtr',
            templateUrl: 'core/components/administration/vlan-pools/vlan-pools.html'
        });
        
        $stateProvider.state('home.deploymentSpecifications',{
            url: '/deploymentSpecifications',
            controller: 'deploymentSpecificationsCtr',
            controllerAs: 'deploymentSpecificationsCtr',
            templateUrl: 'core/components/administration/deployment-specifications/deployment-specifications.html'
        });

        $stateProvider.state('home.deploymentSpecificationById',{
            url: '/deploymentSpecifications/:deploySpecId',
            controller: 'deploymentSpecificationsCtr',
            controllerAs: 'deploymentSpecificationsCtr',
            templateUrl: 'core/components/administration/deployment-specifications/deployment-specifications.html'
        });

        $stateProvider.state('home.virtualChassis',{
            url: '/virtualChassis',
            controller: 'listVirtualChassisCtr',
            controllerAs: 'listVirtualChassisCtr',
            templateUrl: 'core/components/administration/virtual-chassis/virtual-chassis.html'
        });

        $stateProvider.state('home.managementPlane',{
            url: '/managementPlane',
            controller: 'managementPlaneCtr',
            controllerAs: 'managementPlaneCtr',
            templateUrl: 'core/components/administration/management-plane/management-plane.html'
        });

        $stateProvider.state('home.resourceGroups',{
            url: '/resourceGroups',
            controller: 'resourceGroupsCtr',
            controllerAs: 'resourceGroupsCtr',
            templateUrl: 'core/components/administration/resource-groups/resource-groups.html'
        });
        
        $stateProvider.state('home.resourceGroupById',{
            url: '/resourceGroups/:rgId',
            controller: 'resourceGroupsCtr',
            controllerAs: 'resourceGroupsCtr',
            templateUrl: 'core/components/administration/resource-groups/resource-groups.html'
        });

       /* $stateProvider.state('home.managePolicies',{
            url: '/managePolicies',
            controller: 'managePoliciesCtr',
            controllerAs: 'managePoliciesCtr',
            templateUrl: 'core/components/administration/manage-policies/manage-policies.html'
        });*/

        $stateProvider.state('home.shieldxUpdates',{
            url: '/shieldxUpdates',
            controller: 'shieldxUpdatesCtr',
            controllerAs: 'shieldxUpdatesCtr',
            templateUrl: 'core/components/administration/shieldx-updates/shieldx-updates.html'
        });

        $stateProvider.state('home.integrations',{
            url: '/integrations',
            controller: 'integrationsCtr',
            controllerAs: 'integrationsCtr',
            templateUrl: 'core/components/administration/integrations/integrations.html'
        });

        $stateProvider.state('home.logs',{
            url: '/logs',
            controller: 'logsCtr',
            controllerAs: 'logsCtr',
            templateUrl: 'core/components/administration/logs/logs.html'
        });

        $stateProvider.state('home.networks',{
            url: '/networks',
            controller: 'networksCtr',
            controllerAs: 'networksCtr',
            templateUrl: 'core/components/networks/networks.html'
        });

        $stateProvider.state('home.dashboard',{
            url: '/dashboard',
            controller: 'dashboardCtr',
            controllerAs: 'dashboardCtr',
            templateUrl: 'core/components/dashboard/dashboard.html'
        });

        $stateProvider.state('home.EventCorrelationExplorer',{
            url: '/analysis',
            controller: 'analysisCtr',
            controllerAs: 'analysisCtr',
            templateUrl: 'core/components/analysis/analysis.html'
        });

        $stateProvider.state('home.sslkeys',{
            url: '/sslkeys',
            controller: 'sslkeysCtr',
            controllerAs: 'sslkeysCtr',
            templateUrl: 'core/components/administration/sslkeys/sslkeys.html'
        });

        $stateProvider.state('home.license', {
            url: '/license',
            controller: 'licenseCtr',
            controllerAs: 'licenseCtr',
            templateUrl: 'core/components/administration/license/license.html'
        });

        $stateProvider.state('home.reports', {
            url: '/reports',
            controller: 'reportsCtr',
            controllerAs: 'reportsCtr',
            templateUrl: 'core/components/administration/reports/report-configuration.html'
        });

        $stateProvider.state('home.setuptls', {
            url: '/setuptls',
            abstract:true,
            controller: 'setupTlsCtr',
            controllerAs: 'setupTlsCtr',
            templateUrl: 'core/components/administration/sslkeys/setup-tls.html'
        });
        $stateProvider.state('home.setuptls.tlsdecryption', {
            url: '/tlsdecryption',
            controller: 'tlsDecryptionCtr',
            templateUrl: 'core/components/administration/sslkeys/tlsdecryption.html',
        });
        
        $stateProvider.state('home.setuptls.tlsdecryption.inboundkeys', {
            url: '/inboundkeys',
            views: {
                'inboundwebserverkeys': {
                    controller: 'sslkeysCtr',
                    controllerAs: 'sslkeysCtr',
                    templateUrl: 'core/components/administration/sslkeys/sslkeys.html'
                }
             },
            data: {
                 'selectedTab': 0
             },
        });        
        $stateProvider.state('home.setuptls.tlsdecryption.outboundkeys', {
            url: '/outboundkeys',
            views: {
                'resigningcerts': {
                    controller: 'resigningkeysCtr',
                    controllerAs: 'resigningkeysCtr',
                    templateUrl: 'core/components/administration/sslkeys/resigningkeys.html'
                }
             },
            data: {
                 'selectedTab': 1
             },
        }); 


        $stateProvider.state('home.myLocker',{
            url: '/myLocker',
            controller: 'myLockerCtr',
            controllerAs: 'myLockerCtr',
            templateUrl: 'core/components/my-locker/my-locker.html'
        });

		
        $stateProvider.state('home.notification', {
            url: '/notification',
            abstract:true,
            controller: 'notificationCtr',
            controllerAs: 'notificationCtr',
            templateUrl: 'core/components/administration/notification/notification.html'
        });		
        $stateProvider.state('home.notification.settings', {
            url: '/notificationSettingsCtr',
            controller: 'notificationSettingsCtr',
            templateUrl: 'core/components/administration/notification/notification-settings.html',
        });

        $stateProvider.state('home.notification.settings.syslog', {
            url: '/syslog',
            views: {
                'syslognotificationprofile': {
                    controller: 'syslogforwarderCtr',
                    controllerAs: 'syslogforwarderCtr',
                    templateUrl: 'core/components/administration/notification/syslogprofiles.html'
                }
             },
            data: {
                 'selectedTab': 0
             },
        });        
        $stateProvider.state('home.notification.settings.email', {
            url: '/email',
            views: {
                'emailnotificationprofile': {
                    controller: 'emailnotificationCtr',
                    controllerAs: 'emailnotificationCtr',
                    templateUrl: 'core/components/administration/notification/email-notification.html'
                }
             },
            data: {
                 'selectedTab': 1
             },
        }); 

		
        $stateProvider.state('home.setup', {
            url: '/setup',
            abstract:true,
            controller: 'setupCtr',
            controllerAs: 'setupCtr',
            templateUrl: 'core/components/administration/setup/setup.html'
        });
        $stateProvider.state('home.setup.settings', {
            url: '/settings',
            controller: 'settingsCtr',
            templateUrl: 'core/components/administration/setup/settings.html',
        });
        
        $stateProvider.state('home.setup.settings.smbserver', {
            url: '/smbserver',
            views: {
                'smbserversettings': {
                    controller: 'smbServerSettingsCtr',
                    controllerAs: 'smbServerSettingsCtr',
                    templateUrl: 'core/components/administration/setup/smbserver-settings.html'
                }
             },
            data: {
                 'selectedTab': 0
             },
        });        
        $stateProvider.state('home.setup.settings.syslog', {
            url: '/syslog',
            views: {
                'syslogserversettings': {
                    controller: 'syslogServerSettingsCtr',
                    controllerAs: 'syslogServerSettingsCtr',
                    templateUrl: 'core/components/administration/setup/syslogservers.html'
                }
             },
            data: {
                 'selectedTab': 1
             },
        });        
        $stateProvider.state('home.setup.settings.emailserver', {
            url: '/emailserver',
            views: {
                'emailserversettings': {
                    controller: 'emailServerSettingsCtr',
                    controllerAs: 'emailServerSettingsCtr',
                    templateUrl: 'core/components/administration/setup/emailserver-settings.html'
                }
             },
            data: {
                 'selectedTab': 2
             },
        }); 
        $stateProvider.state('home.setup.settings.ldapserver', {
            url: '/ldapserver',
            views: {
                'ldapserversettings': {
                    controller: 'ldapServerSettingsCtr',
                    controllerAs: 'ldapServerSettingsCtr',
                    templateUrl: 'core/components/administration/setup/ldapserver-settings.html'
                }
             },
            data: {
                 'selectedTab': 3
             },
        }); 

        $stateProvider.state('home.users',{
            url: '/users',
            controller: 'usersCtr',
            controllerAs: 'usersCtr',
            templateUrl: 'core/components/administration/users/users.html'
        });      


        $stateProvider.state('home.maintenance', {
            url: '/maintenance',
            abstract:true,
            controller: 'maintenanceCtr',
            controllerAs: 'maintenanceCtr',
            templateUrl: 'core/components/administration/maintenance/maintenance.html'
        });
        $stateProvider.state('home.maintenance.maintenancetasks', {
            url: '/maintenancetasks',
            controller: 'maintenanceTasksCtr',
            templateUrl: 'core/components/administration/maintenance/maintenance-tasks.html',
        });
        
        $stateProvider.state('home.maintenance.maintenancetasks.backup', {
            url: '/backupnow',
            views: {
                'backupnow': {
                    controller: 'backupRestoreCtr',
                    controllerAs: 'backupRestoreCtr',
                    templateUrl: 'core/components/administration/maintenance/backupconfigdata.html'
                }
            },
            data:{
                'selectedTab': 0
            }
        });
        $stateProvider.state('home.maintenance.maintenancetasks.schedulebackup', {
            url: '/schedule-backup',
            views: {
               'schedulebackup': {
                    controller: 'backupSchedulerCtr',
                    controllerAs: 'backupSchedulerCtr',
                    templateUrl: 'core/components/administration/maintenance/backup-scheduler.html'
                }
            },
            data: {
                 'selectedTab': 1
            },
        });
        $stateProvider.state('home.maintenance.maintenancetasks.restore', {
            url: '/restore',
            views: {
                 'restorebackup': {
                    controller: 'backupRestoreCtr',
                    controllerAs: 'backupRestoreCtr',
                    templateUrl: 'core/components/administration/maintenance/restore-data.html'
                }
            },
            data: {
                 'selectedTab': 2
            },
        });
        /*
        $stateProvider.state('home.maintenance.maintenancetasks.schedulepruning', {
            url: '/schedule-pruning',
            views: {
                'schedulepruning': {
                    controller: 'pruningSchedulerCtr',
                    controllerAs: 'pruningSchedulerCtr',
                    templateUrl: 'core/components/administration/maintenance/pruning-scheduler.html'
                }
             },
            data: {
                 'selectedTab': 3
             },
        });
        */
        $stateProvider.state('home.maintenance.maintenancetasks.autocontentdownload', {
            url: '/autocontentdownload',
            views: {
                'autocontentdownload': {
                    controller: 'contentDownloadSchedulerCtr',
                    controllerAs: 'contentDownloadSchedulerCtr',
                    templateUrl: 'core/components/administration/maintenance/content-scheduler.html'
                }
             },
            data: {
                 'selectedTab': 3
             },
        });

        $stateProvider.state('home.policy', {
            url: '/policy',
            abstract:true,
            controller: 'policyCtr',
            controllerAs: 'policyCtr',
            templateUrl: 'core/components/administration/policy/policy.html'
        });
        $stateProvider.state('home.policy.policylist', {
            url: '/policies',
            controller: 'policyListCtrl',
            templateUrl: 'core/components/administration/policy/policy-list.html',
        });
        /*newPolicy  and duplicated variables will be usefull to distigiush between newly created policies*/
        $stateProvider.state('home.policy.policylist.malware', {
            url: '/malwarePolicy/:newPolicy/:duplicated',
            views: {
                'malware': {
                    controller: 'malwarePolicyCtr',
                    controllerAs: 'malwarePolicyCtr',
                    templateUrl: 'core/components/administration/policy/malware/malware.html'
                }
            },
            data:{
                'selectedTab': 2
            }
        });
        $stateProvider.state('home.policy.policylist.accesscontrol', {
            url: '/accesscontrolepolicy/:newPolicy/:duplicated',
            views: {
               'accesscontrol': {
                    controller: 'accessPolicyCtr',
                    controllerAs: 'accessPolicyCtr',
                    templateUrl: 'core/components/administration/policy/acl/access-policy.html'
                }
            },
            data: {
                 'selectedTab': 0
            },
        });
        $stateProvider.state('home.policy.policylist.threatdetection', {
            url: '/threatdetection/:newPolicy/:duplicated',
            views: {
                 'threatdetection': {
                     controller: 'threatDetectionCtr',
                     controllerAs: 'threatDetectionCtr',
                     templateUrl: 'core/components/administration/policy/threat-detection.html'
                 }
             },
            data: {
                 'selectedTab': 1
             },
        });

        $stateProvider.state('home.policy.policylist.securitypolicyset', {
            url: '/securitypolicyset/:newPolicy/:duplicated',
            views: {
                 'securitypolicyset': {
                     controller: 'spsPolicyListCtr',
                     controllerAs: 'spsPolicyListCtr',
                     templateUrl: 'core/components/administration/policy/sps-policy-list.html'
                 }
             },
            data: {
                 'selectedTab': 3
             },
        });

        $stateProvider.state('home.policy.policylist.globalthreat', {
            url: '/globalthreat',
            views: {
                 'globalthreat': {
                     controller: 'globalThreatCtr',
                     controllerAs: 'globalThreatCtr',
                     templateUrl: 'core/components/administration/policy/global/global-threat.html'
                 }
             },
            data: {
                 'selectedTab': 4
             },
        });

        $stateProvider.state('home.policy.threatdetectiondetail', {
            url: '/threatdetectiondetails/:policyId',
            templateUrl: 'core/components/administration/policy/threatdetection-details.html',
            controller: 'threatDetectionDetailCtr',
            params:{tenantData:null, policyobject:null,existingrules: null}

        });
        $stateProvider.state('home.policy.addthreatdetection', {
            url: '/threatdetection/addnew',
            templateUrl: 'core/components/administration/policy/threatdetection-new.html',
            controller: 'newthreatDetectionCtr',
            params : { existingrules: null, policyobject:null}
        });
        $stateProvider.state('home.policy.addthreatdetectionrule', {
            url: '/threatdetection/addnewrule',
            templateUrl: 'core/components/administration/policy/addnewrule.html',
            controller: 'newthreatRuleCtr',
            params : { ruleobject: null, policyobject:null,existingrules:null},
        });
        $stateProvider.state('home.policy.viewallthreat', {
            url: '/threatdetection/viewallthreat/:policyId',
            templateUrl: 'core/components/administration/policy/viewallthreat.html',
            controller: 'allthreatsCtr'
        });
        $stateProvider.state('home.policy.malwaredetail', {
            url: '/malwarepolicydetails/:policyId',
            controller: 'malwarePolicyDetailCtr',
            controllerAs: 'malwarePolicyDetailCtr',
            templateUrl: 'core/components/administration/policy/malware/malware-details.html'
        });
        $stateProvider.state('home.policy.accesspolicydetail', {
            url: '/accesscontrolpolicy/:policyId',
            templateUrl: 'core/components/administration/policy/acl/acl-policy-details.html',
            controller: 'aclPolicyDetailsCtr',
            controllerAs: 'aclPolicyDetailsCtr',
        });
        $stateProvider.state('home.policy.policydetail', {
            url: '/policydetail/:policyId',
            templateUrl: 'core/components/administration/policy/policy-details.html',
            controller: 'editPolicyCtr',
            controllerAs: 'editPolicyCtr',
           /* views: {
                'malware': {
                   // controller: 'malwarePolicyDetalCtr',
                    //controllerAs: 'malwarePolicyCtr',
                    templateUrl: 'core/components/administration/policy/malware-details.html'
                }
            }*/
        });
//        $stateProvider.state('home.policy.editpolicydetail', {
//            url: '/editpolicydetail',
//            templateUrl: 'core/components/administration/policy/policy-details.html',
//            controller: 'editPolicyCtr',
//            controllerAs: 'editPolicyCtr'
//           /* views: {
//                'malware': {
//                   // controller: 'malwarePolicyDetalCtr',
//                    //controllerAs: 'malwarePolicyCtr',
//                    templateUrl: 'core/components/administration/policy/malware-details.html'
//                }
//            }*/
//        });
        $stateProvider.state('home.policy.addpolicydetail', {
            url: '/addpolicydetail',
            templateUrl: 'core/components/administration/policy/add-policy-details.html'
           /* views: {
                'malware': {
                   // controller: 'malwarePolicyDetalCtr',
                    //controllerAs: 'malwarePolicyCtr',
                    templateUrl: 'core/components/administration/policy/malware-details.html'
                }
            }*/
        });
        $stateProvider.state('home.quickSetup.quickSetup-begin', {
            url: '/quickSetup-begin',
            controller: 'quickSetupBeginCtr',
            controllerAs: 'quickSetupBeginCtr',
            templateUrl: 'core/components/administration/quick-setup/quick-setup-begin/quick-setup-begin.html',
            data : {
                'displayName': 'Quick Setup'
            }
        });
        
        $stateProvider.state('home.quickSetup.infrastructure-connector', {
            url: '/infrastructure-connector',
            controller: 'infrastructureConnectorCtr',
            controllerAs: 'infrastructureConnectorCtr',
            templateUrl: 'core/components/administration/quick-setup/infrastructure-connector/infrastructure-connector.html',
            data : {
                'displayName': 'Infrastructure Access'
            }
        });

        $stateProvider.state('home.quickSetup.deployment-specifications', {
            url: '/deployment-specifications',
            controller: 'deploymentSpecificationCtr',
            controllerAs: 'deploymentSpecificationCtr',
            templateUrl: 'core/components/administration/quick-setup/deployment-specification/deployment-specification.html',
            data: {
                'displayName': 'Deployment Specifications'
            }
        });

        $stateProvider.state('home.quickSetup.virtual-chassis', {
            url: '/virtual-chassis',
            controller: 'virtualChassisCtr',
            controllerAs: 'virtualChassisCtr',
            templateUrl: 'core/components/administration/quick-setup/virtual-chassis/virtual-chassis.html',
            data: {
                'displayName': 'Virtual Chassis'
            }
        });

        $stateProvider.state('home.quickSetup.monitor-networks', {
            url: '/monitor-networks',
            controller: 'monitorNetworksCtr',
            controllerAs: 'monitorNetworksCtr',
            templateUrl: 'core/components/administration/quick-setup/monitor-networks/monitor-networks.html',
            data: {
                'displayName': 'Monitor Networks'
            }
        });
        $stateProvider.state('home.quickSetup.ip-pools-management', {            
            url: '/ip-pools-management',
            controller: 'ipPoolsManagementCtr',
            controllerAs: 'ipPoolsManagementCtr',
            templateUrl: 'core/components/administration/quick-setup/ip-pools/ip-pools-management.html',
            data : {
                'displayName': 'IP Addressing Management'
            }
        });
    
        $stateProvider.state('home.quickSetup.ip-pools-backplane', {            
            url: '/ip-pools-backplane',
            controller: 'ipPoolsBackPlaneCtr',
            controllerAs: 'ipPoolsBackPlanelCtr',
            templateUrl: 'core/components/administration/quick-setup/ip-pools/ip-pools-backplane.html',
            data : {
                'displayName': 'IP Addressing Bacckplane'
            }
        });


       $stateProvider.state("addvirtualChassis", {
            views:{
              "addchassiscontainer": {
                templateUrl: "core/components/administration/virtual-chassis/add-virtual-chassis-container.html"
              }
            },
            abstract: true
         });

      $stateProvider.state("addvirtualChassis.newvc", {
        views:{
          "addchassis": {
            templateUrl: "core/components/administration/virtual-chassis/addVitualChassisNew.html"
          }
        }
      });

       $stateProvider.state("addvirtualChassis.newrc", {
        views:{
          "addchassis": {
            templateUrl: "core/components/administration/virtual-chassis/addVirtualChassisneResourceGroup.html"
          }
        }
      });


    $stateProvider.state("addrulecontainer", {
        views:{
          "addrulecontainer": {
            templateUrl: "core/components/administration/resource-groups/add-rule-container.html"
          },
          abstract: true
        }
      });

     $stateProvider.state("addrulecontainer.infra", {
        views:{
          "addrulecontainerchield": {
            templateUrl: "core/components/administration/resource-groups/add-new-rule-infra.html"
          }
        }
      }); 

     $stateProvider.state("addrulecontainer.rule", {
        views:{
          "addrulecontainerchield": {
            templateUrl: "core/components/administration/resource-groups/add-new-rule.html"
          }
        }
      }); 
     $stateProvider.state('home.TopNDetectedThreats', {
        url: '/'+WidgetName.TopNDetectedThreats+'',
        templateUrl: 'core/directive/widget-painter/drilldown-collection/TopNDetectedThreats/TopNDetectedThreats.html',
    });
    $stateProvider.state('home.TopNDetectedApps', {
        url: '/'+WidgetName.TopNDetectedApps+'',
        templateUrl: 'core/directive/widget-painter/drilldown-collection/TopNDetectedApps/TopNDetectedApps.html',
    });
     $stateProvider.state('home.TopNMalwareDomains', {
        url: '/'+WidgetName.TopNMalwareDomains+'',
        templateUrl: 'core/directive/widget-painter/drilldown-collection/TopNMalwareDomains/TopNMalwareDomains.html',
    });
     $stateProvider.state('home.TopNMalwareDetections', {
        url: '/'+WidgetName.TopNMalwareDetections+'',
        templateUrl: 'core/directive/widget-painter/drilldown-collection/TopNMalwareDetections/TopNMalwareDetections.html',
    });
    $stateProvider.state('home.TopNBadCertificates', {
        url: '/'+WidgetName.TopNBadCertificates+'',
        templateUrl: 'core/directive/widget-painter/drilldown-collection/TopNBadCertificates/TopNBadCertificates.html',
    });
    $stateProvider.state('home.TopNAttackerResourceGroup', {
        url: '/'+WidgetName.TopNAttackerResourceGroups+'',
        templateUrl: 'core/directive/widget-painter/drilldown-collection/TopNAttackerResourceGroups/TopNAttackerResourceGroups.html',
    });
    $stateProvider.state('home.TopNVictimResourceGroups', {
        url: '/'+WidgetName.TopNVictimResourceGroups+'',
        templateUrl: 'core/directive/widget-painter/drilldown-collection/TopNVictimResourceGroups/TopNVictimResourceGroups.html',
    });
    $stateProvider.state('home.TopNAttackers', {
        url: '/'+WidgetName.TopNAttackers+'',
        templateUrl: 'core/directive/widget-painter/drilldown-collection/TopNAttackers/TopNAttackers.html',
    });
    $stateProvider.state('home.TopNVictims', {
        url: '/'+WidgetName.TopNVictims+'',
        templateUrl: 'core/directive/widget-painter/drilldown-collection/TopNVictims/TopNVictims.html',
    });
    $stateProvider.state('home.TopNTalkersbyVMname', {
        url: '/'+WidgetName.TopNTalkersbyVMname+'',
        templateUrl: 'core/directive/widget-painter/drilldown-collection/TopNTalkersbyVMname/TopNTalkersbyVMname.html',
    });
    $stateProvider.state('home.TopNTalkersbyResourceGroup', {
        url: '/'+WidgetName.TopNTalkersbyResourceGroup+'',
        templateUrl: 'core/directive/widget-painter/drilldown-collection/TopNTalkersbyResourceGroup/TopNTalkersbyResourceGroup.html',
    });
    $stateProvider.state('home.TopNBlockedClients', {
        url: '/'+WidgetName.TopNBlockedClients+'',
        templateUrl: 'core/directive/widget-painter/drilldown-collection/TopNBlockedClients/TopNBlockedClients.html',
    });
    $stateProvider.state('home.TopNServedDomains', {
        url: '/'+WidgetName.TopNServedDomains+'',
        templateUrl: 'core/directive/widget-painter/drilldown-collection/TopNServedDomains/TopNServedDomains.html',
    });
    $stateProvider.state('home.TopNConversations', {
        url: '/'+WidgetName.TopNConversations+'',
        templateUrl: 'core/directive/widget-painter/drilldown-collection/TopNConversations/TopNConversations.html',
    });
    $stateProvider.state('home.IOP', {
        url: '/'+WidgetName.IOP+'',
        templateUrl: 'core/directive/widget-painter/drilldown-collection/IOP/IOP.html',
    });
    $stateProvider.state('home.InventoryofMicroServices', {
        url: '/'+WidgetName.InventoryofMicroServices+'',
        templateUrl: 'core/directive/widget-painter/drilldown-collection/InventoryofMicroServices/InventoryofMicroServices.html',
    });
    $stateProvider.state('home.NewApplications', {
        url: '/'+WidgetName.NewApplications+'',
        templateUrl: 'core/directive/widget-painter/drilldown-collection/NewApplications/NewApplications.html',
    });  
    
      $urlRouterProvider.otherwise('analysis');  
      // $urlRouterProvider.otherwise('quickSetup/quickSetup-begin');
    }).config(function(RestangularProvider) {
        "ngInject";
        RestangularProvider.setBaseUrl('/shieldxapi/');
        RestangularProvider.setDefaultHeaders({
            'Cache-Control': 'no-cache',
            'Pragma': 'no-cache'
        });
        console.log("the RestangularProvider has this ",RestangularProvider);
        /*RestangularProvider.setErrorInterceptor(function(response, deferred, responseHandler) {
            console.log("I run for every request which throws error");
            if(response.status === 500) {
                console.log("error is catched");

                //return false; // error handled return false incase of the error is handled and no further operation is required, but we also need the regular implementation that we had hence commenting this
            }

            return true; // error not handled
        });*/
        //console.log("dialog obj ",$mdDialog);
    });

function ChartTypes(){}
ChartTypes.pieChartDonut = "PieChartDonut";
ChartTypes.realtimeMultiseriesTrendline= "RealtimeMultiseriesTrendline";
ChartTypes.multiLineChart = "MultiLineChart";
ChartTypes.barChart= "BarChart";
ChartTypes.stackedArea= "StackedArea";
ChartTypes.stackedBarChart= "StackedBarChart";
ChartTypes.groupedBarChart= "GroupedBarChart";
ChartTypes.lineGraphBasic = "LineGraphBasic";
ChartTypes.basicPieChart = "BasicPieChart"; 
ChartTypes.tables = "Tables";
ChartTypes.alert = "Alert";
function WidgetName(){}
WidgetName.TroubledMicroServices= "TroubledMicroServices";
WidgetName.InventoryofMicroServices= "InventoryofMicroServices";
WidgetName.SystemInformation= "SystemInformation"; 
WidgetName.Scaling = "Scaling";
WidgetName.Throughput= "Throughput";
WidgetName.Flows = "Flows";
WidgetName.EventRate = "EventRate";
WidgetName.TopNDetectedThreats= "TopNDetectedThreats";
WidgetName.TopNDetectedApps= "TopNDetectedApps";
WidgetName.TopNMalwareDomains= "TopNMalwareDomains";
WidgetName.TopNMalwareDetections= "TopNMalwareDetections";
WidgetName.TopNBadCertificates= "TopNBadCertificates";
WidgetName.TopNAttackerResourceGroups= "TopNAttackerResourceGroups";
WidgetName.TopNVictimResourceGroups= "TopNVictimResourceGroups";
WidgetName.TopNAttackers= "TopNAttackers"; 
WidgetName.TopNVictims= "TopNVictims";
WidgetName.TopNTalkersbyVMname= "TopNTalkersbyVMname";
WidgetName.TopNTalkersbyResourceGroup= "TopNTalkersbyResourceGroup";
WidgetName.TopNBlockedClients = "TopNBlockedClients";
WidgetName.TopNServedDomains = "TopNServedDomains";
WidgetName.TopNConversations = "TopNConversations";
WidgetName.IOP = "IOP";
WidgetName.NewApplications = "NewApplications";

/*
ShieldX Networks Inc. CONFIDENTIAL
----------------------------------
*
Copyright (c) 2016 ShieldX Networks Inc.
All Rights Reserved.
*
NOTICE: All information contained herein is, and remains
the property of ShieldX Networks Incorporated and its suppliers,
if any. The intellectual and technical concepts contained
herein are proprietary to ShieldX Networks Incorporated
and its suppliers and may be covered by U.S. and Foreign Patents,
patents in process, and are protected by trade secret or copyright law.
Dissemination of this information or reproduction of this material
is strictly forbidden unless prior written permission is obtained
from ShieldX Networks Incorporated.
*/

(function () {
    function dummyCtr($scope) {
        "ngInject";

        /* dummy function to test karma hook */
        $scope.password = '';
        $scope.grade = function () {
            var size = $scope.password.length;
            if (size > 8) {
                $scope.strength = 'strong';
            } else if (size > 3) {
                $scope.strength = 'medium';
            } else {
                $scope.strength = 'weak';
            }
        };

        /* end of hook*/
    }

    angular.module('shieldxApp').controller('dummyCtr', dummyCtr);

})();

/*
ShieldX Networks Inc. CONFIDENTIAL
----------------------------------
*
Copyright (c) 2016 ShieldX Networks Inc.
All Rights Reserved.
*
NOTICE: All information contained herein is, and remains
the property of ShieldX Networks Incorporated and its suppliers,
if any. The intellectual and technical concepts contained
herein are proprietary to ShieldX Networks Incorporated
and its suppliers and may be covered by U.S. and Foreign Patents,
patents in process, and are protected by trade secret or copyright law.
Dissemination of this information or reproduction of this material
is strictly forbidden unless prior written permission is obtained
from ShieldX Networks Incorporated.
*/

(function () {
    function homeCtr($scope, 
        $rootScope,
        $state, 
        $translate,
        $mdSidenav,
        $mdDialog,
        $sessionStorage,
        $log,coreservices,screenMenagment,userSessionMenagment,$timeout) {
        "ngInject";
        //screenMenagment.setCurrentScreen(screenMenagment.screens.HOME_PAGE); 
        // userSessionMenagment.validateUserSession();

        $scope.$storage = $sessionStorage;
        $scope.headerText = $translate.instant('HEADER_TEXT');
        $scope.$on('listenHeaderText', function (event, args) {
            console.log(args);
            $scope.headerText = args.headerText;
        });

       $scope.maximize = false;
        
        $scope.toastTimeout = 5000;
        $scope.active_help_id = "";
        $scope.helpButtonClicked = function(id){
            $scope.active_help_id = id;
            console.log("  helpButtonClicked ");
            $scope.bordcastEventHelpButtonClicked($scope.active_help_id);
        };

        $rootScope.$on('$stateChangeStart', function(event, toState, toParams, fromState, fromParams){
       
        });
        function findMenuItem(){
            $scope.subpaneItem = '';
             _.each($scope.panesA,function(item){
                    if(item.subpanes){
                       $scope.subpaneItem =  _.find(item.subpanes,function(subpane){
                        var menuname = subpaneItemFun(subpane);
                        var data = ($scope.toStateName.indexOf('.')>0)?($scope.toStateName.substring(0,$scope.toStateName.indexOf('.'))):($scope.toStateName);
                            return menuname === data;
                        });
                       //return subpaneItem;
                    }else{
                       if(item.id === $scope.toStateName){
                            $scope.subpaneItem = item;
                       }
                    }
                });
             return $scope.subpaneItem;
        }

        $scope.clickSignOut = function(){
           coreservices.signout();
        };

        $scope.$on('quickSetupBegun', function(){
            //enabling cancel
            $scope.qsStarted = true;
        });
        $scope.$on('quickSetupEnded', function(){
            //disable cancel
            $scope.qsStarted = false;
        });


        console.log('in homeCtr');


        $scope.endSetup = function(ev) {
            // Appending dialog to document.body to cover sidenav in docs app
            var confirm = $mdDialog.confirm({
                    //clickOutsideToClose : true,
                    //escapeToClose : true,
                    onComplete: function afterShowAnimation() {
                        var $dialog = angular.element(document.querySelector('md-dialog'));
                        var $actionsSection = $dialog.find('md-dialog-actions');
                        var $cancelButton = $actionsSection.children()[0];
                        var $confirmButton = $actionsSection.children()[1];

                        var $contentBody = $dialog.find('md-dialog-content');
                        var $contentText = $contentBody.find('div');
                        angular.element($contentText).addClass('confirm-dialog-content-style');

                        angular.element($confirmButton).css('color','#f37864');
                        angular.element($cancelButton).css('color','#f37864');

                    }
                }).title('Cancel Quick Setup?')
                  .textContent('You can save & exit setup and resume later from the Quick setup screen?')
                  .ariaLabel('Exit setup')
                  .targetEvent(ev)
                  .ok('SAVE & EXIT')
                  .cancel('CANCEL SETUP');
            $mdDialog.show(confirm).then(function() {
                console.log($scope.$storage.cloudData);
                $scope.qsStarted = false;
                $state.go('home.quickSetup.quickSetup-begin');
            }, function() {
                delete $scope.$storage.cloudData;
                $scope.clearUnsavedData();
                console.log("deleted coloudData from $sessionStorage");
                $state.go('home.quickSetup.quickSetup-begin');
                $scope.qsStarted = false;
            });
        };
        $scope.clearUnsavedData = function(){
            $scope.$broadcast("unsavedExistInIt");
        };
        $scope.changeLanguage = function() {

            $translate.use('gb').then(function () {
                $scope.headerText = $translate.instant('HEADER_TEXT');
            });
        };

        $scope.leftPanelToggle = function(){
            $mdSidenav('left-nav-panel').toggle()
                .then(function(){
                    $log.debug("close LEFT is done");
                });                
        };

        $scope.gotoPage = function($event) {
            var stateList = $state.get();
            var temp = this;

            console.log(_.find(stateList, { 'name' : temp.$pane.id}));

            var x = _.find(stateList, function(o){
                 return o.name.match('home.'+temp.$pane.id);
            });

            //find 'active' and remove class
            angular.element(document.querySelector('v-pane-header.active')).removeClass('active');
            //set current elem to 'active'
            angular.element($event.currentTarget).addClass('active');

            if(!!x) {
                $scope.leftPanelToggle();
                $state.go('home.'+ temp.$pane.id);
            } else return;
        };

        $scope.setFocusOnElem = function(elemId) {
            setTimeout(function(){
                document.querySelector(elemId).focus();
            },0);
        };

        $scope.bordcastEventHelpButtonClicked = function(helpId){
            console.log("bordcastEventHelpButtonClicked ");
            $scope.$broadcast('onHelpButtonClicked', {
               helpIDString: helpId 
            });
        };
        
        function returnMenuItem(){
            return $scope.panesA;
        }

        $scope.panesB = [
            {
                id: 'aboutUs',
                header: 'About ShieldX Product',
                icon: 'theaters',
                details: 'Video Gallery',
                content: ''
            },
            {
                id: 'dashboard',
                header: 'Dashboard',
                icon: 'dashboard',
                details: 'Overview',
                content: ''
            },
            {
            id: 'pane-1a',
            header: 'Administration',
            content: '',
            icon: 'settings',
            details: 'Setup, Manage & Monitor',
            isExpanded: false,
            isVisible: true,
            subpanes: [
                {
                    id: 'quickSetup.quickSetup-begin',
                    header: 'Quick setup',
                    content: '',
                    headerAddOn: 'Start here'
                }, {
                    id: 'policy.policylist',
                    header: 'Security Policies & Sets',
                    content: ''
                }, {
                    id: 'deploymentComponents',
                    header: 'Deployment Components',
                    content: '',
                    isExpanded: false,
                    subpanes: [
                        {
                            id: 'infrastructureConnectors',
                            header: 'Infrastructure Connectors',
                            content: ''
                            //bubble: '99+'
                            //isDisabled: true

                        }, {
                            id: 'ipPools',
                            header: 'IP Pools',
                            content: ''
                        },{
                            id: 'vlanPools',
                            header: 'VLAN Pools',
                            content: ''
                        }, {
                            id: 'deploymentSpecifications',
                            header: 'Deployment Specifications',
                            content: ''
                        }, {
                            id: 'virtualChassis',
                            header: 'Data Planes',
                            content: ''
                        }, {
                            id: 'managementPlane',
                            header: 'Management Plane',
                            content: ''
                        }
                    ]
                },
                 /*{
                    id: 'resourceGroups',
                    header: 'Groups',
                    content: ''
                }, {
                    id: 'managePolicies',
                    header: 'Manage Policies',
                    content: '',
                    isDisabled: false
                },*/ 
                {
                    id: 'system',
                    header: 'System',
                    content: '',
                    subpanes: [
                        {
                            id: 'shieldxUpdates',
                            header: 'Updates',
                            content: '',
                            isDisabled: false
                        }, {
                            id: 'integrations',
                            header: 'Integrations',
                            content: '',
                            isDisabled: false
                        }, {
                            id: 'logs',
                            header: 'Logs',
                            content: '',
                            isDisabled: false
                        }, {
                            id: 'setuptls.tlsdecryption',
                            header: 'TLS Inspection',
                            content: ''
                        }, {
                            id: 'notification.settings',
                            header: 'Notification',
                            content: ''
                        }, {
                            id: 'setup.settings',
                            header: 'Setup',
                            content: ''
                        }, {
                            id: 'maintenance.maintenancetasks',
                            header: 'Maintenance',
                            content: ''
                        }
                    ]
                },
                {
                    id: 'usersMain',
                    header: 'Users',
                    content: '',
                    subpanes: [
                        {
                            id: 'users',
                            header: 'Manage Users',
                            content: '',
                        }
                    ]
                },
                {
                    id: 'license',
                    header: 'License',
                    content: ''
                }, {
                    id: 'reports',
                    header: 'Reports',
                    content: ''
                }
            ]
            },
            {
                id: 'systemHealth',
                header: 'System Health tools',
                details: 'Keep system running strong',
                icon: 'images/heart-pulse.svg',
                content: '',
                subpanes: [
                    /*{
                        id: 'TroubledMicroservices',
                        header: 'Troubled Microservices',
                        content: '',
                        isDisabled: false
                    }, */
                    {
                        id: 'InventoryofMicroServices',
                        header: 'Inventory of Microservices',
                        content: '',
                        isDisabled: false
                    }
                    /*, {
                        id: 'SystemInformation',
                        header: 'System Information',
                        content: '',
                        isDisabled: false
                    }, {
                        id: 'Scaling',
                        header: 'Scaling',
                        content: ''
                    }, {
                        id: 'Throughput',
                        header: 'Throughput',
                        content: ''
                    }, {
                        id: 'Flows',
                        header: 'Flows',
                        content: ''
                    }, {
                        id: 'EventRate',
                        header: 'Event Rate',
                        content: ''
                    }*/
                ]
                //bubble: '9999+'
            }, {
                id: 'systemAnalysis',
                header: 'Security Analysis tools',
                icon: 'images/binoculars.svg',
                details: 'Correlate & Learn',
                content: '',
                subpanes: [
                    {
                        id: 'EventCorrelationExplorer',
                        header: 'Event Correlation Explorer',
                        content: '',
                        isDisabled: false
                    }, {
                        id: 'TopNDetectedThreats',
                        header: 'Top N Detected Threats',
                        content: '',
                        isDisabled: false
                    }, {
                        id: 'TopNDetectedApps',
                        header: 'Top N Detected Apps',
                        content: '',
                        isDisabled: false
                    }, {
                        id: 'TopNMalwareDomains',
                        header: 'Top N Malware Domains',
                        content: ''
                    }, {
                        id: 'TopNMalwareDetections',
                        header: 'Top N Malware Detections ',
                        content: ''
                    }, {
                        id: 'TopNBadCertificates',
                        header: 'Top N Bad Certificates',
                        content: ''
                    }, {
                        id: 'TopNAttackerResourceGroup',
                        header: 'Top N Attacker Resource Group',
                        content: ''
                    }, {
                        id: 'TopNVictimResourceGroups',
                        header: 'Top N Target Resource Groups',
                        content: ''
                    }, {
                        id: 'TopNAttackers',
                        header: 'Top N Attackers',
                        content: ''
                    }, {
                        id: 'TopNVictims',
                        header: 'Top N Victims',
                        content: ''
                    }, {
                        id: 'TopNTalkersbyVMname',
                        header: 'Top N VMs by Number of Connections',
                        content: ''
                    }, {
                        id: 'TopNTalkersbyResourceGroup',
                        header: 'Top N Resource Groups by Number of Connections',
                        content: ''
                    }, {
                        id: 'TopNBlockedClients',
                        header: 'Top N Blocked Clients',
                        content: ''
                    }, {
                        id: 'TopNServedDomains',
                        header: 'Top N Served Domains ',
                        content: ''
                    }, {
                        id: 'TopNConversations',
                        header: 'Top N VMs by Data Transferred (measured in bytes)',
                        content: ''
                    }, {
                        id: 'IOP',
                        header: 'Indicator of Pivot (I0P)',
                        content: ''
                    }, {
                        id: 'NewApplications',
                        header: 'New Applications',
                        content: ''
                    }
                ]
            }, {
                id: 'myLocker',
                icon: 'work',
                details: 'Bookmarks & Notes',
                header: 'My Locker',
                content: ''
            }
            //,
            // {
            //     id: 'networks',
            //     header: 'Networks',
            //     icon: '',
            //     content: ''
            //     //bubble: '9999+'
            // }
//            ,{
//                id: 'manage',
//                header: 'Manage',
//                content: '',
//                //isExpanded: true,
//                subpanes: [{
//                    id: 'setup',
//                    header: 'Setup',
//                    content: ''
//                },{
//                    id: 'supportability',
//                    header: 'Supportability',
//                    content: ''
//                },{
//                    id: 'integration',
//                    header: 'Integration',
//                    content: ''
//                }]
//            }
        ];
      
       //coreservices.getListOfAuthorities().then(function(data){
            renderLeftPanelMenu();
         //   $scope.$broadcast("authoritiesListavalibale",{"data":data});
       //});
      
      var menuName,menuId,auth_id,valid;
      function subpaneItemFun(data){
        var menuNameWithOutDot;
        if(data.id.indexOf('.') > 0){
            menuNameWithOutDot = data.id.substring(0, data.id.indexOf('.'));    
        }else{
         menuNameWithOutDot = data.id;    
        }
        return menuNameWithOutDot;
      }
      function getAddOnToMenuItem(Pane){
            var menuName = subpaneItemFun(Pane);
            if(menuName === 'logs'){
                menuName = menuName+"_upload";    
            }else if(menuName === "shieldxUpdates"){
                menuName = menuName+"_update";
            }else{
                menuName = menuName+"_read";       
            }
        return menuName;
      }
     // $scope.panesA = [];

        function checkSubmenuAccess(subPane) {

            menuId = getAddOnToMenuItem(subPane);
            if (menuId === "quickSetup_read") {
                var idToCheck = [];
                idToCheck.push(authorities("infrastructureConnectors_discover"));
                idToCheck.push(authorities("deploymentSpecifications_create"));
                idToCheck.push(authorities("virtualChassis_create"));
                idToCheck.push(authorities("resourceGroups_create"));
                auth_id = idToCheck;
            } else {
                auth_id = authorities(menuId);
            }
            if (subPane.id === "shieldxUpdates") {
                // idToCheck  = [];
                var auth_1 = authorities("shieldxUpdates_update");
                var auth_2 = authorities("shieldxUpdates_content_update");
                var auth_3 = authorities("shieldxUpdates_controlplane_read");
                var auth_4 = authorities("shieldxUpdates_controlplane_update");
                valid = false;
                if (userSessionMenagment.isUserAllowd(auth_1) || userSessionMenagment.isUserAllowd(auth_2) || userSessionMenagment.isUserAllowd(auth_3) || userSessionMenagment.isUserAllowd(auth_4)) {
                    valid = true;
                }
            } else if (subPane.id === "systemHealth" || subPane.id === "systemAnalysis") {
                var authdash = authorities("dashboard_read");
                valid = false;
                if (userSessionMenagment.isUserAllowd(authdash)) {
                    valid = true;
                    if (Array.isArray(subPane.subpanes)) {
                        _.each(subPane.subpanes, function(sp) {
                            sp.isVisible = valid;
                        });
                    }
                }
            } else {
                valid = userSessionMenagment.isUserAllowd(auth_id);
            }
            subPane.isVisible = valid;
        }

        function renderLeftPanelMenu() {
            _.each($scope.panesB, function(menuItem) {
                if (menuItem.id === "systemHealth" || menuItem.id === "systemAnalysis") {
                    checkSubmenuAccess(menuItem);
                } else if (Array.isArray(menuItem.subpanes)) {
                    _.each(menuItem.subpanes, function(subPane) {
                        if (Array.isArray(subPane.subpanes)) {
                            _.each(subPane.subpanes, function(subsubPane) {
                                checkSubmenuAccess(subsubPane);
                                if (subsubPane.isVisible) {
                                    subPane.isVisible = true;
                                }
                            });
                        } else {
                            checkSubmenuAccess(subPane);
                        }
                    });
                } else {
                    menuId = getAddOnToMenuItem(menuItem);
                    auth_id = authorities(menuId);
                    //valid = userSessionMenagment.isUserAllowd(auth_id);
                    menuItem.isVisible = userSessionMenagment.isUserAllowd(auth_id);
                }
                //console.log(menuItem);
            });
            $scope.panesA = angular.copy($scope.panesB);
        }
      $scope.expandCallback = function (index, id) {
        console.log('expand:', index, id);
      };

      $scope.collapseCallback = function (index, id) {
        console.log('collapse:', index, id);
      };

      $scope.$on('accordionA:onReady', function () {
        console.log('accordionA is ready!');
      });


        // manage functionality

        $scope.disableTimeout = 300*1000;

        $scope.callout = {};

        if(typeof $sessionStorage.callout !== 'undefined') $scope.callout = $sessionStorage.callout;

        $scope.currentTime = parseInt(new Date().getTime());

        $scope.disableCallout = function (calloutType) {
            if(typeof $sessionStorage.callout === 'undefined') {
                $sessionStorage.callout = {};
            }
            $sessionStorage.callout[calloutType] = new Date().getTime();

            $scope.callout = $sessionStorage.callout;

        };

        $scope.openMenu = function($mdOpenMenu, ev) {
          console.log(" openMenu  ");  
          originatorEv = ev;
          $mdOpenMenu(ev);
        };
        
        $rootScope.$on('$stateChangeStart',
            function(event, toState, toParams, fromState, fromParams){
                if(fromState.name == "home.dashboard"){
                    angular.element(document.querySelector('.headerBar')).removeClass('dark-theme');
                }
                $rootScope.previousState = fromState;
        });
        
        $scope.$on('fullscreenInit', function (event, data) {
            $scope.maximize = !$scope.maximize;
            $scope.$broadcast('fullscreen', null);
        });

//        $scope.checkCalloutEnabled = function (calloutType) {
//            if (typeof $sessionStorage.callout[calloutType] !== 'undefined') {
//                return (parseInt(new Date().getTime()) - $sessionStorage.callout[calloutType] >= $scope.disableTimeout);
//            } else {
//                $sessionStorage.callout[calloutType] = new Date().getTime();
//                return true;
//            }
//        };

    } 
     /*function leftNavCtrl($scope, $timeout, $mdSidenav, $log) {
        "ngInject";
        $scope.close = function () {
            // Component lookup should always be available since we are not using `ng-if`
            $mdSidenav('left-nav-panel').toggle()
                .then(function () {
                    $log.debug("close LEFT is done");
                });
        };
     }*/

    angular.module('shieldxApp').controller('homeCtr', homeCtr);
    //angular.module('shieldxApp').controller('leftNavCtrl', leftNavCtrl);
})();

(function () {
    function authRestangular(Restangular, $http, $q, $sessionStorage,$mdDialog){
    	 "ngInject";

    	var authUser = null;
        var alreadyOpen = false;
        function errorController($scope,$mdDialog,msgData) {
			$scope.msgData = msgData;
            $scope.hide = function() {
              console.log("I am called 123456789");
              $mdDialog.hide();
            };
        }

        angular.module('shieldxApp').controller('errorController', errorController);
    
    	return{
    		signIn : function(userName, password){
     			authUser = new AuthUser();
     			authUser.userName =  userName;
     			authUser.password = password;
     			//console.log("authRestangular  ");
     			//console.dir(authUser);
				return Restangular.withConfig(function (RestangularConfigurer) {
		            RestangularConfigurer.setDefaultHeaders({'X-Username' : authUser.userName, 'X-Password' : authUser.password });
		            RestangularConfigurer.setFullResponse(true);
         		}).one('/').customPOST("login").then(function(data){
         			var token = data.headers('X-Auth-Token');
         			authUser.token = token;
         			console.log("Got Token: "+token);
         			return data;
         		},function(error){
         			return $q.reject(error);
         		});
     		},
    		signOut : function(){
    			return  Restangular.withConfig(function (RestangularConfigurer) {
                     RestangularConfigurer.setDefaultHeaders({'X-Auth-Token' : authUser.getToken()});
                 }).all("/logout").post('').then(function(data){
                    authUser = null;
                    return data;
                 });
               
    		},
    		getUserDetail:function(){
              return authUser;
    		},
    		init:function(){
                var ret = Restangular.withConfig(function (RestangularConfigurer) {
                     //RestangularConfigurer.setBaseUrl("/shieldxapi/");
                    // RestangularConfigurer.setDefaultHeaders({'X-Auth-Token' : authUser.getToken()});
                 });
                ret.setErrorInterceptor(function(response, deferred, responseHandler) {
                    console.log("I run for every request which throws error");
                    if(response.status === 500) {
                        var showMsg = false;
                        console.log("error is catched");
                        var msgData = {"msgStart" : "","msgLink" : "","msgEnd" : ""};
                        switch(response.data.path){
                            case "/shieldxapi/infras" :
                                msgData.msgStart = "Some of parts of your operation might have created deployment components. If you need to clean up these components, please review the";
                                msgData.msgLink = "Administration > Deployment Components";
                                msgData.msgEnd = "section.";
                            break;
                            case "/shieldxapi/infras/resourcegroup" :
                                msgData.msgStart = "Some of parts of your operation might have created deployment components. If you need to clean up these components, please review the";
                                msgData.msgLink = "Administration > Deployment Components";
                                msgData.msgEnd = "section.";
                                showMsg = true;
                            break;
                            default : 
                                msgData.msgStart = "Some of parts of your operation might have created deployment components. If you need to clean up these components, please review the";
                                msgData.msgLink = "Administration > Deployment Components";
                                msgData.msgEnd = "section.";
                        }
                        //return false; // error handled return false incase of the error is handled and no further operation is required, but we also need the regular implementation that we had hence commenting this
                        //if checks whether already dialog box is open or not
                        if(!alreadyOpen && showMsg){
                            $mdDialog.show({
                                skipHide: true,
                                clickOutsideToClose: true,
                                templateUrl: 'core/components/screenComponents/error-message-500.html',
                                parent: angular.element(document.body),
								locals : {msgData : msgData },
                                controller: errorController
                               }).then(function(){
                                    alreadyOpen = false;
                               });
                            alreadyOpen = true;
                        }

                    }

                    return true; // error not handled
                });
                return ret;
    		},
            initSxquery:function(){
                var ret = Restangular.withConfig(function (RestangularConfigurer) {
                     RestangularConfigurer.setBaseUrl("/sxquery/");
                     RestangularConfigurer.setDefaultHeaders({'X-Auth-Token' : authUser.getToken()});
                 });
                ret.setErrorInterceptor(function(response, deferred, responseHandler) {
                    console.log("I run for every dashboard query request which throws error");
                    if(response.status === 500) {
                        console.log("error is catched");

                        //return false; // error handled return false incase of the error is handled and no further operation is required, but we also need the regular implementation that we had hence commenting this
                        //if checks whether already dialog box is open or not
                        if(!alreadyOpen){
                            $mdDialog.show({
                                skipHide: true,
                                clickOutsideToClose: true,
                                templateUrl: 'core/components/screenComponents/error-message-500-dashboard.html',
                                parent: angular.element(document.body),
                                controller: errorController
                               }).then(function(){
                                    alreadyOpen = false;
                               });
                            alreadyOpen = true;
                        }

                    }

                    return true; // error not handled
                });
                return ret;
            },
            setUserDetail:function(userData){
               if(!authUser){
                authUser = new AuthUser();
               } 
               authUser.copy(userData);
            }
    	};

    }
    angular.module('shieldxApp').factory('authRestangular', authRestangular);

})();
(function () {
   

     function commonDataManagement() {
        "ngInject";

        var dataSet = [];
        var dataObj = {};
        return {
            setData: function (data) {
                if(data.hasOwnProperty("id") && data.id !== 0){
                    var updateIndex = _.find(dataSet,{"id": parseInt(data.id)});
                    if(updateIndex){
                        dataSet.splice(updateIndex,0,data);
                    } else {
                        dataSet.splice(data.id,0,data);
                    }
                } else {
                    dataSet.push(data);
                }

            },
            getData: function () {
                return dataSet;
            },
            clearData:function(){
              dataSet = [];
            },
            setObj:function(objValue){
                dataObj = objValue;
            },
            getObj:function(){
                return dataObj;
            }       
      };
    }

 angular.module('shieldxApp').factory('commonDataManagement', commonDataManagement);

})();

(function () {
   

     function screenMenagment($state,$mdDialog,$timeout) {
        "ngInject";

        return{
            currentScreen:null,
            screens:{
                LANDING_PAGE :{name:'landing_page',path:"landingpage"},
                HOME_PAGE :{name:'home_page',path:"homepage"},
                WIZARD_SCREEN :{name:'wizard_page'},
                ADMIN_SCREEN :{name:'admin_page'}
            },
            navigateToPage:function(screen){
               /* var cs = this.getCurrentScreen();
                console.log(" navigateToPage 2 "+cs.name); 
                console.log(" navigateToPage 3 "+screen.name); 
                if(cs.name !== screen.name){
                  this.setCurrentScreen(screen);  
                  $mdDialog.hide();
                  $timeout(function(){
                    $state.go(screen.path);
                  },0); 
                }
                */
            },
            setCurrentScreen : function(screen){
               this.currentScreen = screen; 
            },
            getCurrentScreen : function(){
               return this.currentScreen; 
            }
        };

       
    }

 angular.module('shieldxApp').factory('screenMenagment', screenMenagment);

})();

(function () {
    function dataVisualizationApi() {
        "ngInject";

        return shieldxDataFx();
       
    }

    angular.module('shieldxApp').factory('dataVisualizationApi', dataVisualizationApi);

    function userSessionMenagment($q, $sessionStorage,$state,authRestangular,screenMenagment) {
        "ngInject";

        return{
            validateUserSession:function(){
                        
             var sessionValidity = this.isUserSessionValid();
              if(sessionValidity){
                    var userData = authRestangular.getUserDetail();
                   
//                    console.dir(userData);

                    if(!userData){
                        var data = this.getUserSessionData();
                        authRestangular.setUserDetail(data);
                    }
                 }
              if(!sessionValidity) {
                screenMenagment.navigateToPage(screenMenagment.screens.LANDING_PAGE);
              }  

             return sessionValidity;   
            },
            invalidateUserSession : function(){
               /* if($sessionStorage.userdata && $sessionStorage.userdata.userSession){
                    delete $sessionStorage.userdata.userSession;
                    delete $sessionStorage.userdata.authorities;
                }
                screenMenagment.navigateToPage(screenMenagment.screens.LANDING_PAGE);
                 */
            },
            getUserSessionData : function(){
//                console.log("getUserSessionData 1 ");
                var userdata  = $sessionStorage.userdata; 
//                 console.dir(userdata);
                if(!userdata){
                   return null;
                }
                if(!$sessionStorage.userdata.userSession)
                {
                     return null;
                }
//                console.log("getUserSessionData 2 ");
//                 console.dir($sessionStorage.userdata.userSession);
                return $sessionStorage.userdata.userSession;
            },
            isUserSessionValid : function(){
                return this.getUserSessionData() !== null;
            },
            isUserAllowd:function(data){
                
            },
            saveToUserSession : function(){
                var userdata   = $sessionStorage.userdata; 
                if(!userdata){
                    $sessionStorage.userdata = {};
                }
                var data = authRestangular.getUserDetail();
                if(data){
                    $sessionStorage.userdata.userSession = data;
                } 
           },
           saveListOfAuthorities: function(data){
                $sessionStorage.userdata.authorities = data;
           }

        };

       
    }

    angular.module('shieldxApp').factory('userSessionMenagment', userSessionMenagment);

})();

(function () {
   

     function websocketfectory($q) {
        "ngInject";

        var socket = null;
        var stompClient = null;
        return {
            connect: function () {
                socket = new SockJS('/gs-guide-websocket');
                stompClient = Stomp.over(socket);
                var deferred = $q.defer();
                stompClient.connect({}, function (frame) {
                    console.log('Connected: ' + frame);
                    deferred.resolve(frame);
                    
                });
                return deferred.promise;
            },
            disconnect:function(){
              if (stompClient !== null) {
                 stompClient.disconnect();
               }
            },
            sendData:function(topic,data){
                 stompClient.send(topic, {}, JSON.stringify(data));
            },
            subscribToTheTopic:function(topic){
              var deferred = $q.defer();
              stompClient.subscribe(topic, function (data) {
                 console.log(" subscribToTheTopic 2 ");
                 console.dir(data.body); 
                 deferred.resolve(JSON.parse(data.body));
              });
              return deferred.promise;
            }     
      };
    }

 angular.module('shieldxApp').factory('websocketfectory', websocketfectory);

})();

(function () {
   

     function filterthreatFn() {
        "ngInject";

        return function(data,filterObj){
            console.log(filterObj);
            var output = [];
            if(typeof data !== 'undefined'){
                for(var i = 0;i<data.length; i++){
                    if(data[i].threatResponseData){
                        var status = data[i].threatResponseData.enabled ? "Enabled" : "Disabled";
                        if( ( filterObj._status.indexOf(status) !== -1 || !filterObj._status.length ) && filterObj.protectionType.indexOf(data[i].protectionType) !== -1 && filterObj.severity.indexOf(data[i].severity) !== -1){
                            var passed = true;
                            //action filter not present bypass the checks
                            if(filterObj.action.length < 4 || !filterObj.action.length){
                                var notifypositiveLog = filterObj.action.indexOf("notifySysLog-true");
                                var notifynegativeLog = filterObj.action.indexOf("notifySysLog-false");
                                if((notifypositiveLog === -1 && notifynegativeLog !=  -1) || (notifynegativeLog === -1 && notifypositiveLog !== -1)){
                                    if(notifypositiveLog === -1 && data[i].threatResponseData.notifySysLog )
                                        passed = false;
                                    if(notifynegativeLog === -1 && !data[i].threatResponseData.notifySysLog )
                                        passed = false;
                                }

                                var positiveEmail = filterObj.action.indexOf("notifySMTP-true");
                                var negativeEmail = filterObj.action.indexOf("notifySMTP-false");
                                if((positiveEmail === -1 && negativeEmail !=  -1) || (negativeEmail === -1 && positiveEmail !== -1)){
                                    if(positiveEmail === -1 && data[i].threatResponseData.notifySMTP )
                                        passed = false;
                                    if(negativeEmail === -1 && !data[i].threatResponseData.notifySMTP )
                                        passed = false;
                                }
                            }

                            //response filter not present bypass the checks
                            if(filterObj.response.length < 6 || !filterObj.response.length){
                                var positiveBlock = filterObj.response.indexOf("Block-true");
                                var negativeBlock = filterObj.response.indexOf("Block-false");
                                if((positiveBlock === -1 && negativeBlock !=  -1) || (negativeBlock === -1 && positiveBlock !== -1) ){
                                    if(positiveBlock === -1 && data[i].threatResponseData.block )
                                        passed = false;
                                    if(negativeBlock === -1 && !data[i].threatResponseData.block )
                                        passed = false;
                                }

                                var positiveLog = filterObj.response.indexOf("Log-true");
                                var negativeLog = filterObj.response.indexOf("Log-false");
                                if((positiveLog === -1 && negativeLog !=  -1) || (negativeLog === -1 && positiveLog !== -1)){
                                    if(positiveBlock === -1 && data[i].threatResponseData.logPacket )
                                        passed = false;
                                    if(negativeLog === -1 && !data[i].threatResponseData.logPacket )
                                        passed = false;
                                }

                                var positiveAlert = filterObj.response.indexOf("Alert-true");
                                var negativeAlert = filterObj.response.indexOf("Alert-false");
                                if((positiveAlert === -1 && negativeAlert !=  -1) || (negativeAlert === -1 && positiveAlert !== -1)){
                                    if(positiveAlert === -1 && data[i].threatResponseData.alert )
                                        passed = false;
                                    if(negativeAlert === -1 && !data[i].threatResponseData.alert )
                                        passed = false;
                                }
                            }

                            if(passed)
                                output.push(data[i]);
                            /*if(filterObj.response.length < 6){
                                var passed = true;
                                var checkBlock = false;
                                var check = false;
                                var checkBlock = false;
                                if()

                            } else {*/
                                //output.push(data[i]);
                            //}
                        }
                    }
                }
            }
            if(output.length < 1000)
                console.log("this is the output ",output);

            console.log("output length is ",output.length);
            return output;
        };
    }

 angular.module('shieldxApp').filter('filterthreat', filterthreatFn);

})();

/*
 ShieldX Networks Inc. CONFIDENTIAL
 ----------------------------------
 *
 Copyright (c) 2016 ShieldX Networks Inc.
 All Rights Reserved.
 *
 NOTICE: All information contained herein is, and remains
 the property of ShieldX Networks Incorporated and its suppliers,
 if any. The intellectual and technical concepts contained
 herein are proprietary to ShieldX Networks Incorporated
 and its suppliers and may be covered by U.S. and Foreign Patents,
 patents in process, and are protected by trade secret or copyright law.
 Dissemination of this information or reproduction of this material
 is strictly forbidden unless prior written permission is obtained
 from ShieldX Networks Incorporated.
 */

(function () {

    function backupRestoreService(getDataService, Restangular, $q, readDataService,createDataService, deleteDataService, updateDataService) {
        "ngInject";

        this.backupData = function (paramObj) {
        	console.log("backupRestoreService : backupdata() called. backup config = "+paramObj);
            return getDataService.makeRESTDataCall('POST', 'manage/backup', paramObj).then(function (response) {
                if (response) {
                    return {
                        'status': true,
                        'response': response
                    };
                } else {
                    return {
                        'status': false,
                        'response': response
                    };

                }
            }, function (error) {
                throw (error);
            });  
        };

        this.restoreData = function (paramObj) {
        	console.log("backupRestoreService : restore data "+paramObj);
            return getDataService.makeRESTDataCall('POST', 'manage/restore', paramObj).then(function (response) {
                if (response) {
                    return {
                        'status': true,
                        'response': response
                    };
                } else {
                    return {
                        'status': false,
                        'response': response
                    };

                }
            }, function (error) {
                throw (error);
            });  
        };

        
        this.getBackupConfigList = function() {
        	console.log("backupRestoreService : get backup config list");
        	return getDataService.customGet('manage/backups').then(function(response) {
        		console.log("Response = "+response);
                if (response) {
                	return response;
                    /*return {
                        'status': true,
                        'response': response
                    };*/
                } else {
                    return {
                        'status': false,
                        'response': response
                    };

                }
        	}, function(error) {
        		throw (error);
        	});
        };
       
    }
    angular.module('shieldxApp').service('backupRestoreService', backupRestoreService);

})();
/*
ShieldX Networks Inc. CONFIDENTIAL
----------------------------------
*
Copyright (c) 2016 ShieldX Networks Inc.
All Rights Reserved.
*
NOTICE: All information contained herein is, and remains
the property of ShieldX Networks Incorporated and its suppliers,
if any. The intellectual and technical concepts contained
herein are proprietary to ShieldX Networks Incorporated
and its suppliers and may be covered by U.S. and Foreign Patents,
patents in process, and are protected by trade secret or copyright law.
Dissemination of this information or reproduction of this material
is strictly forbidden unless prior written permission is obtained
from ShieldX Networks Incorporated.
*/

(function () {
    function chartDataLoader(dataServerPath, $http, $q, getDataService) {
        "ngInject";

        this.getChartData = function (paramObj) {
            var deferred = $q.defer();
            var dataObj = {
                'userId': paramObj.id
            };

            var postObj = {
                'postData': dataObj,
                'postURL': 'chartsdata/'+ paramObj.datasetFileName
            };

            getDataService.makePostDataCall(postObj).then(function (response) {
                deferred.resolve(response.data);
            },
                    function (data) {
                        deferred.reject('no data found');
                    });

            return deferred.promise;

        };

    }

//        function chartDataLoader (Restangular) {
//
//            this.getChartData = function (paramObj) {
//                //var deferred = $q.defer();
//                //var userId = paramObj.id;
//
//                 return Restangular.all('posts').getList();
//
//                //return deferred.promise;
//
//            };
//
//        }
    angular.module('shieldxApp').service('chartDataLoader', chartDataLoader);
})();





/*
 ShieldX Networks Inc. CONFIDENTIAL
 ----------------------------------
 *
 Copyright (c) 2016 ShieldX Networks Inc.
 All Rights Reserved.
 *
 NOTICE: All information contained herein is, and remains
 the property of ShieldX Networks Incorporated and its suppliers,
 if any. The intellectual and technical concepts contained
 herein are proprietary to ShieldX Networks Incorporated
 and its suppliers and may be covered by U.S. and Foreign Patents,
 patents in process, and are protected by trade secret or copyright law.
 Dissemination of this information or reproduction of this material
 is strictly forbidden unless prior written permission is obtained
 from ShieldX Networks Incorporated.
 */

(function () {

    function contentDownloadService(getDataService, Restangular, $q, readDataService,createDataService, deleteDataService, updateDataService) {
        "ngInject";

        this.autodownloadcontent = function (paramObj) {
        	console.log("contentDownloadService : autodownloadcontent() : scheduler configuration for auto download of content = "+paramObj);
        	console.log("day of the week ---->> "+paramObj.dayOfTheWeek);
            return getDataService.makeRESTDataCall('POST', 'manage/schedule/downloadcontent', paramObj).then(function (response) {
                if (response) {
                    return {
                        'status': true,
                        'response': response
                    };
                } else {
                    return {
                        'status': false,
                        'response': response
                    };

                }
            }, function (error) {
                throw (error);
            });  
        };
        
        this.getContentDownloadSchedulerDetails = function(tenantId, type) {
        	console.log("contentDownloadService : get content download scheduler config.");
            var callingRoute = "/manage/"+tenantId+"/contentscheduler";
        	return getDataService.customGet(callingRoute).then(function(response) {
        		console.log("Response = "+response);
                if (response) {
                	return response;
                } else {
                    return {
                        'status': false,
                        'response': response
                    };

                }
        	}, function(error) {
        		throw (error);
        	});
        };
       
    }
    angular.module('shieldxApp').service('contentDownloadService', contentDownloadService);

})();
/*
 ShieldX Networks Inc. CONFIDENTIAL
 ----------------------------------
 *
 Copyright (c) 2016 ShieldX Networks Inc.
 All Rights Reserved.
 *
 NOTICE: All information contained herein is, and remains
 the property of ShieldX Networks Incorporated and its suppliers,
 if any. The intellectual and technical concepts contained
 herein are proprietary to ShieldX Networks Incorporated
 and its suppliers and may be covered by U.S. and Foreign Patents,
 patents in process, and are protected by trade secret or copyright law.
 Dissemination of this information or reproduction of this material
 is strictly forbidden unless prior written permission is obtained
 from ShieldX Networks Incorporated.
 */

(function () {
function coreservices(getDataService, createDataService ,  $sessionStorage, $q, readDataService,deleteDataService,userSessionMenagment) {


        this.getNetworkListByCloudId = function (cloudId) {
            return readDataService.readData("networks", cloudId).then(function (data) {
//            return getDataService.makeGetCall('infras', cloudId, 'networks').then(function (data) {
                return data;
            }, function (error) {
                console.log(error);
                return $q.reject(error);
            });
        };

        /*
         GET /shieldxapi/infras/{infraId}/resourcegroup
         */
        this.getResourceGroupsListByCloudId = function (cloudId) {
            return readDataService.readData("resourcegroup", cloudId).then(function (data) {
//            return getDataService.makeGetCall('infras', cloudId, 'resourcegroup').then(function (data) {
                return data;
            }, function (error) {
                console.log(error);
                return $q.reject(error);
            });
        };

         this.getResourceGroupsListByCloudIdFromServer = function (cloudId) {
            return getDataService.makeGetCall('infras', cloudId, 'resourcegroup').then(function (data) {
                return data;
            }, function (error) {
                console.log(error);
                return $q.reject(error);
            });
         };

        this.getListOfTenants = function (cloudId) {
            return readDataService.readData("tenants", cloudId).then(function (data) {
//            return getDataService.makeGetCall('infras', cloudId, 'tenants').then(function (data) {
                return data;
            }, function (error) {
                console.log(error);
                return $q.reject(error);
            });
        };

        this.getSecurityPolicySet = function () {
            return getDataService.makeRESTDataCall('GET', 'policy/securitypolicyset').then(function (data) {
                return data;
            });
        };
        this.getListOfAuthorities = function () {
            return getDataService.makeRESTDataCall('GET', 'user/authorities').then(function (data) {
                  userSessionMenagment.saveListOfAuthorities(data);
                  return data;
            });
        };
        this.signin = function(userName,password){
            var self = this;
            return getDataService.authenticateAndCreateUserSession(userName, password).then(function(data){
              userSessionMenagment.saveToUserSession();
            //  self.getListOfAuthorities();
              return data;
            },function(error){
                userSessionMenagment.invalidateUserSession();
               return $q.reject(error);
            });
        };

        this.signout = function(){
             var that = this;
            return getDataService.invalidUserSession().then(function(data){
                userSessionMenagment.invalidateUserSession();
              return data;
            },function(error){
                 userSessionMenagment.invalidateUserSession();
                return $q.reject(error);
            });
        };

        this.getListOfInfrastructures = function () {
            return readDataService.readData('infras').then(function (response) {
                return response;
            });
        };

       this.getListOfWorkloades = function(){
          var self = this; 
          var count = 0;
          var worloadArray = [];
         return  this.getListOfInfrastructures().then(function(clouds){
               console.log("getAllWorkloades clouds ");
               console.dir(clouds);
               return self.loadWorkload(clouds,count, worloadArray);              
          });
       };

       this.getWorkloadesByCloudId = function(cloudId){
           return getDataService.customGet('infras', cloudId+'/workloads').then(function (data) {
                return data;
            }, function (error) {
                console.log(error);
                return $q.reject(error);
            });
       };

       this.loadWorkload = function(clouds, count, workloadArray){
         var self = this; 
        return  this.getWorkloadesByCloudId(clouds[count].id).then(
             function(workload){
                for(var i =0; i < workload.workloads.length; i++){
                   workloadArray.push(workload.workloads[i]);
                }
               
                if(count < (clouds.length-1)){
                   return self.loadWorkload(clouds,count+1, workloadArray);
                } else{
                  return workloadArray;
                }
             }, function(error){
                console.log(count+"  error "+clouds.length);
                if(count < (clouds.length-1)){
                   return self.loadWorkload(clouds,count+1, workloadArray);
                } else{
                  return workloadArray;
                }
             }
          );
        }; 

        this.loadResourceGroup = function(clouds, count, rgArray){
         var self = this; 
        return  this.getResourceGroupsListByCloudIdFromServer(clouds[count].id).then(
             function(resourceGr){
                for(var i =0; i < resourceGr.length; i++){
                   rgArray.push(resourceGr[i]);
                }
               
                if(count < (clouds.length-1)){
                   return self.loadResourceGroup(clouds,count+1, rgArray);
                } else{
                  return rgArray;
                }
             }, function(error){
                console.log(count+"  error "+clouds.length);
                if(count < (clouds.length-1)){
                   return self.loadResourceGroup(clouds,count+1, rgArray);
                } else{
                  return rgArray;
                }
             }
          );
        };

        this.getListOfResourceGroup = function(){
          var self = this; 
          var count = 0;
          var rgArray = [];
         return  this.getListOfInfrastructures().then(function(clouds){
               console.log("getListOfResourceGroup clouds ");
               console.dir(clouds);
               return self.loadResourceGroup(clouds,count, rgArray);              
          });
        };
      this.getTenantForVMWare = function(){
             var self = this; 
             return this.getListOfInfrastructures().then(function(clouds){
                console.log(" getTenantForVMWare cloud ");
                var cloudID = -1;
                for(var i=0; i < clouds.length; i++ ){
                    var cloudInf = clouds[i];
                    if(cloudInf.type === "VMWARE"){
                       cloudID = cloudInf.id;
                       break;
                    }
                }
                if(cloudID !== -1){
                   return self.getListOfTenants(cloudID).then(function(tenentinfo){
                          console.log(" tenentinfo "+tenentinfo);
                          console.dir(tenentinfo);
                          return tenentinfo[0].id;
                   });  
                }
             });
          }; 
             
        this.getSubscriptionListBelongToAGroup = function (groupId) {
            return readDataService.readData("chassislist").then(function (data) {
                /* jshint ignore:start */
                for(var i=0 ; i <data.length; i++ ){
                   subscriptionList = data[i].subscriptionList;
                    var sub =  _.find(subscriptionList, function (sl){
                        return sl.resourceGroupId === groupId;
                    });
                    if(sub){
                        console.log(" getVirtualChassisBelongToAGroup subscriptionList "+groupId);
                        console.dir(sub);
                        return sub;
                    }

                }
                /* jshint ignore:end */
                return null;
            });
        };


        this.deletSubscriptionByID = function(id, cloudId){

           return deleteDataService.deleteData('subscription', id, cloudId).then(function (data) {
                 console.log("Subscription deleted", id);
                 return {'status': true};
            }, function (error) {
                console.log(error);
                return {'status': false, 'errorMessage': error.data.message};
            });

        };

        this.getmemberListofResourceGroup = function(id,cloudId){
          return getDataService.customGet('infras/resourcegroup/'+id).then(function (data) {
            var matchedInfraIndex = _.findIndex($sessionStorage.infrastructureObj,{"id":cloudId});
            var matchedResourcegroupIndex = _.findIndex($sessionStorage.infrastructureObj[matchedInfraIndex].resourcegroup,{"id":id});
            $sessionStorage.infrastructureObj[matchedInfraIndex].resourcegroup[matchedResourcegroupIndex].memberList = data.memberList;
            console.log("made the call");
              return data;
          });
        };
   
}
    angular.module('shieldxApp').service('coreservices', coreservices);
  

})();
/*
 ShieldX Networks Inc. CONFIDENTIAL
 ----------------------------------
 *
 Copyright (c) 2016 ShieldX Networks Inc.
 All Rights Reserved.
 *
 NOTICE: All information contained herein is, and remains
 the property of ShieldX Networks Incorporated and its suppliers,
 if any. The intellectual and technical concepts contained
 herein are proprietary to ShieldX Networks Incorporated
 and its suppliers and may be covered by U.S. and Foreign Patents,
 patents in process, and are protected by trade secret or copyright law.
 Dissemination of this information or reproduction of this material
 is strictly forbidden unless prior written permission is obtained
 from ShieldX Networks Incorporated.
 */

(function () {
    function createDataService(
            getDataService,
            $sessionStorage,
            $q
            ) {
        "ngInject";

        //$sessionStorage.infrastructureObj = [];

        this.updateSessionData = function (routeName, data, infraid) {
            var infras = $sessionStorage.infrastructureObj;
            console.log("updateSessionData ");
            console.dir(data);
            var infarIndex = -1;
            if (routeName === "infras") {
                if (!infras) {
                    infras = [];
                }
                infras.push(data);
                console.log("cache updated  ");
                console.dir(infras);
            } else {
                if (infraid) {
                    infarIndex = this.getInfraIndexFromId(infraid);
                    if (infarIndex != -1) {
                        var infraRef = infras[infarIndex];
                        this.addResourceToSession(routeName, data, infraRef);
                    }
                }
            }

        };

        this.addResourceToSession = function (routeName, data, infraRef) {
            var resourceRef = infraRef[routeName];
            if (!resourceRef) {
                resourceRef = [];
                infraRef[routeName] = resourceRef;
            }
            resourceRef.push(data);
        };


        this.getInfraIndexFromId = function (infraid) {
            var infras = $sessionStorage.infrastructureObj;
            return  _.findIndex(infras, function (infra) {
                return infra.id === infraid;
            });
        };

        this.createData = function (routeName, data, infraid) {
            console.log("createData    ");
            console.dir(data);
            var path = getApiRoute("POST", routeName);

            var that = this;
            var returnVal = getDataService.makeRESTDataCall('POST', path, data).then(function (result) {

                //data.id = (routeName === "chassis") ? result.id : result;
                if(routeName === "chassis"){
                    data.id = result.id;
                    data.subscriptionList = result.subscriptionList;
                } else {
                    data.id = result;
                }
                var dataCloneRef = angular.copy(data);
                console.log("dataCloneRef  ");
                console.dir(dataCloneRef);
                that.updateSessionData(routeName, dataCloneRef, infraid);
                return result;
            }, function (error) {
                return $q.reject(error);
            });

            return returnVal;
        };
    }
    angular.module('shieldxApp').service('createDataService', createDataService);
})();
  (function() {
      function dashbordService(getDataService, authRestangular) {
          "ngInject";

          this.saveDashboardDataToServer = function(tenantId, dashbordData) {
              var path = "manage/" + tenantId + "/dashboardsettings";
              getDataService.makeRESTDataCall('POST', path, dashbordData).then(function(data) {
                  console.log(" saveDashabordData data file ");
                  console.log(data);
                  return data;
              });
          };

          this.getDashboardDataFromServer = function(tenantId) {
              var path = "manage/" + tenantId + "/dashboardsettings";
              return getDataService.customGet(path).then(function(data) {
                  console.log(" getDashboardData data file ");
                  console.log(data);
                  return data;
              });
          };

          this.getDashboardData = function(teneentId) {
              return this.getDashboardDataFromServer(teneentId).then(function(dataItem) {
                if(!dataItem.hasOwnProperty("columns")) {
                  return {
                    "columns": 1,
                    "lastActiveTab": 0,
                    "tabs": [],
                    "theme": "LIGHT"
                  };
                }
                  var screenData = [];
                  var data = dataItem.tabs;
                  console.log("dashbord data ");
                  console.dir(dataItem);
                  if(dataItem.tabs){
                  for (var i = 0; i < data.length; i++) {
                      var node = data[i];
                      var screenNode = {
                          title: node.title,
                          alerts: node.alerts,
                          dashboardItems: node.dashboarditems
                      };
                      screenData.push(screenNode);
                  }

                  var screenDataDashboard = {
                      "columns": dataItem.columns,
                      "lastActiveTab": dataItem.lastActiveTab,
                      "tabs": screenData,
                      "theme": dataItem.theme
                  };

                  return screenDataDashboard;
                }else{
                  return "";
                }
              });
          };

          this.saveDashboardData = function(teneentId, screenData) {
              var data = [];
              for (var i = 0; i < screenData.tabs.length; i++) {
                  var screen = screenData.tabs[i];
                  var dashBordData = {};
                  dashBordData.title = screen.title;
                  dashBordData.alerts = [];
                  dashBordData.dashboarditems = [];
                  for (var j = 0; j < screen.alerts.length; j++) {
                      var alerts = screen.alerts[j];
                      var alert = {
                          "id": alerts.id,
                          "widgetName": alerts.widgetName
                      };
                      dashBordData.alerts.push(alert);
                  }

                  for (var k = 0; k < screen.dashboardItems.length; k++) {
                      var dashboardItems = screen.dashboardItems[k];
                      var items = {
                          "id": dashboardItems.id,
                          "content": {
                              "widgetName": dashboardItems.content.widgetName
                          }
                      };

                      dashBordData.dashboarditems.push(items);
                  }

                  data.push(dashBordData);
              }
              //console.log(" data *** "+JSON.stringify(data)); 

              var screenDataDashboard = {
                  "columns": screenData.columns,
                  "lastActiveTab": screenData.lastActiveTab,
                  "tabs": data,
                  "theme": screenData.theme
              };

              console.log(" data *** " + JSON.stringify(screenDataDashboard));

              return this.saveDashboardDataToServer(teneentId, screenDataDashboard);
          };

      }
      angular.module('shieldxApp').service('dashbordservice', dashbordService);
  })();

/*
 ShieldX Networks Inc. CONFIDENTIAL
 ----------------------------------
 *
 Copyright (c) 2016 ShieldX Networks Inc.
 All Rights Reserved.
 *
 NOTICE: All information contained herein is, and remains
 the property of ShieldX Networks Incorporated and its suppliers,
 if any. The intellectual and technical concepts contained
 herein are proprietary to ShieldX Networks Incorporated
 and its suppliers and may be covered by U.S. and Foreign Patents,
 patents in process, and are protected by trade secret or copyright law.
 Dissemination of this information or reproduction of this material
 is strictly forbidden unless prior written permission is obtained
 from ShieldX Networks Incorporated.
 */

(function() {
    function dataVisualizationService(getDataService, chartDataLoader, $injector, $q, authRestangular, userSessionMenagment,websocketfectory) {
        "ngInject";

        this.getDataForWidget = function(dataWidgetConfig) {
            if (dataWidgetConfig.getProxyData()) {
                return this.loadDataFromProxySource(dataWidgetConfig.getProxyData());
            }
            var factory = $injector.get(dataWidgetConfig.getWidgetName() + "Factory");
            if (factory) {
                var quaryFunction = factory.getQueryData;
                var query = quaryFunction.apply(factory, [dataWidgetConfig.interval, dataWidgetConfig.nValue]);
                if (dataWidgetConfig.value === 'SystemInformation') {
                    return this.getSystemInfoData(query).then(function(serverResponse) {
                        var dataMassageObject = factory.getDataMassageObject(serverResponse);
                        var converter = dataMassageObject["get" + dataWidgetConfig.getChartType() + "Data"];
                        if (converter) {
                            var result = converter(serverResponse);
                            return result;
                        }
                    });
                } else {
                    return this.sendQueryToServer(query).then(function(serverResponse) {
                        var dataMassageObject = factory.getDataMassageObject(serverResponse);
                        var converter = dataMassageObject["get" + dataWidgetConfig.getChartType() + "Data"];
                        if (converter) {
                            var result = converter(serverResponse);
                            return result;
                        }
                    });
                }
            }
        };

        this.getFilteredDataForWidgets = function(dataWidgetConfigArray) {
            var query = "";
            if (dataWidgetConfigArray) {
                for (var i = 0; i < dataWidgetConfigArray.length; i++) {
                    var dataWidgetConfig = dataWidgetConfigArray[i];
                    var factory = $injector.get(dataWidgetConfig.getWidgetName() + "Factory");
                    var quaryFunction = factory.getQueryData;
                    var queryRef = quaryFunction.apply(factory, [dataWidgetConfig.interval, dataWidgetConfig.nValue]);
                    if (factory) {
                        query += queryRef + "\n";
                    }
                }

                return this.sendQueryToServer(query).then(function(serverResponse) {
                    console.log(" getDataForWidgets  latest data serverResponse");
                    console.dir(serverResponse);
                    console.log("serverResponse.responses " + serverResponse.responses.length);
                    var obj = {};
                    if (serverResponse.responses.length === dataWidgetConfigArray.length) {
                        console.log("data recived for each widget");
                        for (var j = 0; j < dataWidgetConfigArray.length; j++) {
                            var dataWidgetConfigRef = dataWidgetConfigArray[j];
                            var factory = $injector.get(dataWidgetConfigRef.getWidgetName() + "Factory");
                            var dataMassageObject = factory.getDataMassageObject(serverResponse.responses[j], dataWidgetConfig.nValue);
                            var converter = dataMassageObject["get" + dataWidgetConfigRef.getChartType() + "Data"];
                            obj[dataWidgetConfigRef.getWidgetName()] = converter(dataWidgetConfig.otheroption);
                        }
                    }
                    return obj;
                });
            }
        };

        this.getSystemData = function(sysitm) {
            var factory = $injector.get(sysitm.getWidgetName() + "Factory");
            var quaryFunction = factory.getQueryData;
            var query = quaryFunction.apply(factory, [sysitm.interval, sysitm.nValue]);
            return this.getSystemInfoData(query).then(function(serverResponse) {
                var dataMassageObject = factory.getDataMassageObject(serverResponse);
                var converter = dataMassageObject["get" + sysitm.getChartType() + "Data"];
                if (converter) {
                    var result = converter(serverResponse);
                    return result;
                }
            });
        };

        this.getDataForWidgets = function(dataWidgetConfigArray) {
            var sysitm = _.find(dataWidgetConfigArray, function(item) {
                return item.widgetName === "SystemInformation";
            });
            var self = this;
            if (sysitm) {
                if (dataWidgetConfigArray.length > 1) {
                    var newArray = [];
                    for (var i = 0; i < dataWidgetConfigArray.length; i++) {
                        if (dataWidgetConfigArray[i].widgetName !== "SystemInformation") {
                            newArray.push(dataWidgetConfigArray[i]);
                        }
                    }
                    return this.getFilteredDataForWidgets(newArray).then(function(data) {
                        return self.getSystemData(sysitm).then(function(systemData) {
                            data[sysitm.getWidgetName()] = systemData;
                            return data;
                        });
                    });
                } else {
                    return this.getSystemData(sysitm).then(function(data) {
                        var obj = {};
                        obj[sysitm.getWidgetName()] = data;
                        return obj;
                    });
                }
            } else {
                return this.getFilteredDataForWidgets(dataWidgetConfigArray);
            }
        };

        this.getSystemInfoData = function(data) {
            return getDataService.customGet(data).then(function(response) {
                return response;
            }, function(error) {
                console.dir(error);
                if (error && error.status == 401) {
                    userSessionMenagment.invalidateUserSession();
                }
                return $q.reject(error);
            });
        };

        this.getNextWidgetData = function(dataWidgetConfigArray, index, obj) {
            var dataWidgetConfig = dataWidgetConfigArray[index];
            var self = this;
            return this.getDataForWidget(dataWidgetConfig).then(function(widgetData) {
                obj[dataWidgetConfig.getWidgetName()] = widgetData;
                if ((index + 1) >= dataWidgetConfigArray.length) {
                    return obj;
                } else {
                    return self.getNextWidgetData(dataWidgetConfigArray, index + 1, obj);
                }
            });
        };

        this.getWidgetDrillDownFilteredData = function(widgetName) {
            var factory = $injector.get(widgetName + "Factory");
            var interval = 30;
            var nValue = 5;
            var quaryFunction = factory.getQueryData;
            var query = quaryFunction.apply(factory, [interval, nValue]);
            return this.sendQueryToServer(query).then(function(serverResponse) {
                var dataMassageObject = factory.getDataMassageObject(serverResponse);
                var filterData = dataMassageObject.getFiltterData();
                return filterData;
            });
        };

        this.getDrillDownDataForWidget = function(dataWidgetConfig) {
            var factory = $injector.get(dataWidgetConfig.getWidgetName() + "Factory");
            if (factory) {
                var quaryFunction = factory.getDrillDownQueryData;
                var args = [dataWidgetConfig.interval];
                if (dataWidgetConfig.queryArguments.length > 0) {
                    args = args.concat(dataWidgetConfig.queryArguments);
                }
                var query = quaryFunction.apply(factory, args);
                return this.sendQueryToServer(query).then(function(serverResponse) {
                    var dataMassageObject = factory.massageDrillDowndata(serverResponse);
                    return dataMassageObject;
                });
            }
        };

        this.sendQueryToServer = function(query) {
            return this.postQueryToServer(query).then(function(data) {
                return data.plain();
            }, function(error) {

            });
        };


        this.postQueryToServer = function(data) {
            return authRestangular.initSxquery().all("_msearch").post(data).then(function(result) {
                console.debug(" makePostCall  success  " + result);
                return result;
            }, function(error) {
                console.log(" makePostCall  failed ");
                console.dir(error);
                if (error && error.status == 401) {
                    userSessionMenagment.invalidateUserSession();
                }
                return $q.reject(error);
            });
        };

        this.loadDataFromProxySource = function(proxyData) {
            if (proxyData.sourceType == "txt") {
                return this.loadDataFromFile(proxyData.sourceName);
            }
        };

        this.loadDataFromFile = function(fileName) {
            var userInfo = {
                'id': 1, // unnecessary
                'datasetFileName': fileName //set the name of the file to fetch
            };
            return chartDataLoader.getChartData(userInfo).then(function(chartData) {
                return chartData;
            });
        };

        this.getEventDataFor2DRendering = function(filterdata,simulate) {
            filterdata.queryType = "TWO_DIMENSIONAL";
            var payload = filterdata.getJSON();
            var self = this;
            return authRestangular.init().all("queryBuilder").post(payload).then(function(queryRecived) {
                console.log(" this.getEventDataFor2DRendering query recived from query builder");
                queryRecived = queryRecived.plain();
                console.dir(queryRecived);
                var query = JSON.stringify(queryRecived.index) + "\n" + JSON.stringify(queryRecived.query);
                return self.sendQueryToServer(query).then(function(queryResult) {
                    console.log("  getEventDataFor2DRendering from m serarch " + queryResult);
                    var ed = new EventVisualizationData(filterdata, queryResult,simulate);
                    return ed.createJSONFor2D();
                });
            }, function(error) {
                console.log(" makePostCall  failed ");
                console.dir(error);
                if (error && error.status == 401) {
                    userSessionMenagment.invalidateUserSession();
                }
                return $q.reject(error);
            });
        };

        this.getEventDataFor3DRendering = function(filterdata, simulate) {
            filterdata.queryType = "THREE_DIMENSIONAL";
            var payload = filterdata.getJSON();
            var self = this;
            return authRestangular.init().all("queryBuilder").post(payload).then(function(queryRecived) {
                console.log(" getEventDataFor3DRendering query recived from query builder");
                queryRecived = queryRecived.plain();
                console.dir(queryRecived);
                var query = JSON.stringify(queryRecived.index) + "\n" + JSON.stringify(queryRecived.query);
                return self.sendQueryToServer(query).then(function(queryResult) {
                    console.log("  getEventDataFor3DRendering from m serarch " + queryResult);
                    var ed = new EventVisualizationData(filterdata, queryResult,simulate);
                    return ed.createJSONFor3D();
                });
            }, function(error) {
                console.log(" makePostCall  failed ");
                console.dir(error);
                if (error && error.status == 401) {
                    userSessionMenagment.invalidateUserSession();
                }
                return $q.reject(error);
            });

        };

        this.getEventDataFor3DGridData = function(filterdata) {
            filterdata.queryType = "THREE_DIMENSIONAL";
            var payload = filterdata.getJSON();
            var self = this;
            return authRestangular.init().all("queryBuilder").post(payload).then(function(queryRecived) {
                 queryRecived = queryRecived.plain();
                 var query = JSON.stringify(queryRecived.index) + "\n" + JSON.stringify(queryRecived.query);
                 return self.sendQueryToServer(query).then(function(queryResult) {
                    var eventdata = queryResult.responses["0"].hits.hits;
                    var data = [];
                    for(var i=0; i < eventdata.length ; i++){
                        data.push(eventdata[i]._source.event);
                    }
                    return data;
                 });
            });
        };

        this.conectToWebSocket = function(){
           return websocketfectory.connect().then(function(data){
             console.log(" conected To WebSocket ");
           });
        };

        this.sendDataToWebSocketTopic = function(topic,data){
            websocketfectory.sendData(topic,data);
        };

        this.subscribToTheTopic = function(topic){
          return websocketfectory.subscribToTheTopic(topic);
        };



    }
    angular.module('shieldxApp').service('dataVisualizationService', dataVisualizationService);
})();

/*
 ShieldX Networks Inc. CONFIDENTIAL
 ----------------------------------
 *
 Copyright (c) 2016 ShieldX Networks Inc.
 All Rights Reserved.
 *
 NOTICE: All information contained herein is, and remains
 the property of ShieldX Networks Incorporated and its suppliers,
 if any. The intellectual and technical concepts contained
 herein are proprietary to ShieldX Networks Incorporated
 and its suppliers and may be covered by U.S. and Foreign Patents,
 patents in process, and are protected by trade secret or copyright law.
 Dissemination of this information or reproduction of this material
 is strictly forbidden unless prior written permission is obtained
 from ShieldX Networks Incorporated.
 */

(function () {
    function deleteDataService(
            getDataService,
            $sessionStorage,
            $q
            ) {
        "ngInject";


        this.updateSessionData = function (routeName, id, infraid) {
            console.log("updateSessionData " + id);
            var infras = $sessionStorage.infrastructureObj;
            console.dir(infras);
            var infarIndex = -1;
            if (routeName === "infras") {
                console.log("updateSessionData after  delete " + infarIndex);
                console.dir(infras);
                infarIndex = this.getInfraIndexFromId(id);
                if (infarIndex != -1) {
                    infras.splice(infarIndex, 1);
                }
                console.log("updateSessionData after infra delete " + infarIndex);
                console.dir(infras);
            } else {
                if (infraid) {
                    infarIndex = this.getInfraIndexFromId(infraid);
                    if (infarIndex != -1) {
                        var infraRef = infras[infarIndex];
                        this.deleteResourceFromSession(routeName, id, infraRef);
                    }
                } else
                {
                    for (var i = 0; i < infras.length; i++) {
                        this.deleteResourceFromSession(routeName, id, infras[i]);
                    }
                }
            }

        };

        this.deleteResourceFromSession = function (routeName, id, infraRef) {
            var resourceRef = infraRef[routeName];
            console.log(" before deleteResourceFromSession  " + infraRef.name);
            console.dir(resourceRef);
            if (resourceRef && resourceRef.length > 0) {
                var deleteIndex = -1;
                deleteIndex = _.findIndex(resourceRef, function (resource) {
                    console.log("resource.id " + resource.id);
                    return resource.id === id;
                });
                console.log(" resource to be deleted " + deleteIndex);
                console.dir(resourceRef);
                if (deleteIndex !== -1) {
                    resourceRef.splice(deleteIndex, 1);
                }
                console.log(" after deleteResourceFromSession ");
                console.dir(resourceRef);
            }



        };


        this.getInfraIndexFromId = function (infraid) {
            var infras = $sessionStorage.infrastructureObj;
            return  _.findIndex(infras, function (infra) {
                return infra.id === infraid;
            });
        };

        this.deleteData = function (routeName, id, infraid) {
            console.log(" deleteData >> ");
            var path = getApiRoute("DELETE", routeName);
            var that = this;
            var returnVal = getDataService.makeRESTDataCall('DELETE', path, id).then(function (data) {
                that.updateSessionData(routeName, id, infraid);
                return data;
            }, function (error) {
                return $q.reject(error);
            });

            return returnVal;
        };
    }
    angular.module('shieldxApp').service('deleteDataService', deleteDataService);
})();
/*
ShieldX Networks Inc. CONFIDENTIAL
----------------------------------
*
Copyright (c) 2016 ShieldX Networks Inc.
All Rights Reserved.
*
NOTICE: All information contained herein is, and remains
the property of ShieldX Networks Incorporated and its suppliers,
if any. The intellectual and technical concepts contained
herein are proprietary to ShieldX Networks Incorporated
and its suppliers and may be covered by U.S. and Foreign Patents,
patents in process, and are protected by trade secret or copyright law.
Dissemination of this information or reproduction of this material
is strictly forbidden unless prior written permission is obtained
from ShieldX Networks Incorporated.
*/

(function () {
    function deploymentSpecificationService(getDataService, Restangular, createDataService, readDataService, updateDataService, deleteDataService) {
        "ngInject";

        this.createDeploymentSpecfication = function (paramObj) {
            //POST /shieldxapi/deployspec
            return createDataService.createData("deployspec", paramObj, paramObj.cloudid).then(function (data) {
                //return getDataService.makeRESTDataCall('POST', 'deployspec', paramObj).then(function(data) {
                return data;
            });
        };
        this.updateDeploymentSpecfication = function (paramObj) {
            //getDataService.makeRESTDataCall('PUT', paramObj)
            return updateDataService.updateData('deployspec', paramObj, paramObj.cloudid);
            //return getDataService.makeRESTDataCall('PUT', 'deployspec', paramObj);
        };
        this.getHosts = function (cloudId) {
            return readDataService.readData("hosts", cloudId).then(function (data) {
//            return getDataService.makeRESTDataCall('GET', 'infras', cloudId, 'hosts').then(function(data){
                return data;
            });
        };

        this.getDatastore = function (cloudId) {
            return readDataService.readData("datastore", cloudId).then(function (data) {
//            return getDataService.makeRESTDataCall('GET', 'infras', cloudId,'datastore').then(function(data){
                return data;
            });

        };
        //GET /shieldxapi/infras/{infraId}/tenants
        this.getTenants = function (cloudId) {
            return readDataService.readData("tenants", cloudId).then(function (data) {
//            return getDataService.makeRESTDataCall('GET', 'infras', cloudId,'tenants').then(function(data){
                return data;
            });

        };

        this.getRegions = function (cloudId) {
            return readDataService.readData("regions", cloudId).then(function (data) {
//            return getDataService.makeRESTDataCall('GET', 'infras', cloudId,'tenants').then(function(data){
                return data;
            });

        };

        this.deleteDeploymentSpecfication = function (deploymentSpecId, cloudId) {
            return deleteDataService.deleteData('deployspec', deploymentSpecId, cloudId).then(function (data) {
                //return getDataService.makeRESTDataCall('DELETE', 'deployspec', deploymentSpecId).then(function(data){
                console.log("Deployment Specification with id %i deleted successfully...", deploymentSpecId);
                //console.log(data);
                return {'status': true};
            }, function (error) {
                console.log(error);
                return {'status': false, 'errorMessage': error.data.message};
            });
        };

        this.getDeploymentSpecList = function (cloudId) {
            return readDataService.readData("deployspec", cloudId).then(function (data) {
//            return getDataService.makeRESTDataCall('GET', '', cloudId, 'deployspec').then(function(data){
                return data;
            }, function (error) {
                console.log(error);
                //THIS IS MOCK DATA
                return [];

            });
        };

        this.isinlineModeAvailable = function (cloudId, deploymentSpecId) {
            var deploymentSpecData = readDataService.readDataFromSession("deployspec", false, cloudId);
            var inlineModeAvailable = false;
            if (deploymentSpecData) {
                for (var i = 0; i < deploymentSpecData.length; i++) {
                    if(deploymentSpecData[i].id === deploymentSpecId) {
                        inlineModeAvailable = (typeof deploymentSpecData[i].vlanPoolId !== "undefined" &&
                deploymentSpecData[i].vlanPoolId) ? true : false;
                    }
                }
            }
            return inlineModeAvailable;
        };

    }
    angular.module('shieldxApp').service('deploymentSpecificationService', deploymentSpecificationService);
})();

/*
 ShieldX Networks Inc. CONFIDENTIAL
 ----------------------------------
 *
 Copyright (c) 2016 ShieldX Networks Inc.
 All Rights Reserved.
 *
 NOTICE: All information contained herein is, and remains
 the property of ShieldX Networks Incorporated and its suppliers,
 if any. The intellectual and technical concepts contained
 herein are proprietary to ShieldX Networks Incorporated
 and its suppliers and may be covered by U.S. and Foreign Patents,
 patents in process, and are protected by trade secret or copyright law.
 Dissemination of this information or reproduction of this material
 is strictly forbidden unless prior written permission is obtained
 from ShieldX Networks Incorporated.
 */

(function () {

    function emailService(getDataService, Restangular, $q, readDataService,createDataService, deleteDataService, updateDataService) {
        
        "ngInject";

        this.testConnection = function (tenantId, paramObj) {
        	console.log("emailService : testConnection() called. email server config = "+paramObj);
            var callingRoute = "/manage/"+tenantId+"/smtpserver/test";
            return getDataService.makeRESTDataCall('POST', callingRoute, paramObj).then(function (response) {
                if (response) {
                    return {
                        'status': true,
                        'response': response
                    };
                } else {
                    return {
                        'status': false,
                        'response': response
                    };

                }
            }, function (error) {
                throw (error);
            });  
        };


        this.saveEmailServerSettings = function (tenantId, paramObj) {            
        	console.log("emailService : save email server settings "+paramObj);
            var callingRoute = "/manage/"+tenantId+"/smtpserver";
            return getDataService.makeRESTDataCall('PUT', callingRoute, paramObj).then(function (response) {
                if (response) {
                    return {
                        'status': true,
                        'response': response
                    };
                } else {
                    return {
                        'status': false,
                        'response': response
                    };

                }
            }, function (error) {
                throw (error);
            });  
        };

        
        this.getEmailServerSettings = function(tenantId) {
        	console.log("emailService : get email server settings.");
            var callingRoute = "/manage/"+tenantId+"/smtpserver";
        	return getDataService.customGet(callingRoute).then(function(response) {
        		console.log("Response = "+response);
                if (response) {
                	return response;
                    /*return {
                        'status': true,
                        'response': response
                    };*/
                } else {
                    return {
                        'status': false,
                        'response': response
                    };

                }
        	}, function(error) {
        		throw (error);
        	});
        };

        /////  Email notification profile  /////
        this.createEmailNotificationProfile = function (tenantId, paramObj) {

            console.log("emailService : Add email notification profile : "+paramObj);

            var emailnotificationprofile = paramObj;
            var callingRoute = "/manage/smtp/"+tenantId+"/addprofile";
            
            return  getDataService.makeRESTDataCall('POST', callingRoute, emailnotificationprofile).then(function (data) {
                console.log("Email notification profile created.");
                return data;
            });
        };

        this.getSMTPNotificationProfile = function (tenantId) {
            console.log("emailService : get email notification profile for tenant id "+tenantId);
            var callingRoute = "/manage/smtp/"+tenantId+"/profile";
            return getDataService.customGet(callingRoute).then(function(response) {
                console.log("Response = "+response);
                if (response) {
                    return response;
                } else {
                    return {
                        'status': false,
                        'response': response
                    };
                }
            }, function(error) {
                throw (error);
            });

        };


        this.addRecipient = function(tenantId, recipientvo) {
            console.log("emailService : Add email recipient details : "+recipientvo);
            var callingRoute = "/manage/"+tenantId+"/recipient";
            return  getDataService.makeRESTDataCall('POST', callingRoute, recipientvo).then(function (data) {
                console.log("Recipient created.");
                return data;
            });
        };

        this.getRecipients = function(tenantId) {
            console.log("emailService : get recipient emails.");
            var callingRoute = "/manage/"+tenantId+"/recipients";
            return getDataService.customGet(callingRoute).then(function(response) {
                console.log("Response = "+response);
                if (response) {
                    return response;
                } else {
                    return {
                        'status': false,
                        'response': response
                    };
                }
            }, function(error) {
                throw (error);
            });
        };

    }
    
    angular.module('shieldxApp').service('emailService', emailService);

})();
/*
 ShieldX Networks Inc. CONFIDENTIAL
 ----------------------------------
 *
 Copyright (c) 2016 ShieldX Networks Inc.
 All Rights Reserved.
 *
 NOTICE: All information contained herein is, and remains
 the property of ShieldX Networks Incorporated and its suppliers,
 if any. The intellectual and technical concepts contained
 herein are proprietary to ShieldX Networks Incorporated
 and its suppliers and may be covered by U.S. and Foreign Patents,
 patents in process, and are protected by trade secret or copyright law.
 Dissemination of this information or reproduction of this material
 is strictly forbidden unless prior written permission is obtained
 from ShieldX Networks Incorporated.
 */

(function () {
    function dataVisualizationApi() {
        "ngInject";

        return shieldxDataFx();

    }

    angular.module('shieldxApp').factory('dataVisualizationApi', dataVisualizationApi);

})();

/*
 ShieldX Networks Inc. CONFIDENTIAL
 ----------------------------------
 *
 Copyright (c) 2016 ShieldX Networks Inc.
 All Rights Reserved.
 *
 NOTICE: All information contained herein is, and remains
 the property of ShieldX Networks Incorporated and its suppliers,
 if any. The intellectual and technical concepts contained
 herein are proprietary to ShieldX Networks Incorporated
 and its suppliers and may be covered by U.S. and Foreign Patents,
 patents in process, and are protected by trade secret or copyright law.
 Dissemination of this information or reproduction of this material
 is strictly forbidden unless prior written permission is obtained
 from ShieldX Networks Incorporated.
 */

(function () {
    function getDataService(dataServerPath, $http, $q, Restangular,authRestangular, userSessionMenagment) {
        "ngInject";



        // TODO following function needs to be removed later
        this.makePostDataCall = function (dataObj) {

            return $http({
                url: dataServerPath + dataObj.postURL,
                method: "GET",
                data: serializeData(dataObj.postData),
                config: {headers: {'Content-Type': 'application/json'}}
            });

        };

        /*

           <api end point>/resource/{id}/childResource
        */
        this.makeGetCall = function (resource, id, childResource){
          return Restangular.stripRestangular(authRestangular.init().one(resource, id).getList(childResource)).then(function(result){
                          //console.dir(result.plain()); 
              return result;
            },function(error){
               console.log(" makeGetCall  failed ");
               console.dir(error); 
               userSessionMenagment.invalidateUserSession();
              return $q.reject(error);
            });
        };

        /*
            <api end point>/{id}/childResource
        */
        this.makeGetCallWithoutRootResource = function (id, childResource){
           return authRestangular.init().one(id.toString(), childResource).get().then(function(result){
                          //console.dir(result.plain()); 
              return result;
            },function(error){
               console.log(" makeGetCallWithoutRootResource  failed ");
               console.dir(error); 
               if(error && error.status == 401){
                  userSessionMenagment.invalidateUserSession();
               }
              return $q.reject(error);
            });
        };

        /* 

           makeDeleteCall
           
           <api end point>/resourceName/{resourceID}
           @param resourceName  name of the resource to delete
           @param resourceID    id of the resource
        */
        this.makeDeleteCall =  function(resourceName, resourceID){
             return authRestangular.init().one(resourceName, resourceID).remove().then(function(result){
                          //console.dir(result.plain()); 
              return result;
            },function(error){
               console.log(" makeDeleteCall  failed ");
               console.dir(error); 
               if(error && error.status == 401){
               userSessionMenagment.invalidateUserSession();
               }
              return $q.reject(error);
            });
        };

        this.makePutCall = function(resourceName, data){
             return authRestangular.init().all(resourceName).customPUT(data).then(function(result){
                          //console.dir(result.plain()); 
              return result;
            },function(error){
               console.log(" makePutCall  failed ");
               console.dir(error); 
               if(error && error.status == 401){
               userSessionMenagment.invalidateUserSession();
               }
              return $q.reject(error);
            });
        };
        
        this.makePostCall = function(resourceName, data){
            console.debug(" makePostCall "+resourceName+"  ");
            return authRestangular.init().all(resourceName).post(data).then(function(result){
              console.debug(" makePostCall  success  "+result);
              //console.dir(result.plain()); 
              return result;
            },function(error){
               console.log(" makePostCall  failed ");
               console.dir(error); 
               if(error && error.status == 401){
               userSessionMenagment.invalidateUserSession();
               }
              return $q.reject(error);
            });
        };

        this.authenticateAndCreateUserSession = function(userName, password){
           return authRestangular.signIn(userName, password).then(function(data){
			   console.log(" authenticateAndCreateUserSession success ");
             return data;
            },function(error){
				
				return $q.reject(error);
            });
        };

        this.invalidUserSession = function(userName, password){
           return authRestangular.signOut().then(function(data){
                   return data;
            },function(error){
                
				return $q.reject(error);
            });
        };

       this.makeRESTDataCallImpl = function (method, callingObject, dataObj, subObj){
               if(method === "GET") {
                if(typeof dataObj === "undefined" && typeof subObj === "undefined") {
                    return authRestangular.init().all(callingObject).getList().then(function(result){
                       return Restangular.stripRestangular(result);

                    });

                } else if (dataObj && subObj) {

                    return authRestangular.init().one(callingObject, dataObj).getList(subObj).then(function(result){
                       return Restangular.stripRestangular(result);
                    });
                } else {
                    return authRestangular.init().all(dataObj).getList(subObj).then(function(result){
                       return Restangular.stripRestangular(result);
                    });
                }
            }
            if(method ==="POST") {
                return authRestangular.init().all(callingObject).post(dataObj).then(function(result){

                    return result;
                });
            }

            if(method ==="PUT") {
                return authRestangular.init().all(callingObject).customPUT(dataObj);
            }
            if(method ==="DELETE") {
                return authRestangular.init().one(callingObject, dataObj).remove().then(function(result){

                    return result;
                });
            }
        };
        this.makeRESTDataCall = function (method, callingObject, dataObj, subObj) {
           return  this.makeRESTDataCallImpl(method, callingObject, dataObj, subObj).then(function(data){
              //console.log(" makeRESTDataCall success");
                return data;
            },function(error){
                console.log(" makeRESTDataCall error ");
                console.dir(error);
                if(error && error.status == 401){
                    userSessionMenagment.invalidateUserSession();
                }
                return $q.reject(error);
            });
        };

        /*this.customGet = function (callingObj, subObject) {

            return authRestangular.init().all(callingObj).customGET(subObject).then( function(response) {

                return Restangular.stripRestangular(response);
            },function(error){
                console.log(" customGet error >> 1");
                console.dir(error);
                if(error && error.status == 401){
                  userSessionMenagment.invalidateUserSession();
                }
                return $q.reject(error);
            });
        };*/


        this.customGet = function (callingObj, subObject) {

            return authRestangular.init().all(callingObj).customGET(subObject).then( function(response) {

                return Restangular.stripRestangular(response);
            },function(error){
                console.log(" customGet error >> 1");
                console.dir(error);
                if(error && error.status == 401){
                  userSessionMenagment.invalidateUserSession();
                }
                return $q.reject(error);
            });
        };


        this.uploadFile = function (callingObj, file) {
            var fd = new FormData();
            fd.append('file', file);

            return authRestangular.init().one(callingObj).withHttpConfig({transformRequest: angular.identity})
                    .customPOST(fd, '', undefined, {'Content-Type': undefined});
        };


        this.downloadFile = function(callingObj,subObject) {
            
            console.log("Download file started..");
            
            return authRestangular.init().one(callingObj).withHttpConfig({responseType: 'blob'})
                                  .customGET(subObject).then( function(response) {
                //return Restangular.one(callingObj).withHttpConfig({responseType: 'blob'}).response;
                return response;
            },function(error){
                console.log(" customGet error >> 1");
                console.dir(error);
                if(error && error.status == 401){
                  userSessionMenagment.invalidateUserSession();
                }
                return $q.reject(error);
            });
        };

    }

    angular.module('shieldxApp').service('getDataService', getDataService);
})();

function serializeData(data) {
    // If this is not an object, defer to native stringification.
    if (!angular.isObject(data)) {
        return((data === null) ? "" : data.toString());
    }
    var buffer = [];
    // Serialize each key in the object.
    for (var name in data) {
        if (!data.hasOwnProperty(name)) {
            continue;
        }
        var value = data[ name ];
        buffer.push(
                encodeURIComponent(name) +
                "=" +
                encodeURIComponent((value === null) ? "" : value)
                );
    }
    // Serialize the buffer and clean it up for transportation.
    var source = buffer
            .join("&")
            .replace(/%20/g, "+")
            ;
    return(source);
}
/*
 ShieldX Networks Inc. CONFIDENTIAL
 ----------------------------------
 *
 Copyright (c) 2016 ShieldX Networks Inc.
 All Rights Reserved.
 *
 NOTICE: All information contained herein is, and remains
 the property of ShieldX Networks Incorporated and its suppliers,
 if any. The intellectual and technical concepts contained
 herein are proprietary to ShieldX Networks Incorporated
 and its suppliers and may be covered by U.S. and Foreign Patents,
 patents in process, and are protected by trade secret or copyright law.
 Dissemination of this information or reproduction of this material
 is strictly forbidden unless prior written permission is obtained
 from ShieldX Networks Incorporated.
 */

(function () {

    function infrastructureConnectorService(getDataService, Restangular, $q, readDataService,createDataService, deleteDataService, updateDataService) {
        "ngInject";

        this.createInfrastructure = function (paramObj) {
            console.log(paramObj);
            var infrastructureObject1 = paramObj;
            /*var infrastructureObject = {
             "id": 0,
             "ip": paramObj.ip,
             "name": paramObj.name,
             "password": paramObj.password,
             "type": paramObj.type,
             "username": paramObj.username,
             "https" : paramObj.https,
             "domain" : paramObj.domain
             };*/

            return createDataService.createData('infras', infrastructureObject1).then(function (data) {
                console.log(" infrastructureConnectorService data file");
                return data;
            });
        };
        this.updateInfrastructure = function (paramObj) {
            //getDataService.makeRESTDataCall('PUT', paramObj)
            return updateDataService.updateData ('infras', paramObj , paramObj.id).then(function(response) {
                return response;
            }, function (error) {
                throw (error);
            });
        };

        this.getListOfInfrastructures = function () {
            return readDataService.readData('infras').then(function (response) {
                return response;
            });
            /*var deferred = $q.defer();
             
             items = [{"id":1,"name":"shieldx-ness","ip":"10.8.103.14","username":"administer@vsphere.local","password":null,"type":"VMWARE"},{"id":2,"name":"NessDevTeam","ip":"192.168.1.1","username":"mahesh","password":null,"type":"VMWARE"},{"id":3,"name":"NessDevTeam1","ip":"192.168.1.1","username":"mahesh","password":null,"type":"VMWARE"},{"id":4,"name":"NessShieldXTest1","ip":"172.27.255.255","username":"Test","password":null,"type":"VMWARE"},{"id":5,"name":"f","ip":"fadsf","username":"adsf","password":null,"type":"VMWARE"},{"id":6,"name":"Sudeep","ip":"10.10.101.10","username":"sudeep","password":null,"type":"VMWARE"},{"id":7,"name":"NESS-TESTING","ip":"10.8.103.15","username":"ness-user","password":null,"type":"VMWARE"},{"id":8,"name":"dsfdfd","ip":"dfsdfdfs","username":"dfdsfsfdsfdsfdf","password":null,"type":"VMWARE"},{"id":9,"name":"MaheshTest11","ip":"Test By Mahesh from app","username":"mahesh","password":null,"type":"VMWARE"},{"id":10,"name":"dsff","ip":"dfsdf","username":"dfsdf","password":null,"type":"VMWARE"},{"id":11,"name":"retrtrt","ip":"rtertrt","username":"rtertrt","password":null,"type":"VMWARE"},{"id":12,"name":"asdsadsad","ip":"asdsad","username":"asdsad","password":null,"type":"VMWARE"}];
             deferred.resolve(items);
             return deferred.promise;*/
        };

        this.deleteInfrastructure = function (id) {
            if (id) {
                return deleteDataService.deleteData('infras', id).then(function (res) {
                    console.log("Infrastructure deleted successfully");
                    //console.log(data);
                    return {'status': true};
                }, function (error) {
                    console.log(error);
                    return {'status': false, 'errorMessage': error.data.message};
                });
            } else {
                return {'status': false};
            }
        };

        this.discoverInfrastructure = function (cloudId) {
            return getDataService.customGet("infras", cloudId + "/discover").then(function (response) {
                if (response) {
                    return {'status': true};
                } else {
                    return {'status': false};

                }
            }, function (error) {
                console.log(error);
                return {'status': false, 'errorMessage': error.data.message};
            });
        };

        this.uploadSslKeys = function(tenantId, file) {
            
            var callingRoute = "/infras/"+tenantId+"/uploadsslkeys";
            
            return getDataService.uploadFile(callingRoute, file).then(function (response) {
                if (response) {
                    return {
                        'status': true,
                        'response': response
                    };
                } else {
                    return {
                        'status': false,
                        'response': response
                    };

                }
            }, function (error) {
                throw (error);
            });
        };
    }
    angular.module('shieldxApp').service('infrastructureConnectorService', infrastructureConnectorService);
})();

/*
 ShieldX Networks Inc. CONFIDENTIAL
 ----------------------------------
 *
 Copyright (c) 2016 ShieldX Networks Inc.
 All Rights Reserved.
 *
 NOTICE: All information contained herein is, and remains
 the property of ShieldX Networks Incorporated and its suppliers,
 if any. The intellectual and technical concepts contained
 herein are proprietary to ShieldX Networks Incorporated
 and its suppliers and may be covered by U.S. and Foreign Patents,
 patents in process, and are protected by trade secret or copyright law.
 Dissemination of this information or reproduction of this material
 is strictly forbidden unless prior written permission is obtained
 from ShieldX Networks Incorporated.
 */

function IPRangeRowData() {
    this.rangeStartEnableState = true;
    this.rangeEndEnableState = true;
    this.rangeCIDREnableState = true;
    this.rangeStartValue = "";
    this.rangeEndtValue = "";
    this.cidrValue = "";
}
IPRangeRowData.prototype.copy = function (data) {
    this.rangeStartEnableState = data.rangeStartEnableState;
    this.rangeEndEnableState = data.rangeEndEnableState;
    this.rangeCIDREnableState = data.rangeCIDREnableState;
    this.rangeStartValue = data.rangeStartValue;
    this.rangeEndtValue = data.rangeEndtValue;
    this.cidrValue = data.cidrValue;
};

IPRangeRowData.prototype.isPopulated = function () {
    if (this.rangeCIDREnableState) {
        return this.cidrValue !== "";
    } else {
        return this.rangeStartValue !== "" && this.rangeEndtValue !== "";
    }
};

IPRangeRowData.prototype.clone = function () {
    var ipRangeRowData = new IPRangeRowData();
    ipRangeRowData.rangeStartEnableState = this.rangeStartEnableState;
    ipRangeRowData.rangeEndEnableState = this.rangeEndEnableState;
    ipRangeRowData.rangeCIDREnableState = this.rangeCIDREnableState;
    ipRangeRowData.rangeStartValue = this.rangeStartValue;
    ipRangeRowData.rangeEndtValue = this.rangeEndtValue;
    ipRangeRowData.cidrValue = this.cidrValue;

    return ipRangeRowData;
};


function IPPoolServerData() {
    this.backPlaneIpPoolId = 0;
    this.backPlaneIsDhcp = false;
    this.backPlaneNetworkId = 0;
    this.mgmtIpPoolId = 0;
    this.mgmtIsDhcp = false;
    this.mgmtNetworkId = 0;

    this.managmentNetworkHeaderValue = "";
    this.managmentIPPoolHeaderValue = "";

    this.backpaneNetworkHeaderValue = "";
    this.backpaneIPPoolHeaderValue = "";
}



IPPoolServerData.prototype.copy = function (data) {
    if (typeof data.backPlaneIpPoolId !== "undefined") {
        this.backPlaneIpPoolId = data.backPlaneIpPoolId;
    }
    if (typeof data.backPlaneIsDhcp !== "undefined") {
        this.backPlaneIsDhcp = data.backPlaneIsDhcp;
    }
    if (typeof data.backPlaneNetworkId !== "undefined") {
        this.backPlaneNetworkId = data.backPlaneNetworkId;
    }
    if (typeof data.mgmtIpPoolId !== "undefined") {
        this.mgmtIpPoolId = data.mgmtIpPoolId;
    }
    if (typeof data.mgmtIsDhcp !== "undefined") {
        this.mgmtIsDhcp = data.mgmtIsDhcp;
    }
    if (typeof data.mgmtNetworkId !== "undefined") {
        this.mgmtNetworkId = data.mgmtNetworkId;
    }
};

function NewIPDate() {
    this.id = "";
    this.name = "";
    this.discription = "discription";
    this.ranges = [];
    this.mask = "";
    this.gateway = "";
    this.ranges.push(new IPRangeRowData());
}
NewIPDate.prototype.initializeFromIPData = function (ipdata) {
    // console.log(" initializeFromIPData ");
    this.name = ipdata.descr;
    this.gateway = ipdata.gateway;
    this.id = ipdata.id;
    this.name = ipdata.name;
    this.mask = ipdata.prefix;
    this.convertStringToIPRanges(ipdata.ranges);
};

NewIPDate.prototype.convertIPRangeToString = function () {
    var rangesValues = this.ranges;
    var ranges = "";
    if (rangesValues !== null) {
        for (var i = 0; i < rangesValues.length; i++) {
            var rangesValuesTemp = rangesValues[i];
            if (rangesValuesTemp.rangeCIDREnableState) {
                if (ranges !== "") {
                    ranges = ranges + "," + rangesValuesTemp.cidrValue;
                } else {
                    ranges = ranges + rangesValuesTemp.cidrValue;
                }

            } else {
                if (ranges !== "") {
                    ranges = ranges + "," + rangesValuesTemp.rangeStartValue + "-" + rangesValuesTemp.rangeEndtValue;
                } else {
                    ranges = ranges + rangesValuesTemp.rangeStartValue + "-" + rangesValuesTemp.rangeEndtValue;
                }
            }
        }
    }

    return ranges;
};

NewIPDate.prototype.convertStringToIPRanges = function (rangesStr) {
    // console.log(" convertStringToIPRanges  *** "+rangesStr);

    var commaArray = rangesStr.split(",");
    this.ranges = [];
    for (var i = 0; i < commaArray.length; i++) {

        if (commaArray[i].indexOf("-") != -1) {
            //console.log(" convertStringToIPRanges  ip range found  ");
            var dashArray = commaArray[i].split("-");
            // console.dir(dashArray);
            if (dashArray.length == 2) {
                var beIPRangeRowData = new IPRangeRowData();
                beIPRangeRowData.rangeCIDREnableState = false;
                beIPRangeRowData.rangeEndEnableState = true;
                // console.dir(beIPRangeRowData);
                beIPRangeRowData.rangeEndEnableState = true;
                //console.dir(beIPRangeRowData);
                beIPRangeRowData.rangeStartValue = dashArray[0];
                //console.dir(beIPRangeRowData);
                beIPRangeRowData.rangeEndtValue = dashArray[1];
                //console.dir(beIPRangeRowData);


                this.ranges.push(beIPRangeRowData);
                //console.log(" convertStringToIPRanges  ip range pushed  ");
                // console.dir(beIPRangeRowData);
            }
        } else if (commaArray[i].indexOf("/") != -1) {
            // console.log(" convertStringToIPRanges  ip cidr found  ");
            var cidrIPRangeRowData = new IPRangeRowData();
            cidrIPRangeRowData.rangeCIDREnableState = true;
            cidrIPRangeRowData.rangeEndEnableState = false;
            cidrIPRangeRowData.rangeEndEnableState = false;
            cidrIPRangeRowData.cidrValue = commaArray[i];
            this.ranges.push(cidrIPRangeRowData);
        }

        // console.dir(this.ranges);

    }

};
NewIPDate.prototype.clone = function () {
    var newIPDate = new NewIPDate();
    newIPDate.id = this.id;
    newIPDate.name = this.name;
    newIPDate.discription = this.discription;
    newIPDate.mask = this.mask;
    newIPDate.gateway = this.gateway;
    newIPDate.ranges = [];


    for (var i = 0; i < this.ranges.length; i++) {
        newIPDate.ranges.push(this.ranges[i].clone());
    }

    return newIPDate;

};
NewIPDate.prototype.copy = function (data) {
    this.name = data.name;
    this.ranges = [];
    //console.log(" NewIPDat  data initialize copy >>  ");
    //console.dir(data);
    for (var j = 0; j < data.ranges.length; j++) {
        var rangeVal = new IPRangeRowData();
        // console.log(" new  IPRangeRowData created  ");
        rangeVal.copy(data.ranges[j]);
        this.ranges.push(rangeVal);
    }
    this.mask = data.mask;
    this.gateway = data.gateway;
};

NewIPDate.prototype.getIPRangeRows = function () {
    return this.ranges;
};

NewIPDate.prototype.addNewIPRangeRow = function () {
    this.ranges.push(new IPRangeRowData());
};


NewIPDate.prototype.deleteIPRangeRow = function (index) {
    this.ranges.splice(index, 1);
};

NewIPDate.prototype.isPopulated = function () {
    // console.log(" this.name "+this.name);
    //console.log(" this.discription "+this.discription);
    //console.log(" this.startRange "+this.startRange);
    //console.log(" this.endRange "+this.endRange);
    // console.log(" this.mask "+this.mask);
    //console.log(" this.gateway "+this.gateway);
    var returnVal = (this.name !== "" && this.mask !== "" && this.gateway !== "");
    // console.log("NewIPDate this.returnVal "+returnVal);
    if (returnVal) {
        for (var i = 0; i < this.ranges.length; i++) {
            var rangeValue = this.ranges[i];
            console.log("range  " + rangeValue.isPopulated());
            if (!rangeValue.isPopulated())
            {
                returnVal = false;
                return returnVal;
            }

        }
    }
    return returnVal;
};






function IPPoolViewData() {
    this.networkSelected = {id: -1, name: " "};
    this.typeOfIPSelected = "";
    this.newIPData = new NewIPDate();
    this.existingIP = -1;
}



IPPoolViewData.prototype.isPopulated = function () {

    //console.log(" this.networkSelected "+this.networkSelected.id);
    //console.log(" this.typeOfIPSelected "+this.typeOfIPSelected);
    // console.log(" this.existingIP "+this.existingIP);


    if (this.networkSelected.id == -1) {
        return false;
    }

    if (this.typeOfIPSelected === "") {
        return false;
    } else {
        if (this.typeOfIPSelected == "new") {
            return this.newIPData.isPopulated();
        } else if (this.typeOfIPSelected == "existing") {
            return this.existingIP != -1;
        } else if (this.typeOfIPSelected == "dhcp") {
            return true;
        }
    }

};

IPPoolViewData.prototype.copy = function (data) {
    this.networkSelected = data.networkSelected;
    this.typeOfIPSelected = data.typeOfIPSelected;
    if (typeof data.newIPData !== "undefined") {
        this.newIPData.copy(data.newIPData);
    }
    this.existingIP = data.existingIP;
};

function IPPoolData() {
    this.name = "IPPoolData";
    this.serverData = new IPPoolServerData();
    this.managmentIPData = new IPPoolViewData();
    this.backpaneIPData = new IPPoolViewData();
}


IPPoolData.prototype.copy = function (data) {
    if (typeof data.serverData !== "undefined") {
        this.serverData.copy(data.serverData);
    }
    if (typeof data.managmentIPData !== "undefined") {
        this.managmentIPData.copy(data.managmentIPData);
    }
    if (typeof data.backpaneIPData !== "undefined") {
        // console.log(" backpaneIPData need to be copied >> " );    
        this.backpaneIPData.copy(data.backpaneIPData);
    }
};

IPPoolData.prototype.getManagmentIPData = function () {
    return this.managmentIPData;
};


IPPoolData.prototype.getBackPaneIPData = function () {
    return this.backpaneIPData;
};

IPPoolData.prototype.getServerData = function () {
    return  this.serverData;
};

IPPoolData.prototype.isPopulated = function () {
    //console.log("IPPoolData  isPopulated  managmentIPData "+this.managmentIPData.isPopulated());
    // console.log("IPPoolData  isPopulated  backpaneIPData "+this.backpaneIPData.isPopulated());
    return this.managmentIPData.isPopulated() && this.backpaneIPData.isPopulated();
};



/*
ShieldX Networks Inc. CONFIDENTIAL
----------------------------------
*
Copyright (c) 2016 ShieldX Networks Inc.
All Rights Reserved.
*
NOTICE: All information contained herein is, and remains
the property of ShieldX Networks Incorporated and its suppliers,
if any. The intellectual and technical concepts contained
herein are proprietary to ShieldX Networks Incorporated
and its suppliers and may be covered by U.S. and Foreign Patents,
patents in process, and are protected by trade secret or copyright law.
Dissemination of this information or reproduction of this material
is strictly forbidden unless prior written permission is obtained
from ShieldX Networks Incorporated.
*/

(function () {
    function ipPoolServices(getDataService, $sessionStorage, $q, readDataService, createDataService, deleteDataService, updateDataService) {

        "ngInject";
        this.cloudData = {};
        this.getInfrastructureData = function () {
            this.cloudData.cloudId = "1";
            if (typeof $sessionStorage.cloudData == 'undefined') {
                $sessionStorage.cloudData = {};
                $sessionStorage.cloudData.cloudId = "1";
                this.cloudData.cloudId = "1";
            } else {
                this.cloudData.cloudId = $sessionStorage.cloudData.cloudId;
                if (!$sessionStorage.cloudData.cloudId) {
                    $sessionStorage.cloudData.cloudId = "1";
                }
                //console.dir($sessionStorage.cloudData);
            }

            if (typeof this.cloudData.ipPool == 'undefined' && typeof $sessionStorage.cloudData.ipPool != 'undefined') {
                this.cloudData.ipPool = new IPPoolData();
                this.cloudData.ipPool.copy($sessionStorage.cloudData.ipPool);
            }
            if (typeof $sessionStorage.cloudData.ipPool == 'undefined') {
                this.cloudData.ipPool = new IPPoolData();
                $sessionStorage.cloudData.ipPool = {};

            }

            return this.cloudData;
        };


        this.getSessionData = function () {
            console.log(" $sessionStorage.cloudData " + $sessionStorage.cloudData);

            if (typeof $sessionStorage.cloudData == 'undefined') {
                $sessionStorage.cloudData = {};
            }
            if (!$sessionStorage.cloudData.infrastructure) {
                $sessionStorage.cloudData.infrastructure = {};
                $sessionStorage.cloudData.infrastructure.name = "";
                $sessionStorage.cloudData.infrastructure.ip = "";
            }
            return $sessionStorage.cloudData;
        };
        this.getIPPoolData = function () {
            return this.getInfrastructureData().ipPool;
        };

        this.getNetworkListByCloudId = function (cloudId) {
            return readDataService.readData("networks", cloudId).then(function (data) {
//          return getDataService.makeGetCall('infras', cloudId, 'networks').then(function (data) {
                return data;
            }, function (error) {
                console.log(error);
                return [];
            });
        };

        this.getWorkloadsByCloudId = function (cloudId) {
            return getDataService.customGet("infras/" + cloudId + "/workloads").then(function (data) {
                return data;
            }, function (error) {
                console.log(error);
                return [];
            });
        };


        this.getNetworksFromCache = function (callBack) {

            var cloudData = this.getInfrastructureData();
            //console.log(" cloud id "+cloudData.cloudId);
            //console.dir(cloudData.ipPool);
            if (typeof cloudData.ipPool.networks == 'undefined' || cloudData.ipPool.networks.length === 0) {
                console.log(" getNetworksFromCache get Data from server");
                this.getNetworkListByCloudId(cloudData.cloudId).then(function (data) {
                    console.log(" network data");
                    cloudData.ipPool.networks = data;
                    callBack.success(cloudData.ipPool.networks);
                    // console.dir(networkData);
                    return data;
                });
            } else
            {
                callBack.success(cloudData.ipPool.networks);
            }

            return cloudData.ipPool.networks;
        };


        this.getIpPoolListByCloudId = function (cloudId) {
            return readDataService.readData("ippool", cloudId);
//             return getDataService.makeGetCallWithoutRootResource(cloudId, "ippool");
        };

        /*
         Delete a ipPool console.dir
         @param poolId ipPool id
         
         /shieldxapi/ippool/{poolId}
         */
        this.deleteIPPool = function (ipPoolId) {
            console.info(" deleteIPPool ");
            return deleteDataService.deleteData("ippool", ipPoolId);
        };

        this.getExistingIPPoolListFromCache = function (forceUpdate, callBack) {

            var cloudData = this.getInfrastructureData();
            console.info(" getExistingIPPoolList called  ");
            var retPromise = null;
            //console.dir(cloudData);
            if (forceUpdate || (cloudData.cloudId && !cloudData.ipPool.existingipPool)) {
                retPromise = this.getIpPoolListByCloudId(cloudData.cloudId, "ippool").then(function (data) {
                    console.info(" data recived from server for ip list");
                    // console.dir(data.plain());
                    if (data) {
                        cloudData.ipPool.existingipPool = data;
                        // console.dir(cloudData.ipPool.existingipPool); 
                        if (callBack) {
                            callBack.success(cloudData.ipPool.existingipPool);
                        }
                    }
                });


            } else if (cloudData.ipPool.existingipPool) {
                if (callBack) {
                    callBack.success(cloudData.ipPool.existingipPool);
                }
            }
            return retPromise;
        };



        this.getIpPollInfoFromID = function (cloudid, ipPoolID) {
            console.log(" getIpPollInfoFromID cloudid ");
            return this.getIpPoolListByCloudId(cloudid).then(function (result) {
                var ipPoolList = result;
                var i;
                var tempRef;
                for (i in ipPoolList) {
                    tempRef = ipPoolList[i];
                    if (tempRef.id == ipPoolID) {
                        console.log(" getIpPollInfoFromID cloudid " + tempRef);
                        // console.dir(tempRef);
                        return tempRef;
                    }
                }
                return null;
            });
        };
        this.updateIPPool = function (cloudId, id, discription, gateway, name, prefix, ranges) {
            var data = {
                "cloudid": parseInt(cloudId),
                "descr": discription,
                "gateway": gateway,
                "id": parseInt(id),
                "name": name,
                "prefix": parseInt(prefix),
                "ranges": ranges
            };

            return updateDataService.updateData("ippool", data, cloudId);
        };
        this.createNewIPPool = function (cloudId, discription, gateway, name, prefix, ranges) {
            var data = {
                "cloudid": parseInt(cloudId),
                "descr": discription,
                "gateway": gateway,
                "id": 0,
                "name": name,
                "prefix": parseInt(prefix),
                "ranges": ranges
            };
            console.info(" createNewIPPool called");
            //console.dir(data); 
            return createDataService.createData("ippool", data, cloudId).then(function (dataVal) {
                return dataVal;
            });
        };


        this.getExistingIPPoolNameFromID = function (id) {
            var cloudData = this.getInfrastructureData();
            var ipPoolName = "";
            var ip = null;
            var tempRef = null;
            //console.dir(cloudData);   
            var data = cloudData.ipPool.existingipPool;
            for (ip in data) {
                tempRef = data[ip];
                if (tempRef.id == id) {
                    ipPoolName = tempRef.name;
                    break;
                }
            }

            // console.log(" getIPPoolNameFromIDFromCache  ipPoolName "+ipPoolName);
            return ipPoolName;
        };



        this.checkManageMentIPPoolDataPopulated = function () {
            var ipPoolData = this.getIPPoolData().getManagmentIPData();
            return ipPoolData.isPopulated();
        };

        this.checkBackPlaneIPPoolDataPopulated = function () {
            var ipPoolData = this.getIPPoolData().getBackPaneIPData();
            return ipPoolData.isPopulated();
        };

        this.createManagmentNewIPPool = function(ipPoolManagmentData){
                var returnValue = {result: true, promise: null}; 
                var startRange = ipPoolManagmentData.newIPData.startRange;
                var endRange = ipPoolManagmentData.newIPData.endRange;
                var mask = ipPoolManagmentData.newIPData.mask;
                var cloudId = this.getSessionData().cloudId;
                var discription = ipPoolManagmentData.newIPData.discription;
                var gateway = ipPoolManagmentData.newIPData.gateway;
                var id = 0;
                var name = ipPoolManagmentData.newIPData.name;
                var prefix = ipPoolManagmentData.newIPData.mask;
                var ranges = "";
                var rangesValues = ipPoolManagmentData.newIPData.ranges;
                if (rangesValues !== null) {
                    for (var i = 0; i < rangesValues.length; i++) {
                        var rangesValuesTemp = rangesValues[i];
                        if (rangesValuesTemp.rangeCIDREnableState) {
                            if (ranges !== "") {
                                ranges = ranges + "," + rangesValuesTemp.cidrValue;
                            } else {
                                ranges = ranges + rangesValuesTemp.cidrValue;
                            }

                        } else {
                            if (ranges !== "") {
                                ranges = ranges + "," + rangesValuesTemp.rangeStartValue + "-" + rangesValuesTemp.rangeEndtValue;
                            } else {
                                ranges = ranges + rangesValuesTemp.rangeStartValue + "-" + rangesValuesTemp.rangeEndtValue;
                            }
                        }
                    }
                }
                var that = this;
                returnValue.result = false; 
                returnValue.promise = this.getIpPoolListByCloudId(cloudId).then(function(ippools){
                    var ipExit = _.find(ippools,function(item){
                        return item.name === name; 
                    });
                   
                   if(!ipExit) {
                        
                       return that.createPanelIP(cloudId, discription, gateway, id, name, prefix, ranges).then(function (newIPPoll) {
                                console.log(" createPanelIP success ");
                                var serverdata = that.getIPPoolData().getServerData();
                                serverdata.mgmtIpPoolId = newIPPoll.id;
                                serverdata.managmentIPPoolHeaderValue = newIPPoll.name;
                                serverdata.mgmtIsDhcp = false;
                                $sessionStorage.cloudData.ipPool = that.getIPPoolData();
                                console.dir($sessionStorage.cloudData.ipPool);
                                return newIPPoll;
                        },function(error){
                         return $q.reject(error);
                      });
                    
                  } else {
                    var serverdata = that.getIPPoolData().getServerData();
                    serverdata.mgmtIpPoolId = ipExit.id;
                    serverdata.managmentIPPoolHeaderValue = ipExit.name;
                    serverdata.mgmtIsDhcp = false;
                    $sessionStorage.cloudData.ipPool = that.getIPPoolData();
                   
                  }
                },function(error){
                     return $q.reject(error);
                });

                return returnValue;
        };

        this.commitManagmentIPPoolData = function (callBack) {
            var ipPoolManagmentData = this.getIPPoolData().getManagmentIPData();
             var serverdata = this.getIPPoolData().getServerData();
            var returnValue = {result: true, promise: null};

            if (ipPoolManagmentData.typeOfIPSelected == "new") {
              returnValue = this.createManagmentNewIPPool(ipPoolManagmentData);
            } else if (ipPoolManagmentData.typeOfIPSelected == "existing") {
                serverdata.mgmtIpPoolId = parseInt(ipPoolManagmentData.existingIP);
                serverdata.managmentIPPoolHeaderValue = this.getExistingIPPoolNameFromID(serverdata.mgmtIpPoolId);
                serverdata.mgmtIsDhcp = false;
            } else if (ipPoolManagmentData.typeOfIPSelected == "dhcp")
            {
                serverdata.mgmtIsDhcp = true;
                serverdata.managmentIPPoolHeaderValue = "DHCP";
            }
            serverdata.mgmtNetworkId = ipPoolManagmentData.networkSelected.id;
            serverdata.managmentNetworkHeaderValue = ipPoolManagmentData.networkSelected.name;
            $sessionStorage.cloudData.ipPool = this.getIPPoolData();
            return returnValue;
        };

         this.createPanelIP = function(cloudId, discription, gateway, id, name, prefix, ranges){
            var data = {
                "cloudid": parseInt(cloudId),
                "descr": "discription",
                "gateway": gateway,
                "id": 0,
                "name": name,
                "prefix": parseInt(prefix),
                "ranges": ranges
            };

            var that = this;

            return createDataService.createData("ippool", data, cloudId).then(function (dataVal) {
                  return that.getIpPollInfoFromID(cloudId, dataVal).then(
                        function (newIPPoll) {
                           console.log(" newIPPoll info");
                           console.dir(newIPPoll); 
                           return newIPPoll;
                        }, function (error) {
                            return error;
                });
            }, function (error) {
                console.log(" createManagmentNewIPPool  failed >>> ");
                console.dir(error);
                return $q.reject(error);
            });
       }; 


        this.createBacklPlaneNewIPPool = function(ipPoolBackPaneData){
                var returnValue = {result: true, promise: null}; 
                var startRangeBackpane = ipPoolBackPaneData.newIPData.startRange;
                var endRangeBackpane = ipPoolBackPaneData.newIPData.endRange;
                var maskBackpane = ipPoolBackPaneData.newIPData.mask;


                var cloudeIdBackpane = this.getSessionData().cloudId;
                var discriptionBackpane = ipPoolBackPaneData.newIPData.discription;
                var gatewayBackpane = ipPoolBackPaneData.newIPData.gateway;
                var idBackpane = "0";
                var nameBackpane = ipPoolBackPaneData.newIPData.name;
                var prefixBackpane = ipPoolBackPaneData.newIPData.mask;
                var rangesBackpane = "";
                var rangesBackpaneValues = ipPoolBackPaneData.newIPData.ranges;
                if (rangesBackpaneValues !== null) {
                    for (var i = 0; i < rangesBackpaneValues.length; i++) {
                        var rangesValuesTemp = rangesBackpaneValues[i];
                        if (rangesValuesTemp.rangeCIDREnableState) {
                            if (rangesBackpane !== "") {
                                rangesBackpane = rangesBackpane + "," + rangesValuesTemp.cidrValue;
                            } else {
                                rangesBackpane = rangesBackpane + rangesValuesTemp.cidrValue;
                            }

                        } else {
                            if (rangesBackpane !== "") {
                                rangesBackpane = rangesBackpane + "," + rangesValuesTemp.rangeStartValue + "-" + rangesValuesTemp.rangeEndtValue;
                            } else {
                                rangesBackpane = rangesBackpane + rangesValuesTemp.rangeStartValue + "-" + rangesValuesTemp.rangeEndtValue;
                            }
                        }
                    }
                }
                 var that = this;
                returnValue.result = false; 
                returnValue.promise = this.getIpPoolListByCloudId(cloudeIdBackpane).then(function(ippools){
                    var ipExit = _.find(ippools,function(item){
                        return item.name === nameBackpane; 
                    });
                   
                   if(!ipExit) {
                        
                       return that.createPanelIP(cloudeIdBackpane, discriptionBackpane, gatewayBackpane, idBackpane, nameBackpane, prefixBackpane, rangesBackpane).then(function (newIPPoll) {
                                console.log(" createPanelIP success ");
                                var serverdata = that.getIPPoolData().getServerData();
                                serverdata.backPlaneIpPoolId = parseInt(newIPPoll.id);
                                serverdata.backpaneIPPoolHeaderValue = newIPPoll.name;
                                $sessionStorage.cloudData.ipPool = that.getIPPoolData();
                                return newIPPoll;
                        },function(error){
                         return $q.reject(error);
                      });
                    
                  } else {
                    var serverdata = that.getIPPoolData().getServerData();
                     serverdata.backPlaneIpPoolId = parseInt(ipExit.id);
                     serverdata.backpaneIPPoolHeaderValue = ipExit.name;
                     $sessionStorage.cloudData.ipPool = that.getIPPoolData();
                   
                  }
                },function(error){
                     return $q.reject(error);
                });

              return  returnValue; 
        };

        this.commitBacklPlaneIpPoolData = function () {

            var serverdata = this.getIPPoolData().getServerData();
            var ipPoolBackPaneData = this.getIPPoolData().getBackPaneIPData();
            // console.log(" ipPoolManagmentData "+ipPoolBackPaneData.typeOfIPSelected);
            var returnValue = {result: true, promise: null};
            if (ipPoolBackPaneData.typeOfIPSelected == "new") {
                returnValue = this.createBacklPlaneNewIPPool(ipPoolBackPaneData); 
            } else if (ipPoolBackPaneData.typeOfIPSelected == "existing") {
                serverdata.backPlaneIpPoolId = ipPoolBackPaneData.existingIP;
                serverdata.backpaneIPPoolHeaderValue = this.getExistingIPPoolNameFromID(serverdata.backPlaneIpPoolId);
                serverdata.backPlaneIsDhcp = false;
            } else if (ipPoolBackPaneData.typeOfIPSelected == "dhcp") {
                serverdata.backPlaneIsDhcp = true;
                serverdata.backpaneIPPoolHeaderValue = "DHCP";
            }


            serverdata.backPlaneNetworkId = ipPoolBackPaneData.networkSelected.id;
            serverdata.backpaneNetworkHeaderValue = ipPoolBackPaneData.networkSelected.name;

            $sessionStorage.cloudData.ipPool = this.getIPPoolData();
            console.log(" should go to next page ");
            //console.dir(ipPoolBackPaneData.networkSelected);
            // console.dir($sessionStorage.cloudData.ipPool.serverData); 
            return returnValue;
        };
    }
    angular.module('shieldxApp').service('ipPoolServices', ipPoolServices);
})();
/*
 ShieldX Networks Inc. CONFIDENTIAL
 ----------------------------------
 *
 Copyright (c) 2016 ShieldX Networks Inc.
 All Rights Reserved.
 *
 NOTICE: All information contained herein is, and remains
 the property of ShieldX Networks Incorporated and its suppliers,
 if any. The intellectual and technical concepts contained
 herein are proprietary to ShieldX Networks Incorporated
 and its suppliers and may be covered by U.S. and Foreign Patents,
 patents in process, and are protected by trade secret or copyright law.
 Dissemination of this information or reproduction of this material
 is strictly forbidden unless prior written permission is obtained
 from ShieldX Networks Incorporated.
 */

(function () {

    function ldapService(getDataService, Restangular, $q, readDataService,createDataService, deleteDataService, updateDataService) {
        "ngInject";

        this.testConnection = function (paramObj) {
        	console.log("ldapService : testConnection() called. ldap config = "+paramObj);
            return getDataService.makeRESTDataCall('POST', 'manage/ldapserver/test', paramObj).then(function (response) {
                if (response) {
                    return {
                        'status': true,
                        'response': response
                    };
                } else {
                    return {
                        'status': false,
                        'response': response
                    };

                }
            }, function (error) {
                throw (error);
            });  
        };

        this.saveSettings = function (paramObj) {
        	console.log("ldapService : save ldap server settings "+paramObj);
            return getDataService.makeRESTDataCall('PUT', 'manage/ldapserver', paramObj).then(function (response) {
                if (response) {
                    return {
                        'status': true,
                        'response': response
                    };
                } else {
                    return {
                        'status': false,
                        'response': response
                    };

                }
            }, function (error) {
                throw (error);
            });  
        };

        
        this.getSettings = function() {
        	console.log("ldapService : get smb server settings.");
        	return getDataService.customGet('manage/ldapserver/1').then(function(response) {
        		console.log("Response = "+response);
                if (response) {
                	return response;
                    /*return {
                        'status': true,
                        'response': response
                    };*/
                } else {
                    return {
                        'status': false,
                        'response': response
                    };

                }
        	}, function(error) {
        		throw (error);
        	});
        };
       
    }
    angular.module('shieldxApp').service('ldapService', ldapService);

})();
/*
 ShieldX Networks Inc. CONFIDENTIAL
 ----------------------------------
 *
 Copyright (c) 2016 ShieldX Networks Inc.
 All Rights Reserved.
 *
 NOTICE: All information contained herein is, and remains
 the property of ShieldX Networks Incorporated and its suppliers,
 if any. The intellectual and technical concepts contained
 herein are proprietary to ShieldX Networks Incorporated
 and its suppliers and may be covered by U.S. and Foreign Patents,
 patents in process, and are protected by trade secret or copyright law.
 Dissemination of this information or reproduction of this material
 is strictly forbidden unless prior written permission is obtained
 from ShieldX Networks Incorporated.
 */

(function () {
    function licenseService(getDataService) {
        "ngInject";

        // Make a POST call to activate given license
        this.callActivateLicense = function (paramObj) {
            return getDataService.makeRESTDataCall('POST', 'manage/license/activate', paramObj).then(function (response) {
                console.log("Activate License Called for id: " + paramObj);
                return response;
            });
        };

        // GET call to retrieve License from UUID
        this.callGetLicense = function (paramObj) {
            return getDataService.customGet('manage/license/' + paramObj).then(function (data) {
                console.log("Get License Called for id: " + paramObj);
                return data;
            });
        };
    }

    angular.module('shieldxApp').service('licenseService', licenseService);
})();

/*
 ShieldX Networks Inc. CONFIDENTIAL
 ----------------------------------
 *
 Copyright (c) 2016 ShieldX Networks Inc.
 All Rights Reserved.
 *
 NOTICE: All information contained herein is, and remains
 the property of ShieldX Networks Incorporated and its suppliers,
 if any. The intellectual and technical concepts contained
 herein are proprietary to ShieldX Networks Incorporated
 and its suppliers and may be covered by U.S. and Foreign Patents,
 patents in process, and are protected by trade secret or copyright law.
 Dissemination of this information or reproduction of this material
 is strictly forbidden unless prior written permission is obtained
 from ShieldX Networks Incorporated.
 */

(function () {
    function managementService(
            $q,
            getDataService
            ) {
        "ngInject";



        this.callUpgradeSoftware = function () {
            return getDataService.makeRESTDataCall('GET', 'manage/upgrade').then(function (response) {
                return response;
            });
        };

        this.listDeployedSoftwarePackage = function () {
            return getDataService.makeRESTDataCall('GET', 'manage/software/deployed').then(function (response) {
                return response;
            });
        };

        this.checkForSoftwareUpdates = function () {
            return getDataService.makeRESTDataCall('GET', 'manage/software/latest').then(function (response) {
                return response;
            });
        };

        this.upgradeSoftwarePatch = function (hfbuild) {
            console.log("Upgrade to hot fix build "+hfbuild);
            return getDataService.makeRESTDataCall('GET', 'manage/software/update/'+hfbuild+'/').then(function (response) {
                return response;
            });
        };

        this.upgradeSoftware = function () {
            console.log("Upgrade Software to latest");
            return getDataService.makeRESTDataCall('GET', 'manage/software/update').then(function (response) {
                return response;
            });
        };

        this.callUpgradeContent = function () {
            return getDataService.makeRESTDataCall('GET', 'manage/updatecontent').then(function (response) {
                return response;
            });
        };

        this.callUploadLogs = function () {
            return getDataService.makeRESTDataCall('GET', 'manage/upload').then(function (response) {
                return response;
            });
        };

        this.callDownloadEventLogs = function () {
            return getDataService.makeRESTDataCall('GET', 'manage/downloadcsv').then(function (response) {
                return response;
            });
        };

        this.getFireEyeIntegrationDetails = function () {
            return getDataService.customGet('manage/fireeyeconfig').then(function (response) {
                return response;
            });
        };

        this.updateFireEyeIntegrationDetails = function (paramObj) {
            return getDataService.makeRESTDataCall('PUT', 'manage/fireeyeconfig', paramObj);
        };

        this.updateControlPlaneSetting = function (paramObj) {
            return getDataService.makeRESTDataCall('PUT', 'manage/controlplaneconfig', paramObj);
        };


        this.uploadFile = function(tenantId, file) {            
            console.log(" managementService : Upload File for tenantId "+tenantId);
            var callingRoute = "/manage/"+tenantId+"/urlfiltering";            
            return getDataService.uploadFile(callingRoute, file).then(function (response) {
                if (response) {
                    return {
                        'status': true,
                        'response': response
                    };
                } else {
                    return {
                        'status': false,
                        'response': response
                    };

                }
            }, function (error) {
                throw (error);
            });
        };


        this.exportUrlFilteringData = function(tenantId) {
            console.log("managementservice : Export Url filtering content data.");

            var callingRoute = "/manage/"+tenantId+"/exporturlcontent";

            return getDataService.downloadFile(callingRoute).then(function(response) {
                console.log("download file Response = "+response);
                if (response) {
                    console.log(" managementservice : exportUrlFilteringData : response = "+response);
                    return response;
                } else {
                    return {
                        'status': false,
                        'response': response
                    };
                }
            }, function(error) {
                throw (error);
            });
        };



//        this.getControlPlaneSetting = function () {
//            return getDataService.makeRESTDataCall('GET', 'manage/controlplaneconfig').then(function (response) {
//                return response;
//            });
//        };

    }
    angular.module('shieldxApp').service('managementService', managementService);
})();

/*
ShieldX Networks Inc. CONFIDENTIAL
----------------------------------
*
Copyright (c) 2016 ShieldX Networks Inc.
All Rights Reserved.
*
NOTICE: All information contained herein is, and remains
the property of ShieldX Networks Incorporated and its suppliers,
if any. The intellectual and technical concepts contained
herein are proprietary to ShieldX Networks Incorporated
and its suppliers and may be covered by U.S. and Foreign Patents,
patents in process, and are protected by trade secret or copyright law.
Dissemination of this information or reproduction of this material
is strictly forbidden unless prior written permission is obtained
from ShieldX Networks Incorporated.
*/

(function() {
    function policyService(getDataService,  infrastructureConnectorService, Restangular, createDataService, readDataService, updateDataService, deleteDataService, $q, $sessionStorage) {
        "ngInject";

        var policyData = [];
        this.getSecurityPolicySet = function() {
            return getDataService.makeRESTDataCall('GET', 'policy/securitypolicyset').then(function(data) {
                return data;
            }, function(error) {
                console.log(error);
                //THIS IS MOCK DATA
                return [{
                    "id": 4,
                    "name": "ACL"
                }, {
                    "id": 2,
                    "name": "ThreatPrevention"
                }, {
                    "id": 3,
                    "name": "AppID"
                }, {
                    "id": 1,
                    "name": "ThreatPreventionAndAppID"
                }, {
                    "id": 5,
                    "name": "ThreatPreventionAndACL"
                }, {
                    "id": 6,
                    "name": "ACLAndAppId"
                }, {
                    "id": 7,
                    "name": "ACLThreatPreventionAndAppID"
                }];

            });
        };
        this.getSPSByTenant = function(tenantId){
            return getDataService.makeRESTDataCall('GET', 'policy/securitypolicyset/tenant/'+tenantId).then(function(data) {
                return data;
            }, function(error) {
                console.log("Error Occured");
            });
        };
        this.getListOfPoliciesDetails = function(routename, name, objId) {
            //policyData[routename] = [];
            objId = typeof objId !== 'undefined' ? objId : null;
            return readDataService.readData(routename, name, objId, { nocache: true }).then(function(data) {
                //            return getDataService.makeRESTDataCall('GET', '', cloudId, 'deployspec').then(function(data){

                return data;
            }, function(error) {
                console.log(error);
                //THIS IS MOCK DATA
                return $q.reject(error);
            });
        };
        this.getPolicyDetail = function(routename, name, objId) {
            if(objId){
                var dataurl = name + '/' + routename + '/' + objId;
                return getDataService.customGet(dataurl).then(function(response) {
                    return response;
                });
            } else {
                return $q.reject();
            }
        };
        this.getDataBasedOnId = function(path, id, obj) {
            var data = (obj === true) ? (id + '/' + path) : path + '/' + id;
            return getDataService.makeRESTDataCall('GET', data).then(function(result) {
                return result;
            }, function(err) {
                console.log(err);
                return $q.reject(err);
            });
            //$q.promise();
        };

        this.loadClouds = function(clouds, index, datalist,name){
                var cloudsLength = clouds.length;
                var cloud;
                var count = 0; 
                var self = this;
                if(clouds.length > index){
                   cloud = clouds[index];
                   return self.getDataBasedOnId("infras",cloud.id+"/"+name).then(function(tenantData){
                     _.each(tenantData, function(tenant) {
                        tenant.cloudName = cloud.name;
                        datalist.push(tenant);
                      });
                      if(index < cloudsLength){
                         return self.loadClouds(clouds, index+1, datalist,name);  
                      }
                   }); 
                }
        };
        this.getDataFromCloud = function(name){
            var self = this;
            return infrastructureConnectorService.getListOfInfrastructures().then(function(clouds) {
               var dataList = [];
               if(clouds.length > 0){
                   return self.loadClouds(clouds, 0, dataList,name).then(function(data){
                     console.log(" getdata "+dataList);
                     return dataList;
                   }); 
               }else{
                    return $q.reject();
               }
            });
                
        };
       this.getTotalTenats = function(){
            var self = this;
            return self.getDataFromCloud("tenants");
        };
        this.getResourceGroupData = function(){
            var self = this;
            return self.getDataFromCloud("resourcegroup");
        };
        
        
        this.updateMalwarePolicyData = function(path, data) {

            return getDataService.makeRESTDataCall('POST', path, data).then(function(result) {
                return result;
            }, function(err) {
                console.log(err);
                return $q.reject(err);
            });
        };
        this.updateExistingPolicyData = function(path, data) {

            return getDataService.makeRESTDataCall('PUT', path, data).then(function(result) {
                return result;
            }, function(err) {
                console.log(err);
                return $q.reject(err);
            });
        };
        this.deletePolicyBasedOnID = function(path, id) {
            return getDataService.makeRESTDataCall('DELETE', path, id).then(function(data) {
                return data;
            }, function(error) {
                return $q.reject(error);
            });
        };

        this.updatePolicyData = function(path, data) {

            return getDataService.makeRESTDataCall('PUT', path, data).then(function(result) {
                return result;
            }, function(err) {
                console.log(err);
                return $q.reject(err);
            });
        };

        this.createPolicyData = function(path, data) {

            return getDataService.makeRESTDataCall('POST', path, data).then(function(result) {
                return result;
            }, function(err) {
                console.log(err);
                return $q.reject(err);
            });
        };

        this.getDummyData = function(dummyData,path,id){
            return getDataService.makeRESTDataCall('GET', path, id).then(function(result) {
                return result;
            }, function(err) {
                console.log(err);
                return $q.resolve(dummyData);
            });
        };
    }
    angular.module('shieldxApp').service('policyService', policyService);
})();

/*
 ShieldX Networks Inc. CONFIDENTIAL
 ----------------------------------
 *
 Copyright (c) 2016 ShieldX Networks Inc.
 All Rights Reserved.
 *
 NOTICE: All information contained herein is, and remains
 the property of ShieldX Networks Incorporated and its suppliers,
 if any. The intellectual and technical concepts contained
 herein are proprietary to ShieldX Networks Incorporated
 and its suppliers and may be covered by U.S. and Foreign Patents,
 patents in process, and are protected by trade secret or copyright law.
 Dissemination of this information or reproduction of this material
 is strictly forbidden unless prior written permission is obtained
 from ShieldX Networks Incorporated.
 */

(function () {

    function purgeDataService(getDataService, Restangular, $q, readDataService,createDataService, deleteDataService, updateDataService) {
        "ngInject";

        this.schedulepruning = function (paramObj) {
        	console.log("purgeDataService : schedulepruning() called. schedule pruning config = "+paramObj);
            return getDataService.makeRESTDataCall('POST', 'manage/schedule/purge', paramObj).then(function (response) {
                if (response) {
                    return {
                        'status': true,
                        'response': response
                    };
                } else {
                    return {
                        'status': false,
                        'response': response
                    };

                }
            }, function (error) {
                throw (error);
            });  
        };
        
        this.getPruningSchedulerDetails = function() {
        	console.log("purgeDataService : get pruning scheduler config.");
        	return getDataService.customGet('manage/schedule/purge').then(function(response) {
        		console.log("Response = "+response);
                if (response) {
                	return response;
                    /*return {
                        'status': true,
                        'response': response
                    };*/
                } else {
                    return {
                        'status': false,
                        'response': response
                    };

                }
        	}, function(error) {
        		throw (error);
        	});
        };
       
    }
    angular.module('shieldxApp').service('purgeDataService', purgeDataService);

})();
/*
 ShieldX Networks Inc. CONFIDENTIAL
 ----------------------------------
 *
 Copyright (c) 2016 ShieldX Networks Inc.
 All Rights Reserved.
 *
 NOTICE: All information contained herein is, and remains
 the property of ShieldX Networks Incorporated and its suppliers,
 if any. The intellectual and technical concepts contained
 herein are proprietary to ShieldX Networks Incorporated
 and its suppliers and may be covered by U.S. and Foreign Patents,
 patents in process, and are protected by trade secret or copyright law.
 Dissemination of this information or reproduction of this material
 is strictly forbidden unless prior written permission is obtained
 from ShieldX Networks Incorporated.
 */

(function () {
    function readDataService(
            getDataService,
            $sessionStorage,
            $q
            ) {
        "ngInject";
        this.config = null;
        getVChassisSessionData = function () {
            var vChassisList = [];

            if (typeof $sessionStorage.infrastructureObj !== "undefined") {

                _.each($sessionStorage.infrastructureObj, function (infraObj) {

                    if (typeof infraObj.chassis !== "undefined") {

                        _.each(infraObj.chassis, function (vChassis) {

                            vChassisList.push(vChassis);
                        });
                    }
                });
            }
            return vChassisList;
        };


        getSessionData = function (routeName, isRoot, infraId) {

            var currentInfraObj;

            if (isRoot === true) {
                currentInfraObj = $sessionStorage.infrastructureObj;
            } else {
                currentInfraObj = (infraId === "undefined") ?
                        $sessionStorage.infrastructureObj :
                        _.find($sessionStorage.infrastructureObj, {"id": infraId});
            }

            if (typeof currentInfraObj === "undefined") {
                return currentInfraObj;
            }

            if (isRoot === true) {
                return currentInfraObj;
            } else {
                return currentInfraObj[routeName];
            }
        };

        getServerData = function (routeName, route, isRoot, infraId) {
            if(typeof infraId === 'string'){
                infraId = parseInt(infraId);
            } 
            return getDataService.makeRESTDataCall('GET', route).then(function (data) {
            if(typeof readDataService.config === 'object') {   
                if(readDataService.config.hasOwnProperty('nocache')) {
                    if(readDataService.config.nocache) {
                        return data;
                    }
                }
            } 
            if (isRoot === true) {
                    $sessionStorage.infrastructureObj = data;
                } else {
                    if(routeName === "malwarepolicy"){
                         $sessionStorage[routeName] = data;
                            
                    }else{
                         var currentInfraObj = (infraId === "undefined") ?
                            $sessionStorage.infrastructureObj :
                            _.find($sessionStorage.infrastructureObj, {"id": parseInt(infraId)});    
                        currentInfraObj[routeName] = data; 
                    }
                         
                }

                return data;
            });
        };

        this.readData = function (routeName, infraId, objectId, conf) {
            return readDataObj(routeName, infraId, objectId, conf);
        };

        readDataObj = function (routeName, infraId, objectId, conf) {
            readDataService.config = conf;
            if (routeName === "chassislist") {
                return readVChassisData();
            }

            var isRoot = (routeName === "infras") ? true : false;

            var route = getApiRoute("GET", routeName, infraId, objectId);

            if(typeof conf === 'object') {
                if(conf.hasOwnProperty('nocache')) {
                    if(conf.nocache) {
                        return getServerData(routeName, route, isRoot, infraId);
                    }
                } 
            }

            var returnData = getSessionData(routeName, isRoot, infraId);

            if (typeof returnData === "undefined") {
                return getServerData(routeName, route, isRoot, infraId);
            } else {
                return returnCurrentObj(returnData);
            }
        };

        getVChassisServerData = function () {
            return getDataService.makeRESTDataCall('GET', "chassislist").then(function (chassisList) {
                    if (typeof $sessionStorage.infrastructureObj !== "undefined") {
                        _.each($sessionStorage.infrastructureObj, function (infraObj, index) {
                            readDataObj("deployspec", infraObj.id).then(function (deploySpecs) {
                                infraObj.chassis = [];

                            _.each(chassisList, function (chassis) {
                                var chassisSet = false;
                                _.each(deploySpecs, function (deploySpec) {
                                    if (!chassisSet && deploySpec.id === chassis.datapathDeploySpecId) {
                                        infraObj.chassis.push(chassis);
                                        chassisSet = true;
                                    }
                                });
                            });

                            });
                        });
                        return chassisList;
                    } else {
                        this.readData("infras").then(getVChassisServerData());
                    }
            });
        };



        readVChassisData = function () {
            var vChassisList = getVChassisSessionData();

            if (vChassisList.length === 0) {
                return getVChassisServerData();
            }
            return returnCurrentObj(vChassisList);

        };


        /*
         * Stimulate a promise when data returned from sessionStorage
         */
        returnCurrentObj = function (currentInfraObj) {
            var deferred = $q.defer();
            var promise = deferred.promise;
            deferred.resolve(currentInfraObj);
            return promise;
        };

        /*
         * Stimulate a promise when data returned from sessionStorage
         */
        this.readDataFromSession = function (routeName, isRoot, infraId) {
            return getSessionData(routeName, isRoot, infraId);
        };


    }
    angular.module('shieldxApp').service('readDataService', readDataService);
})();
(function () {
    
    function reportGenerationService(getDataService, Restangular, $q, readDataService,
                                     createDataService, deleteDataService, updateDataService) {

        "ngInject";

        this.generateReport = function(reportConfig) {
            
            console.log("reportGenerationService : Generate report ");
            
            //var callingRoute = "/reports/"+tenantId+"/generatesummaryreport";
            var callingRoute = "/reports/generatesummaryreport";

            return getDataService.makePostCall(callingRoute, reportConfig).then(function (response) {
                if (response) {
                    return {
                        'status': true,
                        'response': response
                    };
                } else {
                    return {
                        'status': false,
                        'response': response
                    };
                }
            }, function (error) {
                throw (error);
            });
        }; 

        this.downloadReport = function() {
            console.log("reportGenerationService : Download Report.");
            var callingRoute = "/reports/downloadreport";
            return getDataService.downloadFile(callingRoute).then(function(response) {
                console.log("download file Response = "+response);
                if (response) {
                    console.log(" reportGenerationService : downloadReport : response = "+response);
                    return response;
                } else {
                    return {
                        'status': false,
                        'response': response
                    };
                }
            }, function(error) {
                throw (error);
            });

        };
    }

    angular.module('shieldxApp').service('reportGenerationService', reportGenerationService);

})();
/*
 ShieldX Networks Inc. CONFIDENTIAL
 ----------------------------------
 *
 Copyright (c) 2016 ShieldX Networks Inc.
 All Rights Reserved.
 *
 NOTICE: All information contained herein is, and remains
 the property of ShieldX Networks Incorporated and its suppliers,
 if any. The intellectual and technical concepts contained
 herein are proprietary to ShieldX Networks Incorporated
 and its suppliers and may be covered by U.S. and Foreign Patents,
 patents in process, and are protected by trade secret or copyright law.
 Dissemination of this information or reproduction of this material
 is strictly forbidden unless prior written permission is obtained
 from ShieldX Networks Incorporated.
 */

(function () {
    function resourceGroupService(getDataService, Restangular, readDataService, updateDataService, deleteDataService, createDataService) {
        "ngInject";


         this.createResourceGroup = function (paramObj) {
            //POST /shieldxapi/infras/resourcegroup
            return createDataService.createData("resourcegroup", paramObj, paramObj.cloudId).then(function (data) {
                //return getDataService.makeRESTDataCall('POST', 'infras/resourcegroup',  paramObj).then(function(data) {
                return data;
            });
        };

        /**
         * Function to get List of groups under given Infrastructure
         * @param cloudId (Cloud Id/ Infrastructure Id)
         * @returns array (GroupListData)
         * 
         */

        //GET /shieldxapi/infras/{infraId}/resourcegroup
        this.getGroupList = function (cloudId) {
//            return getDataService.makeRESTDataCall('GET', 'infras', cloudId,'resourcegroup').then(function(data){
            return readDataService.readData("resourcegroup", cloudId).then(function (data) {
                return data;
            }, function (error) {
                console.log(error);
                return [];
            });
        };
       /* this.getResourceGroupListBasedOnId = function(cloudId,objID){
            return readDataService.readData("resourcegroup", cloudId,objID).then(function (data) {
                return data;
            }, function (error) {
                console.log(error);
                return [];
            });
        };*/
        /**
         * Function to Delete resource group Id
         * @param rgId (Group Id)
         * @param cloudId (Cloud Id)
         * @returns object (Object of status)
         *
         */
        //DELETE /shieldxapi/infras/resourcegroup/{rgId}
        this.deleteGroupList = function (rgId, cloudId) {
            return deleteDataService.deleteData('resourcegroup', rgId, cloudId).then(function (data) {
                //return getDataService.makeRESTDataCall('DELETE', 'infras/resourcegroup', rgId).then(function(data){
                console.log("Resource Group with id %i deleted successfully...", rgId);
                //console.log(data);
                return {'status': true};
            }, function (error) {
                console.log(error);
                return {'status': false, 'errorMessage': error.data.message};
            });
        };

        /**
         * Function to Update resource group Id
         * @param paramObject (Object to update)
         * @returns promise
         *
         */
        this.updateResourceGroup = function (paramObject) {
            return updateDataService.updateData('resourcegroup', paramObject, paramObject.cloudId);
            //return getDataService.makeRESTDataCall('PUT', 'infras/resourcegroup', paramObject);
        };

    }
    angular.module('shieldxApp').service('resourceGroupService', resourceGroupService);
})();

/*
 ShieldX Networks Inc. CONFIDENTIAL
 ----------------------------------
 *
 Copyright (c) 2016 ShieldX Networks Inc.
 All Rights Reserved.
 *
 NOTICE: All information contained herein is, and remains
 the property of ShieldX Networks Incorporated and its suppliers,
 if any. The intellectual and technical concepts contained
 herein are proprietary to ShieldX Networks Incorporated
 and its suppliers and may be covered by U.S. and Foreign Patents,
 patents in process, and are protected by trade secret or copyright law.
 Dissemination of this information or reproduction of this material
 is strictly forbidden unless prior written permission is obtained
 from ShieldX Networks Incorporated.
 */

(function () {

    function schedulerService(getDataService, Restangular, $q, readDataService,createDataService, deleteDataService, updateDataService) {
        "ngInject";

        this.scheduleBackup = function (paramObj) {
        	console.log("schedulerService : scheduleBackup() called. schedule back for "+paramObj);
            return getDataService.makeRESTDataCall('POST', 'manage/schedule/backup', paramObj).then(function (response) {
                if (response) {
                    return {
                        'status': true,
                        'response': response
                    };
                } else {
                    return {
                        'status': false,
                        'response': response
                    };

                }
            }, function (error) {
                throw (error);
            });  
        };
        
        this.getSchedulerConfig = function() {
        	console.log("schedulerService : get scheduler config.");
        	return getDataService.customGet('manage/backup/schedulers').then(function(response) {
        		console.log("Response = "+response);
                if (response) {
                	return response;
                    /*return {
                        'status': true,
                        'response': response
                    };*/
                } else {
                    return {
                        'status': false,
                        'response': response
                    };

                }
        	}, function(error) {
        		throw (error);
        	});
        };
       
    }
    angular.module('shieldxApp').service('schedulerService', schedulerService);

})();
/*
 ShieldX Networks Inc. CONFIDENTIAL
 ----------------------------------
 *
 Copyright (c) 2016 ShieldX Networks Inc.
 All Rights Reserved.
 *
 NOTICE: All information contained herein is, and remains
 the property of ShieldX Networks Incorporated and its suppliers,
 if any. The intellectual and technical concepts contained
 herein are proprietary to ShieldX Networks Incorporated
 and its suppliers and may be covered by U.S. and Foreign Patents,
 patents in process, and are protected by trade secret or copyright law.
 Dissemination of this information or reproduction of this material
 is strictly forbidden unless prior written permission is obtained
 from ShieldX Networks Incorporated.
 */

(function () {

    function smbService(getDataService, Restangular, $q, readDataService,createDataService, deleteDataService, updateDataService) {
        "ngInject";

        this.testConnection = function (paramObj) {
        	console.log("smbService : testConnection() called. backup config = "+paramObj);
            return getDataService.makeRESTDataCall('POST', 'manage/smbserver/test', paramObj).then(function (response) {
                if (response) {
                    return {
                        'status': true,
                        'response': response
                    };
                } else {
                    return {
                        'status': false,
                        'response': response
                    };

                }
            }, function (error) {
                throw (error);
            });  
        };

        this.saveSmbServerSettings = function (paramObj) {
        	console.log("smbService : save smb server settings "+paramObj);
            return getDataService.makeRESTDataCall('PUT', 'manage/smbserver', paramObj).then(function (response) {
                if (response) {
                    return {
                        'status': true,
                        'response': response
                    };
                } else {
                    return {
                        'status': false,
                        'response': response
                    };

                }
            }, function (error) {
                throw (error);
            });  
        };

        
        this.getSmbServerSettings = function(tenantId) {
        	console.log("smbService : get smb server settings.");
        	tenantId = '1';
            var callingRoute = "manage/"+tenantId+"/smbserver";
        	return getDataService.customGet(callingRoute).then(function(response) {
        		console.log("Response = "+response);
                if (response) {
                	return response;
                    /*return {
                        'status': true,
                        'response': response
                    };*/
                } else {
                    return {
                        'status': false,
                        'response': response
                    };

                }
        	}, function(error) {
        		throw (error);
        	});
        };
       
    }
    angular.module('shieldxApp').service('smbService', smbService);

})();
(function () {
    
    function sslDecryptionService(getDataService, Restangular, $q, readDataService,createDataService, deleteDataService, updateDataService) {
        "ngInject";

        this.importResigningKeys = function(tenantId, file) {
            
            var callingRoute = "/tls/"+tenantId+"/importresigningkeys";
            
            return getDataService.uploadFile(callingRoute, file).then(function (response) {
                if (response) {
                    return {
                        'status': true,
                        'response': response
                    };
                } else {
                    return {
                        'status': false,
                        'response': response
                    };

                }
            }, function (error) {
                throw (error);
            });
        }; 

        
        this.generateDefaultResigningKey = function(tenantId) {
            
            console.log("Generate Default Certficiate for tenantId : "+tenantId);
            
            var callingRoute = "/tls/"+tenantId+"/generateresigningkey";
            
            return getDataService.makePostCall(callingRoute, tenantId).then(function (response) {
                if (response) {
                    return {
                        'status': true,
                        'response': response
                    };
                } else {
                    return {
                        'status': false,
                        'response': response
                    };

                }
            }, function (error) {
                throw (error);
            });
        }; 


        this.getResigningKeys = function(tenantId) {
            console.log("sslDecryptionService : get resigning keys for tenant id "+tenantId);

            var callingRoute = "/tls/"+tenantId+"/resigningkeys";

            return getDataService.customGet(callingRoute).then(function(response) {
                console.log("Response = "+response);
                if (response) {
                    return response;
                    /*return {
                        'status': true,
                        'response': response
                    };*/
                } else {
                    return {
                        'status': false,
                        'response': response
                    };

                }
            }, function(error) {
                throw (error);
            });
        };

        this.exportPublicKey = function(tenantId) {
            console.log("sslDecryptionService : Export public key ");

            var callingRoute = "/tls/"+tenantId+"/exportkey";

            return getDataService.downloadFile(callingRoute).then(function(response) {
                console.log("download file Response = "+response);
                if (response) {
                    console.log(" sslDecryptionService : exportpulbickey : response = "+response);
                    return response;
                    /*return {
                        'status': true,
                        'response': response
                    };*/
                } else {
                    return {
                        'status': false,
                        'response': response
                    };

                }
            }, function(error) {
                throw (error);
            });
        };


        this.export = function (tenantId) {
            console.log("sslDecryptionService : Export public key ");
            var callingRoute = "/tls/"+tenantId+"/exportkey";
            return getDataService.makeRESTDataCall('GET', callingRoute).then(function (response) {
                return response;
            }, function(error) {
                console.log("Error when exporting key "+error);
                throw (error);
            });
        };


        this.useImportedCert = function(tenantId,useimported) {
            console.log("sslDecryptionService : Use imported cert.");

            var callingRoute = "/tls/"+tenantId+"/useimportedcert/"+useimported;

            return getDataService.customGet(callingRoute).then(function(response) {
                console.log("Response = "+response);
                if (response) {
                    return response;
                    /*return {
                        'status': true,
                        'response': response
                    };*/
                } else {
                    return {
                        'status': false,
                        'response': response
                    };

                }
            }, function(error) {
                throw (error);
            });
        };

        this.getInboundKeys = function(tenantId) {
            console.log("sslDecryptionService : get inbound keys for tenant id : "+tenantId);

            var callingRoute = "/tls/"+tenantId+"/inboundkeys";

            return getDataService.customGet(callingRoute).then(function(response) {
                console.log("Response = "+response);
                if (response) {
                    return response;
                    /*return {
                        'status': true,
                        'response': response
                    };*/
                } else {
                    return {
                        'status': false,
                        'response': response
                    };

                }
            }, function(error) {
                throw (error);
            });
        };

    }
    angular.module('shieldxApp').service('sslDecryptionService', sslDecryptionService);

})();

(function () {

    function syslogForwardingService(getDataService, Restangular, $q, readDataService,createDataService, deleteDataService, updateDataService) {
        "ngInject";


        /////  Syslog forwarding config Profiles  /////
        this.createSyslogProfile = function (tenantId, paramObj) {
            console.log(paramObj);

            var syslogprofile = paramObj;

            var callingRoute = "/syslog/"+tenantId+"/addprofile";

            return  getDataService.makeRESTDataCall('POST', callingRoute, syslogprofile).then(function (data) {
                console.log("Syslog profile created.");
                return data;
            });
        };

        this.getSyslogProfiles = function (tenantId) {

        	var callingRoute = "/syslog/"+tenantId+"/profiles";

            return getDataService.customGet(callingRoute).then(function (response) {
                return response;
            });
        };

        this.deleteSyslogProfile = function(tenantId) {
            //var callingRoute = "/syslog/profiles/"+tenantId;
            return getDataService.makeRESTDataCall('DELETE', 'syslog/profiles', tenantId).then(function(data) {
                return data;
            }, function(error) {
                return $q.reject(error);
            });
        };

        ////  Syslog Server Profile  /////
        this.createSyslogServerProfile = function (tenantId, paramObj) {
            console.log(paramObj);

            var serverProfile = paramObj;

            var callingRoute = "/syslog/"+tenantId+"/addserver";

            return  getDataService.makeRESTDataCall('POST', callingRoute, serverProfile).then(function (data) {
                console.log("Syslog profile created.");
                return data;
            });
        };

        this.getSyslogServerProfiles = function (tenantId) {

        	var callingRoute = "/syslog/"+tenantId+"/serverprofiles";

            return getDataService.customGet(callingRoute).then(function (response) {
                return response;
            });
        };

        this.deleteSyslogServerProfile = function (serverProfileId) {

            //var callingRoute = "/syslog/serverprofile/"+serverProfileId;

            return getDataService.makeRESTDataCall('DELETE', '/syslog/serverprofile/', serverProfileId).then(function(data) {
                return data;
            }, function(error) {
                return $q.reject(error);
            });
        };

    }
    angular.module('shieldxApp').service('syslogForwardingService', syslogForwardingService);
})();    
/*
 ShieldX Networks Inc. CONFIDENTIAL
 ----------------------------------
 *
 Copyright (c) 2016 ShieldX Networks Inc.
 All Rights Reserved.
 *
 NOTICE: All information contained herein is, and remains
 the property of ShieldX Networks Incorporated and its suppliers,
 if any. The intellectual and technical concepts contained
 herein are proprietary to ShieldX Networks Incorporated
 and its suppliers and may be covered by U.S. and Foreign Patents,
 patents in process, and are protected by trade secret or copyright law.
 Dissemination of this information or reproduction of this material
 is strictly forbidden unless prior written permission is obtained
 from ShieldX Networks Incorporated.
 */

(function () {
    function sideNav($mdSidenav) {

        this.buildToggler = function (navID) {
            return function () {

                $mdSidenav(navID)
                        .toggle()
                        .then(function () {
                            //TODO Will add html content 
                        });
            };
        };
    }

    angular.module('shieldxApp').service('sideNav', sideNav);
})();


/*
 ShieldX Networks Inc. CONFIDENTIAL
 ----------------------------------
 *
 Copyright (c) 2016 ShieldX Networks Inc.
 All Rights Reserved.
 *
 NOTICE: All information contained herein is, and remains
 the property of ShieldX Networks Incorporated and its suppliers,
 if any. The intellectual and technical concepts contained
 herein are proprietary to ShieldX Networks Incorporated
 and its suppliers and may be covered by U.S. and Foreign Patents,
 patents in process, and are protected by trade secret or copyright law.
 Dissemination of this information or reproduction of this material
 is strictly forbidden unless prior written permission is obtained
 from ShieldX Networks Incorporated.
 */

(function () {
    function updateDataService(
            getDataService,
            $sessionStorage,
            $q
            ) {
        "ngInject";


        this.updateSessionData = function (routeName, data, infraid) {
            console.log("updateSessionData ");
            var infras = $sessionStorage.infrastructureObj;
            console.dir(infras);
            var infarIndex = -1;
            if (routeName === "infras") {
                console.log("updateSessionData after  delete " + infarIndex);
                console.dir(infras);
                infarIndex = this.getInfraIndexFromId(data.id);
                if (infarIndex != -1) {
                    infras.splice(infarIndex, 1);
                    infras.push(data);
                }
                console.log("updateSessionData after infra delete " + infarIndex);
                console.dir(infras);
            } else {
                if (infraid) {
                    infarIndex = this.getInfraIndexFromId(infraid);
                    if (infarIndex != -1) {
                        var infraRef = infras[infarIndex];
                        this.updateResourceInSession(routeName, data, infraRef);
                    }
                } else
                {
                    for (var i = 0; i < infras.length; i++) {
                        this.updateResourceInSession(routeName, data, infras[i]);
                    }
                }
            }

        };

        this.updateResourceInSession = function (routeName, data, infraRef) {
            var resourceRef = infraRef[routeName];
            console.log(" before updateResourceInSession" + infraRef.name);
            console.dir(resourceRef);
            if (resourceRef && resourceRef.length > 0) {
                var deleteIndex = -1;
                if(data)
                deleteIndex = _.findIndex(resourceRef, function (resource) {
                    return resource.id === data.id;
                });
                console.log(" resource to be deleted " + deleteIndex);
                console.dir(resourceRef);
                if (deleteIndex !== -1) {
                    resourceRef.splice(deleteIndex, 1);
                    resourceRef.push(data);
                }
                console.log(" after updateResourceInSession ");
                console.dir(resourceRef);
            }



        };


        this.getInfraIndexFromId = function (infraid) {
            var infras = $sessionStorage.infrastructureObj;
            return  _.findIndex(infras, function (infra) {
                return infra.id === infraid;
            });
        };

        this.updateData = function (routeName, data, infraid) {
            console.log(" updateData  >> ");
            var path = getApiRoute("PUT", routeName);
            var that = this;
            var returnVal = getDataService.makeRESTDataCall('PUT', path, data).then(function (result) {
                if(typeof result === 'object' )
                    that.updateSessionData(routeName, result, infraid);
                else
                    that.updateSessionData(routeName, data, infraid);
                return result;
            }, function (error) {
                return $q.reject(error);
            });

            return returnVal;
        };
    }
    angular.module('shieldxApp').service('updateDataService', updateDataService);
})();
/*
 ShieldX Networks Inc. CONFIDENTIAL
 ----------------------------------
 *
 Copyright (c) 2016 ShieldX Networks Inc.
 All Rights Reserved.
 *
 NOTICE: All information contained herein is, and remains
 the property of ShieldX Networks Incorporated and its suppliers,
 if any. The intellectual and technical concepts contained
 herein are proprietary to ShieldX Networks Incorporated
 and its suppliers and may be covered by U.S. and Foreign Patents,
 patents in process, and are protected by trade secret or copyright law.
 Dissemination of this information or reproduction of this material
 is strictly forbidden unless prior written permission is obtained
 from ShieldX Networks Incorporated.
 */

(function () {

    function usersService(getDataService, Restangular, $q, readDataService,createDataService, deleteDataService, updateDataService) {
        "ngInject";

        this.createUser = function (paramObj) {
            console.log(paramObj);
            var userObject1 = paramObj;
            userObject1.tenantId=1;
            /*var infrastructureObject = {
             "id": 0,
             "ip": paramObj.ip,
             "name": paramObj.name,
             "password": paramObj.password,
             "type": paramObj.type,
             "username": paramObj.username,
             "https" : paramObj.https,
             "domain" : paramObj.domain
             };*/

            return  getDataService.makeRESTDataCall('POST', 'manage/users', userObject1).then(function (data) {
                console.log(" userService data file");
                return data;
            });
        };
        this.updateUser= function (paramObj) {
            //getDataService.makeRESTDataCall('PUT', paramObj)
            return  getDataService.makeRESTDataCall('PUT', 'manage/users', paramObj).then(function(response) {
                return response;
            }, function (error) {
                throw (error);
            });
        };

        this.getListOfUsers = function () {
            return getDataService.customGet('manage/users').then(function (response) {
                return response;
            });
            /*var deferred = $q.defer();
             
             items = [{"id":1,"name":"shieldx-ness","ip":"10.8.103.14","username":"administer@vsphere.local","password":null,"type":"VMWARE"},{"id":2,"name":"NessDevTeam","ip":"192.168.1.1","username":"mahesh","password":null,"type":"VMWARE"},{"id":3,"name":"NessDevTeam1","ip":"192.168.1.1","username":"mahesh","password":null,"type":"VMWARE"},{"id":4,"name":"NessShieldXTest1","ip":"172.27.255.255","username":"Test","password":null,"type":"VMWARE"},{"id":5,"name":"f","ip":"fadsf","username":"adsf","password":null,"type":"VMWARE"},{"id":6,"name":"Sudeep","ip":"10.10.101.10","username":"sudeep","password":null,"type":"VMWARE"},{"id":7,"name":"NESS-TESTING","ip":"10.8.103.15","username":"ness-user","password":null,"type":"VMWARE"},{"id":8,"name":"dsfdfd","ip":"dfsdfdfs","username":"dfdsfsfdsfdsfdf","password":null,"type":"VMWARE"},{"id":9,"name":"MaheshTest11","ip":"Test By Mahesh from app","username":"mahesh","password":null,"type":"VMWARE"},{"id":10,"name":"dsff","ip":"dfsdf","username":"dfsdf","password":null,"type":"VMWARE"},{"id":11,"name":"retrtrt","ip":"rtertrt","username":"rtertrt","password":null,"type":"VMWARE"},{"id":12,"name":"asdsadsad","ip":"asdsad","username":"asdsad","password":null,"type":"VMWARE"}];
             deferred.resolve(items);
             return deferred.promise;*/
        };

        this.deleteUser = function (login) {
            
                return getDataService.makeRESTDataCall('DELETE', 'manage/users', login).then(function (res) {
                    console.log("User deleted successfully");
                    //console.log(data);
                    return {'status': true};
                }, function (error) {
                    console.log(error);
                    return {'status': false, 'errorMessage': error.data.message};
                });
            
        };

    }
    angular.module('shieldxApp').service('usersService', usersService);
})();

/*
ShieldX Networks Inc. CONFIDENTIAL
----------------------------------
*
Copyright (c) 2016 ShieldX Networks Inc.
All Rights Reserved.
*
NOTICE: All information contained herein is, and remains
the property of ShieldX Networks Incorporated and its suppliers,
if any. The intellectual and technical concepts contained
herein are proprietary to ShieldX Networks Incorporated
and its suppliers and may be covered by U.S. and Foreign Patents,
patents in process, and are protected by trade secret or copyright law.
Dissemination of this information or reproduction of this material
is strictly forbidden unless prior written permission is obtained
from ShieldX Networks Incorporated.
*/

(function () {
    function virtualChassisService(getDataService, coreservices, Restangular, $sessionStorage, $q, createDataService, readDataService, deleteDataService, updateDataService) {
        "ngInject";
        this.createResourceGroup = function (paramObj) {
            //POST /shieldxapi/infras/resourcegroup
            return createDataService.createData("resourcegroup", paramObj, paramObj.cloudId).then(function (data) {
                //return getDataService.makeRESTDataCall('POST', 'infras/resourcegroup',  paramObj).then(function(data) {
                return data;
            });
        };

        this.updateResourceGroup = function (paramObj) {
            //POST /shieldxapi/infras/resourcegroup
            return updateDataService.updateData('resourcegroup', paramObj, paramObj.cloudId);
            //return getDataService.makeRESTDataCall('PUT', 'infras/resourcegroup',  paramObj).then(function(data) {
            //return data;
            //});
        };
        this.createSubscription = function (paramObj) {
            //POST /shieldxapi/clouds/subscription
            /*return getDataService.makeRESTDataCall('POST', 'deployspec', paramObj).then(function(data) {
             return data;
             });*/
        };
        this.createVirtualChassis = function (paramObj) {
            //POST POST /shieldxapi/chassis
            return createDataService.createData("chassis", paramObj, paramObj.cloudId).then(function (data) {
                //return getDataService.makeRESTDataCall('POST', 'chassis', paramObj).then(function(data) {
                return data;
            });
        };
//        this.updateVirtualChassis = function(paramObj){
//            //getDataService.makeRESTDataCall('PUT', paramObj)
//        };
        this.getListOfVirtualChassis = function () {
            return readDataService.readData("chassislist").then(function (data) {
//            return getDataService.makeRESTDataCall('GET', 'chassislist').then(function(data) {
                return data;
            });
        };

        this.getListOfResourceGroups = function (cloudId) {
            return readDataService.readData("resourcegroup", cloudId).then(function (data) {
//            return getDataService.makeGetCall('infras', cloudId, 'resourcegroup').then(function (data) {
                return data;
            }, function (error) {
                console.log(error);
            });
        };

        this.deployVirtualChassis = function (vChassisId) {
            return getDataService.makeRESTDataCall('GET', 'chassis', vChassisId, 'check').then(function (data) {
                console.log("VirtualChassis with id %i checked successfully...", vChassisId);
                //console.log(data);
                return {'status': true};
            }, function (error) {
                console.log(error);
                return {'status': false, 'errorMessage': error.data.message};
            });
        };

        this.reDeployVirtualChassis = function (vChassisId) {
            return getDataService.makeRESTDataCall('GET', 'chassis', vChassisId, 'redeploy').then(function (data) {
                console.log("VirtualChassis with id %i redeployed successfully...", vChassisId);
                //console.log(data);
                return {'status': true};
            }, function (error) {
                console.log(error);
                return {'status': false, 'errorMessage': error.data.message};
            });
        };

        this.deleteResourceGroup = function (rGroupId, cloudId) {
            console.log("DELETE /shieldxapi/infras/resourcegroup/" + rGroupId);
            return deleteDataService.deleteData('resourcegroup', rGroupId, cloudId).then(function (data) {
//            return deleteDataService.deleteData("chassis", rGroupId, paramObj.cloudId).then(function(data){
//            return getDataService.makeRESTDataCall('DELETE', 'infras/resourcegroup', rGroupId).then(function(data){
                console.log("ResourceGroup with id %i deleted successfully...", rGroupId);
                //console.log(data);
                return {'status': true};
            }, function (error) {
                console.log(error);
                return {'status': false, 'errorMessage': error.data.message};
            });
        };

        this.deleteVirtualChassis = function (vChassisId, cloudId) {
            console.log("DELETE /shieldxapi/chassis/" + vChassisId);
            return deleteDataService.deleteData('chassis', vChassisId, cloudId).then(function (data) {
//            return getDataService.makeRESTDataCall('DELETE', 'chassis', vChassisId).then(function(data){
                console.log("VirtualChassis with id %i deleted successfully...", vChassisId);
                //console.log(data);
                return {'status': true};
            }, function (error) {
                console.log(error);
                return {'status': false, 'errorMessage': error.data.message};
            });
        };

        this.updateVirtualChassis = function (paramObj, cloudId) {
            //getDataService.makeRESTDataCall('PUT', paramObj)

            return updateDataService.updateData("chassis", paramObj, cloudId);
        };

        this.getListOfTenants = function (cloudId) {
            return getDataService.makeGetCall('infras', cloudId, 'tenants').then(function (data) {
                return data;
            }, function (error) {
                console.log(error);
            });
        };

        this.getCachedListOfTenants = function (callback) {
            if (!$sessionStorage.cloudData.vChassis.tenants) {
                return coreservices.getListOfTenants($sessionStorage.cloudData.cloudId).then(function (data) {
                    $sessionStorage.cloudData.vChassis.tenants = data;
                    callback.success(data);
                }, function (error) {
                    console.log(error);
                    callback.fail(error);
                });
            } else {
                return callback.success($sessionStorage.cloudData.vChassis.tenants);
            }
        };

        this.getALLResourceGroups = function (callback,
                cloudId,
                cachedNetworkObj,
                cachedResourceGroupObj,
                omitNetworksInResourceGroups,
                currentChasssisExistingGroups,workloads) {
            var that = this;
            if (!cachedResourceGroupObj) {
                coreservices.getResourceGroupsListByCloudId(
                        $sessionStorage.cloudData.cloudId).then(
                        function (data) {
//                            _.each(currentChasssisExistingGroups, function(existingGroup) {
//                                _.remove(data, function(network) {
//                                    return existingGroup.id === network.id;
//                                });
//                            });

                            cachedResourceGroupObj = data;
                            callback.success(
                                    that.mapNetworkToResourcegroup(
                                            cachedNetworkObj,
                                            cachedResourceGroupObj,
                                            omitNetworksInResourceGroups,
                                            currentChasssisExistingGroups,workloads
                                            )
                                    );
                        }, function (error) {
                    callback.fail(error);
                }
                );
            } else {

                callback.success(
                        that.mapNetworkToResourcegroup(
                                cachedNetworkObj,
                                cachedResourceGroupObj,
                                omitNetworksInResourceGroups,
                                currentChasssisExistingGroups,workloads
                                )
                        );
            }
        };

        this.mapNetworkToResourcegroup = function (networkObj, resourceGroupObj, omitNetworksInResourceGroups,currentChasssisExistingGroups,workloads) {
            var rg = resourceGroupObj;
            var nd = networkObj;
            console.log("mapNetworkToResourcegroup ");
            if (rg && nd) {
                //console.log(" resource group "+rg);
                //console.dir(rg);
                //console.log(" networks "+nd);
                // console.dir(nd);  
                return this.getAdditionalNetworkResourceGroupInfo(nd, rg, omitNetworksInResourceGroups,currentChasssisExistingGroups,workloads);
            }

            return {};
        };

        this.getAdditionalNetworkInfo = function (
                networks,
                backPlaneNetworkId,
                mgmtNetworkId) {
            _.forEach(networks, function (network, key) {
                networks[key].isBackplane =
                        (network.id === parseInt(backPlaneNetworkId)) ?
                        true : false;
                networks[key].isManagement =
                        (network.id === parseInt(mgmtNetworkId)) ?
                        true : false;
            });
            return networks;
        };

        this.createSubscriptionList = function (resourceGroup) {
            var sl = [];
            for (var i = 0; i < resourceGroup.length; i++) {
                var rg = resourceGroup[i];
                var subscriptionId = (rg.subscriptionId) ? rg.subscriptionId : null;
                sl.push({"id": subscriptionId, 
                    "resourceGroupId": rg.id, 
                    "spsId": rg.controlPolicy,
                    "inline": rg.inline});
            }
            return  sl;
        };
        getWorkloadByNetwork = function (workloadData, networkId) {
            /*return _.filter(workloadData.workloads, function (workload) {
                if (workload.ports.length) {
                    return (workload.ports[0].networkId == networkId);
                }
            });*/
            var mappedWorkloads = [];
            for (var i = 0; i < workloadData.workloads.length; i++) {
                var workload = workloadData.workloads[i];
                for (var j = 0; j < workload.ports.length; j++) {
                        if(workload.ports[j].networkId === networkId && ! _.find(mappedWorkloads,{"id":workload.id}))
                            mappedWorkloads.push(workload);
                }
            }
            return mappedWorkloads;
        };
        this.getAdditionalNetworkResourceGroupInfo = function (networks, resourceGroups, omitNetworksInResourceGroups,currentChasssisExistingGroups,workloadData) {
            console.log("these are the workloads",workloadData);
            console.log("networksnetworksnetworksnetworksnetworksnetworks");
            console.log(networks);
            var currentGroupList = [];
             _.forEach(currentChasssisExistingGroups,function(singleGroup){
                 currentGroupList.push(singleGroup.id);
             });

            var networksInResoureGroup = [];
            _.each(networks, function (network, networkKey) {
                network.workloads = [];
                network.workloads = getWorkloadByNetwork(workloadData, network.id);
            });
            _.forEach(networks, function (network, networkKey) {
                networks[networkKey].resourceGroupId = null;
                networks[networkKey].resourceGroupName = null;

                _.forEach(resourceGroups, function (resourceGroup) {
                    var obj = {};
                    obj.networkId = network.id;
                    _.forEach(resourceGroup.memberList, function (resourceGroupMember) {
                        if(resourceGroup.resourceType === "NETWORK"){
                            if (resourceGroupMember.networkId === network.id) {

                                networks[networkKey].resourceGroupId = (typeof resourceGroup.id !== "undefined") ?
                                        resourceGroup.id : null;
                                networks[networkKey].resourceGroupName = resourceGroup.name;
                                networksInResoureGroup.push(network);
                            }
                        } else if(resourceGroup.resourceType === "VM"){
                            var matchedWorkload = _.find(workloadData.workloads,{"id":resourceGroupMember.vmId});
                            if(matchedWorkload !== undefined){
                                var matchingNetwork = _.find(networks,{"id":matchedWorkload.ports[0].networkId});
                                if(matchingNetwork !== undefined){
                                    var innerWorkload = _.find(matchingNetwork.workloads,{"id":matchedWorkload.id});
                                    innerWorkload.resourceGroupId = (typeof resourceGroup.id !== "undefined") ?
                                        resourceGroup.id : null;
                                    innerWorkload.resourceGroupName = resourceGroup.name;
                                }
                            }
                            //console.log("the resourcegroup data is ",resourceGroup);
                        }
                    });
                });
            });
            if (omitNetworksInResourceGroups) {
                _.forEach(networks, function (instance) {
                    instance.hide = false;
                    if (instance.resourceGroupName !== null && instance.resourceGroupId !== "" && (currentGroupList.indexOf(instance.resourceGroupId) == -1) ) {
                        instance.hide = true;
                    }
                });
            }
            return networks;
        };

        this.getAllNetworksMappedToResource = function (callback, cloudId, cachedNetworkObj, cachedResourceGroupObj, omitNetworksInResourceGroups, existingGroups, vchassisId, tenantId,workloads) {
            console.log("cachedNetworkObjcachedNetworkObjcachedNetworkObjcachedNetworkObj");
            console.log(cachedNetworkObj);
            console.log("cachedNetworkObjcachedNetworkObjcachedNetworkObj");
            var that = this;
            if (typeof cachedNetworkObj === "undefined" || cachedNetworkObj.length === 0) {
                that.getVchassisNetworkMappingData(cloudId).then(function (networkChassisMapping) {
                    console.log(networkChassisMapping);
                    coreservices.getNetworkListByCloudId(cloudId).then(function (networkData) {
                        cachedNetworkObj = angular.copy(networkData);
                        cachedNetworkObj = _.filter(cachedNetworkObj, function (network) {
                           return (!network.tenantId || (network.tenantId === tenantId));
                        });
                        _.each(networkChassisMapping, function (networkChassisMappingObj) {
                            _.each(networkChassisMappingObj.networks, function (mappingNetwork) {
                                if (vchassisId !== null && networkChassisMappingObj.chassisId !== vchassisId) {
                                    var obj = _.find(cachedNetworkObj, {"id": mappingNetwork});
                                    _.pull(cachedNetworkObj, obj);
                                }
                            });
                        });
                        // callback.success(networkData);  $sessionStorage.cloudData.vChassis.resourceGroup
                        that.getALLResourceGroups(callback, cloudId, cachedNetworkObj, cachedResourceGroupObj, omitNetworksInResourceGroups, existingGroups,workloads);

                    }, function (error) {
                        console.log(error);
                        callback.fail(error);
                    });
                });
            } else {
                that.getVchassisNetworkMappingData(cloudId).then(function (networkChassisMapping) {
                    console.log(networkChassisMapping);
                    _.each(networkChassisMapping, function (networkChassisMappingObj) {
//                        var tempNetworkList = angular.copy(networkList);
                        _.each(networkChassisMappingObj.networks, function (mappingNetwork) {
//                            _.remove(tempNetworkList, function (network) {
                                if (vchassisId !== null && networkChassisMappingObj.chassisId !== vchassisId) {
                                    var obj = _.find(cachedNetworkObj, {"id" : mappingNetwork});
                                    _.pull(cachedNetworkObj, obj);
                                }
//                            });
                        });
//                       finalTempList =  _.union(finalTempList, tempNetworkList);
                    });
                    that.getALLResourceGroups(
                            callback,
                            cloudId,
                            cachedNetworkObj,
                            cachedResourceGroupObj,
                        omitNetworksInResourceGroups, existingGroups,workloads);
                });
            }
        };

        this.getVchassisNetworkMappingData = function (infraId) {

            console.log("getVchassisNetworkMappingData called");

            var resourceGroupChassisMapping = [];
            var networkResourceGroupMapping = [];
            var networkVchassisMapping = [];
            var deferred = $q.defer();
            var promise = deferred.promise;

            console.log("1");
            return $q.all([
                _.each($sessionStorage.infrastructureObj, function (infra) {
                    if (infra.id === infraId) {
                        _.each(infra.chassis, function (chassis) {
                            var rgrp = {};
                            rgrp.chassisId = chassis.id;
                            rgrp.resourceGroupIds = [];
                            _.each(chassis.subscriptionList, function (resourceGroup) {
                                rgrp.resourceGroupIds.push(resourceGroup.id);
                            });
                            resourceGroupChassisMapping.push(rgrp);
                        });
                    }
                }),
                _.each($sessionStorage.infrastructureObj, function (infra) {
                    if (infra.id === infraId) {
                        _.each(infra.resourcegroup, function (resourceGroup) {
                            var rgrp = {};
                            rgrp.resourceGroupId = resourceGroup.id;
                            rgrp.rgNetworks = [];
                            _.each(resourceGroup.memberList, function (networkMember) {
                                rgrp.rgNetworks.push(networkMember.networkId);
                            });
                            networkResourceGroupMapping.push(rgrp);
                        });
                    }
                })]).then(function () {

                console.log("4");
//                var cntr = 0;

                _.each(resourceGroupChassisMapping, function (rgVchassisMappingObj) {
                    var tempNwChassisObj = {};
                    tempNwChassisObj.chassisId = rgVchassisMappingObj.chassisId;
                    tempNwChassisObj.networks = [];
                    _.each(rgVchassisMappingObj.resourceGroupIds, function (resourceGroupId) {

                        _.each(networkResourceGroupMapping, function (nwRgrpMappingObj) {
                            _.each(nwRgrpMappingObj.rgNetworks, function (network) {
                                if (nwRgrpMappingObj.resourceGroupId === resourceGroupId) {
                                    tempNwChassisObj.networks.push(network);
                                }
                            });
                        });
                        networkVchassisMapping.push(tempNwChassisObj);
                    });
//                    cntr++;
                });
//                    if (cntr === resourceGroupChassisMapping.length) {
                        deferred.resolve(networkVchassisMapping);
                        console.log("getVchassisNetworkMappingData called ended");
                        return promise;
//                    }
            });
        };
    }

    angular.module('shieldxApp').service('virtualChassisService', virtualChassisService);
})();

/**
 * Description: Service for VLan Functionality
 * Author: Mahesh Sonawane
 */

(function () {
    function vlanService(getDataService, Restangular, readDataService, updateDataService, deleteDataService, createDataService) {
        "ngInject";
        
        /**
         * Function to get List of VLAN Pools under given Infrastructure
         * @param cloudId (Cloud Id/ Infrastructure Id)
         * @returns array (vLanPoolListData)
         * 
         */
       
        //GET /shieldxapi/{infraId}/vlanpool
        this.getvlanList = function(cloudId){
            console.log(" getvlanList "+cloudId);
              return readDataService.readData("vlanpool", cloudId).then(function(data){
                return data;
            }, function(error) {
                console.log(error);
                return [];
            });
        };

        
       

        this.createVlanPool = function(data, cloudId){
            return createDataService.createData("vlanpool", data, cloudId).then(function(dataVal){return dataVal;});
        };

        /**
         * Function to Delete VLAN
         * @param poolId 
         * @param cloudId
         * @returns Object of status
         * 
         */
        

        //DELETE /shieldxapi/vlanpool/{poolId}
        this.deleteVlanPool = function(poolId, cloudId){
            return deleteDataService.deleteData('vlanpool', poolId , cloudId).then(function(data){
            //return getDataService.makeRESTDataCall('DELETE', 'deployspec', deploymentSpecId).then(function(data){
                console.log("VLanPool with id %i deleted successfully...", poolId);
                //console.log(data);
                return {'status': true};
            }, function(error){
                console.log(error);
                return {'status': false, 'errorMessage' : error.data.message};
            });
        };
        
        /**
         * Function to Update VLAN
         * @param paramObject (Object to update)
         * @returns promise
         *
         */
        this.updateVlanPool = function(paramObject){
            //{"id":4,"name":"test","cloudid":1,"ranges":"200-210,3000-3010"}
            // PUT /shieldxapi/vlanpool
            return updateDataService.updateData ('vlanpool', paramObject , paramObject.cloudid);
            //return getDataService.makeRESTDataCall('PUT', 'infras/resourcegroup', paramObject);
        };
        
        /**
         * Function to Create VLAN
         * @param paramObject (Object to create)
         * @returns promise
         *
         */
        this.createVlanPool = function(paramObject){
            //{"id":4,"name":"test","cloudid":1,"ranges":"200-210,3000-3010"}
            // PUT /shieldxapi/vlanpool
            return createDataService.createData ('vlanpool', paramObject , paramObject.cloudid).then(function(data){
            //return getDataService.makeRESTDataCall('POST', 'vlanpool', paramObj).then(function(data) {
                return data;
            });
        };
        
    }
    angular.module('shieldxApp').service('vlanService', vlanService);
})();
/*
ShieldX Networks Inc. CONFIDENTIAL
----------------------------------
*
Copyright (c) 2016 ShieldX Networks Inc.
All Rights Reserved.
*
NOTICE: All information contained herein is, and remains
the property of ShieldX Networks Incorporated and its suppliers,
if any. The intellectual and technical concepts contained
herein are proprietary to ShieldX Networks Incorporated
and its suppliers and may be covered by U.S. and Foreign Patents,
patents in process, and are protected by trade secret or copyright law.
Dissemination of this information or reproduction of this material
is strictly forbidden unless prior written permission is obtained
from ShieldX Networks Incorporated.
*/

function IPCidrValidator() {
    this.cidrRegex = /^(([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])\.){3}([0-9]|[1-9][0-9]|1[0-9]{2}|2[0-4][0-9]|25[0-5])(\/([0-9]|[1-2][0-9]|3[0-2]))$/;
    this.subnetPattern = [
        {
            range: {max: 32, min: 25},
            ippattetern: [-1, -1, -1, -1]
        },
        {
            range: {max: 24, min: 17},
            ippattetern: [-1, -1, -1, 0]
        },
        {
            range: {max: 16, min: 9},
            ippattetern: [-1, -1, 0, 0]
        },
        {
            range: {max: 8, min: 1},
            ippattetern: [-1, 0, 0, 0]
        },
        {
            range: {max: 0, min: 0},
            ippattetern: [0, 0, 0, 0]
        }
    ];
}

IPCidrValidator.prototype.validateCidr = function (cidr) {
    //console.log(" validateCidr "+cidr);
    if (this.cidrRegex.test(cidr)) {
        var index = cidr.indexOf("/");
        //console.log(" index "+index);
        if (index !== -1) {
            var prifix = parseInt(cidr.substring(index + 1));
            //console.log(" prifix "+cidr.substring(index+1)+" num "+prifix);
            if (!isNaN(prifix)) {
                var objRef = _.find(this.subnetPattern, function (pattern) {
                    return ((prifix <= pattern.range.max) && (prifix >= pattern.range.min));
                });
                //console.log(" objRef "+objRef);
                //console.dir(objRef);
                if (objRef) {
                    var ip = cidr.substring(0, index);
                    //console.log(" ip "+ip);
                    var ipArray = ip.split(".");
                    /* jshint ignore:start */
                    for (var i = 0; i < objRef.ippattetern.length; i++) {
                        var ret = objRef.ippattetern[i];
                        //console.log(" ret "+ret+" ipArray[i] "+ipArray[i]);
                        if (ret == 0) {

                            if (ipArray[i] != 0) {
                                //console.log(" invalid ret  1 "+ret+" ipArray[i] "+ipArray[i]);
                                return false;
                            }

                        } else if (ipArray[i] == 0) {
                            //console.log(" invalid ret  2 "+ret+" ipArray[i] "+ipArray[i]);
                            return false;
                        }

                    }
                    /* jshint ignore:end */
                    //console.log(" valid ");
                    return true;
                }
            }

        }
    }
    return false;
};

/*
 ShieldX Networks Inc. CONFIDENTIAL
 ----------------------------------
 *
 Copyright (c) 2016 ShieldX Networks Inc.
 All Rights Reserved.
 *
 NOTICE: All information contained herein is, and remains
 the property of ShieldX Networks Incorporated and its suppliers,
 if any. The intellectual and technical concepts contained
 herein are proprietary to ShieldX Networks Incorporated
 and its suppliers and may be covered by U.S. and Foreign Patents,
 patents in process, and are protected by trade secret or copyright law.
 Dissemination of this information or reproduction of this material
 is strictly forbidden unless prior written permission is obtained
 from ShieldX Networks Incorporated.
 */

(function() {
    function aboutUsCtr($scope,
        $state,
        $translate) {
        "ngInject";

        $scope.$emit('listenHeaderText', {headerText: 'About the ShieldX Product'});

        $scope.filterByTopic = null;
        $scope.openSearchBox = false;
        $scope.allTopics = ["topic 1", "topic 2", "topic 3", "topic 4", "topic 5", "topic 6"];
        $scope.galleryLimit = Math.floor(window.innerWidth / 360);
        $scope.videos = [{
                "title": "ShieldX Technology Overview",
                "details": "one",
                "topics": ["topic 3", "topic 2"],
                "src": "videos/shieldx_intro_animation.mp4"
            },
            {
                "title": "ShieldX Infrastructure Discovery",
                "details": "two",
                "topics": [
                    "topic 1",
                    "topic 5"
                ],
                "src": ""
            },
            {
                "title": "ShieldX Security Orchestration Policy",
                "details": "three",
                "topics": ["topic 1", "topic 2"],
                "src": ""
            },
            {
                "title": "Headline4",
                "details": "four",
                "topics": ["topic 1"],
                "src": ""
            },
            {
                "title": "Headline5",
                "details": "five",
                "topics": ["topic 6", "topic 3"],
                "src": ""
            },
            {
                "title": "Headline6",
                "details": "six",
                "topics": ["topic 4", "topic 5"],
                "src": ""
            }
        ];
        $scope.featured = $scope.videos[0];
        $scope.change = function() {
            if ($scope.filterByTopic === null) {
                $scope.filterByTopic = '';
            } else if ($scope.filterByTopic === '') {
                $scope.filterByTopic = null;
            }
        };

        $scope.selectTopic = function(value) {
            if (value == $scope.filterByTopic) {
                $scope.filterByTopic = null;
            } else {
                $scope.filterByTopic = value;
            }
        };
        $scope.isFireFox = function(){

            return navigator.userAgent.toLowerCase().indexOf('firefox') > -1;
        };
    }

    angular.module('shieldxApp').controller('aboutUsCtr', aboutUsCtr);

})();

/*
 ShieldX Networks Inc. CONFIDENTIAL
 ----------------------------------
 *
 Copyright (c) 2016 ShieldX Networks Inc.
 All Rights Reserved.
 *
 NOTICE: All information contained herein is, and remains
 the property of ShieldX Networks Incorporated and its suppliers,
 if any. The intellectual and technical concepts contained
 herein are proprietary to ShieldX Networks Incorporated
 and its suppliers and may be covered by U.S. and Foreign Patents,
 patents in process, and are protected by trade secret or copyright law.
 Dissemination of this information or reproduction of this material
 is strictly forbidden unless prior written permission is obtained
 from ShieldX Networks Incorporated.
 */

(function () {
    function analysisCtr($scope,
            $state,
            $translate,
            chartDataLoader,
            dataVisualizationApi,            
            dataVisualizationService, 
            $mdpDatePicker, 
            $mdpTimePicker,coreservices,$mdDialog,$q) {
        "ngInject";

        console.log("analysisCtr initialised");
        $scope.tenentID = null;
        $scope.eventFilterModel = {};
        $scope.graphAttributeModel = {};
        $scope.eventFilterModel.defaultAxisAccessControl = {xAxsis:"Src_RG", yAxis:"Dest_RG"};
        $scope.filterApplyed = false;

        $scope.eventFilterModel.axisAccessControl = [
            {value: "Src_IP", text: 'Source IP'},
            {value: "Src_VM", text: 'Source VM'},
            {value: "Src_RG", text: 'Source Resource Group'},
            {value: "Dest_IP", text: 'Destination IP'},
            {value: "Dest_VM", text: 'Destination VM'},
            {value: "Dest_RG", text: 'Destination Resource Group'},
            {value: "Application_NAME", text: 'Application Name'}
        ];

         $scope.eventFilterModel.defaultAxisMalware = {xAxsis:"Victim_RG", yAxis:"Attacker_RG"};
         $scope.eventFilterModel.axisMalware = [
            {value: "Malware_Name", text: 'Malware Name'},
            {value: "Attacker_IP", text: 'Attacker IP'},
            {value: "Attacker_VM", text: 'Attacker VM'},
            {value: "Attacker_RG", text: 'Attacker Resource Group'},
            {value: "Victim_IP", text: 'Victim IP'},
            {value: "Victim_VM", text: 'Victim VM'},
            {value: "Victim_RG", text: 'Victim Resource Group'}
        ];
         $scope.eventFilterModel.defaultAxisThreatPrevention = {xAxsis:"Victim_RG", yAxis:"Attacker_RG"}; 
         $scope.eventFilterModel.axisThreatPrevention = [
            {value: "Attacker_IP", text: 'Attacker IP'},
            {value: "Attacker_VM", text: 'Attacker VM'},
            {value: "Attacker_RG", text: 'Attacker Resource Group'},
            {value: "Victim_IP", text: 'Victim IP'},
            {value: "Victim_VM", text: 'Victim VM'},
            {value: "Victim_RG", text: 'Victim Resource Group'},
            {value: "Threat_Name", text: 'Threat Name'},
            {value: "Application_NAME", text: 'Application Name'},
            {value: "Policy_Name", text: 'Policy Name'}
        ];


        //$scope.selectedIndex = 0;

       
        var currentDate = new Date();
        var endDate = new Date(currentDate.getTime()- (24*60*60*1000));
        $scope.eventFilterModel.startDate = endDate;
        $scope.eventFilterModel.startTime = endDate;
        $scope.eventFilterModel.endDate = currentDate;
        $scope.eventFilterModel.endTime = currentDate;

        $scope.eventFilterModel.selectedSeverity = null;

        $scope.eventFilterModel.severity = [ 
            {label: 'Critical', color: '#f03e3e', value: "Critical", selected: true},
            {label: 'High', color: '#fd7e14', value: "High", selected: false},
            {label: 'Medium', color: '#d0cd02', value: "Medium", selected: false},
            {label: 'Low', color: '#74b816', value: "Low", selected: false}
        ];

        $scope.eventFilterModel.tenentsSelected = null;
        $scope.eventFilterModel.tenents = [
            {value: 1, text: 'Home Depot'},
            {value: 2, text: 'Home Depot 2'}
        ];

        $scope.eventFilterModel.attackerSelected = "";
        $scope.eventFilterModel.attacker = [
            {value: "RG", text: 'Resource Group'},
            {value: "VM", text: 'VM'}
        ];

        $scope.eventFilterModel.targetSelected = "";
        $scope.eventFilterModel.target = [
            {value: "RG", text: 'Resource Group'},
            {value: "VM", text: 'VM'}
        ];

        $scope.eventFilterModel.eventTypeSelected = "ACCESS_CONTROL";
        $scope.graphAttributeModel.xAxisSelected = $scope.eventFilterModel.defaultAxisAccessControl.xAxsis;
        $scope.graphAttributeModel.xAxis = $scope.eventFilterModel.axisAccessControl;
        $scope.graphAttributeModel.yAxisSelected = $scope.eventFilterModel.defaultAxisAccessControl.yAxis;
        $scope.graphAttributeModel.yAxis =$scope.eventFilterModel.axisAccessControl;

        $scope.eventFilterModel.eventTypes = [
            {value: "ACCESS_CONTROL", text: 'Access Control'},
            {value: "THREAT_PREVENTION", text: 'Threat Prevention'},
            {value: "MALWARE", text: 'Malware'}
        ];
        $scope.eventFilterModel.actionSelected = "PERMIT";
        $scope.eventFilterModel.actions = null;

        $scope.eventFilterModel.actionsACL = [
            {value: "PERMIT", text: 'Flow permitted', selected: true},
            {value: "BLOCKED", text: 'Flow denied', selected: true}
        ];

        $scope.eventFilterModel.actionsTreats = [
            {value: "PERMIT", text: 'Alert Only', selected: true},
            {value: "BLOCKED", text: 'Block', selected: true}
        ];

        $scope.graphAttributeModel.colorSelected = "VOLUME";
        $scope.graphAttributeModel.colorItems = null;

        $scope.graphAttributeModel.colorItemsOthers = [
           {value: "VOLUME", text: 'Volume'}
        ];

        $scope.graphAttributeModel.colorTreats = [
            {value: "SEVERITY", text: 'Severity'},
            {value: "VOLUME", text: 'Volume'}
        ];

        $scope.threedDataVC = null; 

        $scope.colorLegend = {
            "SEVERITY": [
                { text: 'Critical', color: '#f03e3e' },
                { text: 'High', color: '#fd7e14' },
                { text: 'Medium', color: '#fcc419' },
                { text: 'Low', color: '#d0cd02' },
                { text: 'None', color: '#ffffff' } //#74b816
            ],
            "VOLUME": [
                { text: 'High', color: '#c92a2a' },
                { text: 'Above Median', color: '#f03e3e' },
                { text: 'Median', color: '#ff6b6b' },
                { text: 'Below Median', color: '#ffa8a8' },
                { text: 'Low', color: '#ffe3e3' }
            ]
        };

        $scope.eventFilterModel.source = {
            rgselection:"selGR",
            selectedSourceType:"",
            selectedGroups:[],
            selectedVMS:"",
            querySelection:"contains",
            queryResorceGroup:"",
            vmSelection:"contains"
        };

        $scope.eventFilterModel.destination = {
            rgselection:"selGR",
            selectedDestinationType:"",
            selectedGroups:[],
            selectedVMS:"",
            querySelection:"contains",
            queryResorceGroup:"",
            vmSelection:"contains"
        };

        $scope.eventFilterModel.groupType = [
            {value: "selGR", text: 'Select Resource Group'},
            {value: "selQR", text: 'Query Name'}
        ];

        $scope.eventFilterModel.matchingCondition = [
            {value: "beginwith", text: 'BeginWith'},
            {value: "equals", text: 'Equals'},
            {value: "contains", text: 'Contains'}
        ];

        $scope.validateRGName = function(){
          return true;
        };

        $scope.validateVMName = function(){
            return true;
        };


       
       $scope.selectResourceGroupSource = function(event){

         $mdDialog.show({
                controller: 'respourceGroupDialogboxCtr', templateUrl: 'core/components/analysis/resource-group-dialogbox.html', parent: angular.element(document.body), targetEvent: event, clickOutsideToClose: true,
                locals: {
                  selectedgroups:$scope.eventFilterModel.source.selectedGroups
                }
            }).then(function (answerVal) {
                console.log(" resource group  selected");
                console.dir(answerVal);
                $scope.eventFilterModel.source.selectedGroups = answerVal;
                console.log(" $scope.eventFilterModel.source.selectedGroups ");
                 console.dir($scope.eventFilterModel.source.selectedGroups);
            }, function () {
                $scope.status = 'You cancelled the dialog.';
            });

       };
       $scope.selectResourceGroupDestination = function(event){
        $mdDialog.show({
                controller: 'respourceGroupDialogboxCtr', templateUrl: 'core/components/analysis/resource-group-dialogbox.html', parent: angular.element(document.body), targetEvent: event, clickOutsideToClose: true,
                locals: {
                  selectedgroups:$scope.eventFilterModel.source.selectedGroups
                }
            }).then(function (answerVal) {
                console.log(" resource group  selected");
                console.dir(answerVal);
                eventFilterModel.destination.selectedGroups = answerVal;
                console.log(" $scope.eventFilterModel.source.selectedGroups ");
                 console.dir($scope.eventFilterModel.source.selectedGroups);
            }, function () {
                $scope.status = 'You cancelled the dialog.';
            });
       };
         
        // set defaults 
        $scope.eventFilterModel.eventTypeSelected = "ACCESS_CONTROL";
        $scope.eventFilterModel.actions = $scope.eventFilterModel.actionsACL;
        $scope.graphAttributeModel.xAxisSelected = $scope.eventFilterModel.defaultAxisAccessControl.xAxsis;
        $scope.graphAttributeModel.xAxis = $scope.eventFilterModel.axisAccessControl;
        $scope.graphAttributeModel.yAxisSelected = $scope.eventFilterModel.defaultAxisAccessControl.yAxis;
        $scope.graphAttributeModel.yAxis =$scope.eventFilterModel.axisAccessControl;
        $scope.graphAttributeModel.colorSelected = "VOLUME"; 
        $scope.graphAttributeModel.colorItems = $scope.graphAttributeModel.colorItemsOthers;


        $scope.showMore = function(event, data){
            console.log(" show more dialog "+data);

            $mdDialog.show({
                controller: 'showMoreCtr', templateUrl: 'core/components/analysis/show-more.html', parent: angular.element(document.body), targetEvent: event, clickOutsideToClose: true,
                locals: {
                  moreData:data
                }
            }).then(function (answerVal) {
                
            }, function () {
                $scope.status = 'You cancelled the dialog.';
            });
        };

       $scope.selectResourceGroupDestination = function(event){

         $mdDialog.show({
                controller: 'respourceGroupDialogboxCtr', templateUrl: 'core/components/analysis/resource-group-dialogbox.html', parent: angular.element(document.body), targetEvent: event, clickOutsideToClose: true,
                locals: {
                   selectedgroups:$scope.eventFilterModel.destination.selectedGroups
                }
            }).then(function (answerVal) {
                console.log(" resource group  selected");
                console.dir(answerVal);
                $scope.eventFilterModel.destination.selectedGroups = answerVal;
            }, function () {
                $scope.status = 'You cancelled the dialog.';
            });

       };


       $scope.editResourceGroupSource  = function(event){

       };


       $scope.onEventTypeSelectionChanged = function(){

           switch($scope.eventFilterModel.eventTypeSelected){

                case "ACCESS_CONTROL":
                $scope.eventFilterModel.actions = $scope.eventFilterModel.actionsACL;
                $scope.graphAttributeModel.colorItems = $scope.graphAttributeModel.colorItemsOthers;
                $scope.graphAttributeModel.xAxisSelected = $scope.eventFilterModel.defaultAxisAccessControl.xAxsis;
                $scope.graphAttributeModel.xAxis = $scope.eventFilterModel.axisAccessControl;
                $scope.graphAttributeModel.yAxisSelected = $scope.eventFilterModel.defaultAxisAccessControl.yAxis;
                $scope.graphAttributeModel.yAxis =$scope.eventFilterModel.axisAccessControl;
                $scope.graphAttributeModel.colorSelected = "VOLUME";
                break;
                case "THREAT_PREVENTION":
                $scope.eventFilterModel.actions = $scope.eventFilterModel.actionsTreats;
                $scope.graphAttributeModel.colorItems = $scope.graphAttributeModel.colorTreats; 
                $scope.graphAttributeModel.xAxisSelected = $scope.eventFilterModel.defaultAxisThreatPrevention.xAxsis;
                $scope.graphAttributeModel.xAxis = $scope.eventFilterModel.axisThreatPrevention;
                $scope.graphAttributeModel.yAxisSelected = $scope.eventFilterModel.defaultAxisThreatPrevention.yAxis;
                $scope.graphAttributeModel.yAxis =$scope.eventFilterModel.axisThreatPrevention;
                $scope.graphAttributeModel.colorSelected = "SEVERITY";
                break;
                case "MALWARE":
                $scope.graphAttributeModel.xAxisSelected = $scope.eventFilterModel.defaultAxisMalware.xAxsis;
                $scope.graphAttributeModel.xAxis = $scope.eventFilterModel.axisMalware;
                $scope.graphAttributeModel.yAxisSelected = $scope.eventFilterModel.defaultAxisMalware.yAxis;
                $scope.graphAttributeModel.yAxis =$scope.eventFilterModel.axisMalware;
                $scope.graphAttributeModel.colorSelected = "VOLUME";
                $scope.graphAttributeModel.colorItems = $scope.graphAttributeModel.colorItemsOthers;
                break;
            }
            console.log(" onEventTypeSelectionChanged ");
            console.dir($scope.graphAttributeModel);

       };
       $scope.filterData = function(dataArray,criteria,match){
         console.log("filterData "); 
         console.dir(dataArray); 
         console.dir(criteria);
         console.dir(match); 
         var result = [];

         if(criteria === "equal"){
            result.push(dataArray[i]);
         }

          for(var i=0; i <dataArray.length; i++){
              var ind = dataArray[i].indexOf(match);
              if( ind !== -1){
                
                if(criteria === "contains" && ind > 0){
                   result.push(dataArray[i]);
                } else if(criteria === "beginwith" && ind === 0){
                    result.push(dataArray[i]);
                }
              }
               
           }
           console.dir(result); 
           return result;
       };
       $scope.show2DData = function(){
          var startDate = $scope.eventFilterModel.startDate;
            var startTime = $scope.eventFilterModel.startTime; 
            var endDate = $scope.eventFilterModel.endDate ;
            var endTime = $scope.eventFilterModel.endTime;
            console.log(" startDate ");     
            console.dir(startDate);
            console.log(" startTime ");     
            console.dir(startTime);

            var newStartDate = new Date(startDate.getTime());
            newStartDate.setSeconds(startTime.getSeconds());
            newStartDate.setHours(startTime.getHours());
            newStartDate.setMinutes(startTime.getMinutes());

            var newEndDate = new Date(endDate.getTime());
            newEndDate.setSeconds(endTime.getSeconds());
            newEndDate.setHours(endTime.getHours());
            newEndDate.setMinutes(endTime.getMinutes());

            var dataVC = new EventVisualizationFilter();
            
            /*
            console.log(" eventFilterModel.severity "+$scope.eventFilterModel.severity);
            console.dir($scope.eventFilterModel.severity);
            console.log(" graphAttributeModel.colorSelected "+$scope.graphAttributeModel.colorSelected);
            console.dir($scope.graphAttributeModel.colorItems);

            console.log(" startTime "+newStartDate.getTime());
            console.log(" endTime "+newStartDate.getTime());

            console.log(" actionSelected "+$scope.eventFilterModel.actionSelected);
            console.log(" eventTypeSelected "+$scope.eventFilterModel.eventTypeSelected);

            console.log(" xAxisSelected "+ $scope.graphAttributeModel.xAxisSelected);
            console.log(" yAxisSelected "+$scope.graphAttributeModel.yAxisSelected);
            */

            if($scope.graphAttributeModel.colorSelected === "SEVERITY"){
                dataVC.colorType =  $scope.graphAttributeModel.colorSelected;
            }

            if($scope.eventFilterModel.eventTypeSelected !== "ACCESS_CONTROL"){
               dataVC.actionTypeList  = [$scope.eventFilterModel.actionSelected]; 
            }else {
                dataVC.actionTypeList  = [];
                var actions = $scope.eventFilterModel.actions;
                for (var j = 0; j <  actions.length; j++){
                  if(actions[j].selected){
                     dataVC.actionTypeList.push(actions[j].value);
                  }
                }
            }
            
            dataVC.eventType = $scope.eventFilterModel.eventTypeSelected;
            dataVC.startTime = ""+newStartDate.getTime();
            dataVC.endTime = ""+newEndDate.getTime();

            if($scope.eventFilterModel.eventTypeSelected === "THREAT_PREVENTION"){
                var selectedSeverity = [];
                for(var i=0; i<$scope.eventFilterModel.severity.length; i++){
                    var severity = $scope.eventFilterModel.severity[i];
                    if(severity.selected){
                        selectedSeverity.push(severity.value);
                    }
                } 
                if(selectedSeverity.length > 0){
                    dataVC.severity = selectedSeverity;
                } 
            }        


            dataVC.xAxisAttr = $scope.graphAttributeModel.xAxisSelected;
            dataVC.yAxisAttr = $scope.graphAttributeModel.yAxisSelected;

            $scope.xAxisLable = _.find($scope.graphAttributeModel.xAxis, function(value){
                return $scope.graphAttributeModel.xAxisSelected === value.value;
            });

            $scope.yAxisLable = _.find($scope.graphAttributeModel.yAxis, function(value){
                return $scope.graphAttributeModel.yAxisSelected === value.value;
            });

            /*coreservices.getAllWorkloades().then(function(workLoads){
              console.log(" getAllWorkloades workLoads ");
              console.dir(workLoads);
              $scope.load2DData(dataVC);
            });*/

            /*
            this.attackerSourceList = [];
            this.attackerSourceType = "RG";
            this.targetDestinationList = [];
            this.targetDestinationType = "RG";
            */
            var promices =  [];
            var pr = null;

            if($scope.eventFilterModel.source.selectedSourceType == "RG")
            {
                 dataVC.attackerSourceType = "RG";
                if($scope.eventFilterModel.source.rgselection == "selQR"){

                     pr = coreservices.getListOfResourceGroup().then(function(result){
                        //queryResorceGroup
                        var rs= [];
                         for(var i=0; i < result.length ; i++){
                          rs.push(result[i].name);
                         }
                         var fsrg = $scope.filterData(rs, $scope.eventFilterModel.source.querySelection, $scope.eventFilterModel.source.queryResorceGroup);
                         dataVC.attackerSourceList = fsrg;
                         console.log("source  getListOfResourceGroup"); 
                         console.dir(result);
                      });
                 promices.push(pr);
                } else if($scope.eventFilterModel.source.rgselection == "selGR"){
                    dataVC.attackerSourceList = $scope.eventFilterModel.source.selectedGroups;
                }

            }else if($scope.eventFilterModel.source.selectedSourceType == "VM"){
                dataVC.attackerSourceType = "VM";
                pr = coreservices.getListOfWorkloades().then(function(result){
                    //selectedVMS
                    var workLaodNames = [];
                    for(var k=0; k <result.length; k++){
                        workLaodNames.push(result[k].name);
                    }
                    console.log("source  getListOfWorkloades"); 
                    console.dir(result);
                    var fsvm = $scope.filterData(workLaodNames, $scope.eventFilterModel.source.querySelection, $scope.eventFilterModel.source.selectedVMS);
                   //  var fsvm = $scope.filterData(workLaodNames, "beginwith", "Shieldx");
                    dataVC.attackerSourceList = fsvm;
                });
                promices.push(pr);
            }

            if($scope.eventFilterModel.destination.selectedDestinationType == "RG")
            {
                dataVC.targetDestinationType = "RG";
                if($scope.eventFilterModel.destination.rgselection == "selQR"){

                   pr = coreservices.getListOfResourceGroup().then(function(result){
                    var rs2= [];
                         for(var j=0; j < result.length ; j++){
                          rs2.push(result[j].name);
                         }
                         var fd = $scope.filterData(rs2, $scope.eventFilterModel.destination.querySelection, $scope.eventFilterModel.destination.querySelection.queryResorceGroup);
                         dataVC.targetDestinationList = fd;
                         console.log("source  getListOfResourceGroup"); 
                         console.dir(result); 
                   });
                  promices.push(pr);

                } else if($scope.eventFilterModel.destination.rgselection == "selGR"){
                     dataVC.targetDestinationList = $scope.eventFilterModel.destination.selectedGroups;     
                }

            }else if($scope.eventFilterModel.destination.selectedDestinationType == "VM"){
                dataVC.targetDestinationType = "VM";
               pr = coreservices.getListOfWorkloades().then(function(result){
                  //selectedVMS
                   console.log("destination  getListOfWorkloades"); 
                    console.dir(result);

                    var workLaodNamesd = [];
                    for(var l=0; l <result.length; l++){
                        workLaodNamesd.push(result[l].name);
                    }
                    console.log("source  getListOfWorkloades"); 
                    console.dir(result);
                    var fdvm = $scope.filterData(workLaodNamesd, $scope.eventFilterModel.source.querySelection, $scope.eventFilterModel.source.selectedVMS);
                   // var fdvm = $scope.filterData(workLaodNamesd, "contains", "Dev");
                    dataVC.targetDestinationList = fdvm; 
                });
              promices.push(pr);
            }

           
            console.log("$scope.eventFilterModel.source");   
            console.dir($scope.eventFilterModel.source);

            console.log("$scope.eventFilterModel.destination");   
            console.dir($scope.eventFilterModel.destination);
           if(promices.length > 0){
             $q.all(promices).then(function() {
                console.log("after all data loaded ");
                console.dir(dataVC); 
               $scope.load2DData(dataVC);  
             });
           } else{
             $scope.load2DData(dataVC);
           } 
       };

       $scope.load2DData = function(dataVC){
            dataVisualizationService.getEventDataFor2DRendering(dataVC).then(function(result){
                angular.element(document.querySelector('#events-page-mask')).css('display', 'none');
                var filterWarningDiv;
                 
                if(result.links.length === 0){
                    d3.select('#events-container').select("svg").remove();
                    filterWarningDiv = d3.select("#events-grid").append("div").attr("class", "filter-warning-prompt");
                    var filterWarningPos = document.querySelector('#events-grid').getBoundingClientRect();
                    filterWarningDiv.html("<i class=\"material-icons\">&#xE002;</i><div class='text' id='marquee-help-btn'>No events found.</div>");
                    filterWarningDiv.style("left", filterWarningPos.left + (filterWarningPos.width/2) + "px");
                    filterWarningDiv.style("top", filterWarningPos.top + (filterWarningPos.height/3) + "px");

                    return;
                } else {
                    d3.select("#events-grid .filter-warning-prompt").remove();
                }
                var chartObj = {
                    elem: '#navigator',
                    dataset: result  // not customisable option
                };
                dataVisualizationApi.eventsNavigator(chartObj); 

          });
       };
       $scope.threeDInputData = function(){
        console.log(" show3DData "); 
          console.dir(shieldXUI.landscapeData);
          var startDate = $scope.eventFilterModel.startDate;
            var startTime = $scope.eventFilterModel.startTime; 
            var endDate = $scope.eventFilterModel.endDate ;
            var endTime = $scope.eventFilterModel.endTime;
            console.log(" startDate ");     
            console.dir(startDate);
            console.log(" startTime ");     
            console.dir(startTime);

            var newStartDate = new Date(startDate.getTime());
            newStartDate.setSeconds(startTime.getSeconds());
            newStartDate.setHours(startTime.getHours());
            newStartDate.setMinutes(startTime.getMinutes());

            var newEndDate = new Date(endDate.getTime());
            newEndDate.setSeconds(endTime.getSeconds());
            newEndDate.setHours(endTime.getHours());
            newEndDate.setMinutes(endTime.getMinutes());

            var dataVC = new EventVisualizationFilter();
            
            /*
            console.log(" eventFilterModel.severity "+$scope.eventFilterModel.severity);
            console.dir($scope.eventFilterModel.severity);
            console.log(" graphAttributeModel.colorSelected "+$scope.graphAttributeModel.colorSelected);
            console.dir($scope.graphAttributeModel.colorItems);

            console.log(" startTime "+newStartDate.getTime());
            console.log(" endTime "+newStartDate.getTime());

            console.log(" actionSelected "+$scope.eventFilterModel.actionSelected);
            console.log(" eventTypeSelected "+$scope.eventFilterModel.eventTypeSelected);

            console.log(" xAxisSelected "+ $scope.graphAttributeModel.xAxisSelected);
            console.log(" yAxisSelected "+$scope.graphAttributeModel.yAxisSelected);
            */

            if($scope.graphAttributeModel.colorSelected === "SEVERITY"){
                dataVC.colorType =  $scope.graphAttributeModel.colorSelected;
            }

            if($scope.eventFilterModel.eventTypeSelected !== "ACCESS_CONTROL"){
               dataVC.actionTypeList  = [$scope.eventFilterModel.actionSelected]; 
            }else {
                dataVC.actionTypeList  = [];
                var actions = $scope.eventFilterModel.actions;
                for (var l = 0; l <  actions.length; l++){
                  if(actions[l].selected){
                     dataVC.actionTypeList.push(actions[l].value);
                  }
                }
            }

            dataVC.eventType = $scope.eventFilterModel.eventTypeSelected;
            dataVC.startTime = ""+newStartDate.getTime();
            dataVC.endTime = ""+newEndDate.getTime();

            $scope.timeRange = [dataVC.startTime, dataVC.endTime];

            if($scope.eventFilterModel.eventTypeSelected === "THREAT_PREVENTION"){
                var selectedSeverity = [];
                for(var i=0; i<$scope.eventFilterModel.severity.length; i++){
                    var severity = $scope.eventFilterModel.severity[i];
                    if(severity.selected){
                        selectedSeverity.push(severity.value);
                    }
                } 
                if(selectedSeverity.length > 0){
                    dataVC.severity = selectedSeverity;
                } 
            }        


            dataVC.xAxisAttr = $scope.graphAttributeModel.xAxisSelected;
            dataVC.yAxisAttr = $scope.graphAttributeModel.yAxisSelected;

            $scope.xAxisLable = _.find($scope.graphAttributeModel.xAxis, function(value){
                return $scope.graphAttributeModel.xAxisSelected === value.value;
            });

            $scope.yAxisLable = _.find($scope.graphAttributeModel.yAxis, function(value){
                return $scope.graphAttributeModel.yAxisSelected === value.value;
            });

           if(shieldXUI.landscapeData){
            
             var nodesX = shieldXUI.landscapeData.nodesX;
             var xAxsis = [];   
             for(var k =0; k < nodesX.length; k++){
                xAxsis.push(nodesX[k].name);  
             }

             var nodesY = shieldXUI.landscapeData.nodesY;
             var yAxsis = [];   
             for(var j =0; j < nodesY.length; j++){
                yAxsis.push(nodesY[j].name);  
             }

            /* var ed = new EventVisualizationData(); 
             var mapXval = ed.mapAxsisToType(dataVC.xAxisAttr);
            
             if(mapXval.map === "destination"){
                 dataVC.attackerSourceList = xAxsis;
                 dataVC.attackerSourceType = mapXval.type;
             }else if(mapXval.map === "source"){
                 dataVC.targetDestinationList = xAxsis; 
                 dataVC.targetDestinationType = mapXval.type;  
             }

             var mapYval = ed.mapAxsisToType(dataVC.yAxisAttr);
             if(mapYval.map === "destination"){
                 dataVC.attackerSourceList = yAxsis;
                 dataVC.attackerSourceType = mapYval.type;
             }else if(mapYval.map === "source"){
                 dataVC.targetDestinationList = yAxsis; 
                 dataVC.targetDestinationType = mapYval.type;  
             }
             */

             dataVC.attackerSourceList = xAxsis;
             dataVC.attackerSourceType = "RG";
             dataVC.targetDestinationList = yAxsis; 
             dataVC.targetDestinationType = "RG"; 
         }

         return dataVC;
       }; 
        $scope.show3DData = function(){
            var dataVC = $scope.threeDInputData();
            dataVisualizationService.getEventDataFor3DRendering(dataVC).then(function(result){
                $scope.show3DLabels = false;
                if(!$scope.switchTo3D) dataVisualizationApi.eventsVfx({ elem: "#events-container-3D", dataset: result });
                    $scope.switchTo3D = $scope.switchTo3D ? false: true;
            });
        };

      
        $scope.switchTo3D = false;       

        $scope.selected3DNodes = [];

        $scope.showGrid = function(event){
             var dataVC = $scope.threeDInputData();
             $mdDialog.show({
                controller: 'eventGridCtr', templateUrl: 'core/components/analysis/event-grid.html', parent: angular.element(document.body), targetEvent: event, clickOutsideToClose: true,
                locals: {
                  vc:dataVC
                },
                fullscreen: true
            }).then(function (answerVal) {
                
            }, function () {
                $scope.status = 'You cancelled the dialog.';
            });

            d3.select(".matrix-brush").remove();
            d3.selectAll('#events-container .selected', function(d) {
                angular.element(this).removeClass("selected");
            });
            d3.selectAll("#events-container circle").style("fill-opacity",'0.8');
            angular.element(document.querySelector('#Alpha-4---Analysis path')).css('fill', '#6d6e71');
            angular.element(document.querySelector('#Alpha-4---Cursor-Arrow #Solid')).css('fill', '#4a90e2');

            angular.element(document.querySelector('.dataLandscapeBtnDiv')).remove();
            angular.element(document.querySelector('.d3evenDataBtnDiv')).remove();
            angular.element(document.querySelector('.d3brushCloseBtnDiv')).remove();

            angular.element(document.querySelector('#events-tabs')).css('display', 'block');
            angular.element(document.querySelector('#landscape-explorer')).css('display', 'none');
        }; 
        
        $scope.clearLabels = function(event) {
            angular.element(document.querySelectorAll('.selected-3D')).removeClass('selected-3D');
            $scope.selected3DNodes = [];
            angular.element(event.target).css('display', 'none');
        };

        $scope.show3DLabels = false;
        $scope.toggle3DLabels = function(event) {
            $scope.show3DLabels = !$scope.show3DLabels;
            console.log("$scope.show3DLabels "+$scope.show3DLabels);
            if($scope.show3DLabels) {
                angular.element(document.querySelectorAll('.node-3D-labelX')).addClass('show-3D-label');
                angular.element(document.querySelectorAll('.node-3D-labelY')).addClass('show-3D-label');
            }                
            else {
                angular.element(document.querySelectorAll('.node-3D-labelX')).removeClass('show-3D-label');
                angular.element(document.querySelectorAll('.node-3D-labelY')).removeClass('show-3D-label');
            }
        };

        $scope.toggle3D = function(event) {
            if(!shieldXUI.landscapeData) {
                return;
            }
            $scope.show3DData();   

            angular.element(document.querySelector('#events-tabs')).css('display', 'block');
            angular.element(document.querySelector('#landscape-explorer')).css('display', 'none');

            angular.element(document.querySelector('.dataLandscapeBtnDiv')).remove();
            angular.element(document.querySelector('.d3evenDataBtnDiv')).remove();
            angular.element(document.querySelector('.d3brushCloseBtnDiv')).remove();
        };

        $scope.closeLandscapeExplorer = function(event) {

            d3.select(".matrix-brush").remove();
            d3.selectAll('#events-container .selected', function(d) {
                angular.element(this).removeClass("selected");
            });
            d3.selectAll("#events-container circle").style("fill-opacity",'0.8');
            angular.element(document.querySelector('#Alpha-4---Analysis path')).css('fill', '#6d6e71');
            angular.element(document.querySelector('#Alpha-4---Cursor-Arrow #Solid')).css('fill', '#4a90e2');

            angular.element(document.querySelector('.dataLandscapeBtnDiv')).remove();
            angular.element(document.querySelector('.d3evenDataBtnDiv')).remove();
            angular.element(document.querySelector('.d3brushCloseBtnDiv')).remove();

            angular.element(document.querySelector('#events-tabs')).css('display', 'block');
            angular.element(document.querySelector('#landscape-explorer')).css('display', 'none');

            $scope.switchTo3D = false;
        };

        $scope.$emit('listenHeaderText', { headerText: "Analysis"});
        $scope.$on('$viewContentLoaded', function (event) {
            console.log(event);
            fixContainerHeight(1);            
        });

           

      /*
      
       */

        $scope.$on('$viewContentLoaded', function (event) {

            angular.element(document.querySelector('#events-y-axis')).css('width', (window.innerWidth * 0.75) - 144+'px');
            angular.element(document.querySelector('#events-container')).css('width', (window.innerWidth * 0.75) - 144+'px');
            angular.element(document.querySelector('#events-x-axis')).css('height', window.innerHeight - 192+'px');
            angular.element(document.querySelector('#events-container')).css('height', window.innerHeight - 192+'px');    

        }); 

        dataVisualizationService.conectToWebSocket().then(
            function(data){
                dataVisualizationService.subscribToTheTopic("/topic/outgoing").then(function(dataRecived){
                   console.log(" data recived from server 3"+dataRecived);
                   console.dir(dataRecived);
                   var refdata = JSON.parse(dataRecived.content);
                   $scope.processCraditData(refdata);
                });
            }
        );

        $scope.processCraditData = function(data){
           console.log("processCraditData ");
           console.dir(data);
        };

       $scope.senDataToWebSocket = function(data){
          dataVisualizationService.sendDataToWebSocketTopic("/app/incoming",data);
       }; 

        $scope.showGraph = function(event) {
          /*  angular.element(document.querySelector('#events-page-mask')).css('display', 'block');
            $scope.filterApplyed = true;
            $scope.show2DData();*/
            $scope.senDataToWebSocket({command:"start",data:""});
       };
        
        
    }


    angular.module('shieldxApp').controller('analysisCtr', analysisCtr);

})();

/*
 ShieldX Networks Inc. CONFIDENTIAL
 ----------------------------------
 *
 Copyright (c) 2016 ShieldX Networks Inc.
 All Rights Reserved.
 *
 NOTICE: All information contained herein is, and remains
 the property of ShieldX Networks Incorporated and its suppliers,
 if any. The intellectual and technical concepts contained
 herein are proprietary to ShieldX Networks Incorporated
 and its suppliers and may be covered by U.S. and Foreign Patents,
 patents in process, and are protected by trade secret or copyright law.
 Dissemination of this information or reproduction of this material
 is strictly forbidden unless prior written permission is obtained
 from ShieldX Networks Incorporated.
 */

(function () {

    function eventGridCtr($scope, $mdDialog, dataVisualizationService,vc) {
        $scope.vc = vc;
        this.startTime = null;
        var endTime = new Date();
        endTime.setTime(parseInt($scope.vc.endTime));
        var startTime = new Date(); 
        startTime.setTime(parseInt($scope.vc.startTime)); 
        $scope.startTime = startTime.getFullYear()+"/"+(startTime.getMonth()+1)+"/"+startTime.getDate()+" "+(startTime.getHours()+1)+":"+(startTime.getMinutes()+1);
        $scope.endTime  = endTime.getFullYear()+"/"+(endTime.getMonth()+1)+"/"+endTime.getDate()+" "+(endTime.getHours()+1)+":"+(endTime.getMinutes()+1);
        $scope.eventData = [];
        $scope.query = {
  			order: 'name',
  			limit: 10,
  			page: 1
		    };
        dataVisualizationService.getEventDataFor3DGridData($scope.vc).then(function(eventdata){
           console.log("data recived from server");
           console.dir(eventdata);
           for(var i=0; i<eventdata.length; i++){
           	  var node = eventdata[i];
              var timeStr = "";
           	  var st = node['start time']; 
              if(st){
                var time = new Date(); 
                timeStr = (time.getMonth()+1)+"/"+time.getDate()+"/"+time.getFullYear();
                timeStr = timeStr +":"+(time.getMinutes()+1)+":"+(time.getHours()+1)+":"+(time.getSeconds()+1);
              }
           	  var rowData = {
           	  	startTime:timeStr,
				severirty:node.severity,
				srcResourceGroup:node.srcResourceGroup,
				dstResourceGroup:node.dstResourceGroup,
				srcIpAddress:node.srcIpAddress,
				dstIpAddress:node.dstIpAddress,
				dstMachineName:node.dstMachineName,
				srcMachineName:node.srcMachineName,
        policyName:node.policyName,
        threatName:node.threatName,
        fileTag:node.fileTag
           	  };
           	  $scope.eventData.push(rowData);
           }
           console.log(" eventGridCtr ");
           console.dir($scope.eventData);   
        });
        $scope.cancel = function(){
        	$mdDialog.hide();
        };
        //fixContainerHeight(1);
    }
    angular.module('shieldxApp').controller('eventGridCtr', eventGridCtr);

})();
/*
 ShieldX Networks Inc. CONFIDENTIAL
 ----------------------------------
 *
 Copyright (c) 2016 ShieldX Networks Inc.
 All Rights Reserved.
 *
 NOTICE: All information contained herein is, and remains
 the property of ShieldX Networks Incorporated and its suppliers,
 if any. The intellectual and technical concepts contained
 herein are proprietary to ShieldX Networks Incorporated
 and its suppliers and may be covered by U.S. and Foreign Patents,
 patents in process, and are protected by trade secret or copyright law.
 Dissemination of this information or reproduction of this material
 is strictly forbidden unless prior written permission is obtained
 from ShieldX Networks Incorporated.
 */

(function () {
    function eventsFilterCtr($scope){
    	//dynamically correcting all the heights and widths of elements
        if(document.querySelector('#filter-form')) {
            angular.element(document.querySelector('#filter-form')).css('height', (window.innerHeight-113-36)+'px');
            angular.element(document.querySelector('#graph-attributes')).css('height', (window.innerHeight-113)+'px');
            angular.element(document.querySelector('#navigator')).css('width', (window.innerWidth*0.25)+'px');
            angular.element(document.querySelector('#navigator svg')).css('width', (window.innerWidth*0.25)+'px');
        }
    }
    angular.module('shieldxApp').controller('eventsFilterCtr', eventsFilterCtr);
})();
/*
 ShieldX Networks Inc. CONFIDENTIAL
 ----------------------------------
 *
 Copyright (c) 2016 ShieldX Networks Inc.
 All Rights Reserved.
 *
 NOTICE: All information contained herein is, and remains
 the property of ShieldX Networks Incorporated and its suppliers,
 if any. The intellectual and technical concepts contained
 herein are proprietary to ShieldX Networks Incorporated
 and its suppliers and may be covered by U.S. and Foreign Patents,
 patents in process, and are protected by trade secret or copyright law.
 Dissemination of this information or reproduction of this material
 is strictly forbidden unless prior written permission is obtained
 from ShieldX Networks Incorporated.
 */

(function () {
    function graphAttributesFilterCtr($scope){
    	//dynamically correcting all the heights and widths of elements
        angular.element(document.querySelector('#graph-attributes')).css('height', (window.innerHeight-113)+'px');
        angular.element(document.querySelector('#navigator')).css('width', (window.innerWidth*0.25)+'px');
        angular.element(document.querySelector('#navigator')).css('height', (window.innerWidth*0.25)/1.7+'px');
        angular.element(document.querySelector('#navigator svg')).css('width', (window.innerWidth*0.25)+'px');
        angular.element(document.querySelector('#navigator svg')).css('height', (window.innerWidth*0.25)/1.7+'px');

        angular.element(document.querySelectorAll('#events-tabs md-tab-content')[1]).css('overflow','hidden');     
    }
    angular.module('shieldxApp').controller('graphAttributesFilterCtr', graphAttributesFilterCtr);
})();
/*
 ShieldX Networks Inc. CONFIDENTIAL
 ----------------------------------
 *
 Copyright (c) 2016 ShieldX Networks Inc.
 All Rights Reserved.
 *
 NOTICE: All information contained herein is, and remains
 the property of ShieldX Networks Incorporated and its suppliers,
 if any. The intellectual and technical concepts contained
 herein are proprietary to ShieldX Networks Incorporated
 and its suppliers and may be covered by U.S. and Foreign Patents,
 patents in process, and are protected by trade secret or copyright law.
 Dissemination of this information or reproduction of this material
 is strictly forbidden unless prior written permission is obtained
 from ShieldX Networks Incorporated.
 */

(function () {

    function respourceGroupDialogboxCtr($scope, coreservices, $mdDialog, selectedgroups) {

        $scope.selectedgroups = [];
         for(var j=0; j<selectedgroups.length; j++){
            $scope.selectedgroups.push({name:selectedgroups[j]});
        }
        $scope.no_of_rgs = 0;
        $scope.itemChangedBridge = new MethodBridge();
        $scope.items = [];
        $scope.selected = [];
        coreservices.getListOfResourceGroup().then(function(resourcesGroups){
           console.log(" getListOfResourceGroup " + resourcesGroups.length);
           console.dir(resourcesGroups);
           // resourcesGroups = [{name:"sagar"},{name:"sony"},{name:"sony3"}];
           for(var i=0; i<resourcesGroups.length; i++){
            $scope.items.push({name:resourcesGroups[i].name});
           }
          $scope.itemChangedBridge.call($scope.items);
        });
        console.log("selectedgroups");
        console.dir(selectedgroups);
        $scope.cancel = function () {
            $mdDialog.cancel();
        };

        $scope.toggle = function (item, list) {
            console.log(" toggle list");
            console.dir(list);
            console.log(" toggle item");
            console.dir(item);
            var index = _.findIndex($scope.selectedgroups,function(ind){
                return item.name === ind.name;
            });
            if(index == -1){
                $scope.selectedgroups.push(item);
            } else{
                $scope.selectedgroups.splice(index,1);
            }
        };

        $scope.selectGroups = function(){
           
            console.log(" $scope.selectedgroups ");
            console.dir($scope.selectedgroups);
            var gr = [];
            for(var i=0; i<$scope.selectedgroups.length; i++){
              gr.push($scope.selectedgroups[i].name);
            }
            $mdDialog.hide(gr);

        };

         $scope.toggleAll = function ()
         {
            if ($scope.selectedgroups.length === $scope.items.length) { //uncheck all
                $scope.selectedgroups = [];
            } else if ($scope.selectedgroups.length === 0 || $scope.items.length > 0) {
                $scope.selectedgroups = $scope.items.slice(0); //check all
            }
            $scope.no_of_rgs = $scope.selected.length;
        };

        $scope.isIndeterminate = function () 
        {
            return ($scope.selectedgroups.length !== 0 &&
                $scope.selectedgroups.length !== $scope.items.length);
        };
        $scope.isChecked = function () {
            return $scope.selectedgroups.length === $scope.items.length;
        };

        $scope.exists = function (item, list) {
          if($scope.selectedgroups.length === 0){
            return false;
          }
           console.log(" $scope.selectedgroups "+$scope.selectedgroups); 
            var index = _.findIndex($scope.selectedgroups,function(ind){
                return item.name === ind.name;
            });
            console.log(" exists "+item); 
            console.log(" index "+index); 
            return index != -1;
        };
    }
    angular.module('shieldxApp').controller('respourceGroupDialogboxCtr', respourceGroupDialogboxCtr);

})();
/*
 ShieldX Networks Inc. CONFIDENTIAL
 ----------------------------------
 *
 Copyright (c) 2016 ShieldX Networks Inc.
 All Rights Reserved.
 *
 NOTICE: All information contained herein is, and remains
 the property of ShieldX Networks Incorporated and its suppliers,
 if any. The intellectual and technical concepts contained
 herein are proprietary to ShieldX Networks Incorporated
 and its suppliers and may be covered by U.S. and Foreign Patents,
 patents in process, and are protected by trade secret or copyright law.
 Dissemination of this information or reproduction of this material
 is strictly forbidden unless prior written permission is obtained
 from ShieldX Networks Incorporated.
 */

(function () {

    function showMoreCtr($scope, $mdDialog, moreData) {
        $scope.showmoreData = moreData;
        $scope.cancel = function(){
        	$mdDialog.hide();
        };

    }
    angular.module('shieldxApp').controller('showMoreCtr', showMoreCtr);

})();
 /*
 Copyright (c) 2016 ShieldX Networks Inc.
 All Rights Reserved.
 *
 NOTICE: All information contained herein is, and remains
 the property of ShieldX Networks Incorporated and its suppliers,
 if any. The intellectual and technical concepts contained
 herein are proprietary to ShieldX Networks Incorporated
 and its suppliers and may be covered by U.S. and Foreign Patents,
 patents in process, and are protected by trade secret or copyright law.
 Dissemination of this information or reproduction of this material
 is strictly forbidden unless prior written permission is obtained
 from ShieldX Networks Incorporated.
 */

(function () {
	function configureDashboardCtrl($scope,
		$mdDialog, 
		tabConfig,
		activeTabIndex,
		dashboardItemList) {
		"ngInject";

		var response = {};
		$scope.totalCount = dashboardItemList.length;
		$scope.items = dashboardItemList;
		$scope.selected = [];
		$scope.categoryFilter = '';
		$scope.categoriesList = [];
		
		var currentTab = tabConfig[activeTabIndex];
		$scope.dashboardName = currentTab.title;

		//init pre-selected widgets
		//1. chart widgets
		_.forEach(currentTab.dashboardItems, function(value, key){
			var temp = _.find($scope.items, function(obj){
				return value.content.widgetName.match(obj.value); 
			});
			$scope.selected.push(temp);
		});		
		//2. alert widgets
		_.forEach(currentTab.alerts, function(value, key){
			var temp = _.find($scope.items, function(obj){
				return value.widgetName.match(obj.value); 
			});
			$scope.selected.push(temp);
		});

		//create list for category filter
		_.forEach(widgetConfig.categories, function(value, key){
			$scope.categoriesList.push({value : key, name : value});
		});

		$scope.applyDialog = function() {
			var response = { title: $scope.dashboardName, selected: $scope.selected};
			$mdDialog.hide(response);
		};
		$scope.cancelDialog = function() {
			$mdDialog.cancel();
		};

		$scope.editDashboardTitle = function(event, dashboardName) {
			$scope.groupName = dashboardName;
			$mdDialog.show({
                skipHide: true,
                controller: 'newDasboardNameCtrl',
                bindToController: true,
                preserveScope: true,
                templateUrl: 'core/components/dashboard/dashboard-name.html',
                parent: angular.element(document.body),
                targetEvent: event,
                fullscreen: false,
                scope: $scope,
                openFrom: { top: 1100, height: 0 },
                closeTo: { left: 1500 }
            }).then(function(res, $scope) {
            	//currentTab.title = res;
            });
		};

		$scope.showAll = function(event) {
			$scope.items = dashboardItemList;
			angular.element(event.currentTarget).css('color','#4a90e2');
			angular.element(event.currentTarget.nextElementSibling).css('color','#6d6e71');			
		};

		$scope.showSelected = function(event) {
			$scope.items = $scope.selected;
			angular.element(event.currentTarget).css('color','#4a90e2');
			angular.element(event.currentTarget.previousElementSibling).css('color','#6d6e71');
		};

        $scope.isIndeterminate = function () {
            return ($scope.selected.length !== 0 &&
                $scope.selected.length !== $scope.items.length);
        };
        $scope.isChecked = function () {
            return $scope.selected.length === $scope.items.length;
        };
        $scope.toggleAll = function () {
            if ($scope.selected.length === $scope.items.length) { //uncheck all
                $scope.selected = [];
            } else if ($scope.selected.length === 0 || $scope.selected.length > 0) {
                $scope.selected = $scope.items.slice(0); //check all
            }
        };

	}
	angular.module('shieldxApp').controller('configureDashboardCtrl', configureDashboardCtrl);
})();
/*
 ShieldX Networks Inc. CONFIDENTIAL
 ----------------------------------
 *
 Copyright (c) 2016 ShieldX Networks Inc.
 All Rights Reserved.
 *
 NOTICE: All information contained herein is, and remains
 the property of ShieldX Networks Incorporated and its suppliers,
 if any. The intellectual and technical concepts contained
 herein are proprietary to ShieldX Networks Incorporated
 and its suppliers and may be covered by U.S. and Foreign Patents,
 patents in process, and are protected by trade secret or copyright law.
 Dissemination of this information or reproduction of this material
 is strictly forbidden unless prior written permission is obtained
 from ShieldX Networks Incorporated.
 */

(function () {
    function dashboardCtr($scope,
            $state,
            $interval,
            $timeout,
            $log,
            $mdDialog,
            chartDataLoader,
            dataVisualizationApi,
            $translate, 
            dataVisualizationService,
            $rootScope,coreservices, dashbordservice) {
        "ngInject";				

        $scope.widgetData = [];
        $scope.refreshInterval = 30000;
        $scope.refreshing = true;
        //$scope.createDashboard = false;
        $scope.timerRef = undefined;

        $scope.refreshData = function(currTab) {        
        	_.forEach(tabs, function(tab, index) {
				if(index === currTab) {
					var dataWidgetConfigArray = [];
					//for alerts;
					_.forEach(tab.alerts, function(alert, key){
						var dataWidgetConfig = new DataWidgetConfig(widgetConfig.list[alert.widgetName].widgetType, alert.widgetName);
						dataWidgetConfigArray.push(dataWidgetConfig);		
					});
					//for dashboard items
					_.forEach(tab.dashboardItems, function(dashboardItem, key){

						var dataWidgetConfig = new DataWidgetConfig(widgetConfig.list[dashboardItem.content.widgetName].widgetType, dashboardItem.content.widgetName, dashboardItem.content.interval);
						dataWidgetConfig.nValue = (dashboardItem.content.nValue)?dashboardItem.content.nValue:3;
						dashboardItem.content.nValue = (dashboardItem.content.nValue)?dashboardItem.content.nValue:3;
						dataWidgetConfig.interval = (dashboardItem.content.interval)?dashboardItem.content.interval:30;
						dashboardItem.content.interval = (dashboardItem.content.interval)?dashboardItem.content.interval:30;
						dataWidgetConfig.otheroption = dashboardItem.content.otheroption;
						dataWidgetConfigArray.push(dataWidgetConfig);		
					});

					if(dataWidgetConfigArray.length > 0) {
						dataVisualizationService.getDataForWidgets(dataWidgetConfigArray).then(function(response){
							console.log("multifetch enabled response"+response);
							$scope.widgetData[index] = response;
						});	
					}
				}						
			});			
        };


     
        $scope.dashboardTemplate = {};  
        $scope.dashboardTemplate.columns = 1; //default
       	var tabs = [],
        selected = null,
        previous = null,
        stop;
    	//$scope.tabs = tabs;
    	$scope.selectedIndex = 0;
    	$scope.tenentID = 0;
    	$scope.logoURL = "";
		
    	
    	$scope.$watch('selectedIndex', function(current, old){
			/*previous = selected;
			selected = tabs[current];
			if ( old + 1 && (old != current)) $log.debug('Goodbye ' + previous.title + '!');
			if ( current + 1 )                $log.debug('Hello ' + selected.title + '!');*/
			if(!!current)
				$scope.refreshData(current);
		});

		$scope.$watchCollection('widgetData', function(newlist, old){
			console.log(" deep equality test >> ",_.isEqual(newlist, old));
			var curr = angular.copy(newlist[$scope.selectedIndex]);
			_.forEach(curr, function(wData, key){
				//if(wData.length) {
					var d = angular.copy(wData);
					var tempElem = angular.element(document.querySelector('#t'+$scope.selectedIndex+'-'+key));
					var curTab = tabs[$scope.selectedIndex];
	    			var thisDbItem = _.find(curTab.dashboardItems, function(o) { 
	    				return o.id === 't'+$scope.selectedIndex+'-'+key; 
	    			});
	    			if(!thisDbItem) {
	    				thisDbItem = _.find(curTab.alerts, function(o) { 
	    					return o.id === 't'+$scope.selectedIndex+'-'+key; 
	    				});
	    			}
	    			if(!thisDbItem) {
	    				console.error("Something went wrong. PLease contact the UI dev team");
	    			}
					$scope.$broadcast('item-refresh', {
						wdgName: key,
						elem : tempElem[0],
						dataSet : d, 
						activeTab: $scope.selectedIndex,
						refreshStatus: thisDbItem.refresh,
						columns: $scope.dashboardTemplate.columns
					});
				//} else {
				//	console.error('Error: No data available for %o in Tab: %o', key, $scope.selectedIndex);
				//}
			});			
			$scope.refreshing = false;
		});

		/*$scope.$watchCollection('tabs', function(newlist, old){
			console.log('tab content changed!');
		});*/

    	$scope.removeTab = function (tab, ev) {
    		var confirm = $mdDialog.confirm({
    			onComplete: function afterShowAnimation() {
                    var $dialog = angular.element(document.querySelector('md-dialog'));
                    var $actionsSection = $dialog.find('md-dialog-actions');
                    var $cancelButton = $actionsSection.children()[0];
                    var $confirmButton = $actionsSection.children()[1];

                    var $contentBody = $dialog.find('md-dialog-content');
                    var $contentText = $contentBody.find('div');
                    angular.element($contentText).addClass('remove-dialog-content-style');

                    angular.element($cancelButton).addClass('md-accent md-hue-3');
                    angular.element($confirmButton).addClass('md-accent md-raised').css('color','#fff');
                }
    		})
		          .title('Remove Dashboard?')
		          .textContent('Are you sure you want to remove '+ tab.title.toUpperCase() +'?')
		          .targetEvent(ev)
		          .ok('Remove')
		          .cancel('Cancel');

		    $mdDialog.show(confirm).then(function() {
		    	var index = tabs.indexOf(tab);
	    		tabs.splice(index, 1);
	    		if(tabs.length === 0) {
	    			$scope.createDashboard = true;
					$scope.addDashboard = true;
	    		}
	    		dashbordservice.saveDashboardData($scope.tenentID, {
	    			columns: $scope.dashboardTemplate.columns, //$scope.dashboardTemplate.columns = 1,
	    			lastActiveTab: $scope.selectedIndex, //$scope.dashboardTemplate.lastActiveTab = index,
	    			tabs: tabs, //$scope.dashboardTemplate.tabs = tabs,
	    			theme: $scope.dashboardTemplate.theme  //$scope.dashboardTemplate.theme = "LIGHT"	    			
	    		});	    		
		    }, function() {
		    	//do nothing
		    });	    	
	    };

	    $scope.addTab = function (event) {
	    	 $mdDialog.show({
                skipHide: true,
                controller: 'newDasboardNameCtrl',
                bindToController: true,
                preserveScope: true,
                templateUrl: 'core/components/dashboard/dashboard-name.html',
                parent: angular.element(document.body),
                targetEvent: event,
                fullscreen: false,
                scope: $scope,
                openFrom: { top: 1100, height: 0 },
                closeTo: { left: 1500 }
            }).then(function(res) {
            	$scope.createDashboard = false;
            	var newIndex = tabs.push({ title: res, alerts : [], dashboardItems: [] });
            	$timeout(function() {
					$scope.selectedIndex = newIndex - 1;
				});
            	dashbordservice.saveDashboardData($scope.tenentID, {
	    			columns: $scope.dashboardTemplate.columns, //$scope.dashboardTemplate.columns = 1,
	    			lastActiveTab: $scope.selectedIndex, //$scope.dashboardTemplate.lastActiveTab = index,
	    			tabs: tabs, //$scope.dashboardTemplate.tabs = tabs,
	    			theme: $scope.dashboardTemplate.theme  //$scope.dashboardTemplate.theme = "LIGHT"	    			
	    		});
            });
	    };


	    $scope.configureTab = function(event, index) {
	    	console.log(tabs[index]);
	    	var itemList = [];
	    	
	    	_.forEach(widgetConfig.list, function(value, key) {
				itemList.push(value);
			});

	    	$mdDialog.show({
                controller: 'configureDashboardCtrl', 
                templateUrl: 'core/components/dashboard/configure-dashboard-tmpl.html', 
                parent: angular.element(document.body), 
                targetEvent: event, 
                clickOutsideToClose: true,                 
                locals: { tabConfig: tabs, activeTabIndex: index, dashboardItemList: itemList}
            }).then(function (response) {
                console.log(' data back from dialog box >> ', response);
                tabs[index].alerts.length = 0;
                tabs[index].dashboardItems.length = 0;

                tabs[index].title = response.title;

                _.forEach(response.selected, function(obj){
                	if(obj.chartType.match(/Alert/g)) {
                		tabs[index].alerts.push({
                			id: 't'+ index + '-' + obj.value,
                			refresh: true,
                			widgetName : obj.value          			
                		});
                	} else if (obj.chartType.match(/Chart/g)) {
                		tabs[index].dashboardItems.push({                			
							id: 't'+ index + '-' + obj.value, 
							refresh: true,
							content: {							
								widgetName: obj.value,
								options : widgetConfig.list[obj.value].otherConfig,
								nValue :3,
        						interval:30,
        						otheroption:""
							}
                		});
                	}
                });
               var tempObj = _.remove( tabs[index].dashboardItems,function(deleteWidget){
									return deleteWidget.content.widgetName === 'IOP';
							});
				if(tempObj && tempObj.length !== 0){
					tabs[index].dashboardItems.push(tempObj[0]);
				}
               
                $scope.refreshing = true;
                $scope.refreshData(index);
                $scope.switchLayout(null, $scope.dashboardTemplate.columns);
                dashbordservice.saveDashboardData($scope.tenentID, {
	    			columns: $scope.dashboardTemplate.columns, // = 1,
	    			lastActiveTab: index, //$scope.dashboardTemplate.lastActiveTab = index,
	    			tabs: tabs, //$scope.dashboardTemplate.tabs = tabs,
	    			theme: $scope.dashboardTemplate.theme  //$scope.dashboardTemplate.theme = "LIGHT"	    			
	    		});
            }, function () {
                //$scope.editIPRangeMode = false;
            });

	    };	

	    $scope.switchLayout = function(event, layout) {
	    	//setting state to menu item
	    	for(var i = 1; i <= 3; i++){
	    		var menuElem = document.querySelector('#db-config-'+i+'-col');
	    		if(i === layout) {
	    			angular.element(menuElem).addClass('config-selected');
	    		} else {
	    			angular.element(menuElem).removeClass('config-selected');
	    		}
	    	}	    	
			var gridster = document.querySelector('.gridster');
			if(layout == 1){
				angular.element(gridster).addClass('layoutOneColumn').removeClass('layoutTwoColumn').removeClass('layoutThreeColumn');
				$scope.gridsterOpts.rowHeight = 600;
			}else if(layout == 2){
				angular.element(gridster).addClass('layoutTwoColumn').removeClass('layoutOneColumn').removeClass('layoutThreeColumn');
				$scope.gridsterOpts.rowHeight = 500;
			}else if(layout == 3){
				angular.element(gridster).addClass('layoutThreeColumn').removeClass('layoutOneColumn').removeClass('layoutTwoColumn');
				$scope.gridsterOpts.rowHeight = 400;
			}

	    	var tempTab = tabs[$scope.selectedIndex];
	    	var r = 0;
    		_.forEach(tempTab.dashboardItems, function(item, key){
    			//sizeX =6 col =0
    			if(item.content.widgetName === "IOP"){
    				item.sizeX = 6;
    				item.col = 0;
    			}else{
    				if(layout==2){
	    				if( key%2 === 1) {
	    					r++;
	    				}
	    				item.row = r;
	    			}
    				item.sizeX = $scope.gridsterOpts.columns/layout;	
    				item.col = ((key * ($scope.gridsterOpts.columns/layout)) % $scope.gridsterOpts.columns);
    			}

    			//item.sizeY = $scope.gridsterOpts.columns/layout;


    			//item.sizeY = 1/layout;
    			//setting rows and cols
    			
    		});
    		$scope.dashboardTemplate.columns = layout; // ($scope.dashboardTemplate.columns !== layout) ? layout : $scope.dashboardTemplate.columns;
    		$scope.refreshing = true;
    		$scope.refreshData($scope.selectedIndex);	
    		if(!!event) {
	    		dashbordservice.saveDashboardData($scope.tenentID, {
	    			columns: $scope.dashboardTemplate.columns, //$scope.dashboardTemplate.columns = 1,
	    			lastActiveTab: $scope.selectedIndex, //$scope.dashboardTemplate.lastActiveTab = index,
	    			tabs: tabs, //$scope.dashboardTemplate.tabs = tabs,
	    			theme: $scope.dashboardTemplate.theme  //$scope.dashboardTemplate.theme = "LIGHT"	    			
	    		});   	
	    	}
	    };

	    $scope.removeWidget = function(event, dbItem) {
	    	var confirm = $mdDialog.confirm({
    			onComplete: function afterShowAnimation() {
                    var $dialog = angular.element(document.querySelector('md-dialog'));
                    var $actionsSection = $dialog.find('md-dialog-actions');
                    var $cancelButton = $actionsSection.children()[0];
                    var $confirmButton = $actionsSection.children()[1];

                    var $contentBody = $dialog.find('md-dialog-content');
                    var $contentText = $contentBody.find('div');
                    angular.element($contentText).addClass('remove-dialog-content-style');

                    angular.element($cancelButton).addClass('md-accent md-hue-3');
                    angular.element($confirmButton).addClass('md-accent md-raised').css('color','#fff');
                }
    		})
		          .title('Remove Widget?')
		          .textContent('Are you sure you want to remove '+widgetConfig.list[dbItem.content.widgetName].title+'?')
		          .targetEvent(event)
		          .ok('Remove')
		          .cancel('Cancel');

		    $mdDialog.show(confirm).then(function() {
		    	var curTab = tabs[$scope.selectedIndex];
		    	var thisIndex = _.findIndex(curTab.dashboardItems, function(o) { return o.id == dbItem.id; });
	    		curTab.dashboardItems.splice(thisIndex, 1);
	    		dashbordservice.saveDashboardData($scope.tenentID, {
	    			columns: $scope.dashboardTemplate.columns, //$scope.dashboardTemplate.columns = 1,
	    			lastActiveTab: $scope.selectedIndex, //$scope.dashboardTemplate.lastActiveTab = index,
	    			tabs: tabs, //$scope.dashboardTemplate.tabs = tabs,
	    			theme: $scope.dashboardTemplate.theme  //$scope.dashboardTemplate.theme = "LIGHT"	    			
	    		});
		    });	 
	    };
	    
	    $scope.selectedNavlue = function(event, dbItem, interval, nvalue){
	    	/*dbItem.content.nValue = parseInt(nvalue);
	    	dbItem.content.interval = parseInt(interval);*/
	    	console.log(dbItem.content.nvalue);
	    	console.log(dbItem.content.interval);
	    	console.log(dbItem.content.otheroption);
	    };

	    $scope.pauseRefreshToggle = function(event, dbItem) {
	    	var curTab = tabs[$scope.selectedIndex];
	    	var thisIndex = _.find(curTab.dashboardItems, function(o) { return o.id == dbItem.id; });
	    	thisIndex.refresh = !thisIndex.refresh;
	    	console.log(tabs);
	    };

	    $scope.drillDownConfig = {};
	    $scope.drillDownConfig.ready = false;

	    
	    $scope.$on('showDrillDown', function(event, args){	    	
	    	$scope.drillDownConfig.widgetname = args.type.value;
	    	$scope.drillDownConfig.drilldowndata = args.data;
			$scope.drillDownConfig.ready = true;
			$scope.$apply();
			d3.selectAll(".d3-tip.n").remove();
			setTimeout(function(){
				$scope.stopTimer();
			},0);
		});

	    $scope.$on('closeDrillDown', function(event, args){
	    	$scope.drillDownConfig = {};
	    	$scope.drillDownConfig.ready = false;
	    	$scope.refreshing = true;
	    	$scope.$emit('listenHeaderText', { headerText: "Dashboard" });
    		$scope.refreshData($scope.selectedIndex);
	    	//$state.reload();
	    });

	    $scope.toggleFullScreen = function(event) {
	    	var toggleList = ["md-tabs-canvas", "md-tabs-wrapper", "#dashboard-config-cog", "#home-toolbar", ".drill-dn-icon", ".widget-button-controls", ".widget-options"];
	    	_.forEach(toggleList, function(elems, key) {
	    		angular.element(document.querySelectorAll(elems)).css('display','none');
	    	});
	    	angular.element(document.querySelector("#dashboard-page")).css('background','#f7f7f7');
	    	angular.element(document.querySelector("#fullscreen-toolbar")).css('display','block');
	    };

	    angular.element(document).on('keydown keypress', function(event){ 
	    	if(!angular.element(document.querySelector('#fullscreen-toolbar')).css('display')) {
	    		return;
	    	}
			if(!!angular.element(document.querySelector('#fullscreen-toolbar')).css('display').match(/block/) && !!event.key.match(/Escape/)) {
				console.log("exit full screen");
				var toggleList = ["md-tabs-canvas", "md-tabs-wrapper", "#dashboard-config-cog", "#home-toolbar", ".drill-dn-icon", ".widget-button-controls", ".widget-options"];
	    		_.forEach(toggleList, function(elems, key) {
	    			angular.element(document.querySelectorAll(elems)).css('display','block');
	    		});
	    		angular.element(document.querySelector("#dashboard-page")).css('background','#fff');
	    		angular.element(document.querySelector("#fullscreen-toolbar")).css('display','none');
			}
		});

		window.onresize = function(){
			$scope.refreshing = true;
			$scope.refreshData($scope.selectedIndex);
		};

		$scope.toggleTheme = function(event, theme) {
			if(theme.match(/_LIGHT/gi) || theme.match(/LIGHT/gi)) {
				angular.element(document.querySelector('#db-config-light')).addClass('config-selected');
				angular.element(document.querySelector('#db-config-dark')).removeClass('config-selected');
				angular.element(document.querySelector('#dashboard-page')).removeClass('dark-theme');
				angular.element(document.querySelector('#dashboard-page')).addClass('light-theme');
				angular.element(document.querySelector('.headerBar')).removeClass('dark-theme');
				$scope.logoURL = 'images/ui-light-logo@2x.png';
			} else {
				angular.element(document.querySelector('#db-config-dark')).addClass('config-selected');
				angular.element(document.querySelector('#db-config-light')).removeClass('config-selected');
				angular.element(document.querySelector('#dashboard-page')).removeClass('light-theme');
				angular.element(document.querySelector('#dashboard-page')).addClass('dark-theme');
				angular.element(document.querySelector('.headerBar')).addClass('dark-theme');
				$scope.logoURL = 'images/ui-dark-logo@2x.png';
			}
			$scope.dashboardTemplate.theme = theme;
			if(!!event) {
				dashbordservice.saveDashboardData($scope.tenentID, {
	    			columns: $scope.dashboardTemplate.columns, //$scope.dashboardTemplate.columns = 1,
	    			lastActiveTab: $scope.selectedIndex, //$scope.dashboardTemplate.lastActiveTab = index,
	    			tabs: tabs, //$scope.dashboardTemplate.tabs = tabs,
	    			theme: $scope.dashboardTemplate.theme  //$scope.dashboardTemplate.theme = "LIGHT"	    			
	    		});
			}
		};

		$scope.setMessageHeight = function() {
			var winHeight = window.innerHeight;
			return (winHeight - 64 - 49) + 'px';
		};

		$scope.gridsterOpts = {
		    columns: 6, // the width of the grid, in columns
		    pushing: true, // whether to push other items out of the way on move or resize
		    floating: true, // whether to automatically float items up so they stack (you can temporarily disable if you are adding unsorted items with ng-repeat)
		    swapping: true, // whether or not to have items of the same size switch places instead of pushing down if they are the same size
		    width: 'auto', // can be an integer or 'auto'. 'auto' scales gridster to be the full width of its containing element
		    colWidth: 'auto', // can be an integer or 'auto'.  'auto' uses the pixel width of the element divided by 'columns'
		    rowHeight: 600, // can be an integer or 'match'.  Match uses the colWidth, giving you square widgets.
		    margins: [10, 10], // the pixel distance between each widget
		    outerMargin: true, // whether margins apply to outer edges of the grid
		    sparse: false, // "true" can increase performance of dragging and resizing for big grid (e.g. 20x50)
		    isMobile: false, // stacks the grid items if true
		    mobileBreakPoint: 600, // if the screen is not wider that this, remove the grid layout and stack the items
		    mobileModeEnabled: true, // whether or not to toggle mobile mode when screen width is less than mobileBreakPoint
		    minColumns: 1, // the minimum columns the grid must have
		    minRows: 2, // the minimum height of the grid, in rows
		    maxRows: 100,
		    defaultSizeX: 6, // the default width of a gridster item, if not specifed
		    defaultSizeY: 1, // the default height of a gridster item, if not specified
		    minSizeX: 1, // minimum column width of an item
		    maxSizeX: null, // maximum column width of an item
		    minSizeY: 1, // minumum row height of an item
		    maxSizeY: null, // maximum row height of an item
		    resizable: {
		       enabled: false,
		       handles: ['n', 'e', 's', 'w', 'ne', 'se', 'sw', 'nw'],
		       start: function(event, $element, widget) {}, // optional callback fired when resize is started,
		       resize: function(event, $element, widget) {}, // optional callback fired when item is resized,
		       stop: function(event, $element, widget) { // optional callback fired when item is finished resizing
		       		$scope.refreshing = true;
		       		$scope.refreshData($scope.selectedIndex);       		       		
		       	} 
		    },
		    draggable: {
		       enabled: true, // whether dragging items is supported
		       //handle: '.my-class', // optional selector for drag handle
		       start: function(event, $element, widget) {}, // optional callback fired when drag is started,
		       drag: function(event, $element, widget) {}, // optional callback fired when item is moved,
		       stop: function(event, $element, widget) {} // optional callback fired when item is finished dragging
		    }
		};

		
		$scope.setTabData = function(datashabordData){

        	tabs = datashabordData.tabs;
			$scope.tabs = tabs;

			if(tabs.length === 0) {
				$scope.createDashboard = true;
				return;
			}

			$scope.dashboardTemplate.theme = datashabordData.theme;
			$scope.toggleTheme(null, $scope.dashboardTemplate.theme);
			$scope.dashboardTemplate.columns = datashabordData.columns;
			$scope.switchLayout(null, $scope.dashboardTemplate.columns);

			$scope.selectedIndex = 0;

			//update tabs with otherConfig
	    	_.forEach(tabs, function(tabItem, key){
	    		_.forEach(tabItem.dashboardItems, function(widgetItem){
	    			if(widgetConfig.list[widgetItem.content.widgetName].hasOwnProperty('otherConfig'))
	    				widgetItem.content["options"] = widgetConfig.list[widgetItem.content.widgetName].otherConfig; // jshint ignore:line
	    			widgetItem.refresh = true;
	    		});
	    	});
	    	$scope.refreshData($scope.selectedIndex);
        };
        /*$scope.createDashboard = true;
    	$scope.noTenantAvaliable = true;
    	$scope.addDashboard = false;  */
        coreservices.getTenantForVMWare().then(function(tenantid){
			console.log(" getTenantForVMWare ");
			console.dir(tenantid);
			$scope.tenentID = tenantid;
            var self = this;
            var tempObj = '';
            if(tenantid === undefined || tenantid === ''){
				$scope.createDashboard = true;
	        	$scope.noTenantAvaliable = true;
	        	$scope.addDashboard = false;            	
            }else{
            	return dashbordservice.getDashboardData($scope.tenentID).then(function(datashabordData){
					console.log(" getDashboardData "+datashabordData);
					console.dir(datashabordData);
					if(datashabordData && datashabordData !== '' ){
						_.each(datashabordData.tabs,function(dashboardItem){
							tempObj = _.remove(dashboardItem.dashboardItems,function(deleteWidget){
									return deleteWidget.content.widgetName === 'IOP';
							});
							if(tempObj && tempObj.length !== 0){
								dashboardItem.dashboardItems.push(tempObj[0]);
							}
							console.log(tempObj);
						});
						$scope.createDashboard = false;
						if(datashabordData.tabs.length===0){
	        				$scope.addDashboard = true;
						}else{
							$scope.addDashboard = false;
						}
	        			$scope.setTabData(datashabordData);
					}else{
		            	$scope.createDashboard = true;
						$scope.noTenantAvaliable = false;
						$scope.addDashboard = true;
					}
		    	});
            }
            //console.dir(scope.tenentID);
			
		});

		$scope.$emit('listenHeaderText', { headerText: "Dashboard"});			
		
		$scope.startTimer = function(){
			if(!$scope.timerRef){
	        $scope.timerRef = $interval(function(){
					console.log(' #################################   REFRESHING NOW!  #################################');
					$scope.refreshData($scope.selectedIndex);
				}, $scope.refreshInterval);
			}
	       	
		};

		$scope.stopTimer = function(){
			if($scope.timerRef){
			 $interval.cancel($scope.timerRef);
			 $scope.timerRef  = undefined;
		   }
		};

        $scope.startTimer();
        $rootScope.$on('$stateChangeStart', function(event, toState, toParams, fromState, fromParams){
        	$scope.stopTimer();
        });
		
 }

    angular.module('shieldxApp').controller('dashboardCtr', dashboardCtr).directive('directiv', function(){
	    return {
	        restrict: 'A',
	        link: function(scope, element, attrs) {
	            element.bind('click', function(event, element) {
	               scope.$parent.$parent.selectedIndex = scope.$index;	               
	            });
	        }
	    };
	});
	
})();
 /*
 Copyright (c) 2016 ShieldX Networks Inc.
 All Rights Reserved.
 *
 NOTICE: All information contained herein is, and remains
 the property of ShieldX Networks Incorporated and its suppliers,
 if any. The intellectual and technical concepts contained
 herein are proprietary to ShieldX Networks Incorporated
 and its suppliers and may be covered by U.S. and Foreign Patents,
 patents in process, and are protected by trade secret or copyright law.
 Dissemination of this information or reproduction of this material
 is strictly forbidden unless prior written permission is obtained
 from ShieldX Networks Incorporated.
 */

(function () {
	function newDasboardNameCtrl($scope,
		$mdDialog
		) {
		"ngInject";

		$scope.createNewName = function(groupName) {
			if($scope.dashboardName) $scope.dashboardName = groupName;
			$mdDialog.hide(groupName);
		};
		$scope.closeDialog = function() {
			$mdDialog.cancel();
		};

	}
	angular.module('shieldxApp').controller('newDasboardNameCtrl', newDasboardNameCtrl);
})();
(function () {
    function landingPageCtr($scope,$state, coreservices, $mdDialog,screenMenagment,userSessionMenagment) {
        "ngInject";
         console.log("landingPageCtr >>>  ");
        screenMenagment.setCurrentScreen(screenMenagment.screens.HOME_PAGE); 
        $scope.showAuthError = false;
        $scope.errorMesage = "Invalid user name or password";
        $scope.userInfo =  {name:"", password:""};

         $scope.signinUser = function(){
         	console.log(" sigin clicked ");
           $state.go('home.EventCorrelationExplorer');  
         	
         };

        $scope.getUserName = function(){
          	return $scope.userInfo.name;
        };

        $scope.pwdType= "password";

        $scope.togglePasswordType = function () {
            $scope.pwdType = $scope.pwdType === 'password' ? 'text' : 'password';
        };

        $scope.showPrivacyMessage = function(ev){
            $mdDialog.show({
                controller: 'showMessagesCtr', templateUrl: 'core/components/landingpage/privacy-message.html', parent: angular.element(document.body), targetEvent: ev, clickOutsideToClose: true
                
            }).then(function (answerVal) {
                
            }, function () {
               
            });
        };

        $scope.showTermMessage = function(ev){
            $mdDialog.show({
                controller: 'showMessagesCtr', templateUrl: 'core/components/landingpage/term-message.html', parent: angular.element(document.body), targetEvent: ev, clickOutsideToClose: true
                
            }).then(function (answerVal) {
                
            }, function () {
               
            });
        };

        $scope.onPasswordFieldKeyup = function(event){
           if(event.keyCode === 13){
               $scope.signinUser();
           }     
        }; 

    }

    angular.module('shieldxApp').controller('landingPageCtr', landingPageCtr);
})();
/*
 ShieldX Networks Inc. CONFIDENTIAL
 ----------------------------------
 *
 Copyright (c) 2016 ShieldX Networks Inc.
 All Rights Reserved.
 *
 NOTICE: All information contained herein is, and remains
 the property of ShieldX Networks Incorporated and its suppliers,
 if any. The intellectual and technical concepts contained
 herein are proprietary to ShieldX Networks Incorporated
 and its suppliers and may be covered by U.S. and Foreign Patents,
 patents in process, and are protected by trade secret or copyright law.
 Dissemination of this information or reproduction of this material
 is strictly forbidden unless prior written permission is obtained
 from ShieldX Networks Incorporated.
 */

(function () {
     function ShowMessagesCtr($scope, $mdDialog) {
         $scope.hide = function () {
            $mdDialog.hide();
        };
        $scope.closeDialog = function () {
            $mdDialog.cancel();
        };
        $scope.closeDialogWithAnswer = function (answer) {
            var returnVal = {selectedVal: answer, newtworks: $scope.newtworks};
            $mdDialog.hide(returnVal);
        };
    }
    angular.module('shieldxApp').controller('showMessagesCtr', ShowMessagesCtr);
})();
/*
 ShieldX Networks Inc. CONFIDENTIAL
 ----------------------------------
 *
 Copyright (c) 2016 ShieldX Networks Inc.
 All Rights Reserved.
 *
 NOTICE: All information contained herein is, and remains
 the property of ShieldX Networks Incorporated and its suppliers,
 if any. The intellectual and technical concepts contained
 herein are proprietary to ShieldX Networks Incorporated
 and its suppliers and may be covered by U.S. and Foreign Patents,
 patents in process, and are protected by trade secret or copyright law.
 Dissemination of this information or reproduction of this material
 is strictly forbidden unless prior written permission is obtained
 from ShieldX Networks Incorporated.
 */

(function () {
    function myLockerCtr($scope,
            $state,
            $translate) {
        "ngInject";

        $scope.headerText = $translate.instant('HEADER_TEXT');

        console.log("myLockerCtr initialised");

        $scope.$on('$viewContentLoaded', function (event) {
            console.log(event);
            fixContainerHeight(1);
        });

    }


    angular.module('shieldxApp').controller('myLockerCtr', myLockerCtr);

})();

/*
 ShieldX Networks Inc. CONFIDENTIAL
 ----------------------------------
 *
 Copyright (c) 2016 ShieldX Networks Inc.
 All Rights Reserved.
 *
 NOTICE: All information contained herein is, and remains
 the property of ShieldX Networks Incorporated and its suppliers,
 if any. The intellectual and technical concepts contained
 herein are proprietary to ShieldX Networks Incorporated
 and its suppliers and may be covered by U.S. and Foreign Patents,
 patents in process, and are protected by trade secret or copyright law.
 Dissemination of this information or reproduction of this material
 is strictly forbidden unless prior written permission is obtained
 from ShieldX Networks Incorporated.
 */

(function () {
    function networksCtr($scope,
            $state,
            $translate) {
        "ngInject";

        $scope.headerText = $translate.instant('HEADER_TEXT');

        console.log("networksCtr initialised");

        $scope.$on('$viewContentLoaded', function (event) {
            console.log(event);
            fixContainerHeight(1);
        });

    }


    angular.module('shieldxApp').controller('networksCtr', networksCtr);

})();

/*
ShieldX Networks Inc. CONFIDENTIAL
----------------------------------
*
Copyright (c) 2016 ShieldX Networks Inc.
All Rights Reserved.
*
NOTICE: All information contained herein is, and remains
the property of ShieldX Networks Incorporated and its suppliers,
if any. The intellectual and technical concepts contained
herein are proprietary to ShieldX Networks Incorporated
and its suppliers and may be covered by U.S. and Foreign Patents,
patents in process, and are protected by trade secret or copyright law.
Dissemination of this information or reproduction of this material
is strictly forbidden unless prior written permission is obtained
from ShieldX Networks Incorporated.
*/

(function() {
    function aclPolicyTableDirective() {
        var directive = {};
        directive.restrict = 'E';
        directive.templateUrl = 'core/directive/acl-table/acl-table.html';
        directive.scope = {
            content: '=content',
            totaldata:'=totaldata',
            mode:'=mode'
        };
        directive.controller = ['$scope', '$state', 'policyService', '$translate', '$mdDialog', 'dragularService', 'infrastructureConnectorService', '$sessionStorage', 'userSessionMenagment', function($scope, $state, policyService, $translate, $mdDialog, dragularService, infrastructureConnectorService,$sessionStorage,userSessionMenagment) {

            $scope.selectedcheckBox = false;
            $scope.brand = false;
            $scope.policiesList = [];
            $scope.languageInUse = $translate.use();
            $scope.blockingThreshold = '';
            $scope.resGroupTotalList = [];
            $scope.dateInSateParams = false;
            $scope.resPromiseComplited = true;
            $scope.isSearchBarOpen = false;
            $scope.rsGroupselectedValues = [];
            $scope.selectedCopyResList = [];
            if($state.params.policyId){
                $scope.dataInSateParams = true;
            }
            var update_id = authorities("policy_update");
            $scope.is_update_policy = userSessionMenagment.isUserAllowd(update_id);
            policyService.getDataBasedOnId("threatpreventionpolicy/appid", "policy", true).then(function(data) {
                $scope.dataList = data;
                $scope.list_app_activated = false;
            }, function(err) {
                console.log("error while getting the appid list");
                $scope.list_app_activated = false;
            });
            policyService.getDataBasedOnId("policy", "accesscontrolpolicy/action").then(function(res) {
                    $scope.actionList = res;
                }, function(err) {
                    console.log("Error Data From Action");
                    $scope.actionList = ["PERMIT", "DENY"];
                });
            $scope.ProtocolList = [{"protocolName":"TCP"},{"protocolName":"UDP"},{"protocolName":"BOTH"}];
            policyService.getResourceGroupData().then(function(data){
                $scope.totalResGroup = data;
                $scope.resPromiseComplited = false;
             },function(err){
                $scope.resPromiseComplited = false;
                console.log("unable to fetch Resource Groups");
             });
            //$scope.totalResGroup = $sessionStorage.resourcegroup;
            var dragAndDropContainer = document.querySelector('#updateAclRowcontent');
            dragularService([dragAndDropContainer], {
                //containersModel: [$scope.items1],
                //copy: true,
                //move only from left to right  
                //accepts: accepts,
                moves: function(el, container, handle) {
                    return handle.id === 'handle';
                },
                invalid:function(el,container,hadle){
                    var temp  = el.className;
                    return temp.indexOf("ImplicitDenyAll") > 0;
                },
                scope: $scope
            });

            $scope.$on('dragulardrag', function(e, el) {
                console.log(" drag start ");
                e.stopPropagation();

            });
/*            $scope.$on('dragulardrop',function(e,target,source,sibiling){
                console.log(target);
            }); */    
            $scope.$on('dragularrelease',function(e,el){
                 console.log("relase");
                 var elements = angular.element(dragAndDropContainer);
                // console.log(" dragAndDropContainer elements "); 
                // console.dir(elements);
                var dragElements = elements[0].children;
                /* jshint ignore:start */
                for (var i = 0; i < dragElements.length; i++) {
                    var dragElement = dragElements[i];
                     var ruleval = _.find($scope.content, function(o) {
                        return o.orderNum === parseInt(dragElement.id);
                    });
                    ruleval.orderNum = (i + 1);
                }
                $scope.content = _.sortBy( $scope.content, 'orderNum');
                for(var i=0,j=1;i<$scope.content.length;i++){
                    if($scope.content[i].name === 'ImplicitDenyAll'){
                        $scope.content[i].orderNum = $scope.content.length;
                    }else{
                        $scope.content[i].orderNum = j;
                        j++;
                    }
                }
                 $scope.content = _.sortBy( $scope.content, 'orderNum');
                 $scope.$emit('listenAclPolicyData', { data: $scope.content });
                 /* jshint ignore:end */
                  e.stopPropagation();
            });
            $scope.toggleSearchBar = function(event) {
                    $scope.isSearchBarOpen = $scope.isSearchBarOpen === false ? true : false;
                    if ($scope.isSearchBarOpen)
                        angular.element(event.currentTarget.firstElementChild).css('color', '#4a90e2');
                    else
                        angular.element(event.currentTarget.firstElementChild).css('color', '#6d6e71');
            };
            $scope.deleteAclPolicy = function(data){
                _.remove($scope.content, function(item){
                    return item.id === data.id;
                });
                $scope.$emit('listenAclPolicyData', { data: $scope.content });
                console.log($scope.content);
                console.log(data);
            };
            $scope.$emit('listenAclPolicyData', { data: $scope.content });
         /*   $scope.chnageOrderInACLTabel = function(data,key){
                if(data !== '' && $scope.content.length >= parseInt(data) && parseInt(data) > 0  ){
                    $scope.content[key].orderNum = parseInt(data);
                    $scope.content[key].editOrderNumber = false;
                    $scope.content = _.sortBy( $scope.content, 'orderNum');
                   // _.sortBy($scope.content, 'orderNum');
                }
            };*/
            $scope.rangesList = [{
                    'portnumber': '',
                    'start': '',
                    'end': '',
                    'rangeEndEnableState':true,
                    'PortnumberEnableState':true
                }];
            $scope.addAnthorRange = function() {
                var data = {
                    'portnumber': '',
                    'start': '',
                    'end': '',
                    'rangeEndEnableState':true,
                    'PortnumberEnableState':true
                };
                $scope.rangesList.push(data);
            };
            $scope.addAnthorCidr = function(){
                var data = {'value':''};
                $scope.cidrList.push(data);
            };
            $scope.deleteCidr = function(cidr){
                var i = _.findIndex($scope.cidrList, function(item) {
                    return cidr === item;
                });

                if (i !== undefined) {
                    $scope.cidrList.splice(i, 1);
                }
                $scope.IsValidForm();
            };
            $scope.deleterange = function(range) {
                var i = _.findIndex($scope.rangesList, function(item) {
                    return range === item;
                });

                if (i !== undefined) {
                    $scope.rangesList.splice(i, 1);
                }
                if($scope.rangesList.length === 0){
                    $scope.addAnthorRange();
                }
                $scope.IsValidForm();
                //_.remove()
                //$scope.deleted({ranges:$scope.rangesRef}); 
            };
           $scope.endRangeKeyDown = function ($event, rangeData) {
                    if(rangeData.portnumber !==  ''  ){
                        rangeData.rangeEndEnableState = false;
                    }else if(rangeData.start !==  '' || rangeData.end !==  '' ){
                        rangeData.PortnumberEnableState = false;
                    }else{
                        rangeData.rangeEndEnableState = true;
                        rangeData.PortnumberEnableState = true;
                    }

                };

           /* $scope.callToOpenPopUp = function(event,id){
                console.log(id);
                $scope.showMoreResGruops = false;
                if(id === "Server Objects"){
                    $scope.callResourceGroupList(event,id);
                }
            };*/
            $scope.emptyServerObjects = function(){
                $scope.selectedGroupList = [];
                $scope.selectedResGroupObj = []; 
                $scope.selectedResGroupObjID = [];
                $scope.RemoveExistingData =  false;
                $scope.ResGroupRadioSelected = false; 
            };
            $scope.emptyCidrs = function(){
                $scope.cidrList = [{
                    'value':''
                }];
                $scope.RemoveExistingData =  false;
            };

            $scope.callToOpenPopUpForProtocolAppId =  function(event, id){
                if(id === 'AppIDs' ){
                    $scope.callgetListPopUp(event,"AppId");
                }else{
                    $scope.callgetprotocolListPopUp(event,'Protocols');
                }
            };
            $scope.emptyAppIDs = function(){
                $scope.selectedAPPIDGroupList = [];
                $scope.selectedAPPIDObj = [];
                $scope.selectedAPPIDObjID = [];
                $scope.RemoveExistingDataForAPPProto = false;
                $scope.appIDSelected = false;
            };
            $scope.emptyProtoclos = function(){
                $scope.protocolSelectedValue = {'protocolName':''};
                $scope.protocolSelected = false;
                $scope.selectedprotocol = '';
                $scope.RemoveExistingDataForAPPProto = false;
            };
            $scope.cancelDataForTheExisting = function(id){
                if(id === 'Server Objects'){
                    $scope.emptyServerObjects();
                }else if(id === 'CIDRs'){
                    $scope.emptyCidrs();
                }else if(id === 'AppIDs'){
                    $scope.emptyAppIDs();
                }else{
                    $scope.emptyProtoclos();
                }
                $scope.IsValidForm(); 
            };
            $scope.onSelectProtocolCidrsChanged = function(data){
                if( data === "Server Objects" && $scope.cidrList.length > 0){
                    if($scope.cidrList.length > 1){
                        $scope.RemoveExistingData =  true;    
                    }else if($scope.cidrList.length === 1 && $scope.cidrList[0].value !== ''){
                        $scope.RemoveExistingData =  true;    
                    }                        
                }else if(data === "CIDRs" && $scope.ResGroupRadioSelected){
                    $scope.RemoveExistingData =  true;
                }else if(data === "AppIDs" && $scope.protocolSelectedValue !== undefined && $scope.protocolSelectedValue.protocolName !== ''){
                    $scope.RemoveExistingDataForAPPProto =  true;
                }else if(data  === "L4 Protocols" && $scope.selectedAPPIDGroupList.length > 0){
                    $scope.RemoveExistingDataForAPPProto =  true;
                }else{
                    $scope.RemoveExistingData =  false;
                    $scope.RemoveExistingDataForAPPProto = false;
                }
                
            };
            $scope.IsValidForm = function(){
                 if($scope.aclPolicyIndexOfEditRow !== undefined ){
                        if($scope.aclrulename !== ''){
                            $scope.aclnewRForm.$dirty = true; 
                        }
                    }
            };
            $scope.showMoreItemPopUp = function(event,data,name){
                $scope.showmorePopUpData = data;
                $scope.showMoreDataName = name;
                $mdDialog.show({
                    skipHide: true,
                    preserveScope: true,
                    controller: showMoreDataCtrl,
                    bindToController: true,
                    templateUrl: 'core/directive/acl-table/more-data.html',
                    parent: angular.element(document.body),
                    targetEvent: event,
                    fullscreen: false,
                    scope: $scope,
                    openFrom: { top: 1100, height: 0 },
                    closeTo: { left: 1500 }
                }).then(function() {

                });
            };
            function showMoreDataCtrl($mdDialog,$scope){
                $scope.cancelShowMoreDataPopup = function(){
                    $mdDialog.cancel();
                };
            }
            $scope.callResourceGroupList = function(event, data) {
                // $scope.clickedItemForPopup = data;
                $scope.isresSearchBarOpen = false;
                $scope.resGroupFromPopupSeleted=[];
                $mdDialog.show({
                    skipHide: true,
                    preserveScope: true,
                    controller: aclResourceGroupListCtrl,
                    bindToController: true,
                    templateUrl: 'core/directive/acl-table/rs-group.html',
                    parent: angular.element(document.body),
                    locals: {'originalResGroupData': $scope.totalResGroup},
                    targetEvent: event,
                    fullscreen: false,
                    scope: $scope,
                    openFrom: { top: 1100, height: 0 },
                    closeTo: { left: 1500 }
                }).then(function() {

                });
            };

            function aclResourceGroupListCtrl($scope, $mdDialog,originalResGroupData) {
                $scope.popheading = 'Select Resource Groups to Monitor';
                $scope.rcGrouplenghtText = "ResourceGroup(s)";
                $scope.rcGroupSelected = "";
                $scope.selectedResGroup = '';
                $scope.selectedResGroupObj = [];
                $scope.selectedResGroupObjID = [];
                $scope.totalResGroupData = originalResGroupData;
                //$scope.ResGroupRadioSelected = false;
        
                $scope.toggle = function(item, list) {
                    var idx = list.indexOf(item);
                    if (idx > -1) {
                        list.splice(idx, 1);
                    } else {
                        list.push(item);
                    }
                    $scope.radioResGroupSelected = (list.length > 0)?true:false;
                };

                $scope.exists = function(item, list) {
                    return list.indexOf(item) > -1;
                };

                $scope.canceResGroupDialogue = function() {
                    $mdDialog.cancel();
                };
                $scope.isIndeterminate = function () {
                    if($scope.selectedGroupList && $scope.totalResGroup){
                        return ($scope.selectedGroupList.length !== 0 &&
                            $scope.selectedGroupList.length !== $scope.totalResGroup.length);
                    }
                };
                $scope.isChecked = function () {
                    if($scope.totalResGroup && $scope.selectedGroupList){
                        return $scope.selectedGroupList.length === $scope.totalResGroup.length;    
                    }
                    
                };
                $scope.toggleAll = function () {
                    if ($scope.selectedGroupList.length === $scope.totalResGroup.length) { //uncheck all
                        $scope.selectedGroupList = [];
                        $scope.radioResGroupSelected  = false;
                    } else if ($scope.selectedGroupList.length === 0 || $scope.selectedGroupList.length > 0) {
                        $scope.selectedGroupList = $scope.totalResGroup.slice(0);
                        $scope.radioResGroupSelected  = true; //check all
                    }
                    $scope.no_of_selected_ResGroup = $scope.selectedGroupList.length;
                };
                 $scope.toggleSearchBarRes = function(event) {
                    $scope.isresSearchBarOpen = $scope.isresSearchBarOpen === false ? true : false;
                    if ($scope.isresSearchBarOpen)
                        angular.element(event.currentTarget.firstElementChild).css('color', '#4a90e2');
                    else
                        angular.element(event.currentTarget.firstElementChild).css('color', '#6d6e71');
                 };
                $scope.listResGroupDone = function(value) {
                    $mdDialog.hide();
                      $scope.selectedResGroupObj = [];
                      $scope.selectedResGroupObjID = [];
                    $scope.ResGroupRadioSelected = true;
                    $scope.RemoveExistingData = false;
                    _.each($scope.selectedGroupList , function(val){
                        $scope.selectedResGroupObj.push(val.name); 
                        $scope.selectedResGroupObjID.push(val.id); 
                    });
                    $scope.selectedCopyResList = angular.copy($scope.selectedGroupList);
                   $scope.IsValidForm();
                };

            }
            $scope.callgetListPopUp = function(eve, data) {
                $scope.clickedItemForPopup = data;
                $scope.showMoreAppIds = false;
                $mdDialog.show({
                    skipHide: true,
                    preserveScope: true,
                    controller: aclAppIDToMonitorCtrl,
                    bindToController: true,
                    templateUrl: 'core/directive/acl-table/app-id-list.html',
                    parent: angular.element(document.body),
                    locals: {'appIDDataList': $scope.dataList},
                    targetEvent: eve,
                    fullscreen: false,
                    scope: $scope,
                    openFrom: { top: 1100, height: 0 },
                    closeTo: { left: 1500 }
                }).then(function() {

                });
            };
            
            $scope.callgetprotocolListPopUp = function(eve, data) {
                $scope.clickedItemForPopup = data;
                $mdDialog.show({
                    skipHide: true,
                    preserveScope: true,
                    controller: aclprotocolListCtrl,
                    bindToController: true,
                    templateUrl: 'core/directive/acl-table/protocol-list.html',
                    parent: angular.element(document.body),
                    locals: {'orgProtoColList': $scope.ProtocolList},
                    targetEvent: eve,
                    fullscreen: false,
                    scope: $scope,
                    openFrom: { top: 1100, height: 0 },
                    closeTo: { left: 1500 }
                }).then(function() {

                });
            };

            function aclprotocolListCtrl($scope, $mdDialog,orgProtoColList) {
                $scope.heading = 'L4 Protocols to Monitor';
                $scope.ProtocollenghtText = "Protocol(s)";
                $scope.list_protocol_activated = false;
                //$scope.protocolSelected = false;
                $scope.protocolCopyList = orgProtoColList;
                $scope.onSelectProtocolChanged = function() {
                    $scope.protocolFromPopSelected = true;
                };
                $scope.canceProtocolDialogue = function() {
                    $mdDialog.cancel();
                };
                $scope.listProtocolIdDone = function(value) {
                    $mdDialog.hide();
                    $scope.protocolSelected = true;
                    $scope.protocolSelectedValue = JSON.parse(value);
                    $scope.IsValidForm();
                };
            }

            function aclAppIDToMonitorCtrl($scope, $mdDialog,appIDDataList) {
                $scope.selectedAppIdValue = "";
                //$scope.appIDSelected = false;
                //console.log(appIDDataList);
                $scope.originalAppDataList = appIDDataList;
                $scope.selectedAPPIDObjID = [];
                $scope.heading = 'Select AppID to Monitor';
                $scope.lenghtText = "AppID(s)";
                $scope.APPIDFromPopSelected = false;
                $scope.appIdSelectedValue = {};
                $scope.selectedAppIdValue = '';
                if($scope.selectedAPPIDGroupList.length > 0){
                     $scope.APPIDFromPopSelected = true;
                }
                $scope.toggleAppID = function(item, list) {
                    var idx = list.indexOf(item);
                    if (idx > -1) {
                        list.splice(idx, 1);
                    } else {
                        list.push(item);
                    }
                    $scope.APPIDFromPopSelected = (list.length > 0)?true:false;
                };

                $scope.existsAppid = function(item, list) {
                    return list.indexOf(item) > -1;
                };

                $scope.isIndeterminate = function () {
                    if($scope.selectedAPPIDGroupList && $scope.originalAppDataList){
                        return ($scope.selectedAPPIDGroupList.length !== 0 &&
                            $scope.selectedAPPIDGroupList.length !== $scope.originalAppDataList.length);
                    }
                };
                $scope.isChecked = function () {
                    if($scope.selectedAPPIDGroupList && $scope.originalAppDataList){
                        return $scope.selectedAPPIDGroupList.length === $scope.originalAppDataList.length;    
                    }
                };
                $scope.toggleAll = function () {
                    if ($scope.selectedAPPIDGroupList.length === $scope.originalAppDataList.length) { //uncheck all
                        $scope.selectedAPPIDGroupList = [];
                    } else if ($scope.selectedAPPIDGroupList.length === 0 || $scope.selectedAPPIDGroupList.length > 0) {
                        $scope.selectedAPPIDGroupList = $scope.originalAppDataList.slice(0); //check all
                    }
                    $scope.no_of_selected_APPID = $scope.selectedAPPIDGroupList.length;
                };
                /*$scope.onSelectAPPIDChanged = function() {
                    $scope.APPIDFromPopSelected = true;
                };*/
                $scope.cancellistIdDialogue = function() {
                    $mdDialog.cancel();
                };
                $scope.listIdDone = function(value) {
                    $scope.selectedAPPIDObj = [];
                    $scope.selectedAPPIDObjID = [];
                    $mdDialog.hide();
                    $scope.appIDSelected = true;
                    _.each($scope.selectedAPPIDGroupList , function(val){
                        $scope.selectedAPPIDObj.push(val.name); 
                        $scope.selectedAPPIDObjID.push(val.id); 
                    });
                    $scope.IsValidForm();
                    //$scope.appIdSelectedValue = JSON.parse(value);
                };
            }
            $scope.callToAddNewAclRule = function(event,data,key,mode) {
                $scope.FromExistingPolicy = data;
                $scope.aclPolicyIndexOfEditRow = key;
                $scope.mode = mode;
                $mdDialog.show({
                    skipHide: true,
                    preserveScope: true,
                    controller: newAclPolciyDetailsCtr,
                    bindToController: true,
                    templateUrl: 'core/directive/acl-table/acl-policy.html',
                    parent: angular.element(document.body),
                    targetEvent: event,
                    fullscreen: false,
                    scope: $scope,
                    openFrom: { top: 1100, height: 0 },
                    closeTo: { left: 1500 }
                }).then(function() {

                });
            };
            function serialize(data){
                if(data.start && data.end){
                    return ""+data.start+"-"+data.end;    
                }else if(data.portnumber){
                    return data.portnumber;
                }else if(data.value){
                    return data.value;
                }else{
                    return '';
                }
            }
            function serializeACLRanges(data,key){
               var ret = "";
                var appender = "";
                if(key === 'ranges'){
                    _.remove(data,function(item){
                        return (item.end === '' && item.start === '' && item.portnumber === '');
                    });
                        
                }else{
                     _.remove(data,function(item){
                        return item.value === '' ;
                    }); 
                }
                
                for(var i=0; i < data.length; i++){
                    var range = data[i];
                    //if(range.end !== '' || range.start !== '' || range.portnumber !== ''){
                        if(i===0){
                            appender = "";
                        } else {
                            appender = ",";
                        }
                        ret = ret +appender + serialize(range);
                   // }
                         
                } 
                return ret;
            }
            function deserializeACLcidrs(data){
                var cidrAr = data;
                var cidrs = [];
                if(typeof data === "string"){
                    cidrAr = data.split(",");
                }
                for(var i=0; i < cidrAr.length; i++){
                    cidrs.push({'value':cidrAr[i]});
                }
                return cidrs;
            }
            function deserializeACLRanges(data){
                var sampleObj = {
                    'portnumber': '',
                    'start': '',
                    'end': '',
                    'rangeEndEnableState':true,
                    'PortnumberEnableState':true
                };
                var avalRanges = data;
                var rangesDataAfterDes = [];
                if(typeof data === "string"){
                    avalRanges = data.split(",");
                }
                for(var i=0; i < avalRanges.length; i++){
                    var datobj = angular.copy(sampleObj); 
                    if(avalRanges[i].indexOf('-') > 0){
                        var rangearray = avalRanges[i].split("-");
                        datobj.start = rangearray[0];
                        datobj.end = rangearray[1];
                        datobj.PortnumberEnableState = false;
                        rangesDataAfterDes.push(datobj);
                    }else{
                        datobj.portnumber = avalRanges[i];
                         datobj.rangeEndEnableState = false;
                        rangesDataAfterDes.push(datobj);
                    }
                }
                return rangesDataAfterDes;
            }
            $scope.updateAddRuleToAcl = function() {
                var ruleObj = { "id": 0, "name": "", "description": "", "orderNum": 0, "destinationCidrs": "", "destinationResourceGroupList": [], "destinationProtocol": "TCP", "destinationPortRanges": "", "destinationApps": "", "action": '', "enableTLSInspection": false};
                ruleObj.name = $scope.aclrulename;
                ruleObj.description = $scope.aclruledes;
                var serializedRanges = serializeACLRanges($scope.rangesList,'ranges');
                var serializedCidr = serializeACLRanges($scope.cidrList, 'cidrs');
                ruleObj.destinationPortRanges = serializedRanges;
                ruleObj.enabled = $scope.enableButtonChecked;
                ruleObj.enableTLSInspection=$scope.enableTLSInspection;
                ruleObj.action = $scope.actionValue;
                ruleObj.resourcegroupNames= $scope.selectedResGroupObj;
                //selectedResGroupObj
                if($scope.appIDSelected){
                    ruleObj.destinationApps = $scope.selectedAPPIDObj.toString();  
                   // ruleObj.destinationAppsList =  ruleObj.destinationApps.split(',');  
                }
                if($scope.selectedprotocolCidr === "CIDRs"){
                    ruleObj.destinationCidrs = serializedCidr;
                }
                if($scope.selectedprotocolCidr === "Server Objects"){
                    ruleObj.destinationResourceGroupList = $scope.selectedResGroupObjID;    
                }
                _.each($scope.resGroupTotalList,function(resGp){
                        //if(resGp.)
                });
                
                //ruleObj.destinationProtocol = $scope.protocolSelectedValue.protocolName; /*$scope.protocolSelectedValue.protocolName*/
                if($scope.protocolSelectedValue && $scope.protocolFromPopSelected ){
                    ruleObj.destinationProtocol = $scope.protocolSelectedValue.protocolName;    
                }else{
                    ruleObj.destinationProtocol = null;
                }
                
                //$scope.aclRules.push(ruleObj);
                if ($scope.content === undefined) {
                    $scope.content = [];
                }
                if($scope.aclPolicyIndexOfEditRow !== undefined && $scope.aclPolicyIndexOfEditRow !== '' ){
                    ruleObj.id = $scope.content[$scope.aclPolicyIndexOfEditRow].id;
                    ruleObj.orderNum = $scope.content[$scope.aclPolicyIndexOfEditRow].orderNum;
                    $scope.content[$scope.aclPolicyIndexOfEditRow] = ruleObj;
                }else{
                    _.each($scope.content, function(val, key) {
                       // val.orderNum = key + 1;
                       val.newRule = false;
                    });
                     ruleObj.newRule = true;
                     $scope.content.unshift(ruleObj);
                    _.each($scope.content, function(val, key) {
                        val.orderNum = key + 1;
                    });
                }
                console.log("$scope.rangesList >>>>>>>>>>> 2");
                console.dir($scope.rangesList);
                console.dir($scope.aclRules);
                $scope.$emit('listenAclPolicyData', { data: $scope.content });
                $mdDialog.cancel($scope.aclRules);
            };

            function newAclPolciyDetailsCtr($scope, $mdDialog) {
                console.log("from the new acl Polciy dir");
                $scope.enableButtonChecked = true;
                $scope.enableTLSInspection = false;
                $scope.ResGroupRadioSelected = false;
                $scope.protocolSelected = false;
                $scope.appIDSelected = false;
                $scope.aclrulename = '';
                $scope.aclruledes = '';
                $scope.protocolFromPopSelected = false;
                $scope.selectedAPPIDGroupList = [];
                $scope.selectedGroupList = [];
                $scope.selectedResGroupObj = [];
                $scope.selectedprotocol = "";
                $scope.showMoreResGruops = false;
                $scope.showMoreAppIds = false;
                $scope.rangesAvaliable = false;
                $scope.selectedCopyResList = [];
                if(!$scope.dataList){
                    $scope.list_app_activated = true;    
                }
                $scope.aclnewRForm = [];
                //$scope.dataList = [];
                $scope.actionValue = $scope.actionList[0];
                $scope.radioResGroupSelected = false;
                $scope.selectedprotocolCidr = "Server Objects"; 
                $scope.selectedAppIDProtocol = "AppIDs";   
                $scope.rangesList = [{
                    'portnumber': '',
                    'start': '',
                    'end': '',
                    'rangeEndEnableState':true,
                    'PortnumberEnableState':true
                }];
                $scope.cidrList = [{
                    'value':''
                }];
                $scope.cancelAddRuleDialogue = function() {
                    $mdDialog.hide();
                };
                if($scope.FromExistingPolicy) {
                    $scope.aclnewRForm.$dirty = true;  
                    $scope.selectedAPPIDObj = [];
                    $scope.selectedAPPIDObjID = [];
                    $scope.aclrulename = $scope.FromExistingPolicy.name;
                    $scope.aclruledes = $scope.FromExistingPolicy.description;
                    $scope.enableButtonChecked = $scope.FromExistingPolicy.enabled;
                    $scope.enableTLSInspection=$scope.FromExistingPolicy.enableTLSInspection;
                    $scope.actionValue = $scope.FromExistingPolicy.action;    
                    if($scope.FromExistingPolicy.destinationCidrs){
                        $scope.cidrList = deserializeACLcidrs($scope.FromExistingPolicy.destinationCidrs);
                        $scope.selectedprotocolCidr = 'CIDRs';    
                    }
                    if($scope.FromExistingPolicy.destinationPortRanges){
                        $scope.rangesList= deserializeACLRanges($scope.FromExistingPolicy.destinationPortRanges);    
                        $scope.rangesAvaliable = true;
                    }
                    if($scope.FromExistingPolicy.destinationProtocol){
                        $scope.protocolSelectedValue = {'protocolName':''};
                        $scope.protocolSelectedValue.protocolName = $scope.FromExistingPolicy.destinationProtocol;
                        $scope.selectedprotocol = JSON.stringify($scope.protocolSelectedValue);
                        $scope.protocolSelected = true;
                        $scope.protocolFromPopSelected = true;  
                        $scope.selectedAppIDProtocol   = 'L4 Protocols';
                    }
                    
                    //$scope.enableButtonChecked = $scope.FromExistingPolicy.enabled;
                    //$scope.selectedResGroupObjID
                    if($scope.FromExistingPolicy.destinationResourceGroupList !== undefined && $scope.FromExistingPolicy.destinationResourceGroupList.length > 0){
                       _.each($scope.FromExistingPolicy.destinationResourceGroupList,function(resGp){
                           var resGroup = _.find($scope.totalResGroup,function(singleGp){
                                        return singleGp.id === resGp;
                           });
                           if(resGroup){
                                $scope.selectedResGroupObj.push(resGroup.name); 
                                $scope.selectedGroupList.push(resGroup);
                                $scope.ResGroupRadioSelected = true;
                                $scope.radioResGroupSelected = true;

                           }
                        });
                        $scope.selectedprotocolCidr = 'Server Objects'; 
                        $scope.selectedCopyResList =  angular.copy($scope.selectedGroupList); 
                    }
                    if($scope.FromExistingPolicy.destinationApps && $scope.FromExistingPolicy.destinationApps !== ''){
                        var appIdsFromEdit = $scope.FromExistingPolicy.destinationApps.split(",");
                        _.each(appIdsFromEdit,function(val){
                            var appData = _.find($scope.dataList,function(appId){
                                return appId.name === val;
                            });
                            if(appData){
                                $scope.selectedAPPIDGroupList.push(appData);    
                            }
                        });
                      _.each($scope.selectedAPPIDGroupList , function(val){
                            $scope.selectedAPPIDObj.push(val.name); 
                            $scope.selectedAPPIDObjID.push(val.id); 
                        });
                        $scope.appIDSelected = true;   
                        $scope.selectedAppIDProtocol   = 'AppIDs'; 
                    }
                    
                }
   
            }
        }];
        return directive;
    }

    angular.module('shieldxApp').directive('aclPolicyTable', aclPolicyTableDirective);
})();

(function () {
    angular.module('shieldxApp').directive("fileModel", [ '$parse', function ($parse) {
        return {
            restrict: 'A',
            link: function (scope, element, attrs) {
                var model = $parse(attrs.fileModel);
                var modelSetter = model.assign;

                element.bind('change', function () {
                    scope.$apply(function () {
                        modelSetter(scope, element[0].files[0]);
                    });
                });
            }
        };
    }]);
})();

(function () {
    angular.module('shieldxApp').directive('fixwidthheight', function($window){
  return{
  	restrict: 'A',
    link: function(scope, element, attrs){
    	var fixwidthheight = attrs.fixwidthheight;

      var val =   element[0].offsetHeight;
      console.dir(element);
       console.log(" fixwidthheight  >>> width "+val);
      element.css("height", val + 'px');
    }
  };
});
})();
(function () {
    angular.module('shieldxApp').directive('fixheight', function($window){
  return{
  	restrict: 'A',
    link: function(scope, element, attrs){
    	var fixheight = parseInt(attrs.fixheight);
    	console.log(" fx height >>>>>>>>>>>>>>>>>>>>>>> "+fixheight);
    	console.log(" actual  window height "+$window.innerHeight);
        element.css('height', ($window.innerHeight - fixheight) + 'px');
        //element.height($window.innerHeight/3);
    }
  };
});
})();
/*
 ShieldX Networks Inc. CONFIDENTIAL
 ----------------------------------
 *
 Copyright (c) 2016 ShieldX Networks Inc.
 All Rights Reserved.
 *
 NOTICE: All information contained herein is, and remains
 the property of ShieldX Networks Incorporated and its suppliers,
 if any. The intellectual and technical concepts contained
 herein are proprietary to ShieldX Networks Incorporated
 and its suppliers and may be covered by U.S. and Foreign Patents,
 patents in process, and are protected by trade secret or copyright law.
 Dissemination of this information or reproduction of this material
 is strictly forbidden unless prior written permission is obtained
 from ShieldX Networks Incorporated.
 */

(function () {
    function groupDirective() {
        var directive = {};
        directive.restrict = 'E';
        directive.templateUrl = 'core/directive/group/group.html';
        directive.scope = {
            networkInfo: '=netinfo',
            selectedNetworks: '=selectednetworks',
            selectedWorkloads: '=selectedworkloads',
            secrules: '=',
            toggle: '&onToggle',
            resouregroupassigned: "=",
            workloads : "=",
            networksavailable : "=",
            sandboxgroups : "=",
            activeGroups : "=activegroups",
        };
        directive.controller = ['$scope', function ($scope) {

                $scope.sandboxgroups = [];
                $scope.activeGroups = [];
                $scope.sandboxMode = false;

                $scope.pageObjModel = {};
                
                $scope.pageObjModel.firstPageIndexGroup = 0;
                $scope.pageObjModel.lastPageIndexGroup = 6;
                $scope.pageObjModel.startIndexGroup = 0;
                $scope.pageObjModel.endIndexGroup = 6;
                //$scope.pageObjModel.pageLength = 6; //default
                $scope.pageObjModel.pages = 0;

                $scope.manageZoomPagination = function() {
                    var dataToIterate = "";
                    if($scope.sandboxMode){
                        dataToIterate = $scope.sandboxgroups;
                    } else {
                        dataToIterate = $scope.activegroups;
                    }
                    _.forEach(dataToIterate, function(obj, key){
                        if(key >= $scope.pageObjModel.startIndexGroup && key <= $scope.pageObjModel.endIndexGroup)
                            obj.hideForZoom = false;
                        else
                            obj.hideForZoom = true;
                    });
                    $scope.$emit("pageModelSetGroup", {data : $scope.pageObjModel});
                };
                
                $scope.$watchCollection('networksavailable', function(newCollection,oldCollection){
                    if(newCollection.length){
                        console.log("networksavailable called",newCollection);
                        console.log("ruleSet",$scope.ruleSet);
                        $scope.seggregateGroupsFromRulesByStates($scope.ruleSet);
                    }
                });
                $scope.$watchCollection('sandboxgroups', function(newCollection,oldCollection){
                    
                    console.log(newCollection);
                    $scope.init();
                    _.forEach(newCollection, function(obj, key){
                        obj.hideForZoom = false;
                    });
                });
                $scope.init = function(){
                    var dataToIterate;
                    if($scope.sandboxMode){
                        dataToIterate = $scope.sandboxgroups;
                    } else {
                        dataToIterate = $scope.activeGroups;
                    }
                    if(dataToIterate){
                        var canvasWidth = document.querySelector('network').children[0].clientWidth;
                        if(canvasWidth === 0)
                            canvasWidth = document.querySelector('group').children[0].clientWidth;
                        if(canvasWidth === 0)
                            canvasWidth = document.querySelector('#canvas-load-here').clientWidth;      
                        $scope.pageObjModel.pageLengthGroup = (Math.floor(canvasWidth / 174) <= 0)?7:Math.floor(canvasWidth / 174);
                        //$scope.pageObjModel.pageLengthGroup = Math.floor(canvasWidth / 174);
                        $scope.pageObjModel.lastPageIndexGroup = dataToIterate.length;
                    
                        $scope.$emit("pageModelSetGroup", {data : $scope.pageObjModel});
                    }
                };
                $scope.$watchCollection('activeGroups', function(newCollection,oldCollection){
                    $scope.init();
                    console.log(newCollection);
                    
                    _.forEach(newCollection, function(obj, key){
                        obj.hideForZoom = false;
                    });
                });

                $scope.$on('zoomInCanvasGroup', function(event, args){
                    
                    $scope.showWorkload = true;
                    var dataToIterate = "";
                    if($scope.sandboxMode){
                        dataToIterate = $scope.sandboxgroups;
                    } else {
                        dataToIterate = $scope.activeGroups;
                    }
                    _.forEach(dataToIterate, function(obj, key){
                        if( key >= 0 && key < $scope.pageObjModel.pageLengthGroup )
                            obj.hideForZoom = false;
                        else
                            obj.hideForZoom = true;
                    });
                });
                $scope.$on('zoomOutCanvasGroup', function(event, args){
                    $scope.showWorkload = false;
                    var dataToIterate = "";
                    if($scope.sandboxMode){
                        dataToIterate = $scope.sandboxgroups;
                    } else {
                        dataToIterate = $scope.activeGroups;
                    }
                    _.forEach(dataToIterate, function(obj, key){
                        obj.hideForZoom = false;
                    });
                });
                $scope.$on('gotoFirstPageGroup', function(event, args){
                    console.log('gotoFirstPageGroup');
                    $scope.pageObjModel.startIndexGroup = $scope.pageObjModel.firstPageIndexGroup;
                    $scope.pageObjModel.endIndexGroup = $scope.pageObjModel.firstPageIndexGroup + ($scope.pageObjModel.pageLengthGroup - 1);
                    $scope.manageZoomPagination();
                });
                $scope.$on('gotoLastPageGroup', function(event, args){
                    console.log('gotoLastPageGroup');
                    if($scope.pageObjModel.pageLengthGroup < $scope.pageObjModel.lastPageIndexGroup){
                        $scope.pageObjModel.startIndexGroup = $scope.pageObjModel.lastPageIndexGroup - ($scope.pageObjModel.pageLengthGroup - 1);
                        $scope.pageObjModel.endIndexGroup = $scope.pageObjModel.lastPageIndexGroup;
                    }
                    else{
                        $scope.pageObjModel.startIndexGroup = 0;
                        $scope.pageObjModel.endIndexGroup = 6;
                    }
                    $scope.manageZoomPagination();
                });
                $scope.$on('gotoNextPageGroup', function(event, args){
                    console.log('gotoNextPageGroup');
                    $scope.pageObjModel.startIndexGroup = $scope.pageObjModel.endIndexGroup + 1;
                    $scope.pageObjModel.endIndexGroup = $scope.pageObjModel.startIndexGroup + ($scope.pageObjModel.pageLengthGroup - 1);
                    $scope.manageZoomPagination();
                });
                $scope.$on('gotoPrevPageGroup', function(event, args){
                    console.log('gotoPrevPageGroup');
                    $scope.pageObjModel.endIndexGroup = $scope.pageObjModel.startIndexGroup - 1;
                    $scope.pageObjModel.startIndexGroup = $scope.pageObjModel.endIndexGroup - ($scope.pageObjModel.pageLengthGroup - 1);
                    $scope.manageZoomPagination();
                });

                $scope.$on('sandboxModeToggled', function (event, sandboxMode) {
                    $scope.sandboxMode = sandboxMode;
                });
                
                $scope.ruleSet = [];
                $scope.$on("rulesArrayChanged", function (event, args) {
                    $scope.seggregateGroupsFromRulesByStates(args);
                    $scope.ruleSet = args;
                });

                $scope.seggregateGroupsFromRulesByStates = function (rules) {
                    $scope.sandboxgroups = [];
                    $scope.activeGroups = [];
                    if($scope.networksavailable !== undefined){
                        _.each(rules, function (rule) {
                            console.log(rule.groupInfo);
                            console.log("this is the single rule ",rule);
                            var ruleWorkloads = [];
                            _.each(rule.ruleDesc,function(singleDescription){
                                _.each(singleDescription.networks,function(singleNetwork){
                                    if(singleDescription.ruleAttribute == "0"){
                                        var matchingNetwork = _.find($scope.networksavailable,{'id':singleNetwork.id});
                                        if(matchingNetwork !== undefined){
                                            //ruleWorkloads = (matchingNetwork.workloads);
                                            ruleWorkloads = _.union(ruleWorkloads, matchingNetwork.workloads);
                                        }
                                    } else if(singleDescription.ruleAttribute == "2"){
                                        if(singleNetwork.id && !_.find(ruleWorkloads,{'id':singleNetwork.id})){
                                            var matchingWorkloads = _.find($scope.workloads,{'id':singleNetwork.id});
                                            if(matchingWorkloads)
                                                ruleWorkloads.push(matchingWorkloads);
                                        }
                                    }
                                });
                            });
                            rule.noneSPS = rule.aspInfo.name === "None" ? true : false;
                            $scope.sandboxgroups.push(angular.copy({'groupinfo':rule.groupInfo,'workloadinfo':ruleWorkloads,'noneSPS':rule.noneSPS}));
                            if(rule.id) {
                                $scope.activeGroups.push(angular.copy({'groupinfo':rule.groupInfo,'workloadinfo':ruleWorkloads,'noneSPS':rule.noneSPS}));
                            } 
                        });
//                    console.log($scope.sandboxgroups);
//                    console.log($scope.activeGroups);
                        $scope.$emit("groupCountsChangedInit", {
                           active :  $scope.activeGroups.length,
                           sandbox :  $scope.sandboxgroups.length
                        });
                    }
                };
                $scope.init();
            }];
        return directive;
    }

    angular.module('shieldxApp').directive('group', groupDirective);
})();

/*
ShieldX Networks Inc. CONFIDENTIAL
----------------------------------
*
Copyright (c) 2016 ShieldX Networks Inc.
All Rights Reserved.
*
NOTICE: All information contained herein is, and remains
the property of ShieldX Networks Incorporated and its suppliers,
if any. The intellectual and technical concepts contained
herein are proprietary to ShieldX Networks Incorporated
and its suppliers and may be covered by U.S. and Foreign Patents,
patents in process, and are protected by trade secret or copyright law.
Dissemination of this information or reproduction of this material
is strictly forbidden unless prior written permission is obtained
from ShieldX Networks Incorporated.
*/

(function () {
    function helpcontainerDirective() {
        var directive = {};
        directive.restrict = 'E';
        directive.templateUrl = 'core/directive/help-container/helpcontainer.html';
        directive.scope = {
            helpContentID: '=contentid',
            excessComponent: '=excesscomponent'
        };
        directive.controller = ['$rootScope','$scope','$translate', function ($rootScope, $scope,$translate) {
            
            $scope.languageInUse = $translate.use();
            $scope.helpContentURL = "help/"+$scope.languageInUse+"/"+$scope.helpContentID+".html";
            $scope.isOpen = false;
            console.log("helpcontainerDirective >> "+ $scope.helpContentURL);
            console.log(" languageInUse "+$scope.languageInUse);

            $scope.$on("onHelpButtonClicked",function(event, data){
                 $scope.helpContentID = data.helpIDString;
                 $scope.openHelpPanel();
            });

            $rootScope.$on('$translateChangeSuccess', function () {
                // Language has changed
            });

            $scope.toggleHelpPanel = function(){
                 $scope.isOpen = ! $scope.isOpen;
                 $scope.loadHelpContent();
            };

            $scope.openHelpPanel = function(){
                 $scope.isOpen = false;
                 $scope.loadHelpContent();
            };

            $scope.loadHelpContent = function(){
                 console.log("loadhelp with id"+$scope.helpContentID);
                 $scope.helpContentURL = "help/"+$scope.languageInUse+"/"+$scope.helpContentID+".html";
                 console.log("helpContentURL "+$scope.helpContentURL);
                 console.dir($scope.helpContentID);
            };


            $scope.fixHelpContentHeight = function(){
//              console.log("  fixHelpContent >>>>");  
              return fixHelpContent($scope.excessComponent);
//              return 600;
            };

            

     
        }];
    return directive;
    }
    
    angular.module('shieldxApp').directive('helpcontainer', helpcontainerDirective);
})();

/*
ShieldX Networks Inc. CONFIDENTIAL
----------------------------------
*
Copyright (c) 2016 ShieldX Networks Inc.
All Rights Reserved.
*
NOTICE: All information contained herein is, and remains
the property of ShieldX Networks Incorporated and its suppliers,
if any. The intellectual and technical concepts contained
herein are proprietary to ShieldX Networks Incorporated
and its suppliers and may be covered by U.S. and Foreign Patents,
patents in process, and are protected by trade secret or copyright law.
Dissemination of this information or reproduction of this material
is strictly forbidden unless prior written permission is obtained
from ShieldX Networks Incorporated.
*/

(function () {

    function IPRangeCtr() {
        console.log("Controller initialized");
        this.templatName = 'Quick-Setup-Header';
    }
    angular.module('shieldxApp').component("iprange", {
        templateUrl: '/core/directive/ip-range/ip-range.html', controller: IPRangeCtr, bindings: {
            values: '<'
        }
    });
})();
/*
ShieldX Networks Inc. CONFIDENTIAL
----------------------------------
*
Copyright (c) 2016 ShieldX Networks Inc.
All Rights Reserved.
*
NOTICE: All information contained herein is, and remains
the property of ShieldX Networks Incorporated and its suppliers,
if any. The intellectual and technical concepts contained
herein are proprietary to ShieldX Networks Incorporated
and its suppliers and may be covered by U.S. and Foreign Patents,
patents in process, and are protected by trade secret or copyright law.
Dissemination of this information or reproduction of this material
is strictly forbidden unless prior written permission is obtained
from ShieldX Networks Incorporated.
*/

(function () {
    angular.module('shieldxApp').directive("cidrvalidation", function () {
        return {
            restrict: 'A',
            require: 'ngModel',
            link: function (scope, ele, attrs, ctrl) {

                function validationError(value) // you can use any function and parameter name 
                {
                    console.log(" value " + value);
                    console.log(" netmask " + attrs.netmask);
                    var ipCidrValidator = new IPCidrValidator();
                    if (ipCidrValidator.validateCidr(value)) // if model length is greater then 6 it is valide state
                    {
                        ctrl.$setValidity('invalidcidr', true);
                    } else
                    {


                        ctrl.$setValidity('invalidcidr', false); //if less then 6 is invalide
                    }

                    return value; //return to display  error 
                }
                ctrl.$parsers.push(validationError);
            }
        };
    });
})();
/*
 ShieldX Networks Inc. CONFIDENTIAL
 ----------------------------------
 *
 Copyright (c) 2016 ShieldX Networks Inc.
 All Rights Reserved.
 *
 NOTICE: All information contained herein is, and remains
 the property of ShieldX Networks Incorporated and its suppliers,
 if any. The intellectual and technical concepts contained
 herein are proprietary to ShieldX Networks Incorporated
 and its suppliers and may be covered by U.S. and Foreign Patents,
 patents in process, and are protected by trade secret or copyright law.
 Dissemination of this information or reproduction of this material
 is strictly forbidden unless prior written permission is obtained
 from ShieldX Networks Incorporated.
 */

(function () {
    angular.module('shieldxApp').directive("netmaskvalidation", function () {
        return {
            restrict: 'A',
            require: 'ngModel',
            link: function (scope, ele, attrs, ctrl) {

                function validationError(value) // you can use any function and parameter name 
                {
                    var regEx = /^[0-9]*$/;
                    if (regEx.test(value)) {
                        if (value >= 1 && value <= 32) {
                            ctrl.$setValidity('invalidnetmask', true);
                        } else {
                            ctrl.$setValidity('invalidnetmask', false);
                        }

                    } else {
                        ctrl.$setValidity('invalidnetmask', false);
                    }

                    return value; //return to display  error 
                }
                ctrl.$parsers.push(validationError);
            }
        };
    });
})();
/*
ShieldX Networks Inc. CONFIDENTIAL
----------------------------------
*
Copyright (c) 2016 ShieldX Networks Inc.
All Rights Reserved.
*
NOTICE: All information contained herein is, and remains
the property of ShieldX Networks Incorporated and its suppliers,
if any. The intellectual and technical concepts contained
herein are proprietary to ShieldX Networks Incorporated
and its suppliers and may be covered by U.S. and Foreign Patents,
patents in process, and are protected by trade secret or copyright law.
Dissemination of this information or reproduction of this material
is strictly forbidden unless prior written permission is obtained
from ShieldX Networks Incorporated.
*/

(function () {
    function networkDirective() {
        var directive = {};
        directive.restrict = 'E';
        directive.templateUrl = 'core/directive/network/network.html';
        directive.scope = {
            networkInfo: '=netinfo',
            selectedNetworks: '=selectednetworks',
            selectedWorkloads: '=selectedworkloads',
            secrules: '=',
            allNetworksFetched: '=allNetworksFetched',
            groupednet:'=',
            toggle: '&onToggle'
        };
        directive.controller = ['$scope', function ($scope) {
//                console.log("****************$scope.networkInfo***********");
//                console.log($scope.selectedNetworks);
//                console.log("****************$scope.networkInfo***********");
                $scope.sandboxedNetworks = [];
                $scope.showWorkload = false;
                
                $scope.pageObjModel = {};
                
                $scope.pageObjModel.firstPageIndex = 0;
                $scope.pageObjModel.lastPageIndex = 6;
                $scope.pageObjModel.startIndex = 0;
                $scope.pageObjModel.endIndex = 6;
                //$scope.pageObjModel.pageLength = 6; //default
                $scope.pageObjModel.pages = 0;

                $scope.manageZoomPagination = function() {
                    _.forEach($scope.networkInfo, function(obj, key){
                        if(key >= $scope.pageObjModel.startIndex && key <= $scope.pageObjModel.endIndex)
                            obj.hideForZoom = false;
                        else
                            obj.hideForZoom = true;
                    });
                    $scope.$emit("pageModelSet", {data : $scope.pageObjModel});
                };
                
                $scope.$watchCollection('networkInfo', function(newCollection,oldCollection){
                    
                    console.log(newCollection);

                    var canvasWidth = document.querySelector('network').children[0].clientWidth;
                    if(canvasWidth === 0)
                            canvasWidth = document.querySelector('#canvas-load-here').clientWidth;
                    $scope.pageObjModel.pageLength = (Math.floor(canvasWidth / 174) <= 0)?7:Math.floor(canvasWidth / 174);
                    $scope.pageObjModel.lastPageIndex = newCollection.length - 1;
                    if(newCollection.length < 5)
                        $scope.pageObjModel.endIndex = newCollection.length;
                    else
                        $scope.pageObjModel.endIndex = 6;
                    $scope.$emit("pageModelSet", {data : $scope.pageObjModel});

                    if($scope.showWorkload)
                        $scope.$emit('zoomInCanvas');
                    else
                        $scope.$emit('zoomInOut');
                });

                _.each($scope.secrules, function (rule) {

                    var groupName = rule.groupInfo;
                    _.each(rule.ruleDesc, function (ruleDesc) {
                        _.each(ruleDesc.networks, function (network) {
                            if (!_.find($scope.sandboxedNetworks, {"id": network.id})) {
                                network.ruleId = rule.id;
                                network.groupName = groupName.name;
                                $scope.sandboxedNetworks.push(network);
                            }
                        });
                    });
                });

                _.each($scope.networkInfo, function (value, key) {
                    var sanboxObj = _.find($scope.sandboxedNetworks, {"id": value.id});
                    if (sanboxObj) {
                        $scope.networkInfo[key].ruleId = sanboxObj.ruleId;
                        $scope.networkInfo[key].resourceGroupName = sanboxObj.groupName;
                    }
                });
                $scope.getStrokeColor = function(network,workload){
                    if(workload === undefined){
                        if($scope.sandboxMode){
                            if(network.resourceGroupName){
                                if(!network.noneSPS)
                                    return '#13ce66';
                                else
                                    return '#ffc030';
                            }
                            else{
                                return '#ff4949';
                            }
                        } else {
                            if(network.resourceGroupId){
                                if(!network.noneSPS)
                                    return '#13ce66';
                                else
                                    return '#ffc030';
                            }
                            else{
                                return '#ff4949';
                            }
                        }
                    } else {
                        if($scope.sandboxMode){
                            if(network.resourceGroupName || workload.resourceGroupName){
                               /*if(!network.noneSPS )
                                    return '#13ce66';
                                else*/ if(workload.noneSPS || network.noneSPS)
                                    return '#ffc030';
                                else
                                    return '#13ce66';
                            }
                            else{
                                return '#ff4949';
                            }
                        } else {
                            if(network.resourceGroupId || workload.resourceGroupId){
                                /*if(!network.noneSPS )
                                    return '#13ce66';
                                else*/ if(workload.noneSPS || network.noneSPS)
                                    return '#ffc030';
                                else
                                    return '#13ce66';
                            }
                            else{
                                return '#ff4949';
                            }
                        }
                    }
                };
                $scope.existsNetwork = function (networkvalue) {
                    if ($scope.selectedNetworks) {
                        return $scope.selectedNetworks.indexOf(networkvalue) > -1;
                    }
                    return false;
                };

                $scope.existsWorkload = function (wlvalue) {
                    if ($scope.selectedWorkloads) {
                        return $scope.selectedWorkloads.indexOf(wlvalue) > -1;
                    }
                    return false;
                };
                $scope.getPercentage = function(network){
                    var totalWorkloads = network.workloads;
                    var securedWorkloads = 0;
                    if(totalWorkloads){
                        for (var i = network.workloads.length - 1; i >= 0; i--) {
                            if(network.workloads[i].resourceGroupName)
                                securedWorkloads++;
                        }
                        return (securedWorkloads*360)/totalWorkloads;
                    }
                    return 0;
                };
                $scope.getVMcountText = function(allWorkloads){
                    var visibleWorkloads = 0;
                    for(var i = (allWorkloads.length - 1);i>=0;i--){
                        if(!allWorkloads[i].faded)
                            visibleWorkloads++;
                    }
                    if(visibleWorkloads < 1000)
                        return visibleWorkloads;
                    else
                        return Math.floor(visibleWorkloads/1000) + "k";
                };
                $scope.toggleAllNetworks = function(typeOfSelection){
                    $scope.selectedNetworks = [];
                    if(typeOfSelection === 1){
                        _.each($scope.networkInfo,function(availableNetwork){
                            if(!availableNetwork.faded && !availableNetwork.hideForZoom)
                                $scope.selectedNetworks.push(availableNetwork);
                        });
                    }
                    $scope.$emit('toggleAllNetworks',{typeOfSelection:typeOfSelection});
                };
                $scope.$on('addWorkload',function(event,args){
                    _.each(args.networks,function(networkChosen){
                        var currentNetwork = _.find($scope.networkInfo,{'id':networkChosen.id});
                        $scope.selectAllWorkloads(currentNetwork);        
                    });
                });
                $scope.selectAllWorkloads = function(network){
                    _.each(network.workloads,function(singleWorkload){
                            var alreadyPresentWorkload = _.findIndex($scope.selectedWorkloads,{'id':singleWorkload.id});
                            if(alreadyPresentWorkload === -1)
                                $scope.selectedWorkloads.push(singleWorkload);
                        });
                        $scope.$emit('selectAllWorkloadStart',{'selectedworkloads':$scope.selectedWorkloads});
                };
                $scope.sandboxMode = false;
                $scope.$on('sandboxModeToggled', function (event, sandboxMode) {
                    $scope.sandboxMode = sandboxMode;
                });
                function polarToCartesian(centerX, centerY, radius, angleInDegrees) {
                  var angleInRadians = (angleInDegrees-90) * Math.PI / 180.0;

                  return {
                    x: centerX + (radius * Math.cos(angleInRadians)),
                    y: centerY + (radius * Math.sin(angleInRadians))
                  };
                }

                $scope.describeArc = function(x, y, radius, startAngle, endAngle){

                    var start = polarToCartesian(x, y, radius, endAngle);
                    var end = polarToCartesian(x, y, radius, startAngle);

                    var largeArcFlag = endAngle - startAngle <= 180 ? "0" : "1";

                    var d = [
                        "M", start.x, start.y, 
                        "A", radius, radius, 0, largeArcFlag, 0, end.x, end.y
                    ].join(" ");

                    return d;       
                };

                $scope.$on('zoomInCanvas', function(event, args){
                    
                    $scope.showWorkload = true;
                    _.forEach($scope.networkInfo, function(obj, key){
                        if( key >= 0 && key < $scope.pageObjModel.pageLength )
                            obj.hideForZoom = false;
                        else
                            obj.hideForZoom = true;
                    });
                });
                $scope.$on('zoomOutCanvas', function(event, args){
                    $scope.showWorkload = false; 
                    _.forEach($scope.networkInfo, function(obj, key){
                        obj.hideForZoom = false;
                    });
                });
                $scope.$on('gotoFirstPage', function(event, args){
                    console.log('gotoFirstPage');
                    $scope.pageObjModel.startIndex = $scope.pageObjModel.firstPageIndex;
                    $scope.pageObjModel.endIndex = $scope.pageObjModel.firstPageIndex + ($scope.pageObjModel.pageLength - 1);
                    $scope.manageZoomPagination();
                });
                $scope.$on('gotoLastPage', function(event, args){
                    console.log('gotoLastPage');
                    $scope.pageObjModel.endIndex = $scope.pageObjModel.lastPageIndex;
                    if($scope.pageObjModel.lastPageIndex > $scope.pageObjModel.pageLength)
                        $scope.pageObjModel.startIndex = $scope.pageObjModel.lastPageIndex - ($scope.pageObjModel.pageLength - 1);
                    $scope.manageZoomPagination();
                });
                $scope.$on('gotoNextPage', function(event, args){
                    console.log('gotoNextPage');
                    $scope.pageObjModel.startIndex = $scope.pageObjModel.endIndex + 1;
                    $scope.pageObjModel.endIndex = $scope.pageObjModel.startIndex + ($scope.pageObjModel.pageLength - 1);
                    $scope.manageZoomPagination();
                });
                $scope.$on('gotoPrevPage', function(event, args){
                    console.log('gotoPrevPage');
                    $scope.pageObjModel.endIndex = $scope.pageObjModel.startIndex - 1;
                    $scope.pageObjModel.startIndex = $scope.pageObjModel.endIndex - ($scope.pageObjModel.pageLength - 1);
                    $scope.manageZoomPagination();
                });
                
                $scope.showObjectDetails = function (items) {
                    $scope.$emit("showObjectDetailClicked", {data: items});
                };
            }];
        return directive;
    }

    angular.module('shieldxApp').directive('network', networkDirective);
})();

/*
ShieldX Networks Inc. CONFIDENTIAL
----------------------------------
*
Copyright (c) 2016 ShieldX Networks Inc.
All Rights Reserved.
*
NOTICE: All information contained herein is, and remains
the property of ShieldX Networks Incorporated and its suppliers,
if any. The intellectual and technical concepts contained
herein are proprietary to ShieldX Networks Incorporated
and its suppliers and may be covered by U.S. and Foreign Patents,
patents in process, and are protected by trade secret or copyright law.
Dissemination of this information or reproduction of this material
is strictly forbidden unless prior written permission is obtained
from ShieldX Networks Incorporated.
*/

(function() {
    function policyTableDirective() {
        var directive = {};
        directive.restrict = 'E';
        directive.templateUrl = 'core/directive/policy-table/policy-table.html';
        directive.scope = {
            content: '=content'

        };
        directive.controller = ['$rootScope', '$scope', '$translate', '$mdDialog','userSessionMenagment', function($rootScope, $scope, $translate,$mdDialog,userSessionMenagment) {

            //$scope.thresholdVlaues = [{"action":"HIGH"},{"action":"MODERATE"},{"action":"LOW"},{"action":"CLEAN"}];
            $scope.selectedcheckBox = false;
            $scope.brand = false;
            $scope.policiesList = [];
            $scope.languageInUse = $translate.use();
            $scope.blockingThreshold = '';
            //$scope.saveUpdateNewPolicy = false;
            var update_id = authorities("policy_update");
            $scope.is_update_policy = userSessionMenagment.isUserAllowd(update_id);
            $scope.updatedMalwarePolicyRow = function(data, event) {
                if (data.blockingThreshold !== "" && data.alertingThreshold !== "" && data.blackListingThreshold !== "") {
                    $scope.$emit("saveUpdateNewPolicy", {data:data});
                }
            };
            $scope.infoRegardingFileType = function(event,fileType,data){
                 $mdDialog.show({
                        skipHide: true,
                        preserveScope: true,
                        controller: infoListCtr,
                        bindToController: true,
                        templateUrl: 'core/directive/policy-table/info.html',
                        parent: angular.element(document.body),
                        targetEvent: event,
                        fullscreen: false,
                        scope: $scope,
                        openFrom: { top: 1100, height: 0 },
                        closeTo: { left: 1500 }
                    }).then(function() {

                    });
            };
            function infoListCtr($scope, $mdDialog){
                 $scope.cancelTypeInfoDialogue = function() {
                        $mdDialog.cancel();
                };
            }
        }];
        return directive;
    }

    angular.module('shieldxApp').directive('policytable', policyTableDirective);
})();

/*
ShieldX Networks Inc. CONFIDENTIAL
----------------------------------
*
Copyright (c) 2016 ShieldX Networks Inc.
All Rights Reserved.
*
NOTICE: All information contained herein is, and remains
the property of ShieldX Networks Incorporated and its suppliers,
if any. The intellectual and technical concepts contained
herein are proprietary to ShieldX Networks Incorporated
and its suppliers and may be covered by U.S. and Foreign Patents,
patents in process, and are protected by trade secret or copyright law.
Dissemination of this information or reproduction of this material
is strictly forbidden unless prior written permission is obtained
from ShieldX Networks Incorporated.
*/

(function () {

    function searchkDirective() {
        var directive = {};

        directive.controller = ['$scope', function ($scope) {
                function init() {
                    $scope.originalList = angular.copy($scope.datalist);
                    $scope.items = mapItems();
                    $scope.customTooltip = $scope.searchconfig.customTooltip ? $scope.searchconfig.customTooltip : "Search";
                }

                var onDataChanged = function(data){
                    $scope.datalist = data;
                    init();
                }; 

                if($scope.methodbridge){
                    $scope.methodbridge.registerBridge(onDataChanged);
                }
                function getLowerCase(val) {
                    if (!val)
                        return null;
                    if (typeof val === "string")
                        return val.toLowerCase();
                    if (typeof val === "number")
                        return val.toString().toLowerCase();
                }
                function mapItems() {
                    if (!$scope.datalist)
                        return [];
                    var itemsMapped = angular.copy($scope.datalist);
                    return itemsMapped.map(function (i) {
                        if (!i)
                            return i;
                        /*if($scope.searchconfig.searchkeylocale === "^" ){
                         i._lowername = i.label.toLowerCase();
                         i._searchname = i.label;
                         return i;
                         }*/
                        var locale = $scope.searchconfig.searchkeylocale.split(".");
                        locale.shift();
                        var tempObj = i;
                        while (locale.length > 0) {
                            if (tempObj.hasOwnProperty(locale[0])) {
                                tempObj = tempObj[locale[0]];
                                locale.shift();
                            }
                        }
                        i._lowername = getLowerCase(tempObj[$scope.searchconfig.key]); //tempObj[$scope.searchconfig.key].toLowerCase();
                        i._searchname = tempObj[$scope.searchconfig.key];
                        return i;
                    });
                }
                init();
                //$scope.items = mapItems();
                $scope.selectedItemsList = [];
                $scope.selectedItem = null;
                $scope.searchText = [];
                $scope.querySearch = querySearch;
                $scope.transformChip = transformChip;
                $scope.autocompleteRequireMatch = false;

                console.log(" prefix value "+$scope.boxprfix);
                console.log(" searchconfig value "+$scope.searchconfig);
               
                $scope.boxprfix  = "";

                if($scope.searchconfig.serchboxprifix){
                  $scope.boxprfix = $scope.searchconfig.serchboxprifix;   
                } 
               console.dir($scope.boxprfix);
               /// $scope.boxprfix = "abc";
                if ($scope.showicon)
                    $scope.isSearchFieldOpen = false;
                else
                    $scope.isSearchFieldOpen = true;

                $scope.$watchCollection('datalist', function () {
                    if ($scope.originalList === undefined || !$scope.originalList.length)
                        init();
                });

                $scope.filterGrid = function () {
                    var tempArray = [];
                    var arrayHold = [];
                    var partialSearchList = [];
                    var searchTextList = [];
                    if ($scope.selectedItemsList.length) {
                        for (var selItems in $scope.selectedItemsList) {
                            searchTextList.push($scope.selectedItemsList[selItems].name);
                            if ($scope.selectedItemsList[selItems].hasOwnProperty('chiptype')) {
                                if ($scope.selectedItemsList[selItems].chiptype.match(/new/ig)) {
                                    var testStr = $scope.selectedItemsList[selItems].name;
                                    var exp = new RegExp(testStr, 'ig');
                                    console.log('Run partial string search');
                                    for (var i = 0; i < $scope.items.length; ++i) {
                                            if ($scope.items[i]._lowername && $scope.items[i]._lowername.match(exp)) {
                                                partialSearchList.push($scope.items[i]);
                                            }
                                    }
                                }
                                console.log('partial match list', partialSearchList);
                                arrayHold = _.concat(arrayHold, partialSearchList);
                            } else {
                                tempArray = _.filter($scope.items, ['_lowername', $scope.selectedItemsList[selItems]._lowername]);
                                arrayHold = _.concat(arrayHold, tempArray);
                                console.log('full match list', tempArray);
                            }
                            console.log('Array Hold', arrayHold);
                        }
                        //console.log(_.unionBy(arrayHold, '_lowername'));
                        $scope.datalist = _.uniqWith(arrayHold, _.isEqual);
                    } else { //when there are no search chips
                        console.log('restore grid list');
                        $scope.datalist = angular.copy($scope.originalList);
                    }
                    $scope.datalist = _.union(partialSearchList, $scope.datalist);
                    $scope.searchText = searchTextList;
                    _.each($scope.datalist, function(data) {
                        data.type = "NETWORK";
                    });
                    var arg = {'op':"searched",'searchText':searchTextList,selectedEntities:$scope.datalist};
                    $scope.$emit('onNetworkSelectionChanged', arg);
                    $scope.$emit('onChipItemCreated', $scope.selectedItemsList);

                };
                $scope.$on("actionMadeOnChip",function(eve,data){
                    //$scope.searchText = data.data;
                    $scope.selectedItemsList = data.data;
                    $scope.filterGrid();
                });

                /* Return the proper object when the append is called. */
                function transformChip(chip) {
                    // If it is an object, it's already a known chip
                    if (angular.isObject(chip)) {
                        return chip;
                    }
                    // Otherwise, create a new one
                    $scope.searchText.push(chip);
                    return {name: chip, chiptype: 'new'};
                }

                function querySearch(query) {
                    var results = query ? $scope.items.filter(createFilterFor(query)) : [];
                    var data = _.uniqBy(results, '_lowername');
                    return data;
                }

                function createFilterFor(query) {
                    var lowercaseQuery = angular.lowercase(query);
                    return function filterFn(itemX) {
                        if (itemX._lowername !== null) {
                            return  itemX._lowername.indexOf(lowercaseQuery) >=  0;  // || (itemX._lowertype.indexOf(lowercaseQuery) === 0
                        }
                    };
                }

                $scope.toggleSearchFieldView = function () {
                    $scope.isSearchFieldOpen = $scope.isSearchFieldOpen === false ? true : false;
                    setTimeout(function () {
                        document.querySelector("#search-box"+$scope.boxprfix).focus();
                    }, 0);
                };

            }];
        directive.scope = {
            datalist: '=',
            searchconfig: '=',
            showicon: '=',
            hidechips:'=',
            methodbridge:'='
        };
        directive.restrict = 'EA';
        directive.templateUrl = 'core/directive/search/search.html';
        return directive;
    }

    angular.module('shieldxApp').directive('search', searchkDirective);
})();
/*
 ShieldX Networks Inc. CONFIDENTIAL
 ----------------------------------
 *
 Copyright (c) 2016 ShieldX Networks Inc.
 All Rights Reserved.
 *
 NOTICE: All information contained herein is, and remains
 the property of ShieldX Networks Incorporated and its suppliers,
 if any. The intellectual and technical concepts contained
 herein are proprietary to ShieldX Networks Incorporated
 and its suppliers and may be covered by U.S. and Foreign Patents,
 patents in process, and are protected by trade secret or copyright law.
 Dissemination of this information or reproduction of this material
 is strictly forbidden unless prior written permission is obtained
 from ShieldX Networks Incorporated.
 */

(function () {
    function securityOrchestrationCanvasDirective(
            ipPoolServices,
            virtualChassisService,
            policyService,
            deploymentSpecificationService
            ) {
        var directive = {};
        directive.restrict = 'E';
        directive.replace = true;
        directive.templateUrl = 'core/directive/security-orchestration/security-orchestration-canvas-template.html';
        directive.scope = {
            networkInfo: '=netinfo',
            allNetworksFetched: '=allNetworksFetched',
            selectedNetworks: '=selectednetworks',
            selectedWorkloads: '=selectedworkloads',
            networkFetched: '=networkfetched',
            toggle: '&onToggle',
            secrules: '=',
            networkselectionchanged: '&',
            broadcastevent: '&',
            virtualchassisdata:'=',
            resouregroupassigned:'=',
            networksavailable:'=',
            workloads:'='
            
        };
        directive.controller = ['$scope', function ($scope) {

                $scope.canvasLevel = 0;
                $scope.canvasLevelGroup = 0;
                $scope.networkTab = true;
                $scope.visibleNetworks = [];
                $scope.$on('toggleAllNetworks',function(event,args){
                    $scope.toggleNetworkAll(args.typeOfSelection);
                });
                $scope.$on('selectAllWorkloadStart',function(event,args){
                    $scope.selectWorkloadAll(args.selectedworkloads);
                });
                $scope.$on('addWorkload',function(event,args){
                   _.each(args.networks,function(singleNetwork){
                        var mathchedNetwork = _.find($scope.networkInfo,{'id':singleNetwork.id});
                        $scope.toggleNetwork(mathchedNetwork,'NETWORK');
                   });
                });
                $scope.toggleNetworkAll = function(typeOfSelection){
                    if (!$scope.sandboxMode) {
                        $scope.$emit('sandboxModeToggleInit', true);
                    }
                    $scope.selectedEntities = [];
                    if(typeOfSelection === 1){
                        _.each($scope.networkInfo,function(availableNetwork){
                            if(!availableNetwork.faded && !availableNetwork.hideForZoom){
                                availableNetwork.type = SORule.ruleAttribute.NETWORK.link;
                                $scope.selectedEntities.push(availableNetwork);
                            }
                        });
                    }
                    $scope.broadcastevent({event: 'onEntitySelectionChanged', args: {op: "selected", selectedEntities: $scope.selectedEntities}});
                };
                $scope.selectWorkloadAll = function(workloadArray){
                    $scope.selectedEntities = [];
                    if (!$scope.sandboxMode) {
                        $scope.$emit('sandboxModeToggleInit', true);
                    }
                    _.each($scope.selectedNetworks, function(network) {
                        network.type = SORule.ruleAttribute.NETWORK.link;
                        $scope.selectedEntities.push(network);
                    });
                    _.each(workloadArray, function(workload) {
                        workload.type = SORule.ruleAttribute.WORKLOAD.link;
                        $scope.selectedEntities.push(workload);
                        var alreadyadded = _.findIndex($scope.selectedWorkloads,{'id':workload.id,'name':workload.name});
                        if(alreadyadded === -1){
                            $scope.selectedWorkloads.push(workload);
                        }
                    });
                    $scope.broadcastevent({event: 'onEntitySelectionChanged', args: {op: "selected", selectedEntities: $scope.selectedEntities}});
                };
                $scope.toggleNetwork = function (val, type) {
                    var networkval = val;
                    var entityType = type;
                    $scope.selectedEntities = [];
                    if (!$scope.sandboxMode) {
                        $scope.$emit('sandboxModeToggleInit', true);
                    }
                    var idx = null;
                    if (entityType === SORule.ruleAttribute.NETWORK.link) { 
                        console.log(" toggleNetwork ", val);
                        $scope.removeEntity = '';
                        if ($scope.selectedNetworks) {
                            idx = _.findIndex($scope.selectedNetworks,{'id':networkval.id});
                            if (idx > -1) {
//                            networkval.resourceGroupName = null;
                                $scope.selectedNetworks.splice(idx, 1);
                                $scope.removeEntity = networkval;
                            } else {
//                            networkval.resourceGroupName = "grouped";
                                $scope.selectedNetworks.push(networkval);
                            }
//                            $scope.broadcastevent({event: 'onNetworkSelectionChanged', args: {op: "selected", selectedNetworks: $scope.selectedNetworks, removeNetork: $scope.removeNetWork}});
                        }
                    } else if (entityType === SORule.ruleAttribute.WORKLOAD.link) {
                        console.log(" toggleNetwork ", val);
                        $scope.removeEntity = '';
                        if ($scope.selectedWorkloads) {
                            idx = _.findIndex($scope.selectedWorkloads,{'id':networkval.id});
                            if (idx > -1) {
//                            networkval.resourceGroupName = null;
                                $scope.selectedWorkloads.splice(idx, 1);
                                $scope.removeEntityType = networkval;
                                $scope.removeEntity = networkval;
                            } else {
//                            networkval.resourceGroupName = "grouped";
                                $scope.selectedWorkloads.push(networkval);
                            }
//                            $scope.broadcastevent({event: 'onWorkLoadSelectionChanged', args: {op: "selected", selectedWorkloads: $scope.selectedWorkloads, removeWorkload: $scope.removeWorkload}});
                        }
                    }
                    _.each($scope.selectedNetworks, function(network) {
                        network.type = SORule.ruleAttribute.NETWORK.link;
                        $scope.selectedEntities.push(network);
                    });
                    _.each($scope.selectedWorkloads, function(workload) {
                        workload.type = SORule.ruleAttribute.WORKLOAD.link;
                        $scope.selectedEntities.push(workload);
                    });
                    $scope.broadcastevent({event: 'onEntitySelectionChanged', args: {op: "selected", selectedEntities: $scope.selectedEntities, removeEntity: $scope.removeEntity}});
                };

                $scope.secuerMode = "grouped";

//newRuleCreationCanceledEvent
//this event should be called when rule creation process is cancled by user and in argument send instance of SORule type

                $scope.$on(SOEvents.newRuleCreationCanceledEvent, function (event, args) {
                    if (typeof args.rule !== "undefined" && typeof args.rule.ruleDesc !== "undefined" && args.rule.ruleDesc !== []) {
                        $scope.selectedEntities = [];//release all the selected entities
                        $scope.selectedWorkloads = [];//release all the selected entities
                        $scope.selectedNetworks = [];//release all the selected entities
                        //updateNetworks("cancel", args.rule.ruleDesc);
                        updateNetworks("cancel", args.rule);
                    }
                });
//ruleDeletedEvent
//this event should be called when rule description got deleted and in argument send instance of SORule type  
//
                $scope.$on(SOEvents.ruleDeletedEvent, function (event, args) {
                    if(args.ruleref.groupInfo.id === -1 && args.ruleref.deleted){
                      var ind = _.findIndex($scope.secrules, function(rule){
                        return  rule.name === args.ruleref.name;
                      });
                      var tempRule = $scope.secrules[ind];
                      $scope.secrules.splice(ind, 1);
                      /*_.each($scope.secrules,function(singleRule){
                        if(singleRule.precedence > tempRule.precedence){
                            singleRule.precedence--;
                            singleRule.dirty = true;
                        }
                      });*/
                     
                    }
                    if (typeof args.ruleref.ruleDesc !== "undefined" && args.ruleref.ruleDesc !== []) {
                        //updateNetworks("delete", args.ruleref.ruleDesc,args.rule.groupInfo.name,undefined,args.rule.aspInfo.name);
                        updateNetworks("delete", args.ruleref);
                    }

                });


//ruleDescDeletedEvent
//this event should be called when rule description got deleted and in argument send instance of SORule type  
//
                $scope.$on(SOEvents.ruleDescDeletedEvent, function (event, args) {
                    if (typeof args !== "undefined" && args.ruleDescRef !== []) {
                        //updateNetworks("delete", [args.ruleDescRef],null);
                        var ruleObj = new SORule();
                        ruleObj.addSORuleDesc(args.ruleDescRef);
                        updateNetworks("delete", ruleObj,null);
                    }

                });

//ruleEditCanceledEvent
//this event should be called when edit rule  process is cancled by user and in argument send instance of SORule type

                $scope.$on(SOEvents.ruleEditCanceledEvent, function (event, args) {
                    if (typeof args.rule.ruleDesc !== "undefined" && args.rule.ruleDesc !== []) {
                        //updateNetworks("cancel", args.rule.ruleDesc, args.rule.groupInfo.name);
                        updateNetworks("cancel", args.rule);
                    }
                });
                $scope.$on("onTotalDeleteStateChange",function(event,args){
                    if(args.rule.resourceType === "NETWORK"){
                        if (typeof args.rule.ruleDesc !== "undefined" && args.rule.ruleDesc !== []) {
                            //updateNetworks("delete", args.rule.ruleDesc, args.rule.groupInfo.name);
                            updateNetworks("delete", args.rule);
                        }
                    } else {
                        if (typeof args.rule.ruleDesc !== "undefined" && args.rule.ruleDesc !== []) {
                            //updateWorkloads("delete", args.rule.ruleDesc, args.rule.groupInfo.name);
                            updateWorkloads("delete", args.rule);
                        }
                    }
                });

//ruleCreatedEvent
//this event should be called when rule description got created and in argument send instance of SORule type

                $scope.$on(SOEvents.ruleCreatedEvent, function (event, args) {
                    if(args.type === "WORKLOAD"){
                       if (typeof args.rule.ruleDesc !== "undefined" && args.rule.ruleDesc !== []) {
                            //updateWorkloads("add", args.rule.ruleDesc, args.rule.groupInfo.name,undefined,args.rule.aspInfo.name);
                            updateWorkloads("add", args.rule);
                       }
                   } else {
                        if (typeof args.rule.ruleDesc !== "undefined" && args.rule.ruleDesc !== []) {
                            //updateNetworks("add", args.rule.ruleDesc, args.rule.groupInfo.name,undefined,args.rule.aspInfo.name);
                            updateNetworks("add", args.rule);
                       }
                   }
                   /*$scope.broadcastevent({event: 'refereshNetworks'});*/
                });

//ruleUpdatedEvent
//this event should be called when rule is updated by user and in argument send instance of SORule type

                $scope.$on(SOEvents.ruleUpdatedEvent, function (event, args) {
                    $scope.$emit('existingruleupdated',args);
                    console.log("<<< event update canvas on ruleCreatedEvent event >>> ");
                    if(args.type === "WORKLOAD"){                        
                        if (typeof args.rule.ruleDesc !== "undefined" && args.rule.ruleDesc !== []) {
                            //updateWorkloads("add", args.rule.ruleDesc, args.rule.groupInfo.name,undefined,args.rule.aspInfo.name);
                            updateWorkloads("add", args.rule);
                        }

                    } else {
                        if (typeof args.rule.ruleDesc !== "undefined" && args.rule.ruleDesc !== []) {
                            //updateNetworks("add", args.rule.ruleDesc, args.rule.groupInfo.name,undefined,args.rule.aspInfo.name);
                            updateNetworks("add", args.rule);
                        }
                    }
                });
                
                $scope.$on("deleteOldNetworks",function(event,args){
                    if(args.type === "WORKLOAD"){
                        if (typeof args.rule.ruleDesc !== "undefined" && args.rule.ruleDesc !== []) {
                            //updateWorkloads("delete", args.rule.ruleDesc,args.rule.groupInfo.name,undefined,args.rule.aspInfo.name);
                            updateWorkloads("delete", args.rule);
                        }
                    }
                    else{
                       if (typeof args.rule.ruleDesc !== "undefined" && args.rule.ruleDesc !== []) {
                            //updateNetworks("delete", args.rule.ruleDesc,args.rule.groupInfo.name,undefined,args.rule.aspInfo.name);
                            updateNetworks("delete", args.rule);
                        }
                    } 
                });  
                

//ruleCommitedEvent
//this event should be called when rule description got send to server and in argument send instance of SORule type

                $scope.$on(SOEvents.ruleCommitedEvent, function (event, args) {
                    console.log("<<< event update canvas on ruleCreatedEvent event >>> ");
                    if (typeof args.rule.ruleDesc !== "undefined" && args.rule.ruleDesc !== []) {
                        if(args.rule.resourceType === "NETWORK"){
                            //updateNetworks(args.op, args.rule.ruleDesc, args.rule.groupInfo.name);
                            updateNetworks(args.op, args.rule);
                        } else if(args.rule.resourceType === "VM"){
                            updateWorkloads(args.op, args.rule);
                        }
                    }
                    $scope.broadcastevent({event: 'refereshNetworks'});
                });

                $scope.$on("ClearSelections",function(event,args){
                    $scope.selectedEntities = [];//release all the selected entities
                    $scope.selectedWorkloads = [];//release all the selected entities
                    $scope.selectedNetworks = [];//release all the selected entities
                });
                updateNetworks = function (updateType, rule,propogateInfoChange) {
                    var networkToUpdate =  [];
                    var spsName = rule.aspInfo.name;
                    var noneSPS = (spsName === "None" ) ? true : false;
                    var ruleObj = rule.ruleDesc;
                    var groupName = rule.groupInfo.name;
                    var ruleId = rule.id;
                    _.each(ruleObj, function (rule) {
                        _.each(rule.networks, function (network) {

                            var selectedNetworkToUpdate = _.find($scope.selectedNetworks, {'id': network.id});
                            var networkInfoToUpdate = _.find($scope.networksavailable, {'id': network.id});
                            var selectedIdx = $scope.selectedNetworks.indexOf(selectedNetworkToUpdate);
//                            var networkInfoIdx = $scope.networkInfo.indexOf(networkToUpdate);

                            switch (updateType) {
                                case "add" :
                                    console.log("addruleObj");
                                    if(typeof networkInfoToUpdate !== "undefined") {
                                        networkInfoToUpdate.resourceGroupName = groupName;
                                        networkInfoToUpdate.resourceGroupId = ruleId;
                                    }
                                    if(typeof selectedNetworkToUpdate !== "undefined") {
                                        selectedNetworkToUpdate.resourceGroupName = groupName;
                                        selectedNetworkToUpdate.resourceGroupId = ruleId;
                                    }
                                     networkToUpdate.push({net:network,op:"add",grName:groupName,resourceGroupId:networkInfoToUpdate.resourceGroupId});
                                    break;
                                case "delete" :
                                    console.log("deleteruleObj");
                                    if(typeof networkInfoToUpdate !== "undefined") {
                                        networkInfoToUpdate.resourceGroupName = null;
                                        /*networkInfoToUpdate.resourceGroupId = null;
                                        networkInfoToUpdate.ruleId = null;*/
                                        
                                    }
                                   if((typeof $scope.selectedNetworks !== "undefined") &&  (typeof selectedNetworkToUpdate !== "undefined") ) {
                                        selectedNetworkToUpdate.resourceGroupName = null;
                                        $scope.selectedNetworks.splice(selectedIdx, 1);
                                    }
                                     networkToUpdate.push({net:network,op:"delete",grName:""});
                                    break;
                                case "deletePermanent" :
                                    console.log("deleteruleObj");
                                    if(typeof networkInfoToUpdate !== "undefined") {
                                        networkInfoToUpdate.resourceGroupName = null;
                                        networkInfoToUpdate.resourceGroupId = null;
                                        networkInfoToUpdate.ruleId = null;
                                        
                                    }
                                   if((typeof $scope.selectedNetworks !== "undefined") &&  (typeof selectedNetworkToUpdate !== "undefined") ) {
                                        selectedNetworkToUpdate.resourceGroupName = null;
                                        $scope.selectedNetworks.splice(selectedIdx, 1);
                                    }
                                     networkToUpdate.push({net:network,op:"delete",grName:""});
                                    break;
                                case "cancel" :
                                    $scope.selectedNetworks.splice(selectedIdx, 1);
                                    break;
                                default:

                            }
                        });
                    });
                    if(typeof propogateInfoChange === "undefined")
                        $scope.broadcastevent({event: 'networkInfoChanged', args:{networkInfo:$scope.networksavailable , networkToUpdateVal:networkToUpdate,noneSPS:noneSPS} });
                    console.log($scope.networksavailable);
                };

                updateWorkloads = function (updateType, rule,propogateInfoChange){
                    var ruleObj = rule.ruleDesc;
                    var groupName = rule.groupInfo.name;
                    var spsName = rule.aspInfo.name;
                    var ruleId = rule.id;
                    var workloadsToUpdate =  [];
                    var noneSPS = (spsName === "None" ) ? true : false;
                    _.each(ruleObj, function (rule) {
                        _.each(rule.networks, function (workload) {
                            //the object is of type network but is actually a workload,hence to avoid confusion named as workload
                            /*var selectedNetworkToUpdate = _.find($scope.selectedNetworks, {'id': network.id});*/
                            var workloadmatched = _.find($scope.workloads, {'id': workload.id});
                            var networkOfWorkload,workloadIndex,workloadInfoToUpdate;
                            if(workloadmatched){
                                networkOfWorkload = _.find($scope.networksavailable,{"id":workloadmatched.ports[0].networkId});
                                if(networkOfWorkload)
                                    workloadIndex = _.findIndex(networkOfWorkload.workloads,{"id":workload.id});
                                if(workloadIndex !== undefined)
                                    workloadInfoToUpdate = networkOfWorkload.workloads[workloadIndex];
                            }
                            /*var selectedIdx = $scope.selectedNetworks.indexOf(selectedNetworkToUpdate);*/
//                            var networkInfoIdx = $scope.networkInfo.indexOf(networkToUpdate);

                            switch (updateType) {
                                case "add" :
                                    console.log("addruleObj");
                                    if(typeof workloadInfoToUpdate !== "undefined") {
                                        workloadInfoToUpdate.resourceGroupName = groupName;
                                        workloadInfoToUpdate.resourceGroupId = ruleId;
                                    }
                                    /*if(typeof selectedNetworkToUpdate !== "undefined") {
                                        selectedNetworkToUpdate.resourceGroupName = groupName;
                                    }*/
                                     workloadsToUpdate.push({net:workload,op:"add",grName:groupName,resourceGroupId:workloadInfoToUpdate.resourceGroupId});
                                    break;
                                case "delete" :
                                    console.log("deleteruleObj");
                                    if(typeof workloadInfoToUpdate !== "undefined") {
                                        workloadInfoToUpdate.resourceGroupName = null;
                                        /*networkInfoToUpdate.resourceGroupId = null;
                                        networkInfoToUpdate.ruleId = null;*/
                                        
                                    }
                                   /*if((typeof $scope.selectedNetworks !== "undefined") &&  (typeof selectedNetworkToUpdate !== "undefined") ) {
                                        selectedNetworkToUpdate.resourceGroupName = null;
                                        $scope.selectedNetworks.splice(selectedIdx, 1);
                                    }*/
                                     workloadsToUpdate.push({net:workload,op:"delete",grName:""});
                                    break;
                                case "deletePermanent" :
                                    console.log("deleteruleObj");
                                    if(typeof workloadInfoToUpdate !== "undefined") {
                                        workloadInfoToUpdate.resourceGroupName = null;
                                        workloadInfoToUpdate.resourceGroupId = null;
                                        workloadInfoToUpdate.ruleId = null;
                                        
                                    }
                                   /*if((typeof $scope.selectedNetworks !== "undefined") &&  (typeof selectedNetworkToUpdate !== "undefined") ) {
                                        selectedNetworkToUpdate.resourceGroupName = null;
                                        $scope.selectedNetworks.splice(selectedIdx, 1);
                                    }*/
                                     workloadsToUpdate.push({net:workload,op:"delete",grName:"",resourceGroupId:workloadInfoToUpdate.resourceGroupId});
                                    break;
                                case "cancel" :
                                    //$scope.selectedNetworks.splice(selectedIdx, 1);
                                    break;
                                default:

                            }
                        });
                    });
                    if(typeof propogateInfoChange === "undefined")
                        $scope.broadcastevent({event: 'networkInfoChanged', args:{networkInfo:$scope.networksavailable , workloadsToUpdateVal:workloadsToUpdate,noneSPS:noneSPS} });
                    console.log($scope.networksavailable);
                };
                $scope.$on("showNetworks", function (event, args) {
                    $scope.secuerMode = args;
                     $scope.zoomOut();
                });
                $scope.$on(SOEvents.networkChangedEvent,function(event,args){
                    if($scope.canvasLevel === 1){
                        $scope.canvasLevel = 0;
                        $scope.zoomIn();
                    }
                });
                $scope.groupedNetworks = [];
                $scope.$on(SOEvents.showNetoworksBelongToRuleEvent, function (event, args) {
                    console.log("<<< event update canvas on showNetoworksBelongToRuleEvent event >>> ");
                    console.dir(args);
                    console.log("after firing event canvas update start");
                    console.log(args);
                    //$scope.networkInfo[0].faded = true;
                    console.log($scope.networkInfo);
                    if(args.action == "add"){
                        var itemToinsert = {};
                        var workloadCounter = 0;
                        itemToinsert.groupInfo = angular.copy(args.groups.groupInfo);
                        var networksData = [];
                        _.each(args.groups.ruleDesc,function(singleDesc){
                            if(singleDesc.ruleAttribute == "0"){
                                _.each(singleDesc.networks,function(singleNetwork){
                                    var alreadyPresent = _.findIndex(networksData,{'id':singleNetwork.id});
                                    if(alreadyPresent === -1){
                                        var mathchedNetwork = _.find($scope.networkInfo,{'id':singleNetwork.id});
                                        if(mathchedNetwork){
                                            workloadCounter += mathchedNetwork.workloads.length;
                                            networksData.push(angular.copy(mathchedNetwork));
                                        }
                                    }
                                });
                            }
                        });
                        itemToinsert.networks = networksData;
                        itemToinsert.totalWorkloads = workloadCounter;
                        $scope.groupedNetworks.push(itemToinsert);
                    } else {
                        var indexToremove = _.findIndex($scope.groupedNetworks,{'groupInfo':args.groups.groupInfo});
                        $scope.groupedNetworks.splice(indexToremove,1);
                    }
                    /*_.each(args.groups, function (singleGroup) {
                        _.each(singleGroup.networks, function (singleNetwork) {
                            if(args.action == "add")
                                $scope.visibleNetworks.push(singleNetwork.id);
                            else if(args.action == "remove")
                                $scope.visibleNetworks.splice($scope.visibleNetworks.indexOf(singleNetwork.id),1);
                        });
                    });
                    for (var i = 0; i < $scope.networkInfo.length; i++) {
                        if($scope.visibleNetworks.length){
                            if ($scope.visibleNetworks.indexOf($scope.networkInfo[i].id) !== -1)
                                $scope.networkInfo[i].faded = false;
                            else
                                $scope.networkInfo[i].faded = true;
                        } else {
                            $scope.networkInfo[i].faded = false;
                        }
                    }*/

                });

                $scope.sandboxMode = false;
                
                $scope.$on('sandboxModeToggled', function (event, sandboxMode) {
                    $scope.sandboxMode = sandboxMode;
                });
                
                $scope.zoomIn = function (event) {
                    if ($scope.canvasLevel < 1) {
                        $scope.$broadcast('zoomInCanvas', {});
                        return ++$scope.canvasLevel;
                    }
                };
                $scope.$on('nofilterZoomoutStart',function(event,args){
                    $scope.zoomOut();    
                    $scope.zoomOutGroup();    
                });
                $scope.zoomOut = function (event) {
                    if ($scope.canvasLevel > 0) {
                        $scope.$broadcast('zoomOutCanvas', {});
                        return --$scope.canvasLevel;
                    }
                };
                $scope.zoomInGroup = function (event) {
                    if ($scope.canvasLevelGroup < 1) {
                        $scope.$broadcast('zoomInCanvasGroup', {});
                        return ++$scope.canvasLevelGroup;
                    }
                };

                $scope.zoomOutGroup = function (event) {
                    if ($scope.canvasLevelGroup > 0) {
                        $scope.$broadcast('zoomOutCanvasGroup', {});
                        return --$scope.canvasLevelGroup;
                    }
                };

                $scope.gotoFirstPage = function(event) {
                    $scope.$broadcast('gotoFirstPage', {});
                };

                $scope.gotoLastPage = function(event) {
                    $scope.$broadcast('gotoLastPage', {});  
                };

                $scope.gotoNextPage = function (event) {
                    if($scope.pageModel.currentEndNetworkIndex < $scope.pageModel.totalNetworks) {
                        $scope.$broadcast('gotoNextPage', {});    
                    }
                };

                $scope.gotoPrevPage = function (event) {
                    if($scope.pageModel.currentStartNetworkIndex >= $scope.pageModel.pageLength) {
                        $scope.$broadcast('gotoPrevPage', {});    
                    }
                };
                
                $scope.gotoFirstPageGroup = function(event) {
                    $scope.$broadcast('gotoFirstPageGroup', {});
                };

                $scope.gotoLastPageGroup = function(event) {
                    $scope.$broadcast('gotoLastPageGroup', {});  
                };

                $scope.gotoNextPageGroup = function (event) {
                    if($scope.pageModelGroup.currentEndGroupIndex < $scope.pageModelGroup.totalGroups) {
                        $scope.$broadcast('gotoNextPageGroup', {});    
                    }
                };

                $scope.gotoPrevPageGroup = function (event) {
                    if($scope.pageModelGroup.currentStartGroupIndex >= $scope.pageModelGroup.pageLengthGroup) {
                        $scope.$broadcast('gotoPrevPageGroup', {});    
                    }
                };

                $scope.pageModel = {};
                $scope.pageModel.currentPage = 0;
                $scope.pageModel.endIndex = 0;
                $scope.pageModel.pageLength = 0;

                $scope.pageModelGroup = {};
                $scope.pageModel.currentPageGroup = 0;
                $scope.pageModel.endIndexGroup = 0;
                $scope.pageModel.pageLengthGroup = 0;
                
                $scope.$on("pageModelSet", function(event, args) {
                    $scope.pageModel = angular.copy(args.data);
                    $scope.pageModel.currentPageIndex = Math.ceil(($scope.pageModel.endIndex + 1)/$scope.pageModel.pageLength);
                    $scope.pageModel.currentStartNetworkIndex = $scope.pageModel.startIndex + 1;
                    $scope.pageModel.currentEndNetworkIndex = $scope.pageModel.endIndex + 1;
                    $scope.pageModel.totalNetworks = $scope.networkInfo.length;
                });

                $scope.$on("pageModelSetGroup", function(event, args) {
                    $scope.pageModelGroup = angular.copy(args.data);
                    $scope.pageModelGroup.currentPageIndexGroup = Math.floor(($scope.pageModelGroup.endIndexGroup + 1)/$scope.pageModelGroup.pageLengthGroup);
                    $scope.pageModelGroup.currentStartGroupIndex = $scope.pageModelGroup.startIndexGroup + 1;
                    $scope.pageModelGroup.currentEndGroupIndex = $scope.pageModelGroup.endIndexGroup + 1;
                    if($scope.sandboxMode)
                        $scope.pageModelGroup.totalGroups = $scope.sandboxgroups.length;
                    else
                        $scope.pageModelGroup.totalGroups = $scope.activegroups.length;

                    console.log("this is the final data ",$scope.pageModelGroup);
                });
                
                $scope.$on("toggleNetworkData", function(event, args) {
                    $scope.toggleNetwork(args.val, args.type);
                });
                
                $scope.$on("gotoNetworkTab", function (event, args) {
                    $scope.networkTab = true;
                });

                $scope.$on("gotoGroupTab", function (event, args) {
                    $scope.networkTab = false;
                });

            }];
        return directive;
    }

    angular.module('shieldxApp').directive('securityorchestrationcanvas', securityOrchestrationCanvasDirective);
})();

/*
 ShieldX Networks Inc. CONFIDENTIAL
 ----------------------------------
 *
 Copyright (c) 2016 ShieldX Networks Inc.
 All Rights Reserved.
 *
 NOTICE: All information contained herein is, and remains
 the property of ShieldX Networks Incorporated and its suppliers,
 if any. The intellectual and technical concepts contained
 herein are proprietary to ShieldX Networks Incorporated
 and its suppliers and may be covered by U.S. and Foreign Patents,
 patents in process, and are protected by trade secret or copyright law.
 Dissemination of this information or reproduction of this material
 is strictly forbidden unless prior written permission is obtained
 from ShieldX Networks Incorporated.
 */

(function () {
    function securityOrchestrationDirective() {
        var directive = {};
        directive.restrict = 'E';
        directive.replace = true;
        directive.templateUrl = 'core/directive/security-orchestration/security-orchestration-template.html';
        directive.scope = {
            rules: '=',
            cloudid: "=",
            configinfo : "=",
            vchassisid : "=",
            networksavailable : "=",
            resourcegroups : "=",
            backplanenetworkid : "=",
            managmentnetworkid : "=",
            existinggroups : "=",
            virtualchassisdata: "=",
            vcname : "=",
            dsobj : "="
        };

        directive.link = function(scope, element, attrs) {
            scope.$watch('cloudid', function(newValue, oldValue) {
                if (newValue){
                   scope.initOSDirective();
                }
            }, true);
        };

        directive.controller = ['$scope', 'coreservices',
            'virtualChassisService',
            '$mdDialog',
            'deploymentSpecificationService', 'ipPoolServices',
            function ($scope, coreservices,
                    virtualChassisService,
                    $mdDialog,
                    deploymentSpecificationService, ipPoolServices) {
                $scope.$broadcast('cloudChanged', {cloudid: $scope.cloudid});
                $scope.tenantid = -1;
                $scope.maximize = false;
                $scope.workloads = [];
                $scope.attributesFound = [];
//                 console.log($scope.vchassisid);
                $scope.resouregroupassigned = (typeof $scope.virtualchassisdata !== "undefined" && typeof $scope.virtualchassisdata.resourceGroup !== "undefined") ? $scope.virtualchassisdata.resourceGroup : [];

    
                $scope.tenantIdChanged = function (tenantRef) {
                    $scope.activeTenant = tenantRef;
                    $scope.tenantid = tenantRef.id;
                    $scope.$broadcast('tenatChanged', {tenant: tenantRef});
                };
                $scope.$on('nofilterZoomout',function(event,args){
                    $scope.$broadcast('nofilterZoomoutStart');
                });
                $scope.broadcastSOREvents = function (nameOfEvent, arg) {
                    console.log(" event to process "+nameOfEvent);
                    if(nameOfEvent === SOEvents.ruleAllCommitedEvent){
                         $scope.$emit(nameOfEvent, arg);
                    }
                    $scope.$broadcast(nameOfEvent, arg);
                };
                $scope.$on('addWorkloadsofNetworks',function(event,args){
                    $scope.$broadcast('addWorkload',args);
                   
               });

               $scope.initOSDirective= function(){
                console.log("initOSDirective called");
                $scope.networkInfo = [];
                deploymentSpecificationService.getTenants($scope.cloudid).then(function (data) {
                    $scope.tenants = data;
                    console.log($scope.dsobj);
                    if ($scope.tenants && $scope.tenants.length > 0) {
                        if(typeof $scope.dsobj === "undefined") {
                            $scope.dstenant = $scope.tenants[0];
                        } else {
                            $scope.dstenant = _.find($scope.tenants, {'id': $scope.dsobj.tenantId});
                            if (typeof $scope.dstenant === "undefined") {
                                $scope.dstenant = $scope.tenants[0];
                            }
                        }
                       $scope.tenantIdChanged($scope.dstenant);
                       
                    }
                    getNetworks(true, $scope.dstenant.id);
                    console.log("initOSDirective called end");
                });   
               }; 
               
               $scope.$on("reloadNetworksByTenant", function (event, args) {
                   // get all SO rules  which are not committed
                   // delete resourcegroups associated with SO rules
                   //getNetworks(true, args.tenantId);
               });

               $scope.deleteRulesNotUnderTenantId = function (tenantId) {
                   
               };
               
               /*if($scope.cloudid){
                   $scope.initOSDirective();
               }*/
               
                /*getWorkloadByNetwork = function (workloadData, networkId) {
                    return _.filter(workloadData.workloads, function (workload) {
                        if (workload.ports.length) {
                            return (workload.ports[0].networkId == networkId);
                        }
                    });
                };*/

                getNetworks = function (omitNetworksUsed, tenantId) {
                    //
                    ipPoolServices.getWorkloadsByCloudId($scope.cloudid).then(function (workloadData) {   
                        console.log("recevied workloads");                
                        virtualChassisService.getAllNetworksMappedToResource({success: function (data) {
                            console.log("recevied mapping success ");
                                $scope.networks = virtualChassisService.getAdditionalNetworkInfo(
                                        data,
                                        $scope.backplanenetworkid,
                                        $scope.managmentnetworkid
                                        );
                                /*if (typeof $scope.networks !== "undefined") {
                                        for (var i = 0; i < $scope.networks.length; i++) {
                                            $scope.networks[i].workloads = [];
                                            $scope.networks[i].workloads = getWorkloadByNetwork(workloadData, $scope.networks[i].id);
                                        }
                                    }*/
                                    $scope.networkInfo = $scope.networks;
                                    $scope.allNetworksFetched = true;
                                    if ($scope.networkInfo.length === 0){
                                        $scope.allNetworksFetched = false;
                                    }
                                    $scope.workloads = workloadData.workloads;
                                    $scope.attributesFound = workloadData.attributesFound;
                                    $scope.networksCopy = angular.copy($scope.networks);
                                    console.log("these are the rules that are already present here ",$scope.rules);
                                    $scope.$broadcast("totalWorkLoads", {"masterData":$scope.workloads,"totalList":$scope.networkInfo});
                                    setTimeout(function () {
                                        $scope.showUnGrouped("upgrouped"); //setting view to ungrouped 
                                    }, 0);
                                /*ipPoolServices.getWorkloadsByCloudId($scope.cloudid).then(function (workloadData) {

                                    if (typeof $scope.networks !== "undefined") {
                                        for (var i = 0; i < $scope.networks.length; i++) {
                                            $scope.networks[i].workloads = [];
                                            $scope.networks[i].workloads = getWorkloadByNetwork(workloadData, $scope.networks[i].id);
                                        }
                                    }
                                    $scope.networkInfo = $scope.networks;
                                    $scope.workloads = workloadData.workloads;
                                    $scope.attributesFound = workloadData.attributesFound;
                                    $scope.networksCopy = angular.copy($scope.networks);
                                    console.log("these are the rules that are already present here ",$scope.rules);
                                    $scope.$broadcast("totalWorkLoads", {"masterData":$scope.workloads,"totalList":$scope.networkInfo});
                                    setTimeout(function () {
                                        $scope.showUnGrouped("upgrouped"); //setting view to ungrouped 
                                    }, 0);
                                });*/

                               
              
                            }, fail: function (error) {
                                console.log(" virtualChassisService.getAllNetworkInformations error " + error);
                            }},
                                $scope.cloudid,
                                angular.copy($scope.networksavailable),
                                $scope.resourcegroups,
                                omitNetworksUsed,
                                angular.copy($scope.existinggroups), 
                                $scope.vchassisid,
                                tenantId,
                                workloadData);
                    });
                };


                $scope.showAll = function (data) {
                    var tempList = angular.copy($scope.masterList);
                    $scope.viewall = 'active-link';
                    $scope.viewselected = false;
                    $scope.selectAllDisabled = true;
                    $scope.networkInfo = angular.copy(tempList);
                    $scope.recalcNetworkInfo(data);

                };

                $scope.showGrouped = function (data) {
                    var tempList = angular.copy($scope.masterList);
                    $scope.networkInfo = [];
                    $scope.selectAllDisabled = false;
                    _.forEach(tempList, function (obj) {
                           $scope.networkInfo.push(obj);
                    });
                    if ($scope.networkInfo.length === 0) {
                        $scope.selectAllDisabled = true;
                    }
                    $scope.recalcNetworkInfo(data);
                };
                $scope.showUnGrouped = function (data) {
                    //console.log($scope.masterList);
                    var tempList = angular.copy($scope.masterList);
                    $scope.selectedNetworks = [];
                    $scope.networkInfo = [];
                    $scope.selectAllDisabled = false;
                    _.forEach(tempList, function (obj) {
                        /*if (obj.resourceGroupName === null || obj.resourceGroupName === "") {
                            $scope.networkInfo.push(obj);
                        }*/
                        if (obj.resourceGroupId === null || obj.resourceGroupId === "") {
                            $scope.networkInfo.push(obj);
                        }                        
                    });
                    if ($scope.networkInfo.length === 0) {
                        $scope.selectAllDisabled = true;
                    }
                    $scope.networkFetched = true;
                    $scope.recalcNetworkInfo(data);

               };


                $scope.disableAllSelection = function (flag) {
                    _.each($scope.networkInfo, function (obj) {
                        obj.disabled = flag;
                    });
                };

                reCalcNetworks = function () {
                    $scope.networkInfo = virtualChassisService.getAdditionalNetworkResourceGroupInfo(
                            $scope.networks,
                            $scope.resourcegroups
                            );
                    _.remove($scope.networkInfo, function (item) {
                        return item.hide === true;
                    });
                    $scope.networkInfo = virtualChassisService.getAdditionalNetworkResourceGroupInfo(
                            $scope.activeTenant.networks,
                            $scope.resourcegroups
                            );
                    $scope.$emit('listChanged', {});
                };
                $scope.showSelected = function () {
                    $scope.viewall = false;
                    $scope.viewselected = 'active-link';
                    $scope.networkInfo = $scope.selectedNetworks;
                };

                $scope.$on('resourceGroupSelected', function (event, data) {
                for (var i = 0; i < $scope.networkInfo.length; i++) {
                        if ($scope.networkInfo[i].resourceGroupName === data.selRG.name)
                            $scope.networkInfo[i].faded = false;
                        else
                            $scope.networkInfo[i].faded = true;
                    }
                });

                $scope.$on('filteredNetworks',function(event,args){
                    /*$scope.networks = args.networks;
                    $scope.networkInfo = args.networks;*/
                    console.log("last copy of networks ",$scope.networksCopy);
                    /*for (var i = 0; i < $scope.networkInfo.length; i++) {
                        $scope.networkInfo[i].faded = true;
                        var matchedIndex =  _.findIndex(args.networks,{"id":$scope.networkInfo[i].id}) ;
                        if(matchedIndex !== -1){
                            $scope.networkInfo[i].faded = false;
                        }
                        for (var j = 0; j < $scope.networkInfo[i].workloads.length; j++) {
                            $scope.networkInfo[i].workloads[j].faded = true;
                            if(matchedIndex !== -1 && _.find(args.networks[matchedIndex].workloads,{"id":$scope.networkInfo[i].workloads[j].id}) ){
                                $scope.networkInfo[i].workloads[j].faded = false;
                            }
                        }
                    }*/
                    $scope.networkInfo = [];
                    for (var i = 0; i < $scope.networksCopy.length; i++) {
                        var matchedIndex =  _.findIndex(args.networks,{"id":$scope.networksCopy[i].id}) ;
                        if(matchedIndex !== -1){
                            $scope.networkInfo.push(angular.copy($scope.networksCopy[i]));
                            $scope.networkInfo[$scope.networkInfo.length - 1].workloads = [];
                        }
                        for (var j = 0; j < $scope.networksCopy[i].workloads.length; j++) {
                            if(matchedIndex !== -1 && _.find(args.networks[matchedIndex].workloads,{"id":$scope.networksCopy[i].workloads[j].id}) ){
                                $scope.networkInfo[$scope.networkInfo.length - 1].workloads.push($scope.networksCopy[i].workloads[j]);
                            }
                        }
                    }
                });
                $scope.isIndeterminate = function () {
                    return ($scope.selectedNetworks.length !== 0 &&
                            $scope.selectedNetworks.length !== $scope.networkInfo.length);
                };
                $scope.isChecked = function () {
                    return $scope.selectedNetworks.length === $scope.networkInfo.length;
                };
                $scope.toggleAll = function () {
                    if ($scope.selectedNetworks.length === $scope.networkInfo.length) { //uncheck all
                        $scope.selectedNetworks = [];
                    } else if ($scope.selectedNetworks.length === 0 || $scope.selectedNetworks.length > 0) {
                        $scope.selectedNetworks = $scope.networkInfo.slice(0); //check all
                    }
                    $scope.checkCommit();
                    $scope.$broadcast('onNetworkSelectionChanged', {selectedNetworks: $scope.selectedNetworks});
                };

                $scope.$on('newruleaddedworkload',function(event,args){
                    console.log(args);
                    $scope.calculateRuleForWorkload(args.rule);
                });
                $scope.calculateRuleForWorkload = function(rule){
                    // if(typeof $scope.networkInfo === "undefined")
                    //     $scope.networkInfo = angular.copy($scope.activeTenant.networks);
                    _.each(rule.ruleDesc, function (singleRuleDesc) {
                        _.each(singleRuleDesc.networks, function (network) {
                            _.each($scope.networkInfo,function(singleNetwork){
                                var matchedWorkload = _.find(singleNetwork.workloads,{"id":network.id});
                                if(typeof matchedWorkload !== "undefined"){
                                    matchedWorkload.ruleId = rule.id;
                                    matchedWorkload.resourceGroupName = rule.groupInfo.name;
                                    console.log($scope.masterList);
                                }
                            });
                        });
                    });
                };
                $scope.calculateRuleForNetwork = function () {
                    /* jshint ignore:start */
                    for (var j = 0; j < $scope.masterList.length; j++) {
                        _.each($scope.rules, function (rule) {
                            _.each(rule.ruleDesc, function (singleRuleDesc) {
                                _.each(singleRuleDesc.networks, function (network) {
                                    if ($scope.masterList[j].id === network.id) {
                                        $scope.masterList[j].ruleId = angular.copy(rule.id);
                                    }
                                });
                            });
                        });
                    }
                    /* jshint ignore:end */
                };

                $scope.updateMasterList = function () {
                    $scope.groupedElemsCount = 0;
                    $scope.unGroupedElemsCount = 0;
                    for (var i = 0; i < $scope.networkInfo.length; i++) {
                        for (var j = 0; j < $scope.masterList.length; j++) {
                            if ($scope.masterList[j].id === $scope.networkInfo[i].id) {
                                $scope.masterList[j].resourceGroupId = angular.copy($scope.networkInfo[i].resourceGroupId);
                                $scope.masterList[j].resourceGroupName = angular.copy($scope.networkInfo[i].resourceGroupName);
                            }
                        }
                    }
                    $scope.calculateRuleForNetwork();
                    //update variables
                    for (var k = 0; k < $scope.masterList.length; k++) {
                        if ($scope.masterList[k].resourceGroupName)
                            ++$scope.groupedElemsCount;
                        else
                            ++$scope.unGroupedElemsCount;
                    }
                };
                $scope.$on('listChanged', function () { 
                    $scope.updateMasterList();
                });


                

                $scope.$watch('networkInfo', function (newVal) {
                  if (!$scope.init && typeof newVal !== "undefined" && newVal.length > 0) {
                        $scope.originalNetworkList = angular.copy(newVal);
                        for (i = 0; i < $scope.tenants.length; i++) {
                            $scope.tenants[i].networks = $scope.networks;
                        }

                        $scope.masterList = angular.copy($scope.activeTenant.networks);
                        $scope.updateMasterList();
                        $scope.init = true;
                        for (var i = 0; i < $scope.networkInfo.length; i++) {
                            newVal[i].faded = false;
                        }
                    }
                });

                $scope.showTentantPopup = function (ev) {
//            console.dir($scope.tenants);
                    $mdDialog.show({
                        controller: 'tenantDialogBoxCtr', templateUrl: 'core/components/screenComponents/networkView/tenantDialogBox.html', parent: angular.element(document.body), skipHide: true, targetEvent: ev, clickOutsideToClose: true,
                        locals: {
                            tenants: $scope.tenants,
                            selectedTenatnID: $scope.activeTenant.id,
                        }
                    }).then(function (answerVal) {
                        $scope.networkFetched = false;
                        var tenantSelected = $scope.getTenantNameFromID(parseInt(answerVal.selectedVal));
                        $scope.activeTenant = tenantSelected;
                        $scope.selectedNetworks = [];
                        $scope.$broadcast('tenantChanged', {tenant: $scope.activeTenant});
                        $scope.masterList = angular.copy($scope.activeTenant.networks);
                        $scope.updateMasterList();

                        setTimeout(function () {
                            $scope.showUnGrouped("upgrouped"); //setting view to ungrouped 
                            $scope.networkFetched = true;
                        }, 0);

                    }, function () {
                        $scope.status = 'You cancelled the dialog.';
                    });
                };

                $scope.networkFetched = false;

                $scope.selectedNetworks = [];
                $scope.selectedWorkloads = [];

                $scope.$on('newGroupCreated', function (event, data) {
                    if (typeof $scope.resourcegroups === "undefined") {
                        $scope.resourcegroups = [];
                    }
                    $scope.resourcegroups.push(data.newRG);
                    $scope.checkCommit();
                    $scope.selectedNetworks = [];
                    reCalcNetworks();
                    setTimeout(function () {
                        $scope.showUnGrouped("upgrouped"); //setting view to ungrouped 
                    }, 0);
                });

                $scope.$on('existingGroupModified', function (event, data) {
                    var rtRG = _.find($scope.resourcegroups,
                            function (resourceGrp) {
                                return resourceGrp.name === data.exRG.name;
                            });
                    rtRG.memberList = data.exRG.memberList;
                    $scope.selectedNetworks = [];
                    reCalcNetworks();
                    setTimeout(function () {
                        $scope.showGrouped(); //setting view to ungrouped 
                    }, 0);
                });


                $scope.$on('groupDeleted', function (event, data) {
                    _.remove($scope.resourcegroups,
                            function (resourceGrp) {
                                return resourceGrp.name === data.delRG.name;
                            });
                    $scope.checkCommit();
                    reCalcNetworks();
                });

                
                $scope.$on('networkInfoChanged', function (event, data) {
                    $scope.networkInfo = data.networkInfo;
                    $scope.updateMasterList();
/* jshint ignore:start *///logic to check for workload or network based data
                    if(data.networkToUpdateVal){
                        if(data.networkToUpdateVal.length > 0){
                            for(var i =0; i < data.networkToUpdateVal.length; i++){
                                var mn = _.find($scope.masterList, function(net){
                                    return data.networkToUpdateVal[i].net.id === net.id;
                                });

                                if(mn){
                                  mn.resourceGroupId = data.networkToUpdateVal[i].resourceGroupId;
                                  mn.resourceGroupName = data.networkToUpdateVal[i].grName;
                                  mn.noneSPS = data.noneSPS;
                                }
                            }
                        }
                    }

                    if(data.workloadsToUpdateVal){
                        if(data.workloadsToUpdateVal.length > 0){
                            for(var i =0; i < data.workloadsToUpdateVal.length; i++){
                                var workloadmatched = _.find($scope.workloads, {'id': data.workloadsToUpdateVal[i].net.id});
                                var networkOfWorkload,workloadIndex,mn;
                                if(workloadmatched){
                                    networkOfWorkload = _.find($scope.masterList,{"id":workloadmatched.ports[0].networkId});
                                    if(networkOfWorkload)
                                        workloadIndex = _.findIndex(networkOfWorkload.workloads,{"id":workloadmatched.id});
                                    if(workloadIndex !== undefined)
                                        mn = networkOfWorkload.workloads[workloadIndex];
                                }
                                
                                if(mn){
                                  mn.resourceGroupId = data.workloadsToUpdateVal[i].resourceGroupId;
                                  mn.resourceGroupName = data.workloadsToUpdateVal[i].grName;
                                  mn.noneSPS = data.noneSPS;
                                }
                            }
                        }
                    }

                   $scope.referesh($scope.secuerMode);
                    /* jshint ignore:end */
                });

                $scope.$on('refereshNetworks', function (event, data) {
                   $scope.referesh($scope.secuerMode);
                });
                $scope.referesh = function(data) {
                     switch (data) {
                        case "all":
                            $scope.secuerMode = data;
                            $scope.showAll(data);
                            break;
                        case "grouped":
                            $scope.showGrouped(data);
                            $scope.secuerMode = data;
                            break;
                        case "upgrouped":
                            $scope.showUnGrouped(data);
                             $scope.secuerMode = data;
                            break;
                        default:
                            $scope.showAll(data);
                    }
                };

                $scope.$on('showNetworks', function (event, data) {
                    $scope.referesh(data);
                });
                $scope.$on(SOEvents.noneSpsPolicy,function(event,args){
                    console.log("SPS none loaded and catched",args);
                    $scope.spsNoneId = args.asp.id;
                });
                $scope.unsecGrouped = 0;
                $scope.secGrouped = 0;
                $scope.groupObj = {'secgrouped':$scope.secGrouped,'unsecgrouped':$scope.unsecGrouped};
                $scope.recalcNetworkInfo = function (data) {
                    console.log("reCalcNetworks start");
                    $scope.unsecGrouped = 0;
                    $scope.secGrouped = 0;
                    var sandboxedNetworks = [];
                    var sandboxedWorkloads = [];
                    _.each($scope.rules, function (rule) {
                        if(rule.id){
                            var groupName = rule.groupInfo;
                            rule.workloadsSecured = 0;
                            _.each(rule.ruleDesc, function (ruleDesc) {
                                _.each(ruleDesc.networks, function (network) {
                                    if($scope.spsNoneId === rule.aspInfo.id){
                                        network.noneSPS = true;
                                        rule.noneSPS = true;
                                    } else {
                                        network.noneSPS = false;
                                        rule.noneSPS = false;
                                    }
                                    if(rule.resourceType == "NETWORK"){
                                        if (!_.find(sandboxedNetworks, {"id": network.id})) {
                                            network.ruleId = rule.id;
                                            network.groupName = groupName.name;
                                            sandboxedNetworks.push(network);
                                            var matchedNet = _.find($scope.networks, {"id": network.id });
                                            rule.workloadsSecured += matchedNet.workloads.length;
                                        }
                                    } else if(rule.resourceType == "VM") {
                                        if(network.id && !_.find(sandboxedWorkloads, {"id": network.id}) ){
                                            network.ruleId = rule.id;
                                            network.groupName = groupName.name;
                                            sandboxedWorkloads.push(network);
                                            rule.workloadsSecured++;
                                        }
                                    }
                                });
                            });
                        }
                    });
                    var templist = angular.copy($scope.networkInfo);
                    /*var templist = [];
                    if(data === "grouped")
                        templist = angular.copy($scope.networkInfo);
                    else
                        templist = angular.copy($scope.networks);*/
                    var ungroupedList = [];
                    var groupedList = [];

//                    _.each(templist, function (value, key) {
                    for (var i = 0; i < templist.length; i++) {
                        if (typeof templist[i] !== "undefined") {
                            var sanboxObj = _.find(sandboxedNetworks, {"id": templist[i].id});
                            /*if ($scope.sandboxMode) {*/ //Enable this check if we want secured - unsecured to be integrated with sandboxMode
                                for (var j = 0; j < templist[i].workloads.length; j++) {
                                    var sanboxWorkloadObj = _.find(sandboxedWorkloads, {"id": templist[i].workloads[j].id});
                                    if (sanboxWorkloadObj) {
                                        templist[i].workloads[j].ruleId = sanboxWorkloadObj.ruleId;
                                        templist[i].workloads[j].resourceGroupName = sanboxWorkloadObj.groupName;
                                        templist[i].workloads[j].noneSPS = sanboxWorkloadObj.noneSPS;
                                        if(templist[i].workloads[j].noneSPS)
                                            $scope.unsecGrouped++;
                                        else
                                            $scope.secGrouped++;
                                    }
                                    
                                }
                                if (data === "grouped") {
                                    if (sanboxObj) {
                                        templist[i].ruleId = sanboxObj.ruleId;
                                        templist[i].resourceGroupName = sanboxObj.groupName;
                                        templist[i].noneSPS = sanboxObj.noneSPS;
                                        if(templist[i].noneSPS)
                                            $scope.unsecGrouped += templist[i].workloads.length;
                                        else
                                            $scope.secGrouped += templist[i].workloads.length;
                                        groupedList.push(angular.copy(templist[i]));
                                    } else if (templist[i].resourceGroupId) {
                                        groupedList.push(angular.copy(templist[i]));
                                    }
                                } else if (data === "upgrouped") {
                                    if (sanboxObj) {
                                        templist[i].ruleId = sanboxObj.ruleId;
                                        templist[i].resourceGroupName = sanboxObj.groupName;
                                        templist[i].noneSPS = sanboxObj.noneSPS;
                                        if(templist[i].noneSPS)
                                            $scope.unsecGrouped += templist[i].workloads.length;
                                        else
                                            $scope.secGrouped += templist[i].workloads.length;
                                        ungroupedList.push(angular.copy(templist[i]));
                                    } else {
                                        ungroupedList.push(angular.copy(templist[i]));
                                    }
                                } else {
                                    if (sanboxObj) {
                                        templist[i].ruleId = sanboxObj.ruleId;
                                        templist[i].resourceGroupName = sanboxObj.groupName;
                                        templist[i].noneSPS = sanboxObj.noneSPS;
                                        if(templist[i].noneSPS)
                                            $scope.unsecGrouped += templist[i].workloads.length;
                                        else
                                            $scope.secGrouped += templist[i].workloads.length;
                                    }
                                }
                                
                            /*} else {
                                if (data === "grouped") {
                                    if (sanboxObj && sanboxObj.ruleId) {
                                        templist[i].ruleId = sanboxObj.ruleId;
                                        templist[i].resourceGroupName = sanboxObj.groupName;
                                        groupedList.push(angular.copy(templist[i]));
                                    } else if (templist[i].ruleId) {
                                        groupedList.push(angular.copy(templist[i]));
                                    } else {
                                        ungroupedList.push(angular.copy(templist[i]));
                                    }
                                } else if (data === "upgrouped") {
                                    if (sanboxObj && sanboxObj.ruleId) {
                                        templist[i].ruleId = sanboxObj.ruleId;
                                        templist[i].resourceGroupName = sanboxObj.groupName;
                                    } else {
                                        ungroupedList.push(angular.copy(templist[i]));
                                    }
                                } else {
                                    if (sanboxObj) {
                                        templist[i].ruleId = sanboxObj.ruleId;
                                        templist[i].resourceGroupName = sanboxObj.groupName;
                                    }
                                }
                            }*/
                        }
                    }
//                    });
                    if (data === "upgrouped") {
                        $scope.networkInfo = ungroupedList;
                    } else if (data === "grouped") {
                        $scope.networkInfo = groupedList;
                    } else {
                        $scope.networkInfo = templist;
                    }
                   $scope.networksCopy = angular.copy($scope.networkInfo);
                   $scope.broadcastSOREvents(SOEvents.networkChangedEvent, $scope.networkInfo);
                   $scope.broadcastSOREvents('counterChanged', {'secgrouped':$scope.secGrouped,'unsecgrouped':$scope.unsecGrouped});
                   console.log("reCalcNetworks End");
                };
                
                $scope.$on('fullscreen', function (event, data) {
                    if(!$scope.maximize) {
                        fixContainerHeight(2);
                    } else {
                        fixContainerHeight(4);
                    }
                
                    $scope.maximize = !$scope.maximize;
                });
                
                $scope.$on('sandboxModeToggleInit', function (event, sandboxMode) {
                    $scope.sandboxMode = sandboxMode;
                    $scope.$broadcast('sandboxModeToggled', $scope.sandboxMode);
                });
             
                $scope.$on('showObjectDetailClicked', function (event, data) {
                    $scope.$broadcast('showObjectDetail', data);
                });

                $scope.$on('toggleNetworkDataInit', function (event, data) {
                    $scope.$broadcast('toggleNetworkData', data);
                });
                
                $scope.$on("restorePreAttributeSession", function (event, args) {
                    $scope.$broadcast('onRestorePreAttributeSession', {});
                });

                $scope.$on("rulesArrayChangedInit", function (event, args) {
                    $scope.$broadcast('rulesArrayChanged', args);
                });

                $scope.$on("groupCountsChangedInit", function (event, args) {
                    $scope.$broadcast('groupCountsChanged', args);
                });

                $scope.$on("reloadNetworksByTenantInit", function (event, args) {
                    $scope.tenantid = args.tenantId;
                    $scope.$broadcast('reloadNetworksByTenant', args);
                });

            }];

        return directive;
    }

    angular.module('shieldxApp').directive('securityorchestration', securityOrchestrationDirective);
})();

/*
 ShieldX Networks Inc. CONFIDENTIAL
 ----------------------------------
 *
 Copyright (c) 2016 ShieldX Networks Inc.
 All Rights Reserved.
 *
 NOTICE: All information contained herein is, and remains
 the property of ShieldX Networks Incorporated and its suppliers,
 if any. The intellectual and technical concepts contained
 herein are proprietary to ShieldX Networks Incorporated
 and its suppliers and may be covered by U.S. and Foreign Patents,
 patents in process, and are protected by trade secret or copyright law.
 Dissemination of this information or reproduction of this material
 is strictly forbidden unless prior written permission is obtained
 from ShieldX Networks Incorporated.
 */

(function () {
    function securityOrchestrationHeaderDirective() {
        var directive = {};
        directive.restrict = 'E';
        directive.replace = true;
        directive.templateUrl = 'core/directive/security-orchestration/security-orchestration-header-template.html';
        directive.scope = {
            networkInfo: '=netinfo',
            selectedNetworks: '=selectednetworks',
            networkFetched: '=networkfetched',
            masterList: '=masterlist',
            broadcastevent: '&',
            tenants:'=',
            configinfo : "=",
            activetenant:'=',
            networksavailable : '=',
            workloads : '=',
            attributesfound : '=',
            virtualchassisdata:"=",
            resouregroupassigned:"=",
            vchassisid:"=",
            groupobj : "="
        };
        directive.controller = ['$scope', '$rootScope', '$state','$mdDialog', function ($scope, $rootScope, $state,$mdDialog) {
                
                $scope.showRuleFilter = false;
                $scope.existingfilter = {"alphanumeric":[],"os":[],"appname":[]};
                $scope.buttonSelected = "network";
                $scope.methodBridge = new MethodBridge();
                $scope.maximize = false;
                $scope.filteredWorkloadsCount = 0;
                $scope.$on(SOEvents.networkChangedEvent, function (event, args) {
                    console.log("securityOrchestrationHeaderDirective SOEvents.networkChangedEvent");
                    console.dir(args);
                    $scope.methodBridge.call(args);
                });
                $scope.checkfilter = function(){
                    if($scope.existingfilter.alphanumeric.length || $scope.existingfilter.os.length || $scope.existingfilter.appname.length)
                        return false;
                    return true;
                };
                $scope.getAttributeName = function(typeOfattr,itemId){
                    var matchedData = _.find($scope.attributesfound,{'type' : typeOfattr,'id' : itemId});
                    return matchedData.name;
                };
                $scope.uncheckFilter = function(filterType,removedEntity){
                    var matchedIndex = null;
                    if(filterType === 'os'){
                        $scope.existingfilter.os.splice(removedEntity,1);
                    } else if(filterType === 'appname'){
                        $scope.existingfilter.appname.splice(removedEntity,1);
                    } else if(filterType === 'alphanumeric'){
                        $scope.existingfilter.alphanumeric.splice(removedEntity,1);
                    }
                    calculateFilter($scope.existingfilter,$scope.networksavailable);
                };
                function calculateFilter(filter,allNetworks){
                    $scope.networksavailableCopy = angular.copy(allNetworks);
                    $scope.filteredWorkloadsCount = 0;
                    var filteredWorkloads = [];
                    var value = filter;
                    for(var nwiterator = $scope.networksavailableCopy.length - 1; nwiterator >=0; nwiterator--){
                      var singleNetwork = $scope.networksavailableCopy[nwiterator];
                      for (var i = singleNetwork.workloads.length - 1;i >= 0 ;i--) {
                            var singleWorkload = singleNetwork.workloads[i];
                            var alphanumericPass = true;
                            var osPass = value.os.length ? false : true;
                            var appIdPass = value.appname.length ? false : true;
                            if(value.alphanumeric.length && value.alphanumeric.indexOf(singleWorkload.name.toLowerCase().charAt(0)) === -1 ) {
                                alphanumericPass = false;
                            }
                            for (var osIterator = 0; osIterator < value.os.length; osIterator++) {
                                var matchedIndexOS = _.findIndex(singleWorkload.ports[0].attributes,{'type' : 'os','id':value.os[osIterator]});
                                if(matchedIndexOS !== -1)
                                    osPass = true;
                            }
                            for (var appIterator = 0; appIterator < value.appname.length; appIterator++) {
                                var matchedIndexApp = _.findIndex(singleWorkload.ports[0].attributes,{'type' : 'application','id':value.appname[appIterator]});
                                if(matchedIndexApp !== -1)
                                    appIdPass = true;
                            }
                            if(!alphanumericPass || !osPass || !appIdPass){
                                singleNetwork.workloads.splice(i,1);
                            } else {
                                if(filteredWorkloads.indexOf(singleWorkload.id) === -1)
                                    filteredWorkloads.push(singleWorkload.id);
                            }
                        }
                        if(!singleNetwork.workloads.length && (value.os.length || value.appname.length || value.alphanumeric.length) ){
                            $scope.networksavailableCopy.splice(nwiterator,1);
                        }
                       
                    }
                    $scope.filteredWorkloadsCount = filteredWorkloads.length;
                    $scope.$emit('filteredNetworks',{networks:$scope.networksavailableCopy});
                    if(!value.os.length && !value.appname.length && !value.alphanumeric.length)
                        $scope.$emit('nofilterZoomout');
                    console.log("this is the filtered output after workloads process ",$scope.networksavailableCopy);
                    //checkEvent();
                }
                $scope.getFilterCount = function(){
                    return $scope.existingfilter.alphanumeric.length + $scope.existingfilter.os.length + $scope.existingfilter.appname.length;
                };
                $scope.clearFilters = function(){
                    $scope.$emit('filteredNetworks',{networks:$scope.networksavailable});
                    $scope.existingfilter = {"alphanumeric":[],"os":[],"appname":[]};
                };
                $scope.onSelectNetworkClicked = function () {
                    $scope.buttonSelected = "network";
                    $scope.broadcastevent({event: 'gotoNetworkTab', args: {} });
//                    $scope.$emit("gotoNetworkTab", {});
                };

                $scope.onSelectGroupClicked = function () {
                    $scope.buttonSelected = "group";
                    $scope.broadcastevent({event: 'gotoGroupTab', args: {} });
                };

                $scope.disableAllSelection = function (flag) {
                    _.each($scope.items, function (obj) {
                        obj.disabled = flag;
                    });
                };
                 $scope.chipCreated = false;
                $scope.$on('onChipItemCreated', function(event,data){
                    $scope.chipCreated = true;
                    console.log("dataa " + data);
                    $scope.Totalchips = data;
                    $scope.readonly = false;
                    $scope.removable = false;

                });
                $scope.showFilterPopup = function(event){
                    $mdDialog.show({
                        skipHide: true,
                        controller: morefilterCtr,
                        templateUrl: 'core/components/screenComponents/networkView/morefilterspopup.html',
                        parent: angular.element(document.body),
                        targetEvent: event,
                        fullscreen: true,
                        openFrom: {top: 1100, height: 0},
                        closeTo: {left: 1500},
                        locals:{existingfilter:$scope.existingfilter,workloads:$scope.workloads,attributesFound:$scope.attributesfound}
                    }).then(function (value) {
                        //$scope.networksavailableCopy = angular.copy($scope.networksavailable);
                        calculateFilter(value,$scope.networksavailable);
                        $scope.existingfilter = angular.copy(value);
                        console.log(value);
                        //console.log($scope.networksavailableCopy);
                    });
                };
                $scope.deletedChip = function(){
                    $scope.$broadcast("actionMadeOnChip",{"data":$scope.Totalchips});
                    //console.log($scope.Totalchips);
                    if($scope.Totalchips.length  === 0){
                        $scope.chipCreated = false;
                        $scope.$emit('nofilterZoomout');
                    }
                };
                $scope.helpButtonClicked = function(id){
                    $scope.active_help_id = id;
                    console.log("  helpButtonClicked ");
                    $scope.bordcastEventHelpButtonClicked($scope.active_help_id);
                }; 
                $scope.bordcastEventHelpButtonClicked = function(helpId){
                    $scope.$broadcast('onHelpButtonClicked', {
                       helpIDString: helpId 
                    });
                 };
                $scope.$on(SOEvents.ruleCommitedEvent, function (event, args) {
                    $scope.chipCreated = false;
                    $scope.broadcastevent({event: 'showNetworks', args: "grouped" });
                });
                $scope.$on(SOEvents.ruleAllCommitedEvent, function (event, args) {
                    $scope.chipCreated = false;
                    $scope.broadcastevent({event: 'showNetworks', args: "grouped" });
                });
                $scope.data = null;
                $scope.$on('onNetworkSelectionChanged', function (event, data) {
                    $scope.data = data;
                    $scope.dataType = "NETWORK";
                    $scope.showRuleFilter = true;
                    if (data.op === "selected") {
                        $scope.broadcastevent({event: 'networkSelectionChanged', args: $scope.data});  
                    }
                });
                $scope.getWorkloadPercentage = function(workloadCount){
                    if(workloadCount){
                        var percentData = (workloadCount*100)/$scope.totalWorkLoads.length;
                        return percentData.toFixed(2)+"%";
                    }
                    return "0%";
                };
                $scope.$on('onEntitySelectionChanged', function (event, data) {
                    $scope.data = data;
                    $scope.showRuleFilter = true;
                    if (data.op === "selected") {
                        $scope.broadcastevent({event: 'entitySelectionChanged', args: $scope.data});  
                    }
                });
                
                $scope.$on('onWorkLoadSelectionChanged', function (event, data) {
                    $scope.data = data;
                    $scope.dataType = "WORKLOAD";
                    $scope.showRuleFilter = true;
                    if (data.op === "selected") {
                        $scope.broadcastevent({event: 'workloadSelectionChanged', args: $scope.data});  
                    }
                });
                
                $scope.createRuleFilter = function () {
                  $scope.$emit('sandboxModeToggleInit', true);
                  $scope.broadcastevent({event: 'entitySelectionChanged', args: $scope.data});  
                };
                $scope.$on("drawSecureBar",function(event,args){
                    $scope.initialRules = args;
                    $scope.getRsGroupsList = true;
                    $scope.totalsecuredAndUnsecredList();
                });
                $scope.$on('totalWorkLoads',function(event,args){
                    if(args.masterData){        
                        $scope.totalWorkLoads = args.masterData;        
                        $scope.networksWithWorkLoads = args.totalList;  
                        $scope.unsecuredWorkloads = $scope.totalWorkLoads.length;
                        $scope.unsecuredBarWidth = $scope.widthOfdBar($scope.unsecuredWorkloads);     
                        $scope.getWorkloadListCompleted = true;
                        $scope.totalsecuredAndUnsecredList();
                    }  
                });
                $scope.totalsecuredAndUnsecredList = function(){
                    $scope.tempListRules = [];
                    $scope.securedWorkLoads = 0;
                    $scope.unsecgroupvmcount = 0;
                    $scope.unsecuredWorkloads = $scope.totalWorkLoads.length;
                    if($scope.getWorkloadListCompleted && $scope.getRsGroupsList){
                        _.each($scope.initialRules,function(singleRule){
                            var dataObj = {};
                            dataObj.noneSPS = singleRule.noneSPS; 
                            dataObj.workloads = singleRule.workloadsSecured; 
                            dataObj.groupName = singleRule.groupInfo.name;
                            $scope.tempListRules.push(dataObj);
                            if(singleRule.noneSPS)
                                $scope.unsecgroupvmcount += dataObj.workloads;
                            else
                                $scope.securedWorkLoads += dataObj.workloads;
                        });            
                    }
                    $scope.unsecuredWorkloads = $scope.totalWorkLoads.length - ($scope.securedWorkLoads + $scope.unsecgroupvmcount) ;
                    $scope.unsecuredBarWidth = $scope.widthOfdBar($scope.unsecuredWorkloads);
                };
                $scope.getClassSPS = function(dataPassed){
                    return dataPassed.noneSPS ? "noneSPS" : "" ;
                };
                $scope.widthOfdBar = function(lengthOfNetWorks){
                    var renderWidth =  100/$scope.totalWorkLoads.length;
                    return (lengthOfNetWorks === 0)?0:(parseInt(renderWidth*lengthOfNetWorks) + "%"); 
                };
                /*$scope.$on('counterChanged',function(event,args){
                    $scope.securedWorkLoads = args.secgrouped;
                    $scope.unsecgroupvmcount = args.unsecgrouped;
                    if($scope.totalWorkLoads)
                    $scope.unsecuredWorkloads = $scope.totalWorkLoads.length - ($scope.securedWorkLoads + $scope.unsecgroupvmcount) ;
                });*/
                /*function calculateTopBarCounter(){
                    $scope.securedWorkLoads = $scope.groupobj.secgrouped;
                    $scope.unsecgroupvmcount = $scope.groupobj.unsecgrouped;
                        
                }*/
//                var searchData = null;
//                $scope.createRuleFromSearchData = function () {
//                    $rootScope.$broadcast('onNetworkSelectionChanged', searchData);
//                };

                $scope.$on('showNetworks', function (event, data) {
                    switch (data) {
                        case "all":
                            $scope.securedStatus = "0";
                            break;
                        case "grouped":
                            $scope.securedStatus = "1";
                            break;
                        case "upgrouped":
                            $scope.securedStatus = "-1";
                            break;
                        default:
                            $scope.securedStatus = "0";
                    }
                });

                $scope.$watch('securedStatus', function () {
                    checkEvent();
                });
                function checkEvent(){
                    switch ($scope.securedStatus) {
                        case "0":
                            $scope.broadcastevent({event: 'showNetworks', args: 'all'});
                            break;
                        case "1":
                            $scope.broadcastevent({event: 'showNetworks', args: 'grouped'});
                            break;
                        case "-1":
                            $scope.broadcastevent({event: 'showNetworks', args: 'upgrouped'});
                            break;
                        default:
                            $scope.broadcastevent({event: 'showNetworks', args: 'grouped'});
                    }
                }
                $scope.refreshNetworks = function() {
                    $state.reload();
                };
                
                $scope.fullscreen = function() {
                    $scope.maximize = !$scope.maximize;
                    $scope.$emit('fullscreenInit',null);
                };
                
                $scope.sandboxMode = false;
                $scope.$on('sandboxModeToggled', function (event, sandboxMode) {
                    $scope.sandboxMode = sandboxMode;
                });

                $scope.$on('groupCountsChanged', function (event, groupCounts) {
                    $scope.activeGroupCount = groupCounts.active;
                    $scope.sandboxGroupCount = groupCounts.sandbox;
                });
                
                $scope.oldTenant = null;
                $scope.cancelHit = false;
                $scope.$watch('selectedTenant', function(newvalue, oldvalue) {
                    
                    if(!oldvalue) {
                        $scope.oldTenant = $scope.selectedTenant;
                    }
                    if (oldvalue && !$scope.cancelHit) {

                        $mdDialog.show({
                            skipHide: true,
                            controller: switchTenantConfirmCtr,
                            templateUrl: 'core/components/screenComponents/networkView/switchTenantConfirmBox.html',
                            parent: angular.element(document.body),
                            targetEvent: event,
                            fullscreen: true,
                            openFrom: {top: 1100, height: 0},
                            closeTo: {left: 1500},
                            locals: {selectedTenant: newvalue, oldTenant: $scope.oldTenant}
                        }).then(function (value) {
                            $scope.oldTenant = newvalue;
                            $scope.$emit("reloadNetworksByTenantInit", {tenantId: $scope.selectedTenant});
                        }, function () {
                            $scope.cancelHit = true;
                            $scope.selectedTenant = $scope.oldTenant;
                        });
                    } else {
                        $scope.cancelHit = false;
                    }

                });
            }];
        return directive;
    }

    angular.module('shieldxApp').directive('securityorchestrationheader', securityOrchestrationHeaderDirective);
    
    function switchTenantConfirmCtr($scope, $mdDialog, selectedTenant) {
        
        $scope.selectedTenant = selectedTenant;
        $scope.cancelDialog = function () {
            $mdDialog.cancel();
        };
        $scope.applyDialog = function () {
            $mdDialog.hide();
        };

    }
    angular.module('shieldxApp').directive('switchTenantConfirmCtr', switchTenantConfirmCtr);
    
    function morefilterCtr($scope,$mdDialog,existingfilter,workloads,attributesFound){
        var str = "abcdefghijklmnopqrstuvwxyz";
        var numberstring = "0123456789";
        $scope.alphabet = str.toUpperCase().split("");
        $scope.numberList = numberstring.split("");
        $scope.existingfilter = angular.copy(existingfilter);
        $scope.existingfilterCopy = angular.copy(existingfilter);
        //$scope.attributesFound = attributesFound;
        $scope.availableOS = [];
        $scope.availableApp = [];
        _.each(attributesFound,function(typeOfattr){
            if(typeOfattr.type === "os"){
                $scope.availableOS.push(typeOfattr);
            } else if(typeOfattr.type === "application"){
                $scope.availableApp.push(typeOfattr);
            }
        });
        //$scope.alphabetChips = [];
        $scope.alphabetChips = {};
        console.log(workloads);
        _.each(workloads,function(singleWorkload){
            var l = singleWorkload.name.charAt(0).toLowerCase();
            $scope.alphabetChips[l] = (isNaN($scope.alphabetChips[l]) ? 1 : $scope.alphabetChips[l] + 1);
        });
        console.log("data that I get ",$scope.alphabetChips);
        $scope.workloadsavailableAlphanumeric = [];

        $scope.cancelDialog = function(){
            $scope.existingfilter = angular.copy($scope.existingfilterCopy);
            $mdDialog.hide($scope.existingfilter);
        };
        $scope.applyDialog = function(){
            $mdDialog.hide($scope.existingfilter);
        };
        $scope.toggle = function(itemIndex,type){
            var itemPresent = $scope.existingfilter[type].indexOf(itemIndex);
            if(itemPresent === -1){
                $scope.existingfilter[type].push(itemIndex);
            } else {
                $scope.existingfilter[type].splice(itemPresent,1);
            }
        };
        $scope.checkexists = function(itemIndex,type){
            return $scope.existingfilter[type].indexOf(itemIndex) !== -1 ? true : false;
        };
        $scope.getCounter = function(itemIndex){
            if(isNaN($scope.alphabetChips[itemIndex])){
                return 0;
            } else {
                return $scope.alphabetChips[itemIndex] > 9999 ? ( $scope.alphabetChips[itemIndex]/1000 + "k" ) : $scope.alphabetChips[itemIndex];
            }
            
        };
    }
    angular.module('shieldxApp').directive('morefilterCtr', morefilterCtr);

})();


/*
ShieldX Networks Inc. CONFIDENTIAL
----------------------------------
*
Copyright (c) 2016 ShieldX Networks Inc.
All Rights Reserved.
*
NOTICE: All information contained herein is, and remains
the property of ShieldX Networks Incorporated and its suppliers,
if any. The intellectual and technical concepts contained
herein are proprietary to ShieldX Networks Incorporated
and its suppliers and may be covered by U.S. and Foreign Patents,
patents in process, and are protected by trade secret or copyright law.
Dissemination of this information or reproduction of this material
is strictly forbidden unless prior written permission is obtained
from ShieldX Networks Incorporated.
*/

(function () {
    function securityOrchestrationRightpanelDirective() {
        var directive = {};
        directive.restrict = 'E';
        directive.replace = true;
        directive.templateUrl = 'core/directive/security-orchestration/security-orchestration-rightpanel-template.html';
        directive.scope = {
            seccloudid :  "=",
            sectenantid : "=",
            secrules: "=",
            configinfo : "=",
            networksavailable: '=',
            tenants: "=",
            workloads: "=",
            broadcastevent: '&',
            vcname: "="
        };
        
        directive.link = function(scope, element, attrs) {
           console.log(" llink "+scope);    
           scope.$watch('secrules', function(newValue, oldValue) {
                console.log(" secrules  >> "+newValue);    
                if (newValue){
                   scope.rulesArray = scope.secrules;
                   scope.initDirective();
                }
             }, true);

                scope.$watch('sectenantid', function(newValue, oldValue) {
                if (newValue){
                   console.log(" sectenantid change >>>>  "+newValue);
                    scope.sectenantid = newValue;
                }
                }, true);
        };
        
        directive.controller = ['$scope','virtualChassisService','$mdDialog', function ($scope,virtualChassisService,$mdDialog) {
            $scope.toggleNetworkData = function (attribute) {
                $scope.attributeDetailsView = false;
                $scope.$emit('toggleNetworkDataInit', attribute);
            };
            
            $scope.$on("onRestorePreAttributeSession", function (event, args) {
                $scope.attributeDetailsView = false;
            });

            $scope.inmemoryRule = null;
            $scope.lastShownRule = null;
            $scope.sandboxMode = false;
            console.log("calling from the right panel ",$scope.networksavailable);
           $scope.OrchestrationRulesText = "Orchestration Rules";

           $scope.parentTitle = "right hand panel  directive";
           console.log($scope);
           $scope.rulesArray =  $scope.secrules;
           console.log(" securityOrchestrationRightpanelDirective ");
           console.log(" seccloudid "+$scope.seccloudid);
           console.log(" sectenantid "+$scope.sectenantid);
           console.log(" secrules "+$scope.secrules);
           console.dir($scope.secrules);
        $scope.groupsAlreadySelectedinMemory = [];
        _.each($scope.rulesArray,function(singleRule){
            if(singleRule.groupInfo.id !== -1){
                $scope.groupsAlreadySelectedinMemory.push(singleRule.groupInfo.id);
            }
        });
        $scope.returnToPreviousState = function(){
          $scope.$broadcast('returnToPrevious');
        };
        $scope.chassisgroupIds = [];
        $scope.groupData = [];
        virtualChassisService.getListOfVirtualChassis().then(function(allChassis){
            _.each(allChassis,function(singleChassis){
                _.each(singleChassis.subscriptionList,function(singleGroup){
                      $scope.chassisgroupIds.push(singleGroup.resourceGroupId);
                });
            });
            virtualChassisService.getListOfResourceGroups($scope.seccloudid).then(function(allGroups){
              $scope.broadcastevent({event:"existingResourceGroupsData",args:allGroups});
                _.each(allGroups,function(singleGroup){
                    if($scope.chassisgroupIds.indexOf(singleGroup.id) === -1 && $scope.groupsAlreadySelectedinMemory.indexOf(singleGroup.id) === -1 ){
                        $scope.groupData.push(singleGroup);
                    }
                });
            });
        },
        function(error){
          console.log("call failed ",error);
        });
        $scope.broadcastRightSOREvents = function(nameOfEvent, arg) {
             $scope.broadcastevent({event:nameOfEvent, args:arg});
        };
        
        $scope.$on(SOEvents.ruleDeletedEvent, function (event, args) {
           /* if(args.ruleref.groupInfo.id === -1 && args.ruleref.deleted){
              var ind = _.findIndex($scope.secrules, function(rule){
                return  rule.name === args.ruleref.name;
              });
              $scope.secrules.splice(ind, 1);
              $scope.broadcastevent({event: 'refereshNetworks'});
            }*/
            
        });

        $scope.openMenu = function($mdOpenMenu, ev) {
           $mdOpenMenu(ev);
        };

        $scope.onOrchestrationRulesSelected = function(){
           $scope.OrchestrationRulesText = "Orchestration Rules";
           $scope.broadcastevent({event:SOEvents.popUpMenuSelectionChangeEvent, args:{selection:"orchestration-rules"}}); 
        };
        $scope.onWorkAttributesSelected = function(){
           $scope.OrchestrationRulesText = "Workload Attributes";
          $scope.broadcastevent({event:SOEvents.popUpMenuSelectionChangeEvent, args:{selection:"work-attributes"}}); 
        };
        $scope.onGuideSelected = function(){
           $scope.OrchestrationRulesText = "Guide";
           $scope.broadcastevent({event:SOEvents.popUpMenuSelectionChangeEvent, args:{selection:"guid"}});
        };

        

        $scope.initCallback = null;

        $scope.registeInitrCallback = function( arg ){
           $scope.initCallback = arg;
        };
        
        $scope.initDirective = function(){
          if($scope.initCallback){
            $scope.initCallback();
          }
        };
        
        $scope.sandboxMode = false;
        $scope.ruleChanged = false;
        $scope.$on('reorderRules',function(event,args){
          $scope.ruleChanged = true;
        });
        $scope.setSandboxState = function (sandboxMode) {
            $scope.sandboxMode = sandboxMode;
            $scope.$emit('sandboxModeToggleInit', $scope.sandboxMode);
        };
        
        $scope.$on('sandboxModeToggled', function (event, sandboxMode) {
            $scope.sandboxMode = sandboxMode;
        });
        $scope.clickToCreateextOrIntRule = function(item){            
          console.log(item);    
          $scope.newSoRule = new SORule();    
          var ruleattributes = '';    
          $scope.newSoRule.ruleDesc.push(new SORuleDesc());   
          if(item === 0){   
            ruleattributes = SORule.ruleAttribute.CIDR;   
            $scope.newSoRule.groupInfo.id= -1;    
            $scope.newSoRule.groupInfo.name= "External Rule - "+$scope.vcname;    
            $scope.newSoRule.ruleDesc[0].networkSpec = "0.0.0.0/0";   
          }else{    
            ruleattributes = SORule.ruleAttribute.WORKLOAD;   
            $scope.newSoRule.groupInfo.id= -1;    
            $scope.newSoRule.groupInfo.name="Internal Rule - "+$scope.vcname;    
            $scope.newSoRule.ruleDesc[0].networkSpec = ".*";    
          }   
          $scope.newSoRule.ruleDesc[0].ruleAttribute = ruleattributes.id;   
          $scope.newSoRule.ruleDesc[0].matchingCritaria = SORule.matchingCritarias.IS.id;   
          $scope.broadcastevent({event:"externalInternalRuleCreation",args:{"data":$scope.newSoRule}});   
          console.log(ruleattributes);    
        };
        $scope.showgroupPopup = function(event){
          console.log("This is the data required ",$scope.groupData);
            $mdDialog.show({
              controller: 'groupsCtr',
              templateUrl: 'core/components/administration/quick-setup/virtual-chassis/groupPopup.html',
              parent: angular.element(document.body),
              skipHide: true,
              targetEvent: event,
              clickOutsideToClose: true,
              locals: {
                  groupdata: $scope.groupData
              }
            }).then(function (chosenGroups) {
                  _.each($scope.rulesArray,function(singleRule){
                    singleRule.precedence = chosenGroups.length + singleRule.precedence;
                  });
                  var precedence = 1;
                _.each(chosenGroups,function(chosenGroup){
                  var removeIndex = _.findIndex($scope.groupData,chosenGroup);
                  $scope.groupData.splice(removeIndex, 1);
                  var resourceGroup = angular.copy(chosenGroup);
                  var sr = new SORule();
                  sr.mergeExistingGroup(resourceGroup);
                  sr.aspInfo = new ASPInfo();
                  sr.precedence = precedence;
                  sr.imported = true;
                  $scope.rulesArray.push(sr);
                  precedence++;
                });
                
            }, function () {
                $scope.status = 'You cancelled the dialog.';
            });
      };

        $scope.$on('inmemoryRuleSet', function (event, inmemoryRule) {
            // $scope.editModeInit = false;
            // $scope.inmemoryRule = inmemoryRule;
        });
        
        $scope.editModeInit = false;
        $scope.restorePreviousState = function () {
            if ($scope.lastShownRule) {
                $scope.editModeInit = true;
                $scope.lastShownRule.deleted = false;
                $scope.$broadcast("editClicked", $scope.lastShownRule);
            }
        };
        
        $scope.attributeDetailsView = false;
        $scope.$on('showObjectDetail', function (event, data) {
            $scope.attributeDetailsView = true;
        });

        $scope.$watch('rulesArray', function (newValue, oldValue) {
            if (newValue) {
                $scope.$emit('rulesArrayChangedInit', newValue);
            }
        }, true);

        }];
        return directive;
    }

    angular.module('shieldxApp').directive('securityorchestrationrightpanel', securityOrchestrationRightpanelDirective);
    

    function manageOrchestrationRuleCtr($scope) {
        console.log(" manageOrchestrationRuleCtr  >> "+$scope.parentTitle);
        $scope.viewStates = {
                INITIAL_NEW_RULE: 0,
                LIST_RULES: 1,
                EDIT_RULES: 2,
                CREATE_NEW_RULE: 3,
                GUID:4,
                WORK_LOAD:5,
                OBJECT_ATTRIBUTE:6
        };
        console.log("manageOrchestrationRuleCtr sending values ",$scope.groupData);
        $scope.currentState =  -1;
        $scope.previousState = -1;
        $scope.saveRuleStateOnMenuSelection = -1;

        $scope.newSoRule = new SORule();
        //$scope.newSoRule.addSORuleDesc(new SORuleDesc());
        $scope.editSoRule = null;
        $scope.inmemoryRule = null;
        $scope.initEntityCount =  0;
        $scope.disableSave = true;
       
//        var entityAttribute = {
//            NETWORK: {name: "Network", id: "0", type: "NETWORK"},
//            CIDR : {name:"Cidr", id:"1", type:"CIDR"},
//            WORKLOAD: {name: "Workload", id: "2", type: "WORKLOAD"}
//        };

        $scope.$on('returnToPrevious',function(event,args){
          $scope.returnToPreviousState();
        });
        $scope.restorePreAttributeSession = function () {
            $scope.returnToPreviousState();
            $scope.$emit("restorePreAttributeSession", {});
        };
        $scope.setCurrentState = function(arg){
           $scope.previousState =  $scope.currentState;
           $scope.currentState = arg;
           var states = {prevStat:$scope.previousState, currStat:$scope.currentState}; 
           $scope.$broadcast('currentStateChanged', states);
        };

        $scope.isStateInitialNewRule = function(){
           return $scope.currentState === $scope.viewStates.INITIAL_NEW_RULE;
        };

        $scope.isStateListRules = function(){
           return $scope.currentState === $scope.viewStates.LIST_RULES;
        }; 

        $scope.isStateEditRules = function(){
           return $scope.currentState === $scope.viewStates.EDIT_RULES;
        }; 

        $scope.isStateCreateNewRule = function(){
           return $scope.currentState === $scope.viewStates.CREATE_NEW_RULE;
        };

        $scope.isStateGuid = function(){
           return $scope.currentState === $scope.viewStates.GUID;
        };

        $scope.isStateWorkload = function(){
            return $scope.currentState === $scope.viewStates.WORK_LOAD;
        };

        $scope.isObjectAttribute = function(){
            return $scope.currentState === $scope.viewStates.OBJECT_ATTRIBUTE;
        };

        $scope.showGuid = function(gideUrl){
            $scope.$parent.OrchestrationRulesText = "Guide";
            if(!($scope.isStateGuid() || $scope.isStateWorkload())){
              $scope.saveRuleStateOnMenuSelection = $scope.currentState;
            }
            console.log("showGuid "+$scope.saveRuleStateOnMenuSelection);
            $scope.broadcastevent({event:"guideUrlChnaged",args:{url:gideUrl}});
            $scope.setCurrentState($scope.viewStates.GUID);    
        };

        $scope.showWorkload = function(){

            if(!($scope.isStateGuid() || $scope.isStateWorkload())){
              $scope.saveRuleStateOnMenuSelection = $scope.currentState;
            }
            console.log("showWorkload "+$scope.saveRuleStateOnMenuSelection);
            $scope.setCurrentState($scope.viewStates.WORK_LOAD);    
        };

        $scope.restoreRule = function(){
           if($scope.saveRuleStateOnMenuSelection != -1){
            console.log("restoreRule "+$scope.saveRuleStateOnMenuSelection);
            $scope.setCurrentState($scope.saveRuleStateOnMenuSelection);  
           }
        };

        $scope.showCreateNewRule = function(){
            $scope.setCurrentState($scope.viewStates.CREATE_NEW_RULE);
             $scope.disableSave = true;
             $scope.enableSave();
        };

        $scope.showInitNewRule = function(entities){
            if(entities) {
                $scope.setEntitiesMesage(entities);
                $scope.initEntityCount = entities.length;
            } else {
              $scope.newSoRule = new SORule();
            }
            $scope.setCurrentState($scope.viewStates.INITIAL_NEW_RULE);
             $scope.disableSave = true;    
        };

        $scope.showRuleList = function(){
            $scope.setCurrentState($scope.viewStates.LIST_RULES);    
        };

        $scope.showEditRule = function(){
            $scope.setCurrentState($scope.viewStates.EDIT_RULES);    
        };

        $scope.showObjectAttribute = function(){
            $scope.setCurrentState($scope.viewStates.OBJECT_ATTRIBUTE);    
        };

        $scope.cancelCreateNewRule = function(){
           $scope.returnToPreviousState();
        };

        $scope.setEntitiesMesage = function(entities) {
            $scope.entityCounter = {};
            $scope.entityCounter.NETWORK=0;
            $scope.entityCounter.WORKLOAD=0;
            var networkCountMessage = '';
            var workloadCountMessage = '';
            var joinMessage = '';
            $scope.notmixedtype = false;
            _.each(entities, function(entity) {
                
                if(entity.type === SORule.ruleAttribute.NETWORK.link) {
                    $scope.entityCounter.NETWORK++;
                } else if (entity.type === SORule.ruleAttribute.WORKLOAD.link) {
                    $scope.entityCounter.WORKLOAD++;
                }
            });
            if($scope.entityCounter.NETWORK > 0 && $scope.entityCounter.WORKLOAD > 0){
                $scope.notmixedtype = true;
            }
            if($scope.entityCounter.NETWORK > 0) {
                networkCountMessage = $scope.entityCounter.NETWORK + 
                        " Network"  + 
                        (($scope.entityCounter.NETWORK > 1 ) ? "s" : "" );
            }
            if($scope.entityCounter.WORKLOAD > 0) {
                workloadCountMessage = $scope.entityCounter.WORKLOAD + 
                        " Workload" + 
                        (($scope.entityCounter.WORKLOAD > 1 ) ? "s" : "" );
            }
            if(networkCountMessage !== '' && workloadCountMessage  !== '') {
                joinMessage = " & ";
            }
            $scope.entityInitScreenMessage = networkCountMessage +  " " + joinMessage + " " + workloadCountMessage + " " + " selected";
        };

        $scope.$on('sandboxModeToggled', function (event, sandboxMode) {
            if (!sandboxMode) {
              $scope.cancelCreateNewRule();
            }
        });
        $scope.returnToPreviousState = function(){
            if($scope.isStateEditRules() || $scope.isStateCreateNewRule() || $scope.isObjectAttribute() || $scope.isStateGuid()){
                if($scope.isStateGuid()){
                    $scope.$parent.OrchestrationRulesText = "Orchestration Rules";
                    $scope.setCurrentState($scope.previousState);
                }else if($scope.rulesArray.length > 0)
                {
                  $scope.showRuleList();
                }else{
                  $scope.setCurrentState($scope.viewStates.INITIAL_NEW_RULE);
                }
            }
          /* if($scope.previousState !== -1) {
             $scope.setCurrentState($scope.previousState);
           }*/
        };

        $scope.initState = function(){
          $scope.previousState = -1;
          if($scope.currentState ===  $scope.viewStates.INITIAL_NEW_RULE || $scope.currentState === -1){
            if(!$scope.rulesArray){
               $scope.setCurrentState($scope.viewStates.INITIAL_NEW_RULE); 
            } else {
                if($scope.rulesArray.length > 0)
                {
                  $scope.showRuleList();
                }else{
                  $scope.setCurrentState($scope.viewStates.INITIAL_NEW_RULE);
                }
            }
          }
          
            
        };
        
        $scope.$on('onCreateNewRuleClicked', function (event, args) {
            $scope.onCreateNewRuleClicked();
        });

        $scope.onCreateNewRuleClicked = function(){
               $scope.setSandboxState(true);
               $scope.showCreateNewRule();
               $scope.$broadcast('createNewRuleClick');
               if(!$scope.newSoRule.ruleDesc.length)
                $scope.newSoRule.addSORuleDesc(new SORuleDesc());//we need to initialise the new SORuleDesc prototype instead of Object Type
        };
        $scope.showCreateNewRuleMergeWorkload = function(){
          //clear all the networks in the selected network and add the workloads of these networks
         /* _.each($scope.newSoRule.ruleDesc,function(singleDesc){
            //check if it is a network based rule, then clear the network data and add the workload of that network
            if(singleDesc.ruleAttribute == "0"){

            }
          });*/
          var updateNetworkArray = [];
          for (var i = $scope.newSoRule.ruleDesc.length - 1; i >= 0; i--) {
            var currentDesc = $scope.newSoRule.ruleDesc[i];
            if(currentDesc.ruleAttribute == "0"){
              updateNetworkArray = _.unionWith(updateNetworkArray,currentDesc.networks);
              $scope.newSoRule.ruleDesc.splice(i,1);
            }
          }
          $scope.$emit('addWorkloadsofNetworks',{'networks':updateNetworkArray});
          console.log("the existing rule present is ",$scope.newSoRule);
          $scope.setSandboxState(true);
          $scope.showCreateNewRule();
        };
        $scope.onCancelClicked = function(){
            $scope.initEntityCount = 0;
            $scope.broadcastevent({event:SOEvents.newRuleCreationCanceledEvent, args:{rule:$scope.newSoRule}});
            $scope.newSoRule = new SORule();
            console.log($scope.newSoRule);
            $scope.returnToPreviousState();
        };

        $scope.onCreateRuleClicked = function(){
          var tempRule = angular.copy($scope.newSoRule);
          

          if(tempRule.ruleDesc[0].ruleAttribute == "0"){
              $scope.newSoRule.ruleDesc.length = 0;
             setNetworksbyCriteria(tempRule,1);
             $scope.broadcastevent({event:SOEvents.ruleCreatedEvent, args:{rule:$scope.newSoRule}});
           } else if(tempRule.ruleDesc[0].ruleAttribute == "1") {
            $scope.newSoRule.ruleDesc.length = 0;
              _.each(tempRule.ruleDesc,function(singleDesc){
                    $scope.createNewRule(singleDesc.networkSpec, [], SORule.matchingCritarias.IS.id,"CIDR");
              });
           } else if(tempRule.ruleDesc[0].ruleAttribute == "2") {
              $scope.newSoRule.ruleDesc.length = 0;
              setNetworksbyCriteria(tempRule,1, 'WORKLOAD');
              //$scope.$emit('newruleaddedworkload',{rule:$scope.newSoRule});
              $scope.broadcastevent({event:SOEvents.ruleCreatedEvent, args:{rule:$scope.newSoRule,type:'WORKLOAD'}});
           } else if((tempRule.ruleDesc[0].ruleAttribute == "3")){
              $scope.newSoRule.ruleDesc.length = 0;
              setNetworksbyFilter(tempRule,1,"application");
              $scope.broadcastevent({event:SOEvents.ruleCreatedEvent, args:{rule:$scope.newSoRule,type:'WORKLOAD'}});
              
           } else if((tempRule.ruleDesc[0].ruleAttribute == "4")){
              $scope.newSoRule.ruleDesc.length = 0;
              setNetworksbyFilter(tempRule,1,"os");
              $scope.broadcastevent({event:SOEvents.ruleCreatedEvent, args:{rule:$scope.newSoRule,type:'WORKLOAD'}});
           }


           $scope.newSoRule.workloadsSecured = tempRule.workloadsSecured;
           console.log("Newly created rule is this ",$scope.newSoRule);
           $scope.addNewRuleToList();
           $scope.showRuleList();
           $scope.broadcastevent({event:"ClearSelections", args:{rule:$scope.newSoRule}});
           $scope.$parent.ruleChanged = true;
        };

        $scope.$on("externalInternalRuleCreation",function(event,args){    
              console.log(args);    
              $scope.newSoRule = args.data;   
              $scope.setDefaultSps($scope.newSoRule);   
              $scope.setSandboxState(true);   
              $scope.onCreateRuleClicked();   
          });   
        $scope.setDefaultSps = function(rule){    
              rule.aspInfo.id = $scope.noneSpsPolicy.id;    
              rule.aspInfo.name = $scope.noneSpsPolicy.name;    
          };
        function setNetworksbyCriteria(ruleObj,type, entityType){
            var searchEntity = null;
            if(entityType === "WORKLOAD") {
                searchEntity = $scope.workloads;
            } else {
                searchEntity = $scope.networksavailable;
            }
            ruleObj.workloadsSecured = 0;
          _.each(ruleObj.ruleDesc,function(singleDesc){
                console.log("Single Rule Desc ",singleDesc);
                if(singleDesc.matchingCritaria === "1"){
                  var alreadypresent = _.find($scope.newSoRule.ruleDesc,{"name":singleDesc.networkSpec});
                  if(typeof alreadypresent === 'undefined'){
                    var matchedValue = _.find(searchEntity,{"name":singleDesc.networkSpec});
                    if(typeof matchedValue !== "undefined"){
                      if(type === 1)
                        $scope.createNewRule(singleDesc.networkSpec, [matchedValue], SORule.matchingCritarias.IS.id, entityType);
                      else if(type === 2)
                        $scope.updateRule(singleDesc.networkSpec, [matchedValue], SORule.matchingCritarias.IS.id, entityType);
                      if(entityType === "WORKLOAD"){
                        ruleObj.workloadsSecured++;
                      } else{
                        ruleObj.workloadsSecured += matchedValue.workloads.length;
                      }
                  } else {
                      if(type === 1)
                        $scope.createNewRule(singleDesc.networkSpec, [], SORule.matchingCritarias.IS.id, entityType);
                      else if(type === 2)
                        $scope.updateRule(singleDesc.networkSpec, [], SORule.matchingCritarias.IS.id, entityType);
                  }
                } 
              } else if(singleDesc.matchingCritaria === "2") {
                var matchedNetworks = [];
                _.each(searchEntity,function(singleNetwork){
                    if(singleNetwork.name.toLowerCase().indexOf(singleDesc.networkSpec.toLowerCase()) !== -1){
                          matchedNetworks.push(singleNetwork);
                          if(entityType === "WORKLOAD"){
                            ruleObj.workloadsSecured++;
                          } else{
                            ruleObj.workloadsSecured += singleNetwork.workloads.length;
                          }
                    }
                });
                if(type === 1)
                  $scope.createNewRule(singleDesc.networkSpec, matchedNetworks, SORule.matchingCritarias.CONTAINS.id, entityType);
                else if(type === 2)
                  $scope.updateRule(singleDesc.networkSpec, matchedNetworks, SORule.matchingCritarias.CONTAINS.id, entityType);
              } else if(singleDesc.matchingCritaria === "3") {
                var matchedNetworksStarts = [];
                _.each(searchEntity,function(singleNetwork){
                    if(singleNetwork.name.toLowerCase().indexOf(singleDesc.networkSpec.toLowerCase()) === 0){
                          matchedNetworksStarts.push(singleNetwork);
                          if(entityType === "WORKLOAD"){
                            ruleObj.workloadsSecured++;
                          } else{
                            ruleObj.workloadsSecured += singleNetwork.workloads.length;
                          }
                    }
                });
                if(type === 1)
                  $scope.createNewRule(singleDesc.networkSpec, matchedNetworksStarts, SORule.matchingCritarias.BEGIN_WITH.id, entityType);
                else if(type === 2)
                  $scope.updateRule(singleDesc.networkSpec, matchedNetworksStarts, SORule.matchingCritarias.BEGIN_WITH.id, entityType);
              }
          });
        }

        function setNetworksbyFilter(ruleObj,type,attributeType){
            var searchEntity = $scope.workloads;
            var  entityType = attributeType;
            var i,currentWorkload,matchedValue,j;
            ruleObj.workloadsSecured = 0;
          _.each(ruleObj.ruleDesc,function(singleDesc){
                if(singleDesc.matchingCritaria === "1"){
                  var alreadypresent = _.find($scope.newSoRule.ruleDesc,{"name":singleDesc.networkSpec});
                  var matchedWorkloadArray = [];
                  if(typeof alreadypresent === 'undefined'){
                      for(i=0;i<searchEntity.length;i++){
                        currentWorkload = searchEntity[i];
                        /*matchedValue = _.find(searchEntity[i].ports[0].attributes,{"name":singleDesc.networkSpec,"type":attributeType}); 
                        if(typeof matchedValue !== "undefined"){
                          matchedWorkloadArray.push(currentWorkload);
                        }*/
                        for(j = 0;j < searchEntity[i].ports[0].attributes.length;j++){
                          var singleAttribute2 = searchEntity[i].ports[0].attributes[j];
                          if((singleAttribute2.name.toLowerCase() === singleDesc.networkSpec.toLowerCase() ) && (singleAttribute2.type === attributeType)){
                            matchedWorkloadArray.push(currentWorkload);
                            ruleObj.workloadsSecured++;
                            break;
                          }
                        }
                      }
                    }
                    if(type === 1)
                      $scope.createNewRule(singleDesc.networkSpec, matchedWorkloadArray, SORule.matchingCritarias.IS.id, entityType);
                    else if(type === 2)
                      $scope.updateRule(singleDesc.networkSpec, matchedWorkloadArray, SORule.matchingCritarias.IS.id, entityType);
              } else if(singleDesc.matchingCritaria === "2") {
                var containsMatchedWorkloads = [];
                /*_.each(searchEntity,function(singleNetwork){
                    if(singleNetwork.name.toLowerCase().indexOf(singleDesc.networkSpec.toLowerCase()) !== -1){
                          containsMatchedWorkloads.push(singleNetwork);
                    }
                });*/
                for(i=0;i<searchEntity.length;i++){
                    currentWorkload = searchEntity[i];
                    /*matchedValue = _.find(searchEntity.ports[0].attributes,function(singleAttribute){
                      return (singleAttribute.name.toLowerCase().indexOf(singleDesc.networkSpec.toLowerCase()) !== -1) && (singleAttribute.type === attributeType);
                  }); 
                  if(typeof matchedValue !== "undefined"){
                    containsMatchedWorkloads.push(currentWorkload);
                  }*/
                  for(j = 0;j < searchEntity[i].ports[0].attributes.length;j++){
                      var singleAttribute1 = searchEntity[i].ports[0].attributes[j];
                      if((singleAttribute1.name.toLowerCase().indexOf(singleDesc.networkSpec.toLowerCase()) !== -1) && (singleAttribute1.type === attributeType)){
                          containsMatchedWorkloads.push(currentWorkload);
                          ruleObj.workloadsSecured++;
                          break;
                      }
                    }
                }
                if(type === 1)
                  $scope.createNewRule(singleDesc.networkSpec, containsMatchedWorkloads, SORule.matchingCritarias.CONTAINS.id, entityType);
                else if(type === 2)
                  $scope.updateRule(singleDesc.networkSpec, containsMatchedWorkloads, SORule.matchingCritarias.CONTAINS.id, entityType);
              } else if(singleDesc.matchingCritaria === "3") {
                var matchedWorkloadsStarts = [];
                for(i=0;i<searchEntity.length;i++){
                  currentWorkload = searchEntity[i];
                  for(j = 0;j < searchEntity[i].ports[0].attributes.length;j++){
                      var singleAttribute = searchEntity[i].ports[0].attributes[j];
                      if((singleAttribute.name.toLowerCase().indexOf(singleDesc.networkSpec.toLowerCase()) === 0) && (singleAttribute.type === attributeType)){
                          matchedWorkloadsStarts.push(currentWorkload);
                          ruleObj.workloadsSecured++;
                          break;
                      }
                    }
                  }
                if(type === 1)
                  $scope.createNewRule(singleDesc.networkSpec, matchedWorkloadsStarts, SORule.matchingCritarias.BEGIN_WITH.id, entityType);
                else if(type === 2)
                  $scope.updateRule(singleDesc.networkSpec, matchedWorkloadsStarts, SORule.matchingCritarias.BEGIN_WITH.id, entityType);
              }
          });
        }

        $scope.onSaveRuleClicked = function(){
              var tempRule = angular.copy($scope.inmemoryRule);
              if($scope.inmemoryRule !== null){
               
                if($scope.inmemoryRule.equal($scope.editSoRule)){
                   $scope.inmemoryRule.dirty = false;
                  
                } else{
                  if(tempRule.ruleDesc[0].ruleAttribute == "0"){
                    $scope.broadcastevent({event:"deleteOldNetworks", args:{rule:$scope.editSoRule}});
                    $scope.inmemoryRule.ruleDesc.length = 0;
                    setNetworksbyCriteria(tempRule,2);
                  } else if(tempRule.ruleDesc[0].ruleAttribute == "1") {
                    $scope.inmemoryRule.ruleDesc.length = 0;
                    _.each(tempRule.ruleDesc,function(singleDesc){
                          $scope.updateRule(singleDesc.networkSpec, [], SORule.matchingCritarias.IS.id,"CIDR");
                    });
                 }
                 else if(tempRule.ruleDesc[0].ruleAttribute == "2") {
                    $scope.broadcastevent({event:"deleteOldNetworks", args:{rule:$scope.editSoRule,type:'WORKLOAD'}});
                    $scope.inmemoryRule.ruleDesc.length = 0;
                    setNetworksbyCriteria(tempRule,2, 'WORKLOAD');
                 } else if(tempRule.ruleDesc[0].ruleAttribute == "3"){
                  $scope.broadcastevent({event:"deleteOldNetworks", args:{rule:$scope.editSoRule,type:'WORKLOAD'}});
                    $scope.inmemoryRule.ruleDesc.length = 0;
                  setNetworksbyFilter(tempRule,2,"application");
                 } else if(tempRule.ruleDesc[0].ruleAttribute == "4"){
                  $scope.broadcastevent({event:"deleteOldNetworks", args:{rule:$scope.editSoRule,type:'WORKLOAD'}});
                    $scope.inmemoryRule.ruleDesc.length = 0;
                  setNetworksbyFilter(tempRule,2,"os");
                 }
                  tempRule.dirty = true;
//                  if($scope.inmemoryRule.inline !== $scope.editSoRule.inline){
//                    $scope.inmemoryRule.dirty = false;
//                  } else if(!$scope.inmemoryRule.aspInfo.equal($scope.editSoRule.aspInfo)){
//                    $scope.inmemoryRule.dirty = false;
//                  }
                  $scope.$emit('inmemoryRuleSet',tempRule);
                }

                $scope.editSoRule.init($scope.inmemoryRule);
                $scope.editSoRule.workloadsSecured = tempRule.workloadsSecured;
                //$scope.editSoRule.init(tempRule);
                //when only SPS is changed the rule remains same,hence to fire event outside equal check
                if(tempRule.ruleDesc[0].ruleAttribute == "0"){
                  $scope.broadcastevent({event:SOEvents.ruleUpdatedEvent, args:{rule:$scope.inmemoryRule}});
                } else if(tempRule.ruleDesc[0].ruleAttribute >= "2") {
                  $scope.broadcastevent({event:SOEvents.ruleUpdatedEvent, args:{rule:$scope.inmemoryRule,type:'WORKLOAD'}});
                }
              }
              
              $scope.$parent.ruleChanged = true;
              $scope.$parent.lastShownRule = $scope.editSoRule;
              $scope.showRuleList();
              $scope.broadcastevent({event:"ClearSelections", args:{rule:$scope.editSoRule}});
        };
        $scope.onCancelEditClicked = function(){
          if($scope.isStateEditRules()){
           $scope.broadcastevent({event:SOEvents.ruleEditCanceledEvent, args:{rule:$scope.inmemoryRule}}); 
          }else{
            $scope.broadcastevent({event:SOEvents.ruleEditCanceledEvent, args:{rule:$scope.newSoRule}});
          }
            
           if($scope.configinfo.mode !== 'edit_rc'){
              $scope.inmemoryRule = null; 
              $scope.newSoRule = new SORule();
           } 
           $scope.returnToPreviousState();
        };
        $scope.addNewRuleToList = function(){
            var sameRuleFlag = false;
            _.each($scope.rulesArray, function (existingRule) {
               existingRule.precedence++;
               existingRule.dirty = true;
               if(existingRule.aspInfo.id === '' && existingRule.aspInfo.name === ''){    
                    $scope.setDefaultSps(existingRule);   
                  }
                if(existingRule.groupInfo.name === $scope.newSoRule.groupInfo.name) {
                    _.each($scope.newSoRule.ruleDesc, function(NewRuleDesc) {
                        if(!_.find(existingRule.ruleDesc, {"networkSpec": NewRuleDesc.networkSpec})) {
                            existingRule.ruleDesc.push(NewRuleDesc);
                        }
                    });
                    sameRuleFlag = true;
                    return false;
                }
            });
            if(!sameRuleFlag) {
                $scope.rulesArray.push($scope.newSoRule);
            }
            console.log("added rule to the list here : :");
            console.log($scope.rulesArray);
            $scope.newSoRule.precedence = 1;
            $scope.$parent.lastShownRule = $scope.newSoRule; // copy down the last created rule
            $scope.newSoRule = new SORule();
        };
        
        $scope.$on('editClicked', function (event, args) {
          $scope.editSoRule = args;
          $scope.broadcastevent({event:"EditRuleClicked", args:{rule:args}});
          $scope.inmemoryRule = $scope.editSoRule.clone();
          $scope.inmemoryRule.dirty = true;
          $scope.showEditRule();
        });
      $scope.$on("onTotalDeleteStateChange",function(event,args){
          console.log("these are the total rules ",$scope.secrules);
          var tempRule = args.rule;
          _.each($scope.secrules,function(singleRule){
            if(singleRule.precedence > tempRule.precedence){
                singleRule.precedence--;
                singleRule.dirty = true;
            }
          });
          tempRule.precedence = $scope.secrules.length;
          tempRule.dirty = true;
          $scope.$parent.ruleChanged = true;
          $scope.showRuleList();
      });
       $scope.$on("resourceGroupModeNetworks",function(event,args){
          $scope.editSoRule = args;
          $scope.inmemoryRule = $scope.editSoRule.clone();
          $scope.inmemoryRule.dirty = true;
       });
       $scope.enableSave = function(){
          if($scope.isStateCreateNewRule()){
            var newRule = $scope.newSoRule;
            if(newRule.groupInfo.name !== "" ){
              if($scope.configinfo.showSps === true){
                 if(newRule.aspInfo.name !== "") {
                   $scope.disableSave = false;
                 }
              }else{
                  $scope.disableSave = false;
              }
            }
          }
          //$scope.$broadcast('checkMainForm',{});
        };
        $scope.invalidForm = true;
        $scope.$on('mainformvalidityChanged',function(event,args){
          //if form is valid  (true) set disable to false and vice-versa
          $scope.invalidForm = !args.validity;
        });

        $scope.createNewRule = function(pattern, entities, matchingCritaria,typeofRule)
        {
              if($scope.newSoRule === null){
                 $scope.newSoRule = new SORule();
              }
              $scope.newSoRule.dirty = true;
               var ruleDesc = new SORuleDesc();
               if(typeof typeofRule == "undefined" || typeofRule == "NETWORK")
                  ruleDesc.ruleAttribute = SORule.ruleAttribute.NETWORK.id;
               else if(typeofRule == "CIDR")
                  ruleDesc.ruleAttribute = SORule.ruleAttribute.CIDR.id;
               else if(typeofRule == "WORKLOAD")
                  ruleDesc.ruleAttribute = SORule.ruleAttribute.WORKLOAD.id;
               else if(typeofRule == "application")
                ruleDesc.ruleAttribute = SORule.ruleAttribute.WORKLOAD_APP.id;
               else if(typeofRule == "os")
                ruleDesc.ruleAttribute = SORule.ruleAttribute.WORKLOAD_OS.id;
               ruleDesc.matchingCritaria = matchingCritaria; 
               ruleDesc.networkSpec = pattern;
               ruleDesc.precedence = 1;
               ruleDesc.networks = [];
               for(var i = 0; i < entities.length; i++){
                 var network = entities[i];
                 var networkInfo = new NetworkInfo();
                 networkInfo.id = network.id; 
                 networkInfo.name = network.name;
                 ruleDesc.networks.push(networkInfo);
               } 
               $scope.newSoRule.addSORuleDesc(ruleDesc);
        }; 

        $scope.updateRule = function(pattern, networks, matchingCritaria,typeofRule)
        {
                       
               var ruleDesc = new SORuleDesc();
               if(typeof typeofRule == "undefined" || typeofRule == "NETWORK")
                  ruleDesc.ruleAttribute = SORule.ruleAttribute.NETWORK.id;
               else if(typeofRule == "CIDR")
                  ruleDesc.ruleAttribute = SORule.ruleAttribute.CIDR.id;
               else if(typeofRule == "WORKLOAD")
                  ruleDesc.ruleAttribute = SORule.ruleAttribute.WORKLOAD.id;
               else if(typeofRule == "application")
                  ruleDesc.ruleAttribute = SORule.ruleAttribute.WORKLOAD_APP.id;
               else if(typeofRule == "os")
                  ruleDesc.ruleAttribute = SORule.ruleAttribute.WORKLOAD_OS.id;
               ruleDesc.matchingCritaria = matchingCritaria; 
               ruleDesc.networkSpec = pattern;
               ruleDesc.networks = [];
               for(var i = 0; i < networks.length; i++){
                 var network = networks[i];
                 var networkInfo = new NetworkInfo();
                 networkInfo.id = network.id; 
                 networkInfo.name = network.name;
                 ruleDesc.networks.push(networkInfo);
               }
               if($scope.inmemoryRule){
                $scope.inmemoryRule.addSORuleDesc(ruleDesc);
               }
               
        }; 


        $scope.registeInitrCallback($scope.initState);
        
        $scope.$on("playButtonClick",function(event,args){
          args.op = "selected";
          console.log("play action start ");
          console.dir(args);
          $scope.$parent.attributeDetailsView = false;
          $scope.$parent.onOrchestrationRulesSelected();
          $scope.$parent.setSandboxState(true);
          $scope.createRulebasedOnSelection(args);
          $scope.showCreateNewRule();
        });
        $scope.createRulebasedOnSelection = function(args) {
            var name = "";
            if (args.op === "selected") {
                if (typeof args.selectedEntities !== "undefined" && args.selectedEntities.length > 0) {
                    if(!$scope.newSoRule.aspInfo.name && !$scope.newSoRule.groupInfo.name )
                      $scope.newSoRule = new SORule();
                    _.each(args.selectedEntities, function (selectedEntity) {
                        $scope.createNewRule(selectedEntity.name, [selectedEntity], SORule.matchingCritarias.IS.id, selectedEntity.type);
                    });
//                    name = args.selectedNetworks[args.selectedNetworks.length - 1].name;
//                    var networks = [args.selectedNetworks[args.selectedNetworks.length - 1]];
//                    $scope.createNewRule(name, networks, SORule.matchingCritarias.IS.id);
                } else {
                    if($scope.newSoRule.ruleDesc.length > 0){
                      $scope.setCurrentState($scope.viewStates.LIST_RULES);
                    }else{
                      $scope.setCurrentState($scope.viewStates.INITIAL_NEW_RULE);
                      $scope.newSoRule = new SORule();
                    }
                    
                }
                
            } else if (args.op === "searched") {
              if(!$scope.newSoRule.aspInfo.name && !$scope.newSoRule.groupInfo.name)
                $scope.newSoRule = new SORule();
                _.each(args.searchText, function (name) {
//                name = args.searchText;
                    $scope.createNewRule(name, args.selectedEntities, SORule.matchingCritarias.CONTAINS.id );
                });
            }
        };

        $scope.upadateRulebasedOnSelection = function(args) {
            for(var i = ($scope.inmemoryRule.ruleDesc.length -1);i>=0;i--) {
              var singleDesc = $scope.inmemoryRule.ruleDesc[i];
                if((!!!singleDesc.matchingCritaria) || (!!!singleDesc.networkSpec)){
                  $scope.inmemoryRule.ruleDesc.splice(i,1);
                }
            }
            var name = "";
            if (args.op === "selected") {
                name = args.selectedEntities[args.selectedEntities.length-1].name;
                var networks = [args.selectedEntities[args.selectedEntities.length-1]];
                 $scope.updateRule(name, networks, SORule.matchingCritarias.IS.id);
                
            } else if (args.op === "searched") {
                name = args.searchText[0];
                $scope.updateRule(name, args.selectedNetworks, SORule.matchingCritarias.CONTAINS.id );
            }
        };

        $scope.$on('networkSelectionChanged', function(event, args) {
            console.log(" securityOrchestrationRightpanelDirective onNetworkSelectionChanged  >>>> ");
            console.dir(args);
            console.log($scope.configinfo);
             if(typeof args.removeNetork  !== 'undefined' && args.removeNetork  !== '' && $scope.inmemoryRule !== null){
                _.remove($scope.inmemoryRule.ruleDesc,function(item){
                  return item.networkSpec == args.removeNetork.name;
                });
              }else if($scope.configinfo.mode === 'edit_rc' && args.selectedNetworks.length >0 && !$scope.isStateEditRules()){
                $scope.showEditRule();
                $scope.upadateRulebasedOnSelection(args);
            }else if($scope.isStateEditRules()){
                $scope.upadateRulebasedOnSelection(args);   
            } else if (args.selectedNetworks.length === 0){
                $scope.showInitNewRule();
            } else {
                if ($scope.isStateInitialNewRule()) {
                    //$scope.showInitNewRule("Network", args.selectedNetworks.length);
                    $scope.showInitNewRule(args.selectedNetworks);
                } else {
                    $scope.showCreateNewRule();
                }
                $scope.createRulebasedOnSelection(args);
            }
        });

        $scope.$on('entitySelectionChanged', function(event, args) {
            console.log(" securityOrchestrationRightpanelDirective onNetworkSelectionChanged  >>>> ");
            console.dir(args);
            console.log($scope.configinfo);
             if(typeof args.removeEntity  !== 'undefined' && args.removeEntity  !== '' && $scope.inmemoryRule !== null){
                _.remove($scope.inmemoryRule.ruleDesc,function(item){
                    // need to add check
                  return item.networkSpec == args.removeEntity.name;
                });
              }else if($scope.configinfo.mode === 'edit_rc' && args.selectedEntities.length >0 && !$scope.isStateEditRules()){
                   // need to add check
                $scope.showEditRule();
                $scope.upadateRulebasedOnSelection(args);
            }else if($scope.isStateEditRules()){
                 // need to add check
                $scope.upadateRulebasedOnSelection(args);   
            } else if (args.selectedEntities.length === 0 && !$scope.rulesArray.length){
                $scope.newSoRule = new SORule();
                $scope.showInitNewRule();
            }  else if (args.selectedEntities.length === 0 && $scope.rulesArray.length){
                $scope.newSoRule = new SORule();
                $scope.showRuleList();
            } else {
//                if ($scope.isStateInitialNewRule()) {
                    $scope.showInitNewRule(args.selectedEntities);
//                } else {
//                    $scope.showCreateNewRule();
//                }
                $scope.createRulebasedOnSelection(args);
            }
            if(!args.selectedEntities.length)
              $scope.initEntityCount = 0;
        });


        $scope.$on('workloadSelectionChanged', function(event, args) {
            console.log(" securityOrchestrationRightpanelDirective onNetworkSelectionChanged  >>>> ");
            console.dir(args);
            console.log($scope.configinfo);
             if(typeof args.removeWorkload  !== 'undefined' && args.removeWorkload  !== '' && $scope.inmemoryRule !== null){
                _.remove($scope.inmemoryRule.ruleDesc,function(item){
                  return item.networkSpec == args.removeWorkload.name;
                });
              }else if($scope.configinfo.mode === 'edit_rc' && args.selectedWorkloads.length >0 && !$scope.isStateEditRules()){
                $scope.showEditRule();
                $scope.upadateRulebasedOnSelection(args);
            }else if($scope.isStateEditRules()){
                $scope.upadateRulebasedOnSelection(args);   
            } else if (args.selectedWorkloads.length === 0){
                $scope.showInitNewRule();
            } else {
                if ($scope.isStateInitialNewRule()) {
                    $scope.showInitNewRule(args.selectedWorkloads);
                } else {
                    $scope.showCreateNewRule();
                }
                $scope.createRulebasedOnSelection(args);
            }
        });
        $scope.$on(SOEvents.noneSpsPolicy, function (event, args) {    
             $scope.noneSpsPolicy = args.asp;   
        });
        $scope.$on(SOEvents.spsChangeEvent, function (event, args) {
             $scope.enableSave();   
        }); 
        
        $scope.$on(SOEvents.groupChangeEvent, function (event, args) {
            $scope.enableSave();
        });   

        $scope.$on(SOEvents.popUpMenuSelectionChangeEvent, function (event, args) {
          switch(args.selection){
            case "orchestration-rules":
               $scope.restoreRule();
            break;
            case"work-attributes":
               $scope.showWorkload();
            break;
            case"guid":
               $scope.showGuid(args.guideUrl);
            break;
          }

        }); 

        $scope.showAtributeDataPane = false;
        $scope.attributeSrceenDetails = null;
        $scope.networkData = null;
        $scope.$on('showObjectDetail', function (event, objectData) {
            $scope.attributeSrceenDetails = objectData.data.val;
            $scope.attributeType = objectData.data.type;
            $scope.tenant = _.find($scope.tenants, { id : $scope.sectenantid});
            if($scope.attributeType === "WORKLOAD") {
                var networkId = $scope.attributeSrceenDetails.ports[0].networkId;
                $scope.networkData = angular.copy(_.find($scope.networksavailable, {id : networkId}));
                _.each($scope.rulesArray, function (rule) {
                    _.each(rule.ruleDesc, function (SORuleDesc) {
                            if (SORuleDesc.networkSpec === $scope.attributeSrceenDetails.name) {
                                $scope.attributeSrceenDetails.groupInfo = rule.groupInfo;
                                $scope.attributeSrceenDetails.aspInfo = rule.aspInfo;
                            }
                    });
                });
            } else if ($scope.attributeType === "NETWORK"){
                $scope.networkData = objectData.data.val;
                _.each($scope.rulesArray, function (rule) {
                    _.each(rule.ruleDesc, function (SORuleDesc) {
                        _.each(SORuleDesc.networks, function (network) {
                           if(network.id === $scope.networkData.id) {
                               $scope.attributeSrceenDetails.groupInfo =rule.groupInfo;
                               $scope.attributeSrceenDetails.aspInfo =rule.aspInfo;
                           }
                        });
                    });
                });
            }
            $scope.showObjectAttribute();
        });

        $scope.initDirective(); 
    }


    angular.module('shieldxApp').controller('manageOrchestrationRuleCtr', manageOrchestrationRuleCtr);


    function listRulesCtr($scope, $sessionStorage,resourceGroupService,coreservices){
       console.log("sessionStorage is ",$sessionStorage);
       //$scope.commitButtonText =  "Commit Rules "+"(2)";
       $scope.commitButtonText =  "COMMIT TO ACTIVE";
       $scope.creationCount = 0;
       $scope.showGroupCreationProgress = false;
       $scope.temporaryGroups = [];
       $scope.onCommitButtonClicked = function(){
        
        console.log(" commit button clicked >>>> ");
        console.dir($scope.rulesArray);
        
        $scope.creationCount = 0;
       $scope.showGroupCreationProgress = true; 
       $scope.creationCount = ($scope.rulesArray.length-1);   
        $scope.createResourceGroup();
       
       };
       $scope.$on("unsavedExistInIt",function(event,args){
        /* jshint ignore:start */
        for (var i = 0; i < $scope.temporaryGroups.length; i++) {
            var resourceGroupId = $scope.temporaryGroups[i];
            resourceGroupService.deleteGroupList(resourceGroupId,$scope.seccloudid).then(function(deRGa){
               console.log("fee hanging resource deleted  "+deRGa);
            });
          }
        /* jshint ignore:end */
       });
       /*function groupsCtr($scope, $mdDialog,groupdata){
          console.log("  groupsCtr ");
          
          $scope.hide = function (groupdata) {
              $mdDialog.hide(groupdata);
          };
          $scope.closeDialog = function () {
              $mdDialog.cancel();
          };
          $scope.closeDialogWithAnswer = function () {
              $scope.hide(groupdata);
          };
        }*/
       
       $scope.createResourceGroup = function() {
          console.log(" createResourceGroup ");
          console.log("   $scope.tenantIdChanged              2 "+$scope.tenantid);
          console.dir($scope.rulesArray); 
          if($scope.creationCount >= 0){
            var ruleRef = $scope.rulesArray[$scope.creationCount];
            console.log(ruleRef);
            var data = ruleRef.getJSONDataForPOST($scope.seccloudid, $scope.sectenantid);
            data.precedence = ($scope.rulesArray.length+1) - data.precedence;
            if(ruleRef.groupInfo.id === -1 && ! ruleRef.deleted){
              console.log("createResourceGroup ");
              console.dir(data); 
              resourceGroupService.createResourceGroup(data).then(function(newResourceId){
                coreservices.getmemberListofResourceGroup(newResourceId,$scope.seccloudid).then(function(resourceData){
                  console.dir(" resource group created success");
                  $scope.temporaryGroups.push(newResourceId);
                  console.log(" resource group data for this created thing ",resourceData);
                  //ruleRef.mergeExistingGroup(resourceData);
                  $scope.creationCount = $scope.creationCount - 1;
                  console.log("resourceGroup  ");
                  console.dir(ruleRef);
                  ruleRef.groupInfo.id = newResourceId;
                  ruleRef.id = newResourceId;
                  ruleRef.dirty = false;
                  $scope.broadcastevent({event:SOEvents.ruleCommitedEvent, args:{rule:ruleRef,op:"add"}}); 
                  $scope.createResourceGroup();
                });
              },function(error){
                if($scope.creationCount === 0)
                  $scope.showGroupCreationProgress = false;
                  $scope.creationCount = $scope.creationCount - 1;
                  $scope.createResourceGroup();
                });
            } else if(ruleRef.groupInfo.id !== -1 && ! ruleRef.deleted && ruleRef.dirty) {
              data.id = ruleRef.groupInfo.id;
              coreservices.getmemberListofResourceGroup(ruleRef.groupInfo.id,$scope.seccloudid).then(function(originalList){
                var originalRule = new SORule();
                originalRule.mergeExistingGroup(originalList);
                originalRule.resourceType = data.resourceType;
                $scope.broadcastevent({event:SOEvents.ruleCommitedEvent, args:{rule:originalRule,op:"deletePermanent"}}); 
                resourceGroupService.updateResourceGroup(data).then(function(data){
                  coreservices.getmemberListofResourceGroup(ruleRef.groupInfo.id,$scope.seccloudid).then(function(resourceData){
                    console.log(" resource group data for updated this thing ",resourceData);
                    ruleRef.mergeExistingGroup(resourceData);
                    console.dir(" resource group updated success",ruleRef); 
                    $scope.broadcastevent({event:SOEvents.ruleCommitedEvent, args:{rule:ruleRef,op:"add"}}); 
                    $scope.creationCount = $scope.creationCount - 1;
                    ruleRef.dirty = false;
                    $scope.createResourceGroup();
                  });
                },function(error){
                  if($scope.creationCount === 0)
                  $scope.showGroupCreationProgress = false;
                  $scope.creationCount = $scope.creationCount - 1;
                  $scope.createResourceGroup();
                });
              },function(error){
                  $scope.showGroupCreationProgress = false;
                });
            } else if(ruleRef.groupInfo.id !== -1 && ruleRef.deleted) {
                 data.id = ruleRef.groupInfo.id;
                 console.log("createResourceGroup deleted >> ");
                 coreservices.getSubscriptionListBelongToAGroup(ruleRef.groupInfo.id).then(function(vcData){
                 console.log(" Subscription to dilink from vc ");
                 console.dir(vcData);
                 if(vcData){
                      return coreservices.deletSubscriptionByID(vcData.id, $scope.seccloudid).then(function(delData){
                             console.log(" Subscription  dilinked from vc ");
                             console.dir(delData);
                             return resourceGroupService.deleteGroupList(data.id,$scope.seccloudid).then(function(deRG){
                                 console.log(" resource deleted after vc dilink  ");
                                 return deRG;
                             });
                      });
                  }
                  else
                  {
                     return resourceGroupService.deleteGroupList(data.id,$scope.seccloudid).then(function(deRGa){
                                 console.log("fee hanging resource deleted  ");
                                 return deRGa;
                     });
                  }
                 
                }).then(function(fiData){
                  $scope.broadcastevent({event:SOEvents.ruleCommitedEvent, args:{rule:ruleRef, op:"deletePermanent"}});                 
                  $scope.rulesArray.splice($scope.creationCount, 1);
                  ruleRef.deleted = true;
                  $scope.broadcastevent({event:SOEvents.ruleDeletedEvent, args:{ruleref: ruleRef}});
                  $scope.creationCount = $scope.creationCount - 1;
                  $scope.createResourceGroup();
                },function(error){
                  if($scope.creationCount === 0)
                    $scope.showGroupCreationProgress = false;
                  $scope.creationCount = $scope.creationCount - 1;
                  $scope.createResourceGroup();
                });
            } else if(ruleRef.groupInfo.id === -1 && ruleRef.deleted){
                    $scope.rulesArray.splice($scope.creationCount, 1);
                    $scope.creationCount = $scope.creationCount - 1;
                    $scope.createResourceGroup();
            } else{
               $scope.creationCount = $scope.creationCount - 1;
               $scope.createResourceGroup();
            }
               
           $scope.inmemoryRule = null;
          } else{
             console.log("all resource group created ");
             $scope.showGroupCreationProgress = false; 
             $scope.broadcastevent({event:SOEvents.ruleAllCommitedEvent, args:{}});
             $scope.$parent.$parent.ruleChanged = false;
          }
               
       };
    }

    angular.module('shieldxApp').controller('listRulesCtr', listRulesCtr);


    function guidCtr($scope, resourceGroupService, $translate){
        $scope.languageInUse = $translate.use();
        $scope.helpContentID = "virtualchassis_vieweditaddisecgroup_wizard";
        $scope.$on("guideUrlChnaged",function(event,args){
          $scope.helpContentID = args.url;
          $scope.helpContentURL = "help/"+$scope.languageInUse+"/"+$scope.helpContentID+".html";
        });
        $scope.helpContentURL = "help/"+$scope.languageInUse+"/"+$scope.helpContentID+".html";
    }

    angular.module('shieldxApp').controller('guidCtr', guidCtr);

    function workLoadCtr($scope, resourceGroupService){
       
       
    }

    angular.module('shieldxApp').controller('workLoadCtr', workLoadCtr);

    function objectAttributeCtr($scope, resourceGroupService){
       $scope.createRuleByplay = function(argsObj){
          console.log("this is the received obj ",argsObj);
          argsObj.selectedEntities[0].type = argsObj.type;
          $scope.broadcastevent({event:"playButtonClick", args:argsObj});
       };
    }

    angular.module('shieldxApp').controller('objectAttributeCtr', objectAttributeCtr);

    function groupsCtr($scope, $mdDialog,groupdata){
          console.log("  groupsCtr ");
          $scope.isSearchBarOpen = false;
          $scope.selected = [];
          $scope.groupdata = groupdata;
          _.each($scope.groupdata,function(singleGroup){
              singleGroup.rulesCriteria = getCriteriaFromRegex(singleGroup.regex);
          });
          console.log($scope.groupdata);
          $scope.toggleSearchBar = function(event) {
            $scope.isSearchBarOpen = $scope.isSearchBarOpen === false ? true : false;
            if ($scope.isSearchBarOpen)
                angular.element(event.currentTarget.firstElementChild).css('color', '#4a90e2');
            else
                angular.element(event.currentTarget.firstElementChild).css('color', '#6d6e71');
          };
          
          $scope.cancelDialog = function () {
              $mdDialog.cancel();
          };
          $scope.applyDialog = function () {
              $mdDialog.hide($scope.selected);
          };
          function getCriteriaFromRegex(regEx){
              var res = regEx.substring(6, regEx.length-2);
              var conditionArray = res.split(").*|(");
              console.log("condition is ",conditionArray);
              var containCriteriaString = "";
              var startsCriteriaString = "";
              var equalCriteriaString = "";
              var remainingCriterias = [];
              var startsCriteriaArray = [];
              var equalCriteriaArray = [];
              var containCriteriaArray = [];
              //string matches contains criteria if length is 2 else no contains criteria is set
              if(conditionArray.length == 2){
                containCriteriaString = conditionArray[0].substring(3,conditionArray[0].length);
                console.log("contains criteria string is ",containCriteriaString);
                containCriteriaArray = containCriteriaString.split("|");
                console.log("contains criteria selected are ",containCriteriaArray);
                remainingCriterias = conditionArray[1].split(")|(");
                console.log("remaining criteria ",remainingCriterias);
                //remaining criteria is 2 if equal and start both are present
                  
              } else {
                remainingCriterias = conditionArray[0].split(")|(");
                console.log("remaining criteria ",remainingCriterias);
              }
              if(remainingCriterias.length == 2){
                equalCriteriaArray = remainingCriterias[0].split("|");
                console.log(equalCriteriaArray);
                startsCriteriaString = remainingCriterias[1].substring(0,remainingCriterias[1].length-3);
                console.log("starts criteria ",startsCriteriaString);
                startsCriteriaArray = startsCriteriaString.split("|");
                console.log("start criteria array ",startsCriteriaArray);
              } else {
                //presence of ").*" indicates begins with criteria is present
                if(remainingCriterias[0].indexOf(").*") !== -1){
                    startsCriteriaString = remainingCriterias[0].substring(0,remainingCriterias[0].length-3);
                    console.log("starts criteria single ",startsCriteriaString);
                    startsCriteriaArray = startsCriteriaString.split("|");
                    console.log("start criteria array single ",startsCriteriaArray);
                  } else {
                    equalCriteriaString = remainingCriterias[0].substring(1,remainingCriterias[0].length-1);
                    console.log("equal criteria single ",equalCriteriaString);
                    equalCriteriaArray = equalCriteriaString.split("|");
                    console.log("equal criteria array single ",equalCriteriaArray);
                  }
              }
              return {"equal":equalCriteriaArray,"begins":startsCriteriaArray,"contains":containCriteriaArray};
          }
        }
    angular.module('shieldxApp').controller('groupsCtr', groupsCtr);

})();

function SOEvents(){
}

SOEvents.newRuleCreationCanceledEvent = "newRuleCreationCanceledEvent";
SOEvents.ruleDeletedEvent = "ruleDeletedEvent";
SOEvents.ruleDescDeletedEvent = "ruleDescDeletedEvent";
SOEvents.ruleEditCanceledEvent = "ruleEditCanceledEvent";
SOEvents.ruleCreatedEvent = "ruleCreatedEvent";
SOEvents.ruleUpdatedEvent = "ruleUpdatedEvent";
SOEvents.ruleCommitedEvent = "ruleCommitedEvent";
SOEvents.showNetoworksBelongToRuleEvent = "showNetoworksBelongToRuleEvent";
SOEvents.ruleAllCommitedEvent = "ruleAllCommitedEvent";

SOEvents.popUpMenuSelectionChangeEvent = "popUpMenuSelectionChangeEvent";
SOEvents.spsChangeEvent = "spsChangeEvent";
SOEvents.groupChangeEvent = "groupChangeEvent";
SOEvents.noneSpsPolicy = "existingNonePolicy";

SOEvents.networkChangedEvent = "networkChangedEvent";

(function () {
    angular.module('shieldxApp').directive("messageappender", [ '$rootScope', function ($rootScope) {
      console.log("messageappender called");
	  return {	  	
	    link: function(scope, element, attrs) {
	      $rootScope.$on('customMessageBuilder', function(e, val) {
	        var domElement = element[0];
			var token = '|'+ val;
	        if (document.selection) {
	          domElement.focus();
	          var sel = document.selection.createRange();
	          sel.text = token;
	          domElement.focus();
	        } else if (domElement.selectionStart || domElement.selectionStart === 0) {
	          var startPos = domElement.selectionStart;
	          var endPos = domElement.selectionEnd;
	          var scrollTop = domElement.scrollTop;
	          domElement.value = domElement.value.substring(0, startPos) + token + domElement.value.substring(endPos, domElement.value.length);
	          domElement.focus();
	          domElement.selectionStart = startPos + token.length;
	          domElement.selectionEnd = startPos + token.length;
	          domElement.scrollTop = scrollTop;
	        } else {
	          domElement.value += token;
	          domElement.focus();
	        }

	      });
	    }
	  };
  }]);
})();
/*
ShieldX Networks Inc. CONFIDENTIAL
----------------------------------
*
Copyright (c) 2016 ShieldX Networks Inc.
All Rights Reserved.
*
NOTICE: All information contained herein is, and remains
the property of ShieldX Networks Incorporated and its suppliers,
if any. The intellectual and technical concepts contained
herein are proprietary to ShieldX Networks Incorporated
and its suppliers and may be covered by U.S. and Foreign Patents,
patents in process, and are protected by trade secret or copyright law.
Dissemination of this information or reproduction of this material
is strictly forbidden unless prior written permission is obtained
from ShieldX Networks Incorporated.
*/

(function () {
    angular.module('shieldxApp').directive("portnumbervalidation", function () {
        return {
            restrict: 'A',
            require: 'ngModel',
            link: function (scope, ele, attrs, ctrl) {

                function validationError(value) // you can use any function and parameter name 
                {
                   
                    var inputVal = parseInt(value);
                    if(attrs.value){
                       if(inputVal > 65000){
                            ctrl.$setValidity('invalidrange', false);
                        } else {
                            ctrl.$setValidity('invalidrange', true); 
                        }
                    }
                    return value; //return to display  error 
                }
                ctrl.$parsers.push(validationError);
            }
        };
    });
})();
(function () {
	function newVlanDirective() {
		var directive = {};
		directive.restrict = 'E';
		directive.templateUrl = 'core/directive/vlan-pool/new-vlan-pool.html';
		directive.scope = {
			vlanval: '=',
		};
		directive.controller = ['$scope', function($scope) {
			$scope.$on('newRadioButtonClicked', function (event, data) {
				setTimeout(function(){
	                document.querySelector('#rangeNameField').focus();
	            },0);
			  
			});

			$scope.valueChanged = function($event, data){
             	$scope.$emit('newRangeValueChanged', data);   
            };
		}];
		return directive;
	}

	angular.module('shieldxApp').directive('newvlan', newVlanDirective);
})();

/*
ShieldX Networks Inc. CONFIDENTIAL
----------------------------------
*
Copyright (c) 2016 ShieldX Networks Inc.
All Rights Reserved.
*
NOTICE: All information contained herein is, and remains
the property of ShieldX Networks Incorporated and its suppliers,
if any. The intellectual and technical concepts contained
herein are proprietary to ShieldX Networks Incorporated
and its suppliers and may be covered by U.S. and Foreign Patents,
patents in process, and are protected by trade secret or copyright law.
Dissemination of this information or reproduction of this material
is strictly forbidden unless prior written permission is obtained
from ShieldX Networks Incorporated.
*/

(function () {
    angular.module('shieldxApp').directive("rangevalidation", function () {
        return {
            restrict: 'A',
            require: 'ngModel',
            link: function (scope, ele, attrs, ctrl) {

                function validationError(value) // you can use any function and parameter name 
                {
                   // console.log(" value " + value);
                    //console.log(" rangeTyp " + attrs.rangetype);
                    //console.log(" rangecomp  " + attrs.rangecomp);
                    //console.dir(attrs.rangecomp);
                    var otherRange = parseInt(attrs.rangecomp);
                    var inputVal = parseInt(value);
                    var endrange = (attrs.endeange)?parseInt(attrs.endeange):4094;
                    switch(attrs.rangetype){
                        case "start":
                           if(attrs.rangecomp){
                               if(inputVal >= 0){
                                   if (inputVal <  otherRange) 
                                    {
                                        ctrl.$setValidity('invalidrange', true);
                                    } else
                                    {

                                        console.log("mark invalid ");
                                        ctrl.$setValidity('invalidrange', false); 
                                    }
                                } else {
                                    ctrl.$setValidity('invalidrange', false); 
                                }
                           }
                        break;
                        case "end":
                            if(attrs.rangecomp){
                               if(inputVal <=  endrange){
                                   if (inputVal >  otherRange) 
                                    {

                                        ctrl.$setValidity('invalidrange', true);
                                    }
                                     else
                                    {

                                        console.log("mark invalid ");    
                                        ctrl.$setValidity('invalidrange', false); 
                                    }
                                }else{
                                    ctrl.$setValidity('invalidrange', false); 
                                }
                           }
                        break;
                    }
                   
                   
                    return value; //return to display  error 
                }
                ctrl.$parsers.push(validationError);
            }
        };
    });
})();
function Range(){
	this.startRange = null;
	this.endRange = null;
}

Range.prototype.diserialize = function(range){
   if(typeof range === "string"){
	   var index = range.indexOf("-");	
	   if(index != -1){
	   	 this.startRange = parseInt(range.substring(0, index));
	   	 this.endRange = parseInt(range.substring(index+1));
	   }
  	} else {
  		this.startRange = range.startRange;
	    this.endRange = range.endRange;
  	}
};

Range.prototype.serialize = function(range){
  return ""+this.startRange+"-"+this.endRange;
};

Range.prototype.isPopulated = function(){
  if(this.startRange === null || this.startRange === ""){
     return false;
  }

  if(this.endRange === null || this.endRange === ""){
     return false;
  }

  return true;
};
(function () {
	function vlanPoolDirective() {
		var directive = {};
		directive.restrict = 'E';
		directive.templateUrl = 'core/directive/vlan-pool/vlan-pool.html';
		directive.scope = {
			vlan: '=',
			infraid : '=',
			option : '=',
			selectvlan : '=',
			selectedoption : '&',
			selectedvlan : '&'
		};
		directive.controller = ['$scope','vlanService', function($scope, vlanService) {
			if(!$scope.option){
				$scope.option = "novlan";	
			}
			$scope.selectedOption = $scope.option;
			$scope.existingVlanFetched = false;
			$scope.existingVlans = null;
			$scope.selectedVlanVal = "";
			if($scope.selectvlan){
				$scope.selectedVlanVal = $scope.selectvlan;
		    }
            
            $scope.fetchVlanData = function(){
            	 console.log("vlan data fetched 1 "+$scope.infraid); 
            	if($scope.infraid){
            		 $scope.existingVlanFetched = false;
	             	vlanService.getvlanList($scope.infraid).then(function(data){
	                 console.log("vlan data fetched"); 
	                 console.dir(data);
	                 $scope.existingVlans = [];
	                 for(var i = 0; i < data.length; i++){
	                  var vlan = new Vlan();
	                  vlan.diserialize(data[i]);	
	                  $scope.existingVlans.push(vlan); 
	                 }
	                 $scope.existingVlanFetched = true;
	             	});
               }
            };  
			
			$scope.radioOptionClicked = function(){
			  //console.log("radioOptionClicked ");
			  //console.dir($scope.selectedOption);
              $scope.selectedoption({selectedOpt:$scope.selectedOption});
			};

			$scope.newRadioButtonClicked = function(){
				console.log(" newRadioButtonClicked  ");
				$scope.$broadcast('newRadioButtonClicked', {
				});
			};

			$scope.radioVlanClicked = function(){
			  //console.log("radioVlanClicked ");
			  //console.dir($scope.selectedVlanVal);	
              $scope.selectedvlan({selectedVal:$scope.selectedVlanVal});
			};
           $scope.fetchVlanData();
		}];

      directive.link = function(scope, element, attrs) {
		   
           scope.$watch('selectvlan', function(newValue, oldValue) {
                if (newValue){
                   scope.selectedVlanVal = scope.selectvlan;
                }
            }, true);

           scope.$watch('infraid', function(newValue, oldValue) {
                if (newValue){
                   scope.fetchVlanData();
                }
            }, true);
        };
		return directive;
	}

	angular.module('shieldxApp').directive('vlanpool', vlanPoolDirective);
})();

(function () {
	function vlanRangsDirective() {
		var directive = {};
		directive.restrict = 'E';
		directive.templateUrl = 'core/directive/vlan-pool/vlan-ranges.html';
		directive.scope = {
			ranges: '=',
			added : '&',
			deleted : '&'
		};
		directive.controller = ['$scope', function($scope) {
			//$scope.rangeForm = [];
			$scope.onAddnewRangeClicked = function(){

			};
			$scope.addNewRange = function(){
				$scope.rangesRef.push(new Range());
				$scope.added({ranges:$scope.rangesRef});	
			};

			$scope.removeRange = function(range){
				var i = _.findIndex($scope.rangesRef,function(item){
                 return range === item;
				});

				if(i){
					$scope.rangesRef.splice(i,1);
				}
			 $scope.deleted({ranges:$scope.rangesRef});	
			};
		$scope.formvalidation = function (event) {
			console.log("chnagedsadda");
		};
		$scope.$watch("rangeForm.$invalid",function (newValue,old,scope) {
			$scope.$emit('invalidRangeFormData', newValue);  
		},true);
		$scope.createStarRangetMessage = function (rangeForm, index) {

            return   rangeForm["startRange" + index].$error;
         };
         $scope.createEndRangeMessage = function (rangeForm, index) {
            return   rangeForm["endRange" + index].$error;
         };

         $scope.valueChanged = function($event, data){
             $scope.$emit('newRangeValueChanged', data);   
         };

		}];
		directive.link = function(scope, element, attrs) {
		   console.log(" llink "+scope);	
		   
		  
           scope.$watchCollection('ranges', function(newValue, oldValue) {
                if (newValue){
                    if(scope.ranges){
						scope.rangesRef = scope.ranges;
						console.log(" link ");
						console.dir(scope.rangesRef);
						if(scope.rangesRef.length === 0){
							scope.rangesRef.push(new Range());
						}
					} else{
							scope.rangesRef = [new Range()];
					}
                }
            }, true);
        };

		return directive;
	}

	angular.module('shieldxApp').directive('vlanranges', vlanRangsDirective);
})();

function Vlan(){
	this.id = "";
	this.name = "";
	this.discription = "";
	this.ranges = [];
}



Vlan.prototype.addRange= function(range){
  this.ranges.push(range);
};

Vlan.prototype.removeRange= function(range){
  
};

Vlan.prototype.diserialize = function(data){
	 // console.log("diserialize ");
	 // console.dir(data);
	 this.id = data.id;
	 this.name = data.name;

	 if(data.ranges)
	 {
	 	var rangesAr = data.ranges;
	 	if(typeof data.ranges === "string"){
	 	 rangesAr = data.ranges.split(",");
	 	}
	 	this.ranges = [];
	 	for(var i=0; i < rangesAr.length; i++){
	 		var range = new Range();
	 		range.diserialize(rangesAr[i]);
	 		this.ranges.push(range);
	 	     //console.log("diserialize 2");
	 	     //console.dir(range);
	 	}
	 }
};

Vlan.prototype.isPopulated = function(){
	if(this.name === ""){
      return false;
	}
	if(this.ranges.length === 0){
	  return false;
	}
    for(var i =0; i < this.ranges.length; i++){
         var range =  this.ranges[i];
         if(!range.isPopulated()){
           return false;
         }
    }  
	return true;
};

Vlan.prototype.serializeRanges = function(){
    var ret = "";
    var appender = "";
	for(var i=0; i < this.ranges.length; i++){
		var range = this.ranges[i];
		if(i===0){
			appender = "";
		} else {
			appender = ",";
		}
		ret = ret +appender+ range.serialize(); 	
	}

	return ret;
};
/*
ShieldX Networks Inc. CONFIDENTIAL
----------------------------------
*
Copyright (c) 2016 ShieldX Networks Inc.
All Rights Reserved.
*
NOTICE: All information contained herein is, and remains
the property of ShieldX Networks Incorporated and its suppliers,
if any. The intellectual and technical concepts contained
herein are proprietary to ShieldX Networks Incorporated
and its suppliers and may be covered by U.S. and Foreign Patents,
patents in process, and are protected by trade secret or copyright law.
Dissemination of this information or reproduction of this material
is strictly forbidden unless prior written permission is obtained
from ShieldX Networks Incorporated.
*/

(function () {
	function drilldownDirective() {
		var directive = {};
		directive.controller = ['$scope', 
			function($scope){
				var baseURL = 'core/directive/widget-painter/drilldown-collection/';
				$scope.drillDownTmpl = baseURL+"/"+$scope.widgetname+"/"+$scope.widgetname+".html";
				console.log("Received for drilldown ",$scope.drilldowndata);

				$scope.closeDrillDown = function(event) {
					$scope.$emit('closeDrillDown', {});
				};
			}
		];
		directive.scope = {
            widgetname: '=widgetname',
            drilldowndata : '=drilldowndata'
        };
        directive.restrict = 'E';
        directive.templateUrl = 'core/directive/widget-painter/dashboardDrillDown.html';
		return directive;
	}
	angular.module('shieldxApp').directive('drilldowncontainer', drilldownDirective);
})();
/*
ShieldX Networks Inc. CONFIDENTIAL
----------------------------------
*
Copyright (c) 2016 ShieldX Networks Inc.
All Rights Reserved.
*
NOTICE: All information contained herein is, and remains
the property of ShieldX Networks Incorporated and its suppliers,
if any. The intellectual and technical concepts contained
herein are proprietary to ShieldX Networks Incorporated
and its suppliers and may be covered by U.S. and Foreign Patents,
patents in process, and are protected by trade secret or copyright law.
Dissemination of this information or reproduction of this material
is strictly forbidden unless prior written permission is obtained
from ShieldX Networks Incorporated.
*/

(function () {
	function widgetPainterDirective() {
		var directive = {};
		directive.controller = ['$scope','$timeout','$element', 'dataVisualizationApi','dataVisualizationService',
			function($scope, $timeout, $element, dataVisualizationApi,dataVisualizationService){
			
			var chartObj,
				old,
				self = this;
			var functionList = [dataVisualizationApi.barChart, dataVisualizationApi.stackedArea, dataVisualizationApi.tables];

			self.rendered = 'INIT';
			self.data = [];
			self.refresh = true;

			function renderDbChart (chType) {
				if(chType.match(/barchart/i)) {
					return functionList[0];
				} else if (chType.match(/stackedarea/i)) {
					return functionList[1];
				} else if (chType.match(/tables/i)) {
					return functionList[2];
				}
			}


			var widgetTitleDOM = angular.element(angular.element($element[0]).children().find('div')[0]);
			//dynamically inject widget options
			var widgetOptionDOM = angular.element($element[0]).children()[1];
			
			function paintWidget(args) { //wdgName, elem, dataSet, from
				var chartObj = {
					elem: args.elem,
					dataset: args.dataSet,  // not customisable option
					columns: args.columns
				};
				if(widgetConfig.list[args.wdgName].hasOwnProperty("axis")) {
					chartObj.axis = widgetConfig.list[args.wdgName].axis;
				}
				self.data = args.dataSet;
				
				if(self.rendered.match(/INIT/)) {
					console.log(self.rendered);
					self.widgetDetails = widgetConfig.list[args.wdgName];
					//set widget title
					if(!widgetConfig.list[args.wdgName].chartType.match(/Alert/)) {
						widgetTitleDOM.append("<span>"+widgetConfig.list[args.wdgName].title+"</span>");
						if(widgetConfig.list[args.wdgName].drillDown) {
							widgetTitleDOM.append("<i class=\"material-icons drill-dn-icon\">border_all</i>").on('click', function(){
								$scope.$emit('showDrillDown', { type: self.widgetDetails, data: self.data});
							});
						}
						self.rendered = 'RENDERED';
					}
				} else {
					console.log(self.rendered);
				}

				renderDbChart(widgetConfig.list[args.wdgName].widgetType)(chartObj);
 				
 				
			}

			function paintAlerts(args) {
			
				if(self.rendered.match(/INIT/)) {
					switch (args.wdgName) {
						case WidgetName.TroubledMicroServices:
							console.log('painting >>',WidgetName.TroubledMicroServices);
							var TroubledMicroservicesDom = "<div class=\"top-row\">5/151</div>" +
								"<div class=\"bottom-row\">Troubled Microservices</div>";
							if(angular.element(args.elem).hasClass("rendered")) {
								return;
							} else {
								angular.element(args.elem).addClass("rendered");

								angular.element(args.elem).on('click',function(){
									$scope.$emit('showDrillDown', { type: widgetConfig.list[args.wdgName], data: args.dataSet});	
								});
							}
							break;			

						case WidgetName.InventoryofMicroServices:
							console.log('rendering InventoryofMicroServices');
							var InventoryofMicroServicesDOM = "<div style=\" font-size: 28px; font-weight: bold; line-height: 0.86;\">" +
								"<div style=\" float: left; width: 33%;\"><span style=\"color: #6d6e71; margin: 0 10px 0 0;\">"+args.dataSet[0].name +"</span><span style=\"color: #4a90e2;\">" + args.dataSet[0].count+"</span></div>" +
								"<div style=\" float: left; width: 33%;\"><span style=\"color: #6d6e71; margin: 0 10px 0 0;\">"+args.dataSet[1].name +"</span><span style=\"color: #4a90e2;\">" + args.dataSet[1].count+"</span></div>" +
								"<div style=\" float: left; width: 33%;\"><span style=\"color: #6d6e71; margin: 0 10px 0 0;\">"+args.dataSet[2].name +"</span><span style=\"color: #4a90e2;\">" + args.dataSet[2].count+"</span></div>"+
								"</div>" +
								"<div style=\" line-height: 1.14; font-size: 14px; color: #6d6e71; margin: 8px 0 0 0;\">Micro-Services</div>";
							/*if(angular.element(args.elem).hasClass("rendered")) {
								return;
							} else {*/
								angular.element(args.elem).addClass("rendered");
								angular.element(args.elem).html(InventoryofMicroServicesDOM);
								angular.element(args.elem).on('click',function(){
									$scope.$emit('showDrillDown', { type: widgetConfig.list[args.wdgName], data: args.dataSet});	
								});
							//}
							break;

						case WidgetName.SystemInformation:
							console.log('rendering SystemInformation');
							/*var SystemInformationDom = "<div style=\" font-size: 28px; font-weight: bold; line-height: 0.86;\">" +
								"<div  style=\" margin-top:5px; \"><span class='system-info-widget-1'>Build No: </span><span class='system-info-widget-2'>" + args.dataSet.build_number+"</span></div>" +
								"<div  style=\" margin-top:5px;\"><span class='system-info-widget-1'>Version: </span><span class='system-info-widget-2'>" + args.dataSet.version+"</span></div>" +
								"<div  style=\" margin-top:5px;\"><span class='system-info-widget-1'>Current Date: </span><span class='system-info-widget-2'>" + args.dataSet.currectDate+"</span></div>" +
								"<div  style=\" margin-top:5px;\"><span class='system-info-widget-1'>Current Time: </span><span class='system-info-widget-2'>" + args.dataSet.currentTime+"</span></div>" +
								"<div  style=\" margin-top:5px;\"><span class='system-info-widget-1'>System Up Time: </span><span class='system-info-widget-2'>" + args.dataSet.time+"</span></div>" +
								"<div  style=\" margin-top:5px;\"><span class='system-info-widget-1'>Content Version: </span><span class='system-info-widget-2'>" + args.dataSet.content_version+"</span></div>"+
								"</div>" +
								"<div class='system-info-title'>System Information</div>";*/
							var SystemInformationDom = "<div style=\" font-size: 28px; font-weight: bold; line-height: 0.86;\">" +
								"<div style=\" float: left; width: 27%;\"><span style=\"color: #6d6e71; margin: 0 10px 0 0;\">UP</span><span style=\"color: #4a90e2;\">" + args.dataSet.time+"</span></div>" +
								"<div style=\" float: left; width: 36%;\"><span style=\"color: #6d6e71; margin: 0 10px 0 0;\">SYS</span><span style=\"color: #4a90e2;\">" + args.dataSet.version+"</span></div>" +
								"<div style=\" float: left; width: 36%;\"><span style=\"color: #6d6e71; margin: 0 10px 0 0;\">CNT</span><span style=\"color: #4a90e2;\">" + args.dataSet.contentVersion+"</span></div>"+
								"</div>" +
								"<div style=\" line-height: 1.14; font-size: 14px; color: #6d6e71; margin: 8px 0 0 0;\">System Information</div>";

							/*var SystemInformationDom = "<div style=\" font-size: 28px; font-weight: bold; line-height: 0.86;\">" +
							"<div  style=\" margin-top:5px; \"><span class='system-info-widget-1'>Build No: </span><span class='system-info-widget-2'>" + args.dataSet.build_number+"</span></div>" +
							"<div  style=\" margin-top:5px;\"><span class='system-info-widget-1'>Version: </span><span class='system-info-widget-2'>" + args.dataSet.version+"</span></div>" +
							"<div  style=\" margin-top:5px;\"><span class='system-info-widget-1'>Current Date: </span><span class='system-info-widget-2'>" + args.dataSet.currectDate+"</span></div>" +
							"<div  style=\" margin-top:5px;\"><span class='system-info-widget-1'>Current Time: </span><span class='system-info-widget-2'>" + args.dataSet.currentTime+"</span></div>" +
							"<div  style=\" margin-top:5px;\"><span class='system-info-widget-1'>System Up Time: </span><span class='system-info-widget-2'>" + args.dataSet.time+"</span></div>" +
							"<div  style=\" margin-top:5px;\"><span class='system-info-widget-1'>Content Version: </span><span class='system-info-widget-2'>" + args.dataSet.content_version+"</span></div>"+
							"</div>" +
							"<div class='system-info-title'>System Information</div>";*/

							/*if(angular.element(args.elem).hasClass("rendered")) {
								return;
							} else {*/
								angular.element(args.elem).addClass("rendered");
								angular.element(args.elem).html(SystemInformationDom);
								/*angular.element(args.elem).on('click',function(){
									//$scope.$emit('showDrillDown', { type: widgetConfig.list[args.wdgName], data: args.dataSet});	
								});*/
							//}
							break;

						case WidgetName.NewApplications:
							console.log('rendering NewApplications');
							var NewApplicationsDom = "<table class="+WidgetName.NewApplications+"><thead><th>Application Name</th></thead><tbody>";
							var data= '';
							for(var i=0;i<args.dataSet.length;i++){
								 data = data + "<tr><td>"+args.dataSet[i].key+"</td></tr>";
							}
							NewApplicationsDom = NewApplicationsDom + data + "</tbody></table>";
							if(angular.element(args.elem).hasClass("rendered")) {
								return;
							} else {
								angular.element(args.elem).addClass("rendered");
								angular.element(args.elem).append(NewApplicationsDom);
								angular.element(args.elem).on('click',function(){
									$scope.$emit('showDrillDown', { type: widgetConfig.list[args.wdgName], data: args.dataSet});	
								});
							}							
							break;

						/*default:
							console.error("Something is wrong here");*/
					}
				}
			
			}

			function loadChartData(fileName,chartType,widgetType ) {
				var proxyData = new ProxyData(fileName);
                var dataWidgetConfig = new DataWidgetConfig(chartType,widgetType,proxyData);
				return dataVisualizationService.getDataForWidget(dataWidgetConfig).then(function (chartData) {
					return chartData;
				});
			}
			function loadChartDataFromServer(chartType, widgetType ) {
				var dataWidgetConfig = new DataWidgetConfig(chartType, widgetType);
				return dataVisualizationService.getDataForWidget(dataWidgetConfig).then(function (chartData) {
					return chartData;
				});
			}


			function loadDrillDownDataFromServer(widgetType,chartType,interval) {
				var args = [];
				for (var i = 3; i < arguments.length; i++) {
                     args.push(arguments[i]);
                }
                console.log("loadDrillDownDataFromServer args "+args);
                console.dir(args);
				var dataWidgetConfig = new DataWidgetConfig(chartType, widgetType,interval,args);
				
				return dataVisualizationService.getDrillDownDataForWidget(dataWidgetConfig).then(function (chartData) {
					return chartData;
				});
			}

			$scope.$on('item-resized', function(event,args){
				if(args.widget.content.widgetName.match(event.currentScope.widget)) {
					console.log('firing widget repaint', event.currentScope.widget);
					paintWidget({
						wdgName: event.currentScope.widget, 
						elem: args.elem[0],
						dataSet : args.widgetData,
						from : "RESIZE"
					});
				}				
			});

			$scope.$on('item-refresh', function(event,args){
				var currentWdgId;
				self.refresh = args.refreshStatus;
				
				if(event.currentScope.$parent.hasOwnProperty("gridsterItem")) {
					currentWdgId = event.currentScope.$parent.gridsterItem.$element["0"].firstElementChild.id;
					if(args.elem.id.match(currentWdgId) && self.refresh) {
						paintWidget({
							wdgName: args.wdgName, 
							elem: args.elem,
							dataSet : args.dataSet,
							from : "REFRESH",
							columns : args.columns
						});
					} 
				} else {
					if(event.currentScope.widget.match(args.wdgName)) {
						paintAlerts({
							wdgName: args.wdgName, 
							elem: args.elem,
							dataSet : args.dataSet,
							from : "REFRESH",
						});
					}
				}
				
			});
			
		}];
		directive.scope = {
            widget: '=widget'
        };
		directive.restrict = 'A';
		return directive;
	}
	angular.module('shieldxApp').directive('widget', widgetPainterDirective);
})();
(function() {
    var EventRateWidget = function() {
        return {
            getDrillDownQueryData: function() {
                return "";
            },
            getQueryData: function(intervalRef) {
                var presentEpoch = Math.round(new Date().getTime());
                var pastEpoch = presentEpoch - (60 * intervalRef * 1000);
                var timezone = jstz.determine().name();
                var queryHeader = {
                    "index": "shieldxevents",
                    "ignore_unavailable": true,
                    "preference": 1482258802419
                };

                var queryBody = {
                    "size": 0,
                    "query": {
                        "bool": {
                            "must": [{
                                "query_string": {
                                    "query": "*",
                                    "analyze_wildcard": true
                                }
                            }, {
                                "range": {
                                    "aggregate": {
                                        "gte": pastEpoch,
                                        "lte": presentEpoch,
                                        "format": "epoch_millis"
                                    }
                                }
                            }],
                            "must_not": []
                        }
                    },
                    "aggs": {
                        "2": {
                            "date_histogram": {
                                "field": "aggregate",
                                "interval": "10m",
                                "time_zone": timezone,
                                "min_doc_count": 1
                            },
                            "aggs": {
                                "3": {
                                    "terms": {
                                        "field": "event.severity",
                                        "size": 5,
                                        "order": {
                                            "_count": "desc"
                                        }
                                    }
                                }
                            }
                        }
                    }
                };

                var query = JSON.stringify(queryHeader) + "\n" + JSON.stringify(queryBody);
                return query;
            },
            getDataMassageObject: function(data) {
                return {
                    getBarChartData: function() {
                        return "";
                    },
                    getStackedAreaData: function(otheroption) {

                        var chartData = [];
                        console.log("EventRateWidget getStackedAreaData");
                        console.log("otheroption " + otheroption);
                        console.dir(data);
                        if (!otheroption) {
                            otheroption = "High";
                        }
                        var buckets = data.aggregations["2"].buckets;
                        console.log("buckets");
                        console.dir(buckets);
                        var maxBucketLength = 0;
                        var maxBucket;
                        var allSubBucket = [];
                        for (var i = 0; i < buckets.length; i++) {
                            var bucket = buckets[i];
                            //var kas = bucket.key_as_string.slice(0, 19);
                            var kas = bucket.key;
                            var subBucket = bucket["3"].buckets;

                            if (subBucket.length > maxBucketLength) {
                                maxBucketLength = subBucket.length;
                                maxBucket = subBucket;
                            }
                            allSubBucket.push({ "data": kas, "bucket": subBucket });
                        }

                        for (var k = 0; k < allSubBucket.length; k++) {
                            var fgTemp = allSubBucket[k].bucket;
                            var newKas = allSubBucket[k].data;
                            for (var j = 0; j < fgTemp.length; j++) {
                                var temp = fgTemp[j];
                                if (otheroption === "Critical") {
                                    if (temp.key == "Critical") {
                                        chartData.push({ "date": newKas, "key": temp.key, "value": temp.doc_count });
                                    }
                                } else {
                                    chartData.push({ "date": newKas, "key": temp.key, "value": temp.doc_count });
                                }

                            }

                            /* jshint ignore:start */

                            if (fgTemp.length < maxBucketLength) {
                                for (var t = 0; t < maxBucket.length; t++) {
                                    var keyExt = maxBucket[t].key;
                                    var tx = _.find(fgTemp, function(ty) {
                                        return ty.key === keyExt;
                                    });

                                    if (!tx) {
                                        if (otheroption === "Critical") {
                                            if (tkeyExt == "Critical") {
                                                chartData.push({ "date": newKas, "key": keyExt, "value": 0 });
                                            }
                                        } else {
                                            chartData.push({ "date": newKas, "key": keyExt, "value": 0 });
                                        }

                                    }
                                }
                            }
                            /* jshint ignore:end */



                        }
                        console.log("chatData EventRateWidget >> ");
                        console.dir(chartData);
                        return chartData;
                    },
                    massageDrillDowndata: function(data) {
                        return "";
                    }
                };
            }
        };
    };
    angular.module('shieldxApp').factory(WidgetName.EventRate + "Factory", EventRateWidget);
})();

(function() {

    var FlowWidget = function() {
        return {
            getDrillDownQueryData: function() {
                return "";
            },
            getQueryData: function(intervalRef) {
                var presentEpoch = Math.round(new Date().getTime());
                var pastEpoch = presentEpoch - (60 * intervalRef * 1000);
                var timezone = jstz.determine().name();
                var queryHeader = {
                    "index": "shieldxstats",
                    "ignore_unavailable": true,
                    "preference": 1481054742905
                };

                var queryBody = {
                    "query": {
                        "bool": {
                            "must": [{
                                "query_string": {
                                    "query": "_type:DPI",
                                    "analyze_wildcard": true
                                }
                            }, {
                                "range": {
                                    "aggregate": {
                                        "gte": pastEpoch,
                                        "lte": presentEpoch,
                                        "format": "epoch_millis"
                                    }
                                }
                            }],
                            "must_not": []
                        }
                    },
                    "aggs": {
                        "2": {
                            "date_histogram": {
                                "field": "aggregate",
                                "interval": "1m",
                                "time_zone": timezone,
                                "min_doc_count": 1
                            },
                            "aggs": {
                                "3": {
                                    "terms": {
                                        "field": "microServiceName",
                                        "size": 150,
                                        "order": {
                                            "1": "desc"
                                        }
                                    },
                                    "aggs": {
                                        "1": {
                                            "avg": {
                                                "field": "ncumstatistics.flows_created_rate"
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                };


                var query = JSON.stringify(queryHeader) + "\n" + JSON.stringify(queryBody);
                return query;
            },
            getDataMassageObject: function(data) {
                return {
                    getBarChartData: function() {
                        return "";
                    },
                    getStackedAreaData: function() {
                        var chartData = [];
                        console.log("FlowWidget getStackedAreaData");
                        console.dir(data);
                        var buckets = data.aggregations["2"].buckets;
                        console.log("buckets");
                        console.dir(buckets);
                        var maxBucketLength = 0;
                        var maxBucket;
                        var allSubBucket = [];
                        for (var i = 0; i < buckets.length; i++) {
                            var bucket = buckets[i];
                            //var kas = bucket.key_as_string.slice(0, 19);
                            var kas = bucket.key;
                            var subBucket = bucket["3"].buckets;

                            if (subBucket.length > maxBucketLength) {
                                maxBucketLength = subBucket.length;
                                maxBucket = subBucket;
                            }
                            allSubBucket.push({ "data": kas, "bucket": subBucket });
                        }

                        for (var k = 0; k < allSubBucket.length; k++) {
                            var fgTemp = allSubBucket[k].bucket;
                            var newKas = allSubBucket[k].data;
                            for (var j = 0; j < fgTemp.length; j++) {
                                var temp = fgTemp[j];
                                chartData.push({ "date": newKas, "key": temp.key, "value": temp["1"].value });
                            }

                            /* jshint ignore:start */

                            if (fgTemp.length < maxBucketLength) {
                                for (var t = 0; t < maxBucket.length; t++) {
                                    var keyExt = maxBucket[t].key;
                                    var tx = _.find(fgTemp, function(ty) {
                                        return ty.key === keyExt;
                                    });

                                    if (!tx) {
                                        chartData.push({ "date": newKas, "key": keyExt, "value": 0 });
                                    }
                                }
                            }
                            /* jshint ignore:end */



                        }
                        console.log("chatData FlowWidget >> ");
                        console.dir(chartData);
                        return chartData;
                    },
                    massageDrillDowndata: function(data) {
                        return "";
                    }
                };
            }
        };
    };
    console.log("dynamic factory  flows " + (WidgetName.Flows + "Factory"));
    angular.module('shieldxApp').factory(WidgetName.Flows + "Factory", FlowWidget);
})();

(function() {
    var InventoryofMicroServicesWidget = function() {


        return {
            getDrillDownQueryData: function(intervalRef) {
                var presentEpoch = Math.round(new Date().getTime());
                var pastEpoch = presentEpoch - (60 * intervalRef * 1000);
                var timezone = jstz.determine().name();
                var queryHeader = {
                    "index": "shieldxstats",
                    "ignore_unavailable": true,
                    "preference": 1482180275502
                };
                var queryBody = {
                    "query": {
                        "bool": {
                            "must": [{
                                "query_string": {
                                    "analyze_wildcard": true,
                                    "query": "*"
                                }
                            }, {
                                "range": {
                                    "aggregate": {
                                        "gte": pastEpoch,
                                        "lte": presentEpoch,
                                        "format": "epoch_millis"
                                    }
                                }
                            }],
                            "must_not": []
                        }
                    },
                    "aggs": {
                        "2": {
                            "date_histogram": {
                                "field": "aggregate",
                                "interval": "1m",
                                "time_zone": timezone,
                                "min_doc_count": 1
                            },
                            "aggs": {
                                "1": {
                                    "cardinality": {
                                        "field": "microServiceInstanceId"
                                    }
                                },
                                "3": {
                                    "terms": {
                                        "field": "microServiceTypeString",
                                        "size": 10,
                                        "order": { "1": "desc" }
                                    },
                                    "aggs": {
                                        "1": {
                                            "cardinality": {
                                                "field": "microServiceInstanceId"
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                };
                var query = JSON.stringify(queryHeader) + "\n" + JSON.stringify(queryBody);
                return query;
            },
            getQueryData: function(intervalRef) {
                var presentEpoch = Math.round(new Date().getTime());
                var pastEpoch = presentEpoch - (60 * intervalRef * 1000);
                var timezone = jstz.determine().name();
                var queryHeader = {
                    "index": "shieldxstats",
                    "ignore_unavailable": true,
                    "preference": 1481590535466
                };

                var queryBody = {
                    "query": {
                        "bool": {
                            "must": [{
                                "query_string": {
                                    "query": "*",
                                    "analyze_wildcard": true
                                }
                            }, {
                                "range": {
                                    "aggregate": {
                                        "gte": pastEpoch,
                                        "lte": presentEpoch,
                                        "format": "epoch_millis"
                                    }
                                }
                            }],
                            "must_not": []
                        }
                    },
                    "aggs": {
                        "2": {
                            "terms": {
                                "field": "microServiceTypeString",
                                "size": 5,
                                "order": { "1": "desc" }
                            },
                            "aggs": {
                                "1": {
                                    "cardinality": {
                                        "field": "microServiceInstanceId"
                                    }
                                }
                            }
                        }
                    }
                };

                var query = JSON.stringify(queryHeader) + "\n" + JSON.stringify(queryBody);
                return query;
            },
            getDataMassageObject: function(data) {
                console.log("from getDataMassageObject");
                return {
                    getBarChartData: function() {
                        console.log("from bar chart data");
                        return "";
                    },
                    getAlertData: function() {
                        console.log("from  Table data");
                        var tableData = [];
                        var rowData = data.aggregations["2"].buckets;
                        // var tableData = [];
                        for (var i = 0; i < rowData.length; i++) {

                            tableData.push({ "count": rowData[i].doc_count, "name": rowData[i].key });
                        }

                        return tableData;

                    },

                };
            },
            massageDrillDowndata: function(data) {
                console.log("from bar Drill Down  Bar data");
                //var chartData  =[];
                var buckets = data.responses[0].aggregations["2"].buckets;
                var allSubBucket = [];
                var bucketData = '';
                for (var i = 0; i < buckets.length; i++) {
                    bucketData = buckets[i];
                    bucketData = bucketData[3].buckets;
                    for (var j = 0; j < bucketData.length; j++) {
                        allSubBucket.push({ "count": bucketData[j].doc_count, "name": bucketData[j].key });
                    }
                }
                return allSubBucket;
            }
        };
    };
    angular.module('shieldxApp').factory(WidgetName.InventoryofMicroServices + "Factory", InventoryofMicroServicesWidget);
})();

(function() {
    var IOPWidget = function() {
        return {
            getDrillDownQueryData: function(intervalRef) {
                var presentEpoch = Math.round(new Date().getTime());
                var pastEpoch = presentEpoch - (60 * intervalRef * 1000);
                var timezone = jstz.determine().name();
                console.dir(arguments);
                var startStr = "event.iopDetectionId:(";
                var endStr = ")";
                var query = WidgetDataUtil.drillDownParamsWithOutSpace(startStr, arguments, endStr);
                var queryHeader = {
                    "index": "shieldxdetailedalerts",
                    "ignore_unavailable": true,
                    "preference": 1481583229034
                };
                var queryBody = {
                    "size": 50,
                    "sort": [{
                        "aggregate": {
                            "order": "desc",
                            "unmapped_type": "boolean"
                        }
                    }],
                    "query": {
                        "bool": {
                            "must": [{
                                "query_string": {
                                    "query": query,
                                    "analyze_wildcard": true
                                }
                            }, {
                                "range": {
                                    "aggregate": {
                                        "gte": pastEpoch,
                                        "lte": presentEpoch,
                                        "format": "epoch_millis"
                                    }
                                }
                            }],
                            "must_not": []
                        }
                    }
                };
                return JSON.stringify(queryHeader) + "\n" + JSON.stringify(queryBody);
                //return query;
            },
            getQueryData: function(intervalRef) {
                var presentEpoch = Math.round(new Date().getTime());
                var pastEpoch = presentEpoch - (60 * intervalRef * 1000);
                var timezone = jstz.determine().name();
                var queryHeader = {
                    "index": "shieldxdetailedalerts",
                    "ignore_unavailable": true,
                    "preference": 1484156126157
                };

                var queryBody = {
                        "size": 0,
                        "query": {
                            "bool": {
                                "must": [{
                                    "query_string": {
                                        "query": "iop",
                                        "analyze_wildcard": true
                                    }
                                }, {
                                    "range": {
                                        "aggregate": {
                                            "gte": pastEpoch,
                                            "lte": presentEpoch,
                                            "format": "epoch_millis"
                                        }
                                    }
                                }],
                                "must_not": []
                            }
                        },
                        "aggs": {
                            "iopChain": {
                                "terms": {
                                    "field": "event.iopDetectionId",
                                    "order": { "_count": "desc" }
                                },
                                "aggs": {
                                    "iopHop": {
                                        "terms": {
                                            "field": "event.iopHop",
                                            "order": { "_count": "desc" }
                                        },
                                        "aggs": {
                                            "Time Interval": {
                                                "date_histogram": {
                                                    "field": "aggregate",
                                                    "interval": "5m",
                                                    "time_zone": timezone,
                                                    "min_doc_count": 1
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    };
                return JSON.stringify(queryHeader) + "\n" + JSON.stringify(queryBody);
            },
            getDataMassageObject: function(data) {
                return {
                    getTablesData: function() {
                        console.log("From Iop Pie Chart Data");
                        console.dir(data);
                        var totalData = data.aggregations.iopChain.buckets;
                        var tableData = { headers: "", rowData: "" };
                        var chainData= {};
                        var multiChain = {},temp,totalChainData;
                        var timeInterval1,timeInterval2;
                        var hour1,hour2,minutes1,minutes2,date1,date2,newDate,todayDate,offset;
                        tableData.headers = [
                            { title: 'ID' },
                            { title: 'Stage 1' },
                            { title: 'Stage 2' },
                            { title: 'Stage 3' },
                            { title: 'Stage 4' }
                        ];
                        for(var i=0;i<totalData.length;i++){
                            chainData[i] ={id:"",val:""};
                            chainData[i].id =totalData[i].key;
                            totalChainData = totalData[i].iopHop.buckets;
                            for(var j=0;j<totalChainData.length;j++){
                                multiChain[j] = {count:"0",hours:"0",mintues:"0"};
                                temp = totalChainData[j];
                                multiChain[j].count = totalChainData[j].doc_count;
                                if(j !== 0 && j !== totalChainData.length -1){
                                    timeInterval1 = totalChainData[j-1];
                                    timeInterval1 = new Date(timeInterval1['Time Interval'].buckets[0].key_as_string);
                                    /*hour1 =  timeInterval1.getHours();
                                    minutes1 =  timeInterval1.getMinutes();*/
                                    timeInterval2 = totalChainData[j+1];
                                    timeInterval2 = new Date(timeInterval2['Time Interval'].buckets[0].key_as_string);
                                    date1 = timeInterval1.getTime(); 
                                    date2 = timeInterval2.getTime();
                                    newDate = new Date(date2-date1);
                                    todayDate = new Date();
                                    offset = todayDate.getTimezoneOffset() * 60 * 1000;
                                     newDate = newDate.getTime() + offset;
                                     newDate = new Date(newDate);
                                    multiChain[j].hours =  newDate.getHours();
                                    multiChain[j].mintues =  (newDate.getMinutes() > 10)?newDate.getMinutes():('0'+newDate.getMinutes());
                                    //var totalHrs = (hour2*60 + minutes2) - (hour1*60 + minutes1);

                                    /*multiChain[j].hours = hour2-hour1; 
                                    multiChain[j].mintues = minutes2-minutes1;*/ 
                               }
                              
                            }
                            chainData[i].val =multiChain;
                           
                        }
                       tableData.rowData = chainData;
                        return tableData;
                    },
                };
            },
            massageDrillDowndata: function(data) {
                var hits = data.responses[0].hits.hits;
                var rowData = [];
                var sourceData = '';
                var stages = [],
                    stageInfo = [],
                    childData = [];

                for (var i = 0; i < hits.length; i++) {
                    //sourceData = hits[i]._source;
                    sourceData = hits[i]._source;
                    sourceData = sourceData.event;
                    stageInfo.push(sourceData);
                    if (stages.length === 0) {
                        stages.push(sourceData.iopHop);
                    } else {
                        if (stages.indexOf(sourceData.iopHop) === -1) {
                            stages.push(sourceData.iopHop);
                        }
                    }
                    /*sourceData= sourceData.event;
                    rowData.push( { "appId":sourceData.appId,"dstIpAddress":sourceData.dstIpAddress,
                    "dstPort":sourceData.dstPort,"iopDetectionId":sourceData.iopDetectionId,
                    "iopHop":sourceData.iopHop,"iopThreatName":sourceData.iopThreatName,"iopRuleId":sourceData.iopRuleId,
                    "protocol":sourceData.protocol,
                    "protocolName":sourceData.protocolName,"srcIpAddress":sourceData.srcIpAddress,
                    "srcPort":sourceData.srcPort,"threatName":sourceData.threatName });*/
                }
                for (var j = 0; j < stages.length; j++) {
                    rowData[j] = { stage: "", val: "" };
                    rowData[j].stage = stages[j];
                    childData = [];
                    for (var k = 0; k < stageInfo.length; k++) {
                        if (stageInfo[k].iopHop === stages[j]) {
                            childData.push(stageInfo[k]);
                        }
                    }
                    rowData[j].val = childData;
                }
                return rowData;
            }
        };
    };
    angular.module('shieldxApp').factory(WidgetName.IOP + "Factory", IOPWidget);
})();

(function() {
    var NewApplicationsWidget = function() {
        return {
            getDrillDownQueryData: function(intervalRef) {
                var presentEpoch = Math.round(new Date().getTime());
                var pastEpoch = presentEpoch - (60 * intervalRef * 1000);
                var queryHeader = {
                    "index": "shieldxevents",
                    "ignore_unavailable": true,
                    "preference": 1481583229034
                };
                var queryBody = {
                    "size": 50,
                    "sort": [{
                        "aggregate": {
                            "order": "desc",
                            "unmapped_type": "boolean"
                        }
                    }],
                    "query": {
                        "bool": {
                            "must": [{
                                "query_string": {
                                    "query": "_type:DPI and event.applicationName:*",
                                    "analyze_wildcard": true
                                }
                            }, {
                                "range": {
                                    "aggregate": {
                                        "gte": pastEpoch,
                                        "lte": presentEpoch,
                                        "format": "epoch_millis"
                                    }
                                }
                            }],
                            "must_not": []
                        }
                    }
                };
                var query = JSON.stringify(queryHeader) + "\n" + JSON.stringify(queryBody);
                return query;
            },
            getQueryData: function(intervalRef) {
                var presentEpoch = Math.round(new Date().getTime());
                var pastEpoch = presentEpoch - (60 * intervalRef * 1000);
                var queryHeader = {
                    "index": "shieldxevents",
                    "ignore_unavailable": true,
                    "preference": 1481235097198
                };
                var queryBody = {
                    "query": {
                        "bool": {
                            "must": [{
                                "query_string": {
                                    "query": "*",
                                    "analyze_wildcard": true
                                }
                            }, {
                                "range": {
                                    "aggregate": {
                                        "gte": pastEpoch,
                                        "lte": presentEpoch,
                                        "format": "epoch_millis"
                                    }
                                }
                            }],
                            "must_not": []
                        }
                    },
                    "aggs": {
                        "2": {
                            "significant_terms": {
                                "field": "event.applicationName",
                                "size": 10
                            },
                            "aggs": {
                                "3": {
                                    "terms": {
                                        "field": "aggregate",
                                        "size": 5,
                                        "order": { "_count": "desc" }
                                    }
                                }
                            }
                        }
                    }
                };
                var query = JSON.stringify(queryHeader) + "\n" + JSON.stringify(queryBody);
                return query;
            },
            getDataMassageObject: function(data) {
                return {
                    getBarChartData: function() {
                        return "";
                    },
                    getTablesData: function() {
                        console.log("from table new applicationName");
                        var rowData = [];
                        //var tableData = [];
                        var buckets = data.aggregations["2"].buckets;
                        //var headers = {"title1":"BG Count","title2":"Doc Count","title3":"Key","title4":"Score"};
                        for (var i = 0; i < buckets.length; i++) {
                            rowData.push({ "bgCount": buckets[i].bg_count, "docCount": buckets[i].doc_count, "key": buckets[i].key, "score": buckets[i].score });
                        }
                        /*tableData.push(headers);
                        tableData.push(rowData);*/
                        // console.log(tableData);
                        return rowData;
                    },
                };

            },
            massageDrillDowndata: function(data) {
                var rowData = [];
                var tableData = [];
                var hits = data.responses[0].hits.hits;
                /*var headers = {"title1":"appId","title2":"dstIpAddress","title3":"dstPort","title4":"eventType",
                "title5":"pmId","title6":"protocol","title7":"protocolName","title8":"srcIpAddress",
                "title9":"srcPort","title10":"threatName"};*/
                for (var i = 0; i < hits.length; i++) {
                    var sourceData = hits[i]._source;
                    sourceData = sourceData.event;
                    rowData.push({
                        "appId": sourceData.appId,
                        "applicationName": sourceData.applicationName,
                        "dstIpAddress": sourceData.dstIpAddress,
                        "dstPort": sourceData.dstPort,
                        "protocol": sourceData.protocol,
                        "protocolName": sourceData.protocolName,
                        "srcIpAddress": sourceData.srcIpAddress,
                        "srcPort": sourceData.srcPort
                    });
                }
                /* tableData.push(headers);
                 tableData.push(rowData);*/
                return rowData;
            }
        };
    };
    angular.module('shieldxApp').factory(WidgetName.NewApplications + "Factory", NewApplicationsWidget);
})();

(function() {
    var ScalingWidget = function() {
        return {
            getDrillDownQueryData: function() {
                return "";
            },
            getQueryData: function(intervalRef) {
                var presentEpoch = Math.round(new Date().getTime());
                var pastEpoch = presentEpoch - (60 * intervalRef * 1000);
                var timezone = jstz.determine().name();
                var queryHeader = {
                    "index": "shieldxstats",
                    "ignore_unavailable": true,
                    "preference": 1481237372803
                };

                var queryBody = {
                    "query": {
                        "bool": {
                            "must": [{
                                "query_string": {
                                    "query": "*",
                                    "analyze_wildcard": true
                                }
                            }, {
                                "range": {
                                    "aggregate": {
                                        "gte": pastEpoch,
                                        "lte": presentEpoch,
                                        "format": "epoch_millis"
                                    }
                                }
                            }],
                            "must_not": []
                        }
                    },
                    "aggs": {
                        "3": {
                            "date_histogram": {
                                "field": "aggregate",
                                "interval": "1m",
                                "time_zone": timezone,
                                "min_doc_count": 1
                            },
                            "aggs": {
                                "4": {
                                    "terms": {
                                        "field": "microServiceTypeString",
                                        "size": 5,
                                        "order": {
                                            "1": "desc"
                                        }
                                    },
                                    "aggs": {
                                        "1": {
                                            "cardinality": {
                                                "field": "microServiceInstanceId"
                                            }
                                        },
                                        "5": {
                                            "terms": {
                                                "field": "microServiceTypeString",
                                                "size": 5,
                                                "order": {
                                                    "1": "desc"
                                                }
                                            },
                                            "aggs": {
                                                "1": {
                                                    "cardinality": {
                                                        "field": "microServiceInstanceId"
                                                    }
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                };

                var query = JSON.stringify(queryHeader) + "\n" + JSON.stringify(queryBody);
                return query;
            },
            getDataMassageObject: function(data) {
                return {
                    getBarChartData: function() {
                        return "";
                    },
                    getStackedAreaData: function(otheroption) {
                        console.log(" ScalingWidget  otheroption");
                        if (!otheroption) {
                            otheroption = "ALL";
                        }
                        var chartData = [];
                        console.log("FlowWidget getStackedAreaData");
                        console.dir(data);
                        var buckets = data.aggregations["3"].buckets;
                        console.log("buckets");
                        console.dir(buckets);
                        var maxBucketLength = 0;
                        var maxBucket;
                        var allSubBucket = [];
                        var missingBucketnamesObj = {};
                        var missingBucketnamesArray = [];
                        for (var i = 0; i < buckets.length; i++) {
                            var bucket = buckets[i];
                            //var kas = bucket.key_as_string.slice(0, 19);
                            var kas = bucket.key;
                            var subBucket = bucket["4"].buckets;

                            if (subBucket.length > maxBucketLength) {
                                maxBucketLength = subBucket.length;
                                maxBucket = subBucket;
                            }

                            for (var o = 0; o < subBucket.length; o++) {
                                if (missingBucketnamesObj[subBucket[o].key] === undefined) {
                                    missingBucketnamesObj[subBucket[o].key] = true;
                                    missingBucketnamesArray.push(subBucket[o].key);
                                }
                            }

                            allSubBucket.push({ "data": kas, "bucket": subBucket });
                        }

                        for (var k = 0; k < allSubBucket.length; k++) {
                            var fgTemp = allSubBucket[k].bucket;
                            var newKas = allSubBucket[k].data;
                            for (var j = 0; j < fgTemp.length; j++) {
                                var temp = fgTemp[j];
                                if (otheroption === "ALL") {
                                    chartData.push({ "date": newKas, "key": temp.key, "value": temp["1"].value });
                                } else {
                                    if (temp.key === otheroption) {
                                        chartData.push({ "date": newKas, "key": temp.key, "value": temp["1"].value });
                                    }
                                }

                            }

                            /* jshint ignore:start */

                            /*if (fgTemp.length < maxBucketLength) {
                                for (var t = 0; t < maxBucket.length; t++) {
                                    var keyExt = maxBucket[t].key;
                                    var tx = _.find(fgTemp, function(ty) {
                                        return ty.key === keyExt;
                                    });

                                    if (!tx) {
                                        chartData.push({ "date": newKas, "key": keyExt, "value": 0 });
                                    }
                                }
                            }
                            */
                            for (var t = 0; t < missingBucketnamesArray.length; t++) {
                                var keyFound = _.find(fgTemp, function(ty) {
                                    return ty.key === missingBucketnamesArray[t];
                                });
                                if (!keyFound) {
                                    if (otheroption === "ALL") {
                                        chartData.push({ "date": newKas, "key": missingBucketnamesArray[t], "value": 0 });
                                    } else {
                                        if (missingBucketnamesArray[t] === otheroption) {
                                            chartData.push({ "date": newKas, "key": missingBucketnamesArray[t], "value": 0 });
                                        }
                                    }

                                }
                            }

                            /* jshint ignore:end */



                        }
                        console.log("chatData FlowWidget >> ");
                        console.dir(chartData);
                        return chartData;
                    },
                    massageDrillDowndata: function(data) {
                        return "";
                    }
                };
            }
        };
    };
    angular.module('shieldxApp').factory(WidgetName.Scaling + "Factory", ScalingWidget);
})();

(function() {
    var SystemInformationWidget = function() {
        return {
            getDrillDownQueryData: function() {
                return "";
            },
            getQueryData: function(intervalRef) {
                var query = "manage/systeminfo";
                return query;
            },
            getDataMassageObject: function(data) {
                return {
                    getAlertData: function() {
                        var dateObj = new Date(data.systemUptime);

                        var hour = (dateObj.getHours() < 10) ? ('0' + dateObj.getHours()) : dateObj.getHours();
                        var min = (dateObj.getMinutes() < 10) ? ('0' + dateObj.getMinutes()) : dateObj.getMinutes();
                        data.time = hour + ":" + min;
                        //var sec = (dateObj.getSeconds() < 10) ? ('0' + dateObj.getSeconds()) : dateObj.getSeconds();
                        //data.time = hour + ":" + min + ":" + sec;
                        /*var cuDate = new Date();
                        var date = cuDate.getDate();
                        var year = cuDate.getFullYear();
                        var month = cuDate.getMonth();
                        hour = (cuDate.getHours() < 10) ? ('0' + cuDate.getHours()) : cuDate.getHours();
                        min = (cuDate.getMinutes() < 10) ? ('0' + cuDate.getMinutes()) : cuDate.getMinutes();*/
                        /*cuDate.getMinutes();*/
                        //sec = (cuDate.getSeconds() < 10) ? ('0' + cuDate.getSeconds()) : cuDate.getSeconds();
                        /*cuDate.getSeconds();*/
                        //MM/dd/yyyy HH:mm:ss
                        /*data.currectDate = month + "/" + date + "/" + year;
                        data.currentTime = hour + ":" + min + ":" + sec;*/
                        return data;
                    },
                    getStackedAreaData: function() {

                        return chartData;
                    },

                };
            },
            massageDrillDowndata: function(data) {
                return "";
            }
        };
    };

    angular.module('shieldxApp').factory(WidgetName.SystemInformation + "Factory", SystemInformationWidget);
})();

(function() {
    var ThroughputWidget = function() {
        return {
            getDrillDownQueryData: function() {
                return "";
            },
            getQueryData: function(intervalRef) {
                var presentEpoch = Math.round(new Date().getTime());
                var pastEpoch = presentEpoch - (60 * intervalRef * 1000);
                var timezone = jstz.determine().name();
                var queryHeader = {
                    "index": "shieldxstats",
                    "ignore_unavailable": true,
                    "preference": 1481054742905
                };

                var queryBody = {
                    "query": {
                        "bool": {
                            "must": [{
                                "query_string": {
                                    "query": "_type:SI",
                                    "analyze_wildcard": true
                                }
                            }, {
                                "range": {
                                    "aggregate": {
                                        "gte": pastEpoch,
                                        "lte": presentEpoch,
                                        "format": "epoch_millis"
                                    }
                                }
                            }],
                            "must_not": []
                        }
                    },
                    "aggs": {
                        "2": {
                            "date_histogram": {
                                "field": "aggregate",
                                "interval": "1m",
                                "time_zone": timezone,
                                "min_doc_count": 1
                            },
                            "aggs": {
                                "3": {
                                    "terms": {
                                        "field": "microServiceName",
                                        "size": 150,
                                        "order": {
                                            "1": "desc"
                                        }
                                    },
                                    "aggs": {
                                        "1": {
                                            "avg": {
                                                "field": "ncumstatistics.Mbps"
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                };

                var query = JSON.stringify(queryHeader) + "\n" + JSON.stringify(queryBody);
                return query;
            },
            getDataMassageObject: function(data) {
                return {
                    getBarChartData: function() {
                        return "";
                    },
                    getStackedAreaData: function() {
                        var chartData = [];
                        console.log("FlowWidget getStackedAreaData");
                        console.dir(data);
                        var buckets = data.aggregations["2"].buckets;
                        console.log("buckets");
                        console.dir(buckets);
                        var maxBucketLength = 0;
                        var maxBucket;
                        var allSubBucket = [];
                        for (var i = 0; i < buckets.length; i++) {
                            var bucket = buckets[i];
                            //var kas = bucket.key_as_string.slice(0, 19);
                            var kas = bucket.key;
                            var subBucket = bucket["3"].buckets;

                            if (subBucket.length > maxBucketLength) {
                                maxBucketLength = subBucket.length;
                                maxBucket = subBucket;
                            }
                            allSubBucket.push({ "data": kas, "bucket": subBucket });
                        }

                        for (var k = 0; k < allSubBucket.length; k++) {
                            var fgTemp = allSubBucket[k].bucket;
                            var newKas = allSubBucket[k].data;
                            for (var j = 0; j < fgTemp.length; j++) {
                                var temp = fgTemp[j];
                                chartData.push({ "date": newKas, "key": temp.key, "value": temp["1"].value });
                            }

                            /* jshint ignore:start */

                            if (fgTemp.length < maxBucketLength) {
                                for (var t = 0; t < maxBucket.length; t++) {
                                    var keyExt = maxBucket[t].key;
                                    var tx = _.find(fgTemp, function(ty) {
                                        return ty.key === keyExt;
                                    });

                                    if (!tx) {
                                        chartData.push({ "date": newKas, "key": keyExt, "value": 0 });
                                    }
                                }
                            }
                            /* jshint ignore:end */



                        }
                        console.log("chatData FlowWidget >> ");
                        console.dir(chartData);
                        return chartData;
                    },
                    massageDrillDowndata: function(data) {
                        return "";
                    }
                };
            }
        };
    };
    angular.module('shieldxApp').factory(WidgetName.Throughput + "Factory", ThroughputWidget);
})();

(function() {
    var TopNAttackerResourceGroupsWidget = function() {
        return {
            getDrillDownQueryData: function(intervalRef) {
                var presentEpoch = Math.round(new Date().getTime());
                var pastEpoch = presentEpoch - (60 * intervalRef * 1000);
                /*  var query = "_type:DPI AND event.AttackerResourceGroup:(";
                  console.dir(arguments);
                   var addFirst = true;
                  for (i = 1; i < arguments.length; i++) {
                     if (!addFirst) {
                        query += " OR "+arguments[i];
                     } else if(addFirst)
                     {
                        addFirst = false;
                        query += "  "+arguments[i];  
                     }
                 }
                 query += ")";
                 console.log("query  "+query);*/
                var startStr = "_type:DPI AND event.AttackerResourceGroup:(";
                var endStr = ")";
                var query = WidgetDataUtil.drillDownParamsWithOutSpace(startStr, arguments, endStr);
                console.dir(arguments);
                var queryHeader = {
                    "index": "shieldxdetailedalerts",
                    "ignore_unavailable": true,
                    "preference": 1481582140001
                };

                var queryBody = {
                    "size": 50,
                    "sort": [{
                        "aggregate": {
                            "order": "desc",
                            "unmapped_type": "boolean"
                        }
                    }],
                    "query": {
                        "bool": {
                            "must": [{
                                "query_string": {
                                    "query": query,
                                    "analyze_wildcard": true
                                }
                            }, {
                                "range": {
                                    "aggregate": {
                                        "gte": pastEpoch,
                                        "lte": presentEpoch,
                                        "format": "epoch_millis"
                                    }
                                }
                            }],
                            "must_not": []
                        }
                    }
                };
                return JSON.stringify(queryHeader) + "\n" + JSON.stringify(queryBody);

            },
            getQueryData: function(intervalRef, sizeValue) {
                var presentEpoch = Math.round(new Date().getTime());
                var pastEpoch = presentEpoch - (60 * intervalRef * 1000);
                if (!sizeValue) {
                    sizeValue = 50;
                }
                var queryHeader = {
                    "index": "shieldxdetailedalerts",
                    "ignore_unavailable": true,
                    "preference": 1481580902567
                };

                var queryBody = {
                    "size": 0,
                    "query": {
                        "bool": {
                            "must": [{
                                "query_string": {
                                    "analyze_wildcard": true,
                                    "query": "_type:DPI"
                                }
                            }, {
                                "range": {
                                    "aggregate": {
                                        "gte": pastEpoch,
                                        "lte": presentEpoch,
                                        "format": "epoch_millis"
                                    }
                                }
                            }],
                            "must_not": []
                        }
                    },
                    "aggs": {
                        "2": {
                            "terms": {
                                "field": "event.AttackerResourceGroup",
                                "size": sizeValue,
                                "order": { "_count": "desc" }
                            }
                        }
                    }
                };
                return JSON.stringify(queryHeader) + "\n" + JSON.stringify(queryBody);
            },
            getDataMassageObject: function(data) {
                return {
                    getBarChartData: function() {
                        var buckets = data.aggregations["2"].buckets;
                        var piChatData = WidgetDataUtil.parseBarChartData(buckets);
                        console.log("TopNDetectedAppsWidget getBarChartData");
                        console.dir(piChatData);
                        return piChatData;
                    },
                    getStackedAreaData: function() {

                        return chartData;
                    },

                };
            },
            massageDrillDowndata: function(data) {
                var hits = data.responses[0].hits.hits;
                var rowData = [];
                var sourceData = '';
                for (var i = 0; i < hits.length; i++) {
                    sourceData = hits[i]._source;
                    sourceData = sourceData.event;
                    rowData.push({
                        "appId": sourceData.appId,
                        "Attacker": sourceData.Attacker,
                        "AttackerIp": sourceData.AttackerIp,
                        "AttackerResourceGroup": sourceData.AttackerResourceGroup,
                        "Victim": sourceData.Victim,
                        "VictimIp": sourceData.VictimIp,
                        "VictimResourceGroup": sourceData.VictimResourceGroup,
                        "dstIpAddress": sourceData.dstIpAddress,
                        "policyName": sourceData.policyName,
                        "policyType": sourceData.policyType,
                        "protocolName": sourceData.protocolName,
                        "securityPolicySetName": sourceData.securityPolicySetName,
                        "sensorResponse": sourceData.sensorResponse,
                        "severity": sourceData.severity,
                        "srcIpAddress": sourceData.srcIpAddress,
                        "srcPort": sourceData.srcPort,
                        "threatName": sourceData.threatName,
                        "dstPort": sourceData.dstPort
                    });
                }
                return rowData;

            }
        };
    };
    angular.module('shieldxApp').factory(WidgetName.TopNAttackerResourceGroups + "Factory", TopNAttackerResourceGroupsWidget);
})();

(function() {
    var TopNAttackersWidget = function() {
        return {
            getDrillDownQueryData: function(intervalRef) {
                console.log(" TopNDetectedAppsWidget getDrillDownQueryData  ");
                console.log("intervalRef  " + intervalRef);
                var query = "_type:DPI AND event.Attacker:(";
                console.dir(arguments);
                var addFirst = true;
                for (i = 1; i < arguments.length; i++) {
                    if (!addFirst) {
                        query += " OR " + arguments[i];
                    } else if (addFirst) {
                        addFirst = false;
                        query += "  " + arguments[i];
                    }
                }
                query += ")";
                console.log("query  " + query);
                console.dir(arguments);
                var presentEpoch = Math.round(new Date().getTime());
                var pastEpoch = presentEpoch - (60 * intervalRef * 1000);

                var queryHeader = {
                    "index": "shieldxevents",
                    "ignore_unavailable": true,
                    "preference": 1482258802419
                };
                var queryBody = {
                    "sort": [{
                        "aggregate": {
                            "order": "desc",
                            "unmapped_type": "boolean"
                        }
                    }],
                    "query": {
                        "bool": {
                            "must": [{
                                "query_string": {
                                    "query": query,
                                    "analyze_wildcard": true
                                }
                            }, {
                                "range": {
                                    "aggregate": {
                                        "gte": pastEpoch,
                                        "lte": presentEpoch,
                                        "format": "epoch_millis"
                                    }
                                }
                            }],
                            "must_not": []
                        }
                    }
                };
                return JSON.stringify(queryHeader) + "\n" + JSON.stringify(queryBody);
            },
            getQueryData: function(intervalRef, sizevalue) {
                if (!sizevalue) {
                    sizevalue = 50;
                }
                var presentEpoch = Math.round(new Date().getTime());
                var pastEpoch = presentEpoch - (60 * intervalRef * 1000);
                var queryHeader = {
                    "index": "shieldxdetailedalerts",
                    "ignore_unavailable": true,
                    "preference": 1481580902567
                };

                var queryBody = {
                    "query": {
                        "bool": {
                            "must": [{
                                "query_string": {
                                    "analyze_wildcard": true,
                                    "query": "_type:DPI"
                                }
                            }, {
                                "range": {
                                    "aggregate": {
                                        "gte": pastEpoch,
                                        "lte": presentEpoch,
                                        "format": "epoch_millis"
                                    }
                                }
                            }],
                            "must_not": []
                        }
                    },
                    "aggs": {
                        "2": {
                            "terms": {
                                "field": "event.Attacker",
                                "size": sizevalue,
                                "order": {
                                    "_count": "desc"
                                }
                            }
                        }
                    }
                };
                return JSON.stringify(queryHeader) + "\n" + JSON.stringify(queryBody);
            },
            getDataMassageObject: function(data) {
                return {
                    getBarChartData: function() {
                        var buckets = data.aggregations["2"].buckets;
                        var piChatData = WidgetDataUtil.parseBarChartData(buckets);
                        console.log("TopNDetectedAppsWidget getBarChartData");
                        console.dir(piChatData);
                        return piChatData;
                    },
                    getStackedAreaData: function() {

                        return chartData;
                    },
                    massageDrillDowndata: function(data) {
                        return "";
                    }
                };
            },
            massageDrillDowndata: function(data) {
                var tabularView = {};
                tabularView.headers = [];
                tabularView.headers.push({ title: 'Attacker' });
                tabularView.headers.push({ title: 'Attacker IP' });
                tabularView.headers.push({ title: 'Attacker resource group' });
                tabularView.headers.push({ title: 'Security Policy Set' });
                tabularView.headers.push({ title: 'Sensor response' });
                tabularView.headers.push({ title: 'Severity' });
                tabularView.headers.push({ title: 'Policy name' });
                tabularView.rowData = [];

                console.log("massageDrillDowndata ");
                var events = data.responses[0].hits.hits;
                for (var i = 0; i < events.length; i++) {
                    var source = events[i]._source;
                    tabularView.rowData.push({ val1: source.event.Attacker, val2: source.event.AttackerIp, val3: source.event.AttackerResourceGroup, val4: source.event.securityPolicySetName, val5: source.event.sensorResponse, val6: source.event.severity, val7: source.event.policyName });
                }
                console.dir(tabularView);
                return tabularView;
            }
        };
    };
    angular.module('shieldxApp').factory(WidgetName.TopNAttackers + "Factory", TopNAttackersWidget);
})();

(function() {
    var TopNBadCertificatesWidget = function() {
        return {
            getDrillDownQueryData: function(intervalRef) {
                console.log(" TopNBadCertificatesWidget getDrillDownQueryData  ");
                console.log("intervalRef  " + intervalRef);
                var startStr = "_type:DPI AND event.certTag:(";
                var endStr = ")";
                var query = WidgetDataUtil.drillDownParamsWithOutSpace(startStr, arguments, endStr);
                // console.dir(arguments);
                console.dir(query);
                var presentEpoch = Math.round(new Date().getTime());
                var pastEpoch = presentEpoch - (60 * intervalRef * 1000);

                var queryHeader = {
                    "index": "shieldxdetailedalerts",
                    "ignore_unavailable": true,
                    "preference": 1481583229034
                };
                var queryBody = {
                    "size": 50,
                    "sort": [{
                        "aggregate": {
                            "order": "desc",
                            "unmapped_type": "boolean"
                        }
                    }],
                    "query": {
                        "bool": {
                            "must": [{
                                "query_string": {
                                    "query": query,
                                    "analyze_wildcard": true
                                }
                            }, {
                                "range": {
                                    "aggregate": {
                                        "gte": pastEpoch,
                                        "lte": presentEpoch,
                                        "format": "epoch_millis"
                                    }
                                }
                            }],
                            "must_not": []
                        }
                    }
                };
                return JSON.stringify(queryHeader) + "\n" + JSON.stringify(queryBody);

            },
            getQueryData: function(intervalRef, sizevalue) {
                if (!sizevalue) {
                    sizevalue = 50;
                }
                var presentEpoch = Math.round(new Date().getTime());
                var pastEpoch = presentEpoch - (60 * intervalRef * 1000);
                var queryHeader = {
                    "index": "shieldxdetailedalerts",
                    "ignore_unavailable": true,
                    "preference": 1482528522504
                };

                var queryBody = {
                    "size": 0,
                    "query": {
                        "bool": {
                            "must": [{
                                "query_string": {
                                    "query": "_type:DPI",
                                    "analyze_wildcard": true
                                }
                            }, {
                                "range": {
                                    "aggregate": {
                                        "gte": pastEpoch,
                                        "lte": presentEpoch,
                                        "format": "epoch_millis"
                                    }
                                }
                            }],
                            "must_not": []
                        }
                    },
                    "aggs": {
                        "2": {
                            "terms": {
                                "field": "event.certTag",
                                "size": sizevalue,
                                "order": {
                                    "_count": "desc"
                                }
                            }
                        }
                    }
                };
                var query = JSON.stringify(queryHeader) + "\n" + JSON.stringify(queryBody);
                return query;
            },
            getDataMassageObject: function(data) {
                return {
                    getBarChartData: function() {
                        if (data) {
                            var buckets = data.aggregations["2"].buckets;
                            var piChatData = WidgetDataUtil.parseBarChartData(buckets);
                            console.log("TopNBadCertificatesWidget getBarChartData");
                            console.dir(piChatData);
                            return piChatData;
                        }

                        return [];
                    },
                    getStackedAreaData: function() {

                        return chartData;
                    },

                };
            },
            massageDrillDowndata: function(data) {
                var tabularView = {};
                tabularView.headers = [];
                tabularView.headers.push({ title: 'Certificate Name' });
                tabularView.headers.push({ title: 'Protocol Name' });
                tabularView.headers.push({ title: 'Source IP' });
                tabularView.headers.push({ title: 'Source Port' });
                tabularView.headers.push({ title: 'Destination IP' });
                tabularView.headers.push({ title: 'Destination Port' });
                tabularView.rowData = [];

                console.log("massageDrillDowndata ");
                var events = data.responses[0].hits.hits;
                for (var i = 0; i < events.length; i++) {
                    var source = events[i]._source;
                    tabularView.rowData.push({ val1: source.event.certTag, val2: source.event.protocolName, val3: source.event.srcIpAddress, val4: source.event.srcPort, val5: source.event.dstIpAddress, val6: source.event.dstPort });
                }
                console.dir(tabularView);
                return tabularView;
            }
        };
    };
    angular.module('shieldxApp').factory(WidgetName.TopNBadCertificates + "Factory", TopNBadCertificatesWidget);
})();

(function() {
    var TopNBlockedClientsWidget = function() {
        return {
            getDrillDownQueryData: function(intervalRef) {
                console.log(" TopNBlockedClientsWidget getDrillDownQueryData  ");
                console.log("intervalRef  " + intervalRef);
                var query = "_type:TCP AND event.sensorResponse:Blocked AND event.srcMachineName:(";
                console.dir(arguments);
                var addFirst = true;
                for (i = 1; i < arguments.length; i++) {
                    if (!addFirst) {
                        query += " OR " + arguments[i];
                    } else if (addFirst) {
                        addFirst = false;
                        query += "  " + arguments[i];
                    }
                }
                query += ")";
                console.log("query  " + query);
                console.dir(arguments);
                var presentEpoch = Math.round(new Date().getTime());
                var pastEpoch = presentEpoch - (60 * intervalRef * 1000);

                var queryHeader = {
                    "index": "shieldxevents",
                    "ignore_unavailable": true,
                    "preference": 1482180275502
                };
                var queryBody = {
                    "size": 500,
                    "sort": [{
                        "aggregate": {
                            "order": "desc",
                            "unmapped_type": "boolean"
                        }
                    }],
                    "query": {
                        "bool": {
                            "must": [{
                                "query_string": {
                                    "query": query,
                                    "analyze_wildcard": true
                                }
                            }, {
                                "range": {
                                    "aggregate": {
                                        "gte": pastEpoch,
                                        "lte": presentEpoch,
                                        "format": "epoch_millis"
                                    }
                                }
                            }],
                            "must_not": []
                        }
                    }
                };
                return JSON.stringify(queryHeader) + "\n" + JSON.stringify(queryBody);
            },
            getQueryData: function(intervalRef, sizevalue) {
                if (!sizevalue) {
                    sizevalue = 5;
                }
                var presentEpoch = Math.round(new Date().getTime());
                var pastEpoch = presentEpoch - (60 * intervalRef * 1000);
                var queryHeader = {
                    "index": "shieldxevents",
                    "ignore_unavailable": true,
                    "preference": 1482180275502
                };

                var queryBody = {
                    "query": {
                        "bool": {
                            "must": [{
                                "query_string": {
                                    "query": "_type:TCP AND event.sensorResponse:Blocked",
                                    "analyze_wildcard": true
                                }
                            }, {
                                "range": {
                                    "aggregate": {
                                        "gte": pastEpoch,
                                        "lte": presentEpoch,
                                        "format": "epoch_millis"
                                    }
                                }
                            }],
                            "must_not": []
                        }
                    },
                    "aggs": {
                        "2": {
                            "terms": {
                                "field": "event.srcMachineName",
                                "size": sizevalue,
                                "order": { "_count": "desc" }
                            }
                        }
                    }
                };
                return JSON.stringify(queryHeader) + "\n" + JSON.stringify(queryBody);
            },
            getDataMassageObject: function(data) {
                return {
                    getBarChartData: function() {
                        var buckets = data.aggregations["2"].buckets;
                        var piChatData = WidgetDataUtil.parseBarChartData(buckets);
                        console.log("TopNDetectedAppsWidget getBarChartData");
                        console.dir(piChatData);
                        return piChatData;
                    },
                    getStackedAreaData: function() {

                        return chartData;
                    },
                    massageDrillDowndata: function(data) {
                        return "";
                    }
                };
            },
            massageDrillDowndata: function(data) {
                var tabularView = {};
                tabularView.headers = [];
                tabularView.headers.push({ title: 'Machine Name' });
                tabularView.headers.push({ title: 'Destination Name' });
                tabularView.headers.push({ title: 'Source IP' });
                tabularView.headers.push({ title: 'Source Port' });
                tabularView.headers.push({ title: 'Destination IP' });
                tabularView.headers.push({ title: 'Destination Port' });
                tabularView.rowData = [];

                console.log("massageDrillDowndata ");
                var events = data.responses[0].hits.hits;
                for (var i = 0; i < events.length; i++) {
                    var source = events[i]._source;
                    tabularView.rowData.push({ val1: source.event.srcMachineName, val2: source.event.dstMachineName, val3: source.event.srcIpAddress, val4: source.event.srcPort, val5: source.event.dstIpAddress, val6: source.event.dstPort });
                }
                console.dir(tabularView);
                return tabularView;
            }
        };
    };
    angular.module('shieldxApp').factory(WidgetName.TopNBlockedClients + "Factory", TopNBlockedClientsWidget);
})();

(function() {
    var TopNConversationsWidget = function() {
        return {
            getDrillDownQueryData: function(intervalRef) {
                console.log(" TopNConversationsWidget getDrillDownQueryData  ");
                console.log("intervalRef  " + intervalRef);
                var query = "_type:TCP AND event.srcMachineName:" + arguments[1].source + " AND event.dstMachineName:" + arguments[1].victim + "";
                console.log("query  " + query);
                console.dir(arguments[1].source);
                var presentEpoch = Math.round(new Date().getTime());
                var pastEpoch = presentEpoch - (60 * intervalRef * 1000);

                var queryHeader = {
                    "index": ["shieldxevents"],
                    "ignore_unavailable": true,
                    "preference": 1482191877914
                };
                var queryBody = {
                    "size": 500,
                    "sort": [{
                        "aggregate": {
                            "order": "desc",
                            "unmapped_type": "boolean"
                        }
                    }],
                    "query": {
                        "bool": {
                            "must": [{
                                "query_string": {
                                    "query": query,
                                    "analyze_wildcard": true
                                }
                            }, {
                                "range": {
                                    "aggregate": {
                                        "gte": pastEpoch,
                                        "lte": presentEpoch,
                                        "format": "epoch_millis"
                                    }
                                }
                            }],
                            "must_not": []
                        }
                    }
                };
                return JSON.stringify(queryHeader) + "\n" + JSON.stringify(queryBody);
            },
            getQueryData: function(intervalRef, sizevalue) {
                if (!sizevalue) {
                    sizevalue = 5;
                }
                var presentEpoch = Math.round(new Date().getTime());
                var pastEpoch = presentEpoch - (60 * intervalRef * 1000);
                var queryHeader = {
                    "index": "shieldxevents",
                    "ignore_unavailable": true,
                    "preference": 1481580902567
                };

                var queryBody = {
                    "size": 0,
                    "query": {
                        "bool": {
                            "must": [{
                                "query_string": {
                                    "analyze_wildcard": true,
                                    "query": "_type:TCP"
                                }
                            }, {
                                "range": {
                                    "aggregate": {
                                        "gte": pastEpoch,
                                        "lte": presentEpoch,
                                        "format": "epoch_millis"
                                    }
                                }
                            }],
                            "must_not": []
                        }
                    },
                    "aggs": {
                        "3": {
                            "terms": {
                                "field": "event.srcMachineName",
                                "size": parseInt(sizevalue),
                                "order": {
                                    "4": "desc"
                                }
                            },
                            "aggs": {
                                "4": {
                                    "sum": {
                                        "field": "event.sendByte"
                                    }
                                },
                                "5": {
                                    "terms": {
                                        "field": "event.dstMachineName",
                                        "size": 50,
                                        "order": {
                                            "4": "desc"
                                        }
                                    },
                                    "aggs": {
                                        "4": {
                                            "sum": {
                                                "field": "event.sendByte"
                                            }
                                        },
                                        "6": {
                                            "sum": {
                                                "field": "event.recvByte"
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                };
                return JSON.stringify(queryHeader) + "\n" + JSON.stringify(queryBody);
            },
            getDataMassageObject: function(data, navlue) {
                var ognvalue = navlue;
                return {
                    getBarChartData: function() {
                        console.log(ognvalue);
                        var navlue = parseInt(ognvalue);
                        var buckets = data.aggregations["3"].buckets;
                        console.log("TopNConversationsWidget getBarChartData");
                        console.dir(buckets);
                        var piChatData = [];
                        for (var i = 0; i < buckets.length; i++) {
                            var bucket = buckets[i];
                            var name = bucket.key;
                            var subBukets = bucket["5"].buckets;
                            for (var j = 0; j < subBukets.length; j++) {
                                var sb = subBukets[j];
                                var subName = sb.key;
                                var byteSent = parseInt(sb["4"].value);
                                var byteRecived = parseInt(sb["6"].value);
                                piChatData.push({ "Letter": "(" + name + " _ " + subName + ")", "Freq": (byteSent + byteRecived), "source": name, "victim": subName });
                            }

                        }
                        var totalData = _.sortBy(piChatData, 'Freq');
                        console.log(totalData);
                        if (totalData.length >= navlue) {
                            piChatData = totalData.slice(totalData.length - navlue, totalData.length);
                        }
                        return piChatData;
                    },
                    getStackedAreaData: function() {

                        return chartData;
                    },
                    massageDrillDowndata: function(data) {
                        return "";
                    }
                };
            },
            massageDrillDowndata: function(data) {
                var tabularView = {};
                tabularView.headers = [];
                tabularView.headers.push({ title: 'action' });
                tabularView.headers.push({ title: 'Destination IP' });
                tabularView.headers.push({ title: 'Destination Resource Group' });
                tabularView.headers.push({ title: 'Policy type' });
                tabularView.headers.push({ title: 'Recived Byte' });
                tabularView.headers.push({ title: 'Send Byte' });
                tabularView.headers.push({ title: 'Source IP' });
                tabularView.rowData = [];

                console.log("massageDrillDowndata ");
                var events = data.responses[0].hits.hits;
                for (var i = 0; i < events.length; i++) {
                    var source = events[i]._source;
                    tabularView.rowData.push({ val1: source.event.action, val2: source.event.dstIpAddress, val3: source.event.dstResourceGroup, val4: source.event.policyType, val5: source.event.recvByte, val6: source.event.sendByte, val7: source.event.srcIpAddress });
                }
                console.dir(tabularView);
                return tabularView;
            }
        };
    };
    angular.module('shieldxApp').factory(WidgetName.TopNConversations + "Factory", TopNConversationsWidget);
})();

(function() {
    var TopNDetectedAppsWidget = function() {
        return {
            getDrillDownQueryData: function(intervalRef) {
                console.log(" TopNDetectedAppsWidget getDrillDownQueryData  ");
                console.log("intervalRef  " + intervalRef);
                var query = "_type:DPI AND event.applicationName:(";
                console.dir(arguments);
                var addFirst = true;
                for (i = 1; i < arguments.length; i++) {
                    if (!addFirst) {
                        query += " OR " + arguments[i];
                    } else if (addFirst) {
                        addFirst = false;
                        query += "  " + arguments[i];
                    }
                }
                query += ")";
                console.log("query  " + query);
                console.dir(arguments);
                var presentEpoch = Math.round(new Date().getTime());
                var pastEpoch = presentEpoch - (60 * intervalRef * 1000);

                var queryHeader = {
                    "index": "shieldxevents",
                    "ignore_unavailable": true,
                    "preference": 1481582140001
                };
                var queryBody = {
                    "size": 50,
                    "sort": [{
                        "aggregate": {
                            "order": "desc",
                            "unmapped_type": "boolean"
                        }
                    }],
                    "query": {
                        "bool": {
                            "must": [{
                                "query_string": {
                                    "query": query,
                                    "analyze_wildcard": true
                                }
                            }, {
                                "exists": {
                                    "field": "event.applicationName"
                                }
                            }, { "exists": { "field": "chassisId" } }, {
                                "range": {
                                    "aggregate": {
                                        "gte": pastEpoch,
                                        "lte": presentEpoch,
                                        "format": "epoch_millis"
                                    }
                                }
                            }],
                            "must_not": []
                        }
                    }
                };
                return JSON.stringify(queryHeader) + "\n" + JSON.stringify(queryBody);
            },
            getQueryData: function(intervalRef, sizevalue) {
                console.log("intervalRef " + intervalRef);
                console.log("sizevalue " + sizevalue);
                if (!sizevalue) {
                    sizevalue = 5;
                }
                var presentEpoch = Math.round(new Date().getTime());
                var pastEpoch = presentEpoch - (60 * intervalRef * 1000);
                var queryHeader = {
                    "index": "shieldxevents",
                    "ignore_unavailable": true,
                    "preference": 1481580902567
                };

                if (!sizevalue) {
                    sizevalue = 50;
                }

                var queryBody = {
                    "size": 0,
                    "query": {
                        "bool": {
                            "must": [{
                                "query_string": {
                                    "analyze_wildcard": true,
                                    "query": "_type:DPI"
                                }
                            }, {
                                "range": {
                                    "aggregate": {
                                        "gte": pastEpoch,
                                        "lte": presentEpoch,
                                        "format": "epoch_millis"
                                    }
                                }
                            }],
                            "must_not": []
                        }
                    },
                    "aggs": {
                        "2": {
                            "terms": {
                                "field": "event.applicationName",
                                "size": sizevalue,
                                "order": {
                                    "_count": "desc"
                                }
                            }
                        }
                    }
                };
                return JSON.stringify(queryHeader) + "\n" + JSON.stringify(queryBody);
            },
            getDataMassageObject: function(data) {
                return {
                    getBarChartData: function() {
                        if (data && data.aggregations) {
                            var buckets = data.aggregations["2"].buckets;
                            var piChatData = WidgetDataUtil.parseBarChartData(buckets);
                            console.log("TopNDetectedAppsWidget getBarChartData");
                            console.dir(piChatData);
                            return piChatData;
                        }
                        return [];
                    }
                };
            },
            massageDrillDowndata: function(data) {
                var tabularView = {};
                tabularView.headers = [];
                tabularView.headers.push({ title: 'Application Name' });
                tabularView.headers.push({ title: 'Protocol Name' });
                tabularView.headers.push({ title: 'Source IP' });
                tabularView.headers.push({ title: 'Source Port' });
                tabularView.headers.push({ title: 'Destination IP' });
                tabularView.headers.push({ title: 'Destination Port' });
                //tabularView.headers.push({title: 'Domain'});
                tabularView.rowData = [];

                console.log("massageDrillDowndata ");
                var events = data.responses[0].hits.hits;
                for (var i = 0; i < events.length; i++) {
                    var source = events[i]._source;
                    tabularView.rowData.push({ val1: source.event.applicationName, val2: source.event.protocolName, val3: source.event.srcIpAddress, val4: source.event.srcPort, val5: source.event.dstIpAddress, val6: source.event.dstPort });
                }
                console.dir(tabularView);
                return tabularView;
            }
        };
    };
    angular.module('shieldxApp').factory(WidgetName.TopNDetectedApps + "Factory", TopNDetectedAppsWidget);
})();

(function() {
    var TopNDetectedThreatsWidget = function() {
        return {
            getDrillDownQueryData: function(intervalRef) {
                console.log("  TopNDetectedThreatsWidget >>> ");
                var startStr = "_type:DPI AND event.threatName:(";
                var endStr = ")";
                var query = WidgetDataUtil.drillDownParamsWithOutSpace(startStr, arguments, endStr);
                console.dir(arguments);
                var presentEpoch = Math.round(new Date().getTime());
                var pastEpoch = presentEpoch - (60 * intervalRef * 1000);
                var queryHeader = {
                    "index": "shieldxdetailedalerts",
                    "ignore_unavailable": true,
                    "preference": 1481583229034
                };

                var queryBody = {
                    "size": 50,
                    "sort": [{
                        "aggregate": {
                            "order": "desc",
                            "unmapped_type": "boolean"
                        }
                    }],
                    "query": {
                        "bool": {
                            "must": [{
                                "query_string": {
                                    "query": query,
                                    "analyze_wildcard": true
                                }
                            }, {
                                "range": {
                                    "aggregate": {
                                        "gte": pastEpoch,
                                        "lte": presentEpoch,
                                        "format": "epoch_millis"
                                    }
                                }
                            }],
                            "must_not": []
                        }
                    }
                };

                return JSON.stringify(queryHeader) + "\n" + JSON.stringify(queryBody);
                //return queryStr;
            },
            getQueryData: function(intervalRef, sizevalue) {
                var presentEpoch = Math.round(new Date().getTime());
                var pastEpoch = presentEpoch - (60 * intervalRef * 1000);
                if (!sizevalue) {
                    sizevalue = 50;
                }
                var queryHeader = {
                    "index": "shieldxdetailedalerts",
                    "ignore_unavailable": true,
                    "preference": 1481580991781
                };

                var queryBody = {
                    "size": 0,
                    "query": {
                        "bool": {
                            "must": [{
                                "query_string": {
                                    "query": "_type:DPI",
                                    "analyze_wildcard": true
                                }
                            }, {
                                "range": {
                                    "aggregate": {
                                        "gte": pastEpoch,
                                        "lte": presentEpoch,
                                        "format": "epoch_millis"
                                    }
                                }
                            }],
                            "must_not": []
                        }
                    },
                    "aggs": {
                        "2": {
                            "terms": {
                                "field": "event.threatName",
                                "size": sizevalue,
                                "order": {
                                    "_count": "desc"
                                }
                            }
                        }
                    }
                };

                var query = JSON.stringify(queryHeader) + "\n" + JSON.stringify(queryBody);
                return query;
            },
            getDataMassageObject: function(data) {
                return {
                    getBarChartData: function() {
                        var buckets = data.aggregations["2"].buckets;
                        var piChatData = WidgetDataUtil.parseBarChartData(buckets);
                        console.log("TopNDetectedThreatsWidget getBarChartData");
                        console.dir(piChatData);
                        return piChatData;
                    },
                    getStackedAreaData: function() {

                        return chartData;
                    }

                };
            },
            massageDrillDowndata: function(data) {
                var tabularView = {};
                tabularView.headers = [];
                tabularView.headers.push({ title: 'Threat Name' });
                tabularView.headers.push({ title: 'Protocol Name' });
                tabularView.headers.push({ title: 'Source IP' });
                tabularView.headers.push({ title: 'Source Port' });
                tabularView.headers.push({ title: 'Destination IP' });
                tabularView.headers.push({ title: 'Destination Port' });
                tabularView.rowData = [];

                console.log("massageDrillDowndata ");
                var events = data.responses[0].hits.hits;
                for (var i = 0; i < events.length; i++) {
                    var source = events[i]._source;
                    tabularView.rowData.push({ val1: source.event.threatName, val2: source.event.protocolName, val3: source.event.srcIpAddress, val4: source.event.srcPort, val5: source.event.dstIpAddress, val6: source.event.dstPort });
                }
                console.dir(tabularView);
                return tabularView;
            }
        };
    };
    angular.module('shieldxApp').factory(WidgetName.TopNDetectedThreats + "Factory", TopNDetectedThreatsWidget);
})();

(function() {
    var TopNMalwareDetectionsWidget = function() {
        return {
            getDrillDownQueryData: function(intervalRef) {

                console.log("  TopNMalwareDetectionsWidget >>> ");
                var query = " * AND event.fileTag:(";
                console.dir(arguments);
                var addFirst = true;
                for (i = 1; i < arguments.length; i++) {
                    if (!addFirst) {
                        query += " OR " + arguments[i];
                    } else if (addFirst) {
                        addFirst = false;
                        query += "  " + arguments[i];
                    }
                }
                query += ")";
                var presentEpoch = Math.round(new Date().getTime());
                var pastEpoch = presentEpoch - (60 * intervalRef * 1000);
                var queryHeader = {
                    "index": "shieldxdetailedalerts",
                    "ignore_unavailable": true,
                    "preference": 1481583229034
                };

                var queryBody = {
                    "size": 50,
                    "sort": [{
                        "aggregate": {
                            "order": "desc",
                            "unmapped_type": "boolean"
                        }
                    }],
                    "query": {
                        "bool": {
                            "must": [{
                                "query_string": {
                                    "query": query,
                                    "analyze_wildcard": true
                                }
                            }, {
                                "range": {
                                    "aggregate": {
                                        "gte": pastEpoch,
                                        "lte": presentEpoch,
                                        "format": "epoch_millis"
                                    }
                                }
                            }],
                            "must_not": []
                        }
                    }
                };
                var queryStr = JSON.stringify(queryHeader) + "\n" + JSON.stringify(queryBody);
                return queryStr;
            },
            getQueryData: function(intervalRef, sizevalue) {
                if (!sizevalue) {
                    sizevalue = 5;
                }
                var presentEpoch = Math.round(new Date().getTime());
                var pastEpoch = presentEpoch - (60 * intervalRef * 1000);

                var queryHeader = {
                    "index": "shieldxdetailedalerts",
                    "ignore_unavailable": true,
                    "preference": 1481054742905
                };

                var queryBody = {
                    "query": {
                        "bool": {
                            "must": [{
                                "query_string": {
                                    "query": "*",
                                    "analyze_wildcard": true
                                }
                            }, {
                                "range": {
                                    "aggregate": {
                                        "gte": pastEpoch,
                                        "lte": presentEpoch,
                                        "format": "epoch_millis"
                                    }
                                }
                            }],
                            "must_not": []
                        }
                    },
                    "size": 0,
                    "aggs": {
                        "3": {
                            "terms": {
                                "field": "event.fileTag",
                                "size": sizevalue,
                                "order": {
                                    "_count": "desc"
                                }
                            },
                            "aggs": {
                                "4": {
                                    "terms": {
                                        "field": "event.srcIpAddress",
                                        "size": sizevalue,
                                        "order": {
                                            "_count": "desc"
                                        }
                                    },
                                    "aggs": {
                                        "5": {
                                            "terms": {
                                                "field": "event.dstIpAddress",
                                                "size": sizevalue,
                                                "order": {
                                                    "_count": "desc"
                                                }
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                };

                var query = JSON.stringify(queryHeader) + "\n" + JSON.stringify(queryBody);
                return query;
            },
            getDataMassageObject: function(data) {
                return {
                    getBarChartData: function() {
                        var buckets = data.aggregations["3"].buckets;
                        var piChatData = WidgetDataUtil.parseBarChartData(buckets);
                        console.log("TopNDetectedThreatsWidget getBarChartData");
                        console.dir(piChatData);
                        return piChatData;
                    },
                    getStackedAreaData: function() {

                        return chartData;
                    }
                };
            },
            massageDrillDowndata: function(data) {
                var tabularView = {};
                tabularView.headers = [];
                tabularView.headers.push({ title: 'Malware File Name' });
                tabularView.headers.push({ title: 'Protocol Name' });
                tabularView.headers.push({ title: 'Source IP' });
                tabularView.headers.push({ title: 'Source Port' });
                tabularView.headers.push({ title: 'Destination IP' });
                tabularView.headers.push({ title: 'Destination Port' });
                tabularView.rowData = [];

                console.log("massageDrillDowndata ");
                var events = data.responses[0].hits.hits;
                for (var i = 0; i < events.length; i++) {
                    var source = events[i]._source;
                    tabularView.rowData.push({ val1: source.event.fileTag, val2: source.event.protocolName, val3: source.event.srcIpAddress, val4: source.event.srcPort, val5: source.event.dstIpAddress, val6: source.event.dstPort });
                }
                console.dir(tabularView);
                return tabularView;
            }
        };
    };
    angular.module('shieldxApp').factory(WidgetName.TopNMalwareDetections + "Factory", TopNMalwareDetectionsWidget);
})();

(function() {
    var TopNMalwareDomainsWidget = function() {
        return {
            getDrillDownQueryData: function(intervalRef) {
                var presentEpoch = Math.round(new Date().getTime());
                var pastEpoch = presentEpoch - (60 * intervalRef * 1000);


                var query = "_type:DPI AND event.domainTag:(";
                console.dir(arguments);
                var addFirst = true;
                for (i = 1; i < arguments.length; i++) {
                    if (!addFirst) {
                        query += " OR " + arguments[i];
                    } else if (addFirst) {
                        addFirst = false;
                        query += "  " + arguments[i];
                    }
                }
                query += ")";

                var queryHeader = {
                    "index": "shieldxdetailedalerts",
                    "ignore_unavailable": true,
                    "preference": 1481583229034
                };



                var queryBody = {
                    "sort": [{
                        "aggregate": {
                            "order": "desc",
                            "unmapped_type": "boolean"
                        }
                    }],
                    "query": {
                        "bool": {
                            "must": [{
                                "query_string": {
                                    "query": query,
                                    "analyze_wildcard": true
                                }
                            }, {
                                "range": {
                                    "aggregate": {
                                        "gte": pastEpoch,
                                        "lte": presentEpoch,
                                        "format": "epoch_millis"
                                    }
                                }
                            }],
                            "must_not": []
                        }
                    }
                };
                return JSON.stringify(queryHeader) + "\n\r" + JSON.stringify(queryBody);
            },
            getQueryData: function(intervalRef, sizevalue) {
                if (!sizevalue) {
                    sizevalue = 50;
                }
                var presentEpoch = Math.round(new Date().getTime());
                var pastEpoch = presentEpoch - (60 * intervalRef * 1000);
                var queryHeader = {
                    "index": "shieldxdetailedalerts",
                    "ignore_unavailable": true,
                    "preference": 1481580991781
                };
                var queryBody = {
                    "size": 0,
                    "query": {
                        "bool": {
                            "must": [{
                                "query_string": {
                                    "query": "*",
                                    "analyze_wildcard": true
                                }
                            }, {
                                "range": {
                                    "aggregate": {
                                        "gte": pastEpoch,
                                        "lte": presentEpoch,
                                        "format": "epoch_millis"
                                    }
                                }
                            }],
                            "must_not": []
                        }
                    },
                    "aggs": {
                        "2": {
                            "terms": {
                                "field": "event.domainTag",
                                "size": sizevalue,
                                "order": {
                                    "_count": "desc"
                                }
                            }
                        }
                    }
                };
                return JSON.stringify(queryHeader) + "\n" + JSON.stringify(queryBody);
            },
            getDataMassageObject: function(data) {
                return {
                    getBarChartData: function() {
                        var buckets = data.aggregations["2"].buckets;
                        var piChatData = WidgetDataUtil.parseBarChartData(buckets);
                        console.log("TopNMalwareDomainsWidget getBarChartData");
                        console.dir(piChatData);
                        return piChatData;
                    },
                    getStackedAreaData: function() {

                        return chartData;
                    }
                };
            },
            massageDrillDowndata: function(data) {
                var tabularView = {};
                tabularView.headers = [];
                tabularView.headers.push({ title: 'Application Name' });
                tabularView.headers.push({ title: 'Protocol Name' });
                tabularView.headers.push({ title: 'Source IP' });
                tabularView.headers.push({ title: 'Source Port' });
                tabularView.headers.push({ title: 'Destination IP' });
                tabularView.headers.push({ title: 'Destination Port' });
                tabularView.headers.push({ title: 'Domain' });
                tabularView.rowData = [];

                console.log("massageDrillDowndata ");
                var events = data.responses[0].hits.hits;
                for (var i = 0; i < events.length; i++) {
                    var source = events[i]._source;
                    tabularView.rowData.push({ val1: source.event.applicationName, val2: source.event.protocolName, val3: source.event.srcIpAddress, val4: source.event.srcPort, val5: source.event.dstIpAddress, val6: source.event.dstPort, val7: source.event.domain });
                }
                console.dir(tabularView);
                return tabularView;
            }
        };
    };
    angular.module('shieldxApp').factory(WidgetName.TopNMalwareDomains + "Factory", TopNMalwareDomainsWidget);
})();

(function() {
    var TopNServedDomainsWidget = function() {
        return {
            getDrillDownQueryData: function(intervalRef) {
                console.log(" TopNServedDomainsWidget getDrillDownQueryData  ");
                console.log("intervalRef  " + intervalRef);

                function isBlank(str) {
                    return (!str || /^\s*$/.test(str));
                }
                var query = "_type:DPI AND event.domain:(";
                console.dir(arguments);
                var addFirst = true;
                for (i = 1; i < arguments.length; i++) {
                    if (!isBlank(arguments[i])) {
                        if (!addFirst) {
                            query += " OR " + arguments[i];
                        } else if (addFirst) {
                            addFirst = false;
                            query += "  " + arguments[i];
                        }
                    }
                }
                query += ")";

                console.log("query  " + query);
                console.dir(arguments);
                var presentEpoch = Math.round(new Date().getTime());
                var pastEpoch = presentEpoch - (60 * intervalRef * 1000);

                var queryHeader = {
                    "index": "shieldxdetailedalerts",
                    "ignore_unavailable": true,
                    "preference": 1481583229034
                };
                var queryBody = {
                    "sort": [{
                        "aggregate": {
                            "order": "desc",
                            "unmapped_type": "boolean"
                        }
                    }],
                    "query": {
                        "bool": {
                            "must": [{
                                "query_string": {
                                    "query": query,
                                    "analyze_wildcard": true
                                }
                            }, {
                                "range": {
                                    "aggregate": {
                                        "gte": pastEpoch,
                                        "lte": presentEpoch,
                                        "format": "epoch_millis"
                                    }
                                }
                            }],
                            "must_not": []
                        }
                    }
                };
                return JSON.stringify(queryHeader) + "\n" + JSON.stringify(queryBody);
            },
            getQueryData: function(intervalRef, sizevalue) {
                var presentEpoch = Math.round(new Date().getTime());
                var pastEpoch = presentEpoch - (60 * intervalRef * 1000);
                if (!sizevalue) {
                    sizevalue = 50;
                }

                var queryHeader = {
                    "index": "shieldxevents",
                    "ignore_unavailable": true,
                    "preference": 1481580991781
                };
                var queryBody = {
                    "size": 0,
                    "query": {
                        "bool": {
                            "must": [{
                                "query_string": {
                                    "analyze_wildcard": true,
                                    "query": "_type:DPI"
                                }
                            }, {
                                "range": {
                                    "aggregate": {
                                        "gte": pastEpoch,
                                        "lte": presentEpoch,
                                        "format": "epoch_millis"
                                    }
                                }
                            }],
                            "must_not": []
                        }
                    },
                    "aggs": {
                        "2": {
                            "terms": {
                                "field": "event.domain",
                                "size": sizevalue,
                                "order": {
                                    "_count": "desc"
                                }
                            }
                        }
                    }
                };

                var query = JSON.stringify(queryHeader) + "\n" + JSON.stringify(queryBody);
                return query;
            },
            getDataMassageObject: function(data) {
                return {
                    getBarChartData: function() {
                        var buckets = data.aggregations["2"].buckets;
                        var piChatData = WidgetDataUtil.parseBarChartData(buckets);
                        console.log("TopNDetectedThreatsWidget getBarChartData");
                        console.dir(piChatData);
                        return piChatData;
                    },
                    getStackedAreaData: function() {

                        return chartData;
                    },
                    massageDrillDowndata: function(data) {
                        return "";
                    }
                };
            },
            massageDrillDowndata: function(data) {
                var tabularView = {};
                tabularView.headers = [];
                tabularView.headers.push({ title: 'Application Name' });
                tabularView.headers.push({ title: 'Protocol Name' });
                tabularView.headers.push({ title: 'Source IP' });
                tabularView.headers.push({ title: 'Source Port' });
                tabularView.headers.push({ title: 'Destination IP' });
                tabularView.headers.push({ title: 'Destination Port' });
                tabularView.headers.push({ title: 'Domain' });
                tabularView.rowData = [];

                console.log("massageDrillDowndata ");
                var events = data.responses[0].hits.hits;
                for (var i = 0; i < events.length; i++) {
                    var source = events[i]._source;
                    tabularView.rowData.push({ val1: source.event.applicationName, val2: source.event.protocolName, val3: source.event.srcIpAddress, val4: source.event.srcPort, val5: source.event.dstIpAddress, val6: source.event.dstPort, val7: source.event.domain });
                }
                console.dir(tabularView);
                return tabularView;
            }
        };
    };
    angular.module('shieldxApp').factory(WidgetName.TopNServedDomains + "Factory", TopNServedDomainsWidget);
})();

(function() {
    var TopNTalkersbyResourceGroupWidget = function() {
        return {
            getDrillDownQueryData: function(intervalRef) {
                var filterData = arguments[1];
                var source = filterData.name;
                var dest = filterData.destnation;
           //_type:TCP AND event.srcMachineName:bats1Ctr-2-Clnt_2_35.80 AND event.dstMachineName:bats1Ctr-2-Srvr_2_35.81
                 var query = " _type:TCP AND event.srcResourceGroup:" + arguments[1].source + " AND event.dstResourceGroup:" + arguments[1].victim + "";
                var presentEpoch = Math.round(new Date().getTime());
                var pastEpoch = presentEpoch - (60 * intervalRef * 1000);
                var queryHeader = {
                        "index": "shieldxevents",
                        "ignore_unavailable": true,
                        "preference": 1482170500264
                    };

                var queryBody = {
                        "size": 500,
                        "sort": [{
                            "aggregate": {
                                "order": "desc",
                                "unmapped_type": "boolean"
                            }
                        }],
                        "query": {
                            "bool": {
                                "must": [{
                                    "query_string": {
                                        "query": query,
                                        "analyze_wildcard": true
                                    }
                                }, {
                                    "range": {
                                        "aggregate": {
                                            "gte": pastEpoch,
                                            "lte": presentEpoch,
                                            "format": "epoch_millis"
                                        }
                                    }
                                }],
                                "must_not": []
                            }
                        }
                    };
                var queryStr = JSON.stringify(queryHeader) + "\n" + JSON.stringify(queryBody);
                return queryStr;
            },
            getQueryData: function(intervalRef, sizevalue) {
                if (!sizevalue) {
                    sizevalue = 5;
                }
                var presentEpoch = Math.round(new Date().getTime());
                var pastEpoch = presentEpoch - (60 * intervalRef * 1000);
                var timezone = jstz.determine().name();
                var queryHeader = {
                    "index": "shieldxevents",
                    "ignore_unavailable": true,
                    "preference": 1482173223246
                };

                var queryBody = {
                    "size": 50,
                    "query": {
                        "bool": {
                            "must": [{
                                "query_string": {
                                    "query": "_type:TCP",
                                    "analyze_wildcard": true
                                }
                            }, {
                                "range": {
                                    "aggregate": {
                                        "gte": pastEpoch,
                                        "lte": presentEpoch,
                                        "format": "epoch_millis"
                                    }
                                }
                            }],
                            "must_not": []
                        }
                    },
                    "aggs": {
                        "2": {
                            "terms": {
                                "field": "event.srcResourceGroup",
                                "size": sizevalue,
                                "order": { "_count": "desc" }
                            },
                            "aggs": {
                                "3": {
                                    "terms": {
                                        "field": "event.dstResourceGroup",
                                        "size": sizevalue,
                                        "order": { "_count": "desc" }
                                    }
                                }
                            }
                        }
                    }
                };

                var query = JSON.stringify(queryHeader) + "\n" + JSON.stringify(queryBody);
                return query;
            },
            getDataMassageObject: function(data,navlue) {
                var ognvalue = navlue;
                return {
                    getBarChartData: function() {
                        var buckets = data.aggregations["2"].buckets;
                        var navlue = parseInt(ognvalue);
                        var piChatData = WidgetDataUtil.getPairedBarChartData(buckets);
                        console.log("TopNBadCertificatesWidget getBarChartData");
                        console.dir(piChatData);
                        var totalData = _.sortBy(piChatData, 'Freq');
                        if (totalData.length >= navlue) {
                            piChatData = totalData.slice(totalData.length - navlue, totalData.length);
                        }
                        return piChatData;
                    },
                    getStackedAreaData: function() {

                        return chartData;
                    },
                    massageDrillDowndata: function(data) {
                        return "";
                    },
                    getFiltterData: function() {
                        var buckets = data.responses[0].aggregations["2"].buckets;
                        var filterData = [];
                        for (var i = 0; i < buckets.length; i++) {
                            var eachBucket = buckets[i];
                            var rgData = {
                                name: eachBucket.key,
                                destnation: []
                            };
                            var subBucket = eachBucket["3"].buckets;
                            for (var k = 0; k < subBucket.length; k++) {
                                rgData.destnation.push(subBucket[k].key);
                            }

                            filterData.push(rgData);
                        }
                        return filterData;
                    }
                };
            },
            massageDrillDowndata: function(data) {
                var tabularView = {};
                tabularView.headers = [];
                tabularView.headers.push({ title: 'Source Machine Name' });
                tabularView.headers.push({ title: 'Source IP' });
                tabularView.headers.push({ title: 'Source ResourceGroup ' });
                tabularView.headers.push({ title: 'Destination Machine Name' });
                tabularView.headers.push({ title: 'Destination IP' });
                tabularView.headers.push({ title: 'Destination ResourceGroup' });

                tabularView.rowData = [];

                console.log("massageDrillDowndata ");
                var events = data.responses[0].hits.hits;
                for (var i = 0; i < events.length; i++) {
                    var source = events[i]._source;
                    tabularView.rowData.push({ val1: source.event.srcMachineName, val2: source.event.srcIpAddress, val3: source.event.srcResourceGroup, val4: source.event.dstMachineName, val5: source.event.dstIpAddress, val6: source.event.dstResourceGroup });
                }
                console.dir(tabularView);
                return tabularView;
            }
        };
    };
    angular.module('shieldxApp').factory(WidgetName.TopNTalkersbyResourceGroup + "Factory", TopNTalkersbyResourceGroupWidget);
})();

(function() {
    var TopNTalkersbyVMnameWidget = function() {
        return {
            getDrillDownQueryData: function(intervalRef) {
                console.log(" TopNDetectedAppsWidget getDrillDownQueryData  ");
                console.log("intervalRef  " + intervalRef);
                var filterData = arguments[1];
                var source = filterData.name;
                var dest = filterData.destnation;
                //var subQuery = "";
                var addFirst = true;
                /*for (i = 0; i < dest.length; i++) {
                    if (!addFirst) {
                        subQuery += " OR  ( event.srcMachineName:" + source + " AND event.dstMachineName:" + dest[i] + ")";
                    } else if (addFirst) {
                        addFirst = false;
                        subQuery += " ( event.srcMachineName:" + source + " AND event.dstMachineName:" + dest[i] + ")";
                    }
                }*/
                var query = "_type:TCP AND event.srcMachineName:" + arguments[1].source + " AND event.dstMachineName:" + arguments[1].victim + "";
                //event.srcMachineName:bats1Ctr-2-Clnt_2_35.80 AND event.dstMachineName:bats1Ctr-2-Srvr_2_35.81
                //var query = "_type:DPI AND (" + subQuery + ")";
                console.log("query  " + query);
                console.dir(arguments);
                var presentEpoch = Math.round(new Date().getTime());
                var pastEpoch = presentEpoch - (60 * intervalRef * 1000);

                var queryHeader = {
                    "index": "shieldxevents",
                    "ignore_unavailable": true,
                    "preference": 1482170500264
                };
                var queryBody = {
                    "sort": [{
                        "aggregate": {
                            "order": "desc",
                            "unmapped_type": "boolean"
                        }
                    }],
                    "query": {
                        "bool": {
                            "must": [{
                                "query_string": {
                                    "query": query,
                                    "analyze_wildcard": true
                                }
                            }, {
                                "range": {
                                    "aggregate": {
                                        "gte": pastEpoch,
                                        "lte": presentEpoch,
                                        "format": "epoch_millis"
                                    }
                                }
                            }],
                            "must_not": []
                        }
                    }
                };
                return JSON.stringify(queryHeader) + "\n" + JSON.stringify(queryBody);
            },
            getQueryData: function(intervalRef, sizevalue) {
                if (!sizevalue) {
                    sizevalue = 5;
                }
                var presentEpoch = Math.round(new Date().getTime());
                var pastEpoch = presentEpoch - (60 * intervalRef * 1000);
                var queryHeader = {
                    "index": "shieldxevents",
                    "ignore_unavailable": true,
                    "preference": 1482173223246
                };

                var queryBody = {
                    "size": 0,
                    "query": {
                        "bool": {
                            "must": [{
                                "query_string": {
                                    "query": "_type:TCP",
                                    "analyze_wildcard": true
                                }
                            }, {
                                "range": {
                                    "aggregate": {
                                        "gte": pastEpoch,
                                        "lte": presentEpoch,
                                        "format": "epoch_millis"
                                    }
                                }
                            }],
                            "must_not": []
                        }
                    },
                    "aggs": {
                        "2": {
                            "terms": {
                                "field": "event.srcMachineName",
                                "size": sizevalue,
                                "order": { "_count": "desc" }
                            },
                            "aggs": {
                                "3": {
                                    "terms": {
                                        "field": "event.dstMachineName",
                                        "size": sizevalue,
                                        "order": { "_count": "desc" }
                                    }
                                }
                            }
                        }
                    }
                };
                return JSON.stringify(queryHeader) + "\n" + JSON.stringify(queryBody);
            },
            getDataMassageObject: function(data,navlue) {
                 var ognvalue = navlue;
                return {
                    getBarChartData: function() {
                        console.log("TopNTalkersbyVMnameWidget");
                        var buckets = data.aggregations["2"].buckets;
                        var navlue = parseInt(ognvalue);
                        var piChatData = WidgetDataUtil.getPairedBarChartData(buckets);
                        console.log("TopNBadCertificatesWidget getBarChartData");
                        console.dir(piChatData);
                        var totalData = _.sortBy(piChatData, 'Freq');
                        if (totalData.length >= navlue) {
                            piChatData = totalData.slice(totalData.length - navlue, totalData.length);
                        }
                        return piChatData;
                    },
                    getStackedAreaData: function() {

                        return chartData;
                    },
                    getFiltterData: function() {
                        var buckets = data.responses[0].aggregations["2"].buckets;
                        var filterData = [];
                        for (var i = 0; i < buckets.length; i++) {
                            var eachBucket = buckets[i];
                            var vmdata = {
                                name: eachBucket.key,
                                destnation: []
                            };
                            var subBucket = eachBucket["3"].buckets;
                            for (var k = 0; k < subBucket.length; k++) {
                                vmdata.destnation.push(subBucket[k].key);
                            }

                            filterData.push(vmdata);
                        }
                        return filterData;
                    }
                };
            },
            massageDrillDowndata: function(data) {
                var tabularView = {};
                tabularView.headers = [];
                tabularView.headers.push({ title: 'Source Machine Name' });
                tabularView.headers.push({ title: 'Source IP' });
                tabularView.headers.push({ title: 'Source ResourceGroup ' });
                tabularView.headers.push({ title: 'Destination Machine Name' });
                tabularView.headers.push({ title: 'Destination IP' });
                tabularView.headers.push({ title: 'Destination ResourceGroup' });
                //tabularView.headers.push({ title: 'Application Name' });
                tabularView.rowData = [];

                console.log("massageDrillDowndata ");
                var events = data.responses[0].hits.hits;
                for (var i = 0; i < events.length; i++) {
                    var source = events[i]._source;
                    tabularView.rowData.push({ val1: source.event.srcMachineName, val2: source.event.srcIpAddress, val3: source.event.srcResourceGroup, val4: source.event.dstMachineName, val5: source.event.dstIpAddress, val6: source.event.dstResourceGroup });
                }
                console.dir(tabularView);
                return tabularView;
            }
        };
    };
    angular.module('shieldxApp').factory(WidgetName.TopNTalkersbyVMname + "Factory", TopNTalkersbyVMnameWidget);
})();

(function() {
    var TopNVictimResourceGroupsWidget = function() {
        return {
            getDrillDownQueryData: function(intervalRef) {
                console.log("  TopNDetectedThreatsWidget >>> ");
                var query = "_type:DPI AND event.VictimResourceGroup:(";
                console.dir(arguments);
                var addFirst = true;
                for (i = 1; i < arguments.length; i++) {
                    if (!addFirst) {
                        query += " OR " + arguments[i];
                    } else if (addFirst) {
                        addFirst = false;
                        query += "  " + arguments[i];
                    }
                }
                query += ")";
                var presentEpoch = Math.round(new Date().getTime());
                var pastEpoch = presentEpoch - (60 * intervalRef * 1000);
                var queryHeader = {
                    "index": "shieldxdetailedalerts",
                    "ignore_unavailable": true,
                    "preference": 1481583229034
                };

                var queryBody = {
                    "sort": [{
                        "aggregate": {
                            "order": "desc",
                            "unmapped_type": "boolean"
                        }
                    }],
                    "query": {
                        "bool": {
                            "must": [{
                                "query_string": {
                                    "query": query,
                                    "analyze_wildcard": true
                                }
                            }, {
                                "range": {
                                    "aggregate": {
                                        "gte": pastEpoch,
                                        "lte": presentEpoch,
                                        "format": "epoch_millis"
                                    }
                                }
                            }],
                            "must_not": []
                        }
                    }
                };
                var queryStr = JSON.stringify(queryHeader) + "\n" + JSON.stringify(queryBody);
                return queryStr;
            },
            getQueryData: function(intervalRef, sizevalue) {
                if (!sizevalue) {
                    sizevalue = 5;
                }
                var presentEpoch = Math.round(new Date().getTime());
                var pastEpoch = presentEpoch - (60 * intervalRef * 1000);

                var queryHeader = {
                    "index": "shieldxdetailedalerts",
                    "ignore_unavailable": true,
                    "preference": 1481580902567
                };

                var queryBody = {
                    "size": 0,
                    "query": {
                        "bool": {
                            "must": [{
                                "query_string": {
                                    "analyze_wildcard": true,
                                    "query": "_type:DPI"
                                }
                            }, {
                                "range": {
                                    "aggregate": {
                                        "gte": pastEpoch,
                                        "lte": presentEpoch,
                                        "format": "epoch_millis"
                                    }
                                }
                            }],
                            "must_not": []
                        }
                    },
                    "aggs": {
                        "2": {
                            "terms": {
                                "field": "event.VictimResourceGroup",
                                "size": sizevalue,
                                "order": {
                                    "_count": "desc"
                                }
                            }
                        }
                    }
                };

                var query = JSON.stringify(queryHeader) + "\n" + JSON.stringify(queryBody);
                return query;
            },
            getDataMassageObject: function(data) {
                return {
                    getBarChartData: function() {
                        var buckets = data.aggregations["2"].buckets;
                        var piChatData = WidgetDataUtil.parseBarChartData(buckets);
                        console.log("TopNDetectedThreatsWidget getBarChartData");
                        console.dir(piChatData);
                        return piChatData;
                    },
                    getStackedAreaData: function() {

                        return chartData;
                    }
                };
            },
            massageDrillDowndata: function(data) {
                var tabularView = {};
                tabularView.headers = [];
                tabularView.headers.push({ title: 'Victim Resource Group Name' });
                tabularView.headers.push({ title: 'Victim IP' });
                tabularView.headers.push({ title: 'Attacker ResourceGroup Name' });
                tabularView.headers.push({ title: 'Attacker IP' });
                tabularView.headers.push({ title: 'Attacker Name' });
                tabularView.headers.push({ title: 'Victim Name' });
                tabularView.headers.push({ title: 'Threat Name' });
                tabularView.rowData = [];

                console.log("massageDrillDowndata ");
                var events = data.responses[0].hits.hits;
                for (var i = 0; i < events.length; i++) {
                    var source = events[i]._source;
                    tabularView.rowData.push({ val1: source.event.VictimResourceGroup, val2: source.event.VictimIp, val3: source.event.AttackerResourceGroup, val4: source.event.AttackerIp, val5: source.event.Attacker, val6: source.event.Victim, val7: source.event.threatName });
                }
                console.dir(tabularView);
                return tabularView;
            }
        };
    };
    angular.module('shieldxApp').factory(WidgetName.TopNVictimResourceGroups + "Factory", TopNVictimResourceGroupsWidget);
})();

(function() {
    var TopNVictimsWidget = function() {
        return {
            getDrillDownQueryData: function(intervalRef) {
                console.log(" TopNDetectedAppsWidget getDrillDownQueryData  ");
                console.log("intervalRef  " + intervalRef);
                var query = "_type:DPI AND event.Victim:(";
                console.dir(arguments);
                var addFirst = true;
                for (i = 1; i < arguments.length; i++) {
                    if (!addFirst) {
                        query += " OR " + arguments[i];
                    } else if (addFirst) {
                        addFirst = false;
                        query += "  " + arguments[i];
                    }
                }
                query += ")";
                console.log("query  " + query);
                console.dir(arguments);
                var presentEpoch = Math.round(new Date().getTime());
                var pastEpoch = presentEpoch - (60 * intervalRef * 1000);

                var queryHeader = {
                    "index": "shieldxdetailedalerts",
                    "ignore_unavailable": true,
                    "preference": 1481582140001
                };
                var queryBody = {
                    "sort": [{
                        "aggregate": {
                            "order": "desc",
                            "unmapped_type": "boolean"
                        }
                    }],
                    "query": {
                        "bool": {
                            "must": [{
                                "query_string": {
                                    "query": query,
                                    "analyze_wildcard": true
                                }
                            }, {
                                "range": {
                                    "aggregate": {
                                        "gte": pastEpoch,
                                        "lte": presentEpoch,
                                        "format": "epoch_millis"
                                    }
                                }
                            }],
                            "must_not": []
                        }
                    }
                };
                return JSON.stringify(queryHeader) + "\n" + JSON.stringify(queryBody);
            },
            getQueryData: function(intervalRef, sizevalue) {
                if (!sizevalue) {
                    sizevalue = 5;
                }
                var presentEpoch = Math.round(new Date().getTime());
                var pastEpoch = presentEpoch - (60 * intervalRef * 1000);
                var queryHeader = {
                    "index": "shieldxdetailedalerts",
                    "ignore_unavailable": true,
                    "preference": 1481580902567
                };

                var queryBody = {
                    "size": 0,
                    "query": {
                        "bool": {
                            "must": [{
                                "query_string": {
                                    "analyze_wildcard": true,
                                    "query": "_type:DPI"
                                }
                            }, {
                                "range": {
                                    "aggregate": {
                                        "gte": pastEpoch,
                                        "lte": presentEpoch,
                                        "format": "epoch_millis"
                                    }
                                }
                            }],
                            "must_not": []
                        }
                    },
                    "aggs": {
                        "2": {
                            "terms": {
                                "field": "event.Victim",
                                "size": sizevalue,
                                "order": {
                                    "_count": "desc"
                                }
                            }
                        }
                    }
                };
                return JSON.stringify(queryHeader) + "\n" + JSON.stringify(queryBody);
            },
            getDataMassageObject: function(data) {
                return {
                    getBarChartData: function() {
                        var buckets = data.aggregations["2"].buckets;
                        var piChatData = WidgetDataUtil.parseBarChartData(buckets);
                        console.log("TopNDetectedAppsWidget getBarChartData");
                        console.dir(piChatData);
                        return piChatData;
                    },
                    getStackedAreaData: function() {

                        return chartData;
                    },
                    massageDrillDowndata: function(data) {
                        return "";
                    }
                };
            },
            massageDrillDowndata: function(data) {
                var tabularView = {};
                tabularView.headers = [];
                tabularView.headers.push({ title: 'Victim' });
                tabularView.headers.push({ title: 'Victim IP' });
                tabularView.headers.push({ title: 'Victim resource group' });
                tabularView.headers.push({ title: 'Security Policy Set' });
                tabularView.headers.push({ title: 'Sensor response' });
                tabularView.headers.push({ title: 'Severity' });
                tabularView.headers.push({ title: 'Policy name' });
                tabularView.rowData = [];

                console.log("massageDrillDowndata ");
                var events = data.responses[0].hits.hits;
                for (var i = 0; i < events.length; i++) {
                    var source = events[i]._source;
                    tabularView.rowData.push({ val1: source.event.Victim, val2: source.event.VictimIp, val3: source.event.VictimResourceGroup, val4: source.event.securityPolicySetName, val5: source.event.sensorResponse, val6: source.event.severity, val7: source.event.policyName });
                }
                console.dir(tabularView);
                return tabularView;
            }
        };
    };
    angular.module('shieldxApp').factory(WidgetName.TopNVictims + "Factory", TopNVictimsWidget);
})();

(function() {
    var TroubledMicroServicesWidget = function() {
        return {
            getDrillDownQueryData: function() {
                return "";
            },
            getQueryData: function() {
                var presentEpoch = Math.round(new Date().getTime());
                var interval = 30;
                var pastEpoch = presentEpoch - (60 * interval * 1000);
                console.log(" present ephoc >> " + presentEpoch);
                console.log(" pastEpoch ephoc >> " + pastEpoch);
                var queryRequest = new ElasticSearchRequest();
                queryRequest.setSearchType("count").
                setIgnoreUnavailable(true).
                setIndex("shieldxalerts").
                setQuery("*").
                setGte(pastEpoch).
                setlte(presentEpoch);

                var agg = new ElasticSearchAgg();

                var bucket = new ElasticSearchBucket();
                bucket.setType(ElasticSearchBucket.TERMS);
                bucket.setFieldName("malDomain");

                var field = new ElasticSearchField();
                field.value = 50;
                field.type = ElasticSearchField.NUMERICAL;
                bucket.addFields("size", field);

                field = new ElasticSearchField();
                field.value = "{\"1\":\"desc\"}";
                field.type = ElasticSearchField.GENARIC;
                bucket.addFields("order", field);
                agg.addBucket(bucket);

                var agg1 = new ElasticSearchAgg();
                bucket = new ElasticSearchBucket();
                bucket.setType(ElasticSearchBucket.SUM);
                bucket.setFieldName("malDomCount");
                agg1.addBucket(bucket);

                agg.addNestedArgs(agg1);

                queryRequest.setAggregation(agg);

                var query = queryRequest.getJSON();

                return query;
            },
            getDataMassageObject: function(data) {
                return {
                    getBarChartData: function() {
                        return "";
                    },
                    getAlertData: function() {
                        var piChatData = [];
                        console.log("getBasicPieChartData");
                        console.dir(data);
                        var buckets = data.aggregations["1"].buckets;
                        console.log("buckets");
                        console.dir(buckets);
                        for (var i = 0; i < buckets.length; i++) {
                            var bucket = buckets[i];
                            piChatData.push({ "label": bucket.key, "value": bucket["1"].value });
                        }
                        console.log("piChatData  >> ");
                        console.dir(buckets);
                        return piChatData;
                    }
                };
            },
            massageDrillDowndata: function(data) {
                return "";
            }
        };
    };

    angular.module('shieldxApp').factory(WidgetName.TroubledMicroServices + "Factory", TroubledMicroServicesWidget);
})();

function AuthUser(){
  this.userName ="";
  this.password = "";
  this.isLoggedIn = false;
  this.role = "";
  this.token = "";
}


AuthUser.prototype.copy= function(data){
  this.userName = data.userName;
  this.password = data.password;
  this.isLoggedIn = data.isLoggedIn;
  this.role = data.role;
  this.token = data.token;
};

AuthUser.prototype.getToken= function(){
 return this.token;
};


function authorities(id){
  return authorities.list[id];
}
authorities.list = {
  quickSetup_read:"QUICKSETUP_READ",
  ipPools_read:"IPPOOL_READ", 
  ipPools_create:"IPPOOL_CREATE",
  ipPools_update:"IPPOOL_UPDATE",
  ipPools_delete:"IPPOOL_DELETE",
  infrastructureConnectors_read:"INFRA_READ",
  infrastructureConnectors_create:"INFRA_CREATE",
  infrastructureConnectors_delete:"INFRA_DELETE",
  infrastructureConnectors_update:"INFRA_UPDATE",
  infrastructureConnectors_discover:"INFRA_DISCOVER",
  vlanPools_read:"VLANPOOL_READ",
  vlanPools_create:"VLANPOOL_CREATE",
  vlanPools_delete:"VLANPOOL_DELETE",
  vlanPools_update:"VLANPOOL_UPDATE",
  deploymentSpecifications_read:"DEPLOYSPEC_READ",
  deploymentSpecifications_create:"DEPLOYSPEC_CREATE",
  deploymentSpecifications_delete:"DEPLOYSPEC_DELETE",
  deploymentSpecifications_update:"DEPLOYSPEC_UPDATE",
  virtualChassis_read:"CHASSIS_READ",
  virtualChassis_create:"CHASSIS_CREATE",
  virtualChassis_delete:"CHASSIS_UPDATE",
  virtualChassis_update:"CHASSIS_UPDATE",
  virtualChassis_check:"CHASSIS_CHECK",
  virtualChassis_deploy:"CHASSIS_DEPLOY",
  resourceGroups_read:"RG_READ",
  resourceGroups_create:"RG_CREATE",
  resourceGroups_delete:"RG_DELETE",
  resourceGroups_update:"RG_UPDATE", 
  shieldxUpdates_update:"SOFTWARE_UPGRADE",
  shieldxUpdates_content_update:"CONTENT_UPDATE",
  shieldxUpdates_controlplane_read:"CONTROLPLANE_READ",
  shieldxUpdates_controlplane_update:"CONTROLPLANE_UPDATE",
  integrations_read:"INTEGRATIONS_READ",
  integrations_update:"INTEGRATIONS_UPDATE",
  logs_upload:"LOG_UPLOAD",
  policy_read:"POLICY_READ",
  policy_create:"POLICY_CREATE",
  policy_delete:"POLICY_DELETE",
  policy_update:"POLICY_UPDATE",
  setuptls_read:"TLS_IMPORT_KEYS",
  setuptls_read_public_keys:"TLS_GET_KEYS",
  setuptls_generate_default_keys:"TLS_UPDATE_KEYS",
  setup_read:"SETUP_READ",
  setup_update:"SETUP_UPDATE",
  notification_read:"SETUP_READ",
  notification_update:"SETUP_UPDATE",
  license_read:"SETUP_READ",
  license_update:"SETUP_UPDATE",
  reports_read:"SETUP_READ",
  maintenance_read:"MAINTENANCE_READ",
  maintenance_update:"MAINTENANCE_UPDATE",
  users_read:"USER_READ",
  users_create:"USER_CREATE",
  users_delete:"USER_DELETE",
  users_update:"USER_UPDATE",
  dashboard_read:"DASHBOARD_READ",
  dashboard_create:"DASHBOARD_CREATE",
  networks_read:"NETWORK_READ",
  analysis_read:"ANALYSIS_READ",
  myLocker_read:"MYLOCKER_READ",
  aboutUs_read:"ABOUTUS_READ"
};


function widgetConfig() {}

widgetConfig.categories = {
    SystemHealth: "System Health",
    Composition: "Composition",
    SecurityEvent: "Security Event",
    Loading: "Loading",
    Anomaly: "Anomaly"
};

widgetConfig.list = {
    /*"TroubledMicroServices": {
        title: "Troubled Microservices",
        value: WidgetName.TroubledMicroServices,
        chartType: "Alert",
        widgetType: ChartTypes.alert,
        category: widgetConfig.categories.SystemHealth,
        otherConfig: [],
        drillDown: true
    },*/
    "InventoryofMicroServices": {
        title: "Inventory of Microservices",
        value: WidgetName.InventoryofMicroServices,
        chartType: "Alert",
        widgetType: ChartTypes.alert,
        category: widgetConfig.categories.Composition,
        drillDown: true
    },
    "SystemInformation": {
        title: "System Information",
        value: WidgetName.SystemInformation,
        chartType: "Alert",
        widgetType: ChartTypes.alert,
        category: widgetConfig.categories.Composition,
        drillDown: true
    },
    "Scaling": {
        title: "Scaling",
        value: WidgetName.Scaling,
        chartType: "Chart",
        widgetType: ChartTypes.stackedArea,
        category: widgetConfig.categories.Loading,
        otherConfig: [{
            label: 'Time Interval',
            model: 'timeInterval',
            options: [
                { value: 30, text: 'Past 30 min' },
                { value: 60, text: 'Past 1 Hr' },
                { value: 120, text: 'Past 2 Hrs' },
                { value: 240, text: 'Past 4 Hrs' },
                { value: 480, text: 'Past 8 Hrs' }
            ]
        }, {
            label: 'Micro Services',
            model: 'microServices',
            options: [
                { value: 'ALL', text: 'ALL' },
                { value: 'SI', text: 'SI' },
                { value: 'NOX', text: 'NOX' },
                { value: 'DPCC', text: 'DPCC' },
                { value: 'TLS', text: 'TLS' },
                { value: 'DPI', text: 'DPI' }
            ]
        }],
        drillDown: false,
        axis: { xlabel: "Time", ylabel: "Number of micro-services" }
    },
    "Throughput": {
        title: "Throughput",
        value: WidgetName.Throughput,
        chartType: "Chart",
        widgetType: ChartTypes.stackedArea,
        category: widgetConfig.categories.Loading,
        otherConfig: [{
            label: 'Time Interval',
            model: 'timeInterval',
            options: [
                { value: 30, text: 'Past 30 min' },
                { value: 60, text: 'Past 1 Hr' },
                { value: 120, text: 'Past 2 Hrs' },
                { value: 240, text: 'Past 4 Hrs' },
                { value: 480, text: 'Past 8 Hrs' }
            ]
        }],
        drillDown: false,
        axis: { xlabel: "Time", ylabel: "Traffic in Mbps" }
    },
    "Flows": {
        title: "Flows",
        value: WidgetName.Flows,
        chartType: "Chart",
        widgetType: ChartTypes.stackedArea,
        category: widgetConfig.categories.Loading,
        otherConfig: [{
            label: 'Time Interval',
            model: 'timeInterval',
            options: [
                { value: 30, text: 'Past 30 min' },
                { value: 60, text: 'Past 1 Hr' },
                { value: 120, text: 'Past 2 Hrs' },
                { value: 240, text: 'Past 4 Hrs' },
                { value: 480, text: 'Past 8 Hrs' }
            ]
        }],
        drillDown: false,
        axis: { xlabel: "Time", ylabel: "Number of flows" }
    },
    "EventRate": {
        title: "Event Rate",
        value: WidgetName.EventRate,
        chartType: "Chart",
        widgetType: ChartTypes.stackedArea,
        category: widgetConfig.categories.Loading,
        otherConfig: [{
            label: 'Time Interval',
            model: 'timeInterval',
            options: [
                { value: 30, text: 'Past 30 min' },
                { value: 60, text: 'Past 1 Hr' },
                { value: 120, text: 'Past 2 Hrs' },
                { value: 240, text: 'Past 4 Hrs' },
                { value: 480, text: 'Past 8 Hrs' }
            ]
        }, {
            label: 'Threshold',
            model: 'threshold',
            default: "Critical",
            options: [
                { value: 'Critical', text: 'Critical' },
                { value: 'High', text: 'High' }
            ]
        }],
        drillDown: false,
        axis: { xlabel: "Time", ylabel: "Number of events reported" }
    },
    "TopNDetectedThreats": {
        title: "Top N Detected Threats",
        value: WidgetName.TopNDetectedThreats,
        chartType: "Chart",
        widgetType: ChartTypes.barChart,
        category: widgetConfig.categories.SecurityEvent,
        otherConfig: [{
            label: 'Time Interval',
            model: 'timeInterval',
            options: [
                { value: 30, text: 'Past 30 min' },
                { value: 60, text: 'Past 1 Hr' },
                { value: 120, text: 'Past 2 Hrs' },
                { value: 240, text: 'Past 4 Hrs' },
                { value: 480, text: 'Past 8 Hrs' }
            ]
        }],
        drillDown: true,
        axis: { xlabel: "Name of the threat", ylabel: "Count" }
    },
    "TopNDetectedApps": {
        title: "Top N Detected Apps",
        value: WidgetName.TopNDetectedApps,
        chartType: "Chart",
        widgetType: ChartTypes.barChart,
        category: widgetConfig.categories.SecurityEvent,
        otherConfig: [{
            label: 'Time Interval',
            model: 'timeInterval',
            options: [
                { value: 30, text: 'Past 30 min' },
                { value: 60, text: 'Past 1 Hr' },
                { value: 120, text: 'Past 2 Hrs' },
                { value: 240, text: 'Past 4 Hrs' },
                { value: 480, text: 'Past 8 Hrs' }
            ]
        }],
        drillDown: true,
        axis: { xlabel: "Name of the app", ylabel: "Count" }
    },
    "TopNMalwareDomains": {
        title: "Top N Malware Domains",
        value: WidgetName.TopNMalwareDomains,
        chartType: "Chart",
        widgetType: ChartTypes.barChart,
        category: widgetConfig.categories.SecurityEvent,
        otherConfig: [{
            label: 'Time Interval',
            model: 'timeInterval',
            options: [
                { value: 30, text: 'Past 30 min' },
                { value: 60, text: 'Past 1 Hr' },
                { value: 120, text: 'Past 2 Hrs' },
                { value: 240, text: 'Past 4 Hrs' },
                { value: 480, text: 'Past 8 Hrs' }
            ]
        }],
        drillDown: true,
        axis: { xlabel: "Name of the malware domain", ylabel: "Count" }
    },
    "TopNMalwareDetections": {
        title: "Top N Malware Detections",
        value: WidgetName.TopNMalwareDetections,
        chartType: "Chart",
        widgetType: ChartTypes.barChart,
        category: widgetConfig.categories.SecurityEvent,
        otherConfig: [{
            label: 'Time Interval',
            model: 'timeInterval',
            options: [
                { value: 30, text: 'Past 30 min' },
                { value: 60, text: 'Past 1 Hr' },
                { value: 120, text: 'Past 2 Hrs' },
                { value: 240, text: 'Past 4 Hrs' },
                { value: 480, text: 'Past 8 Hrs' }
            ]
        }],
        drillDown: true,
        axis: { xlabel: "Name of the malware", ylabel: "Count" }
    },
    "TopNBadCertificates": {
        title: "Top N Bad Certificates",
        value: WidgetName.TopNBadCertificates,
        chartType: "Chart",
        widgetType: ChartTypes.barChart,
        category: widgetConfig.categories.SecurityEvent,
        otherConfig: [{
            label: 'Time Interval',
            model: 'timeInterval',
            options: [
                { value: 30, text: 'Past 30 min' },
                { value: 60, text: 'Past 1 Hr' },
                { value: 120, text: 'Past 2 Hrs' },
                { value: 240, text: 'Past 4 Hrs' },
                { value: 480, text: 'Past 8 Hrs' }
            ]
        }],
        drillDown: true,
        axis: { xlabel: "Name of the certificate", ylabel: "Count" }
    },
    "TopNAttackerResourceGroups": {
        title: "Top N Attacker Resource Groups",
        value: WidgetName.TopNAttackerResourceGroups,
        chartType: "Chart",
        widgetType: ChartTypes.barChart,
        category: widgetConfig.categories.SecurityEvent,
        otherConfig: [{
            label: 'Time Interval',
            model: 'timeInterval',
            options: [
                { value: 30, text: 'Past 30 min' },
                { value: 60, text: 'Past 1 Hr' },
                { value: 120, text: 'Past 2 Hrs' },
                { value: 240, text: 'Past 4 Hrs' },
                { value: 480, text: 'Past 8 Hrs' }
            ]
        }],
        drillDown: true,
        axis: { xlabel: "Resource groups", ylabel: "Count" }
    },
    "TopNVictimResourceGroups": {
        title: "Top N Victim Resource Groups",
        value: WidgetName.TopNVictimResourceGroups,
        chartType: "Chart",
        widgetType: ChartTypes.barChart,
        category: widgetConfig.categories.SecurityEvent,
        otherConfig: [{
            label: 'Time Interval',
            model: 'timeInterval',
            options: [
                { value: 30, text: 'Past 30 min' },
                { value: 60, text: 'Past 1 Hr' },
                { value: 120, text: 'Past 2 Hrs' },
                { value: 240, text: 'Past 4 Hrs' },
                { value: 480, text: 'Past 8 Hrs' }
            ]
        }],
        drillDown: true,
        axis: { xlabel: "Name of the resource group", ylabel: "Count" }
    },
    "TopNAttackers": {
        title: "Top N Attackers",
        value: WidgetName.TopNAttackers,
        chartType: "Chart",
        widgetType: ChartTypes.barChart,
        category: widgetConfig.categories.SecurityEvent,
        otherConfig: [{
            label: 'Time Interval',
            model: 'timeInterval',
            options: [
                { value: 30, text: 'Past 30 min' },
                { value: 60, text: 'Past 1 Hr' },
                { value: 120, text: 'Past 2 Hrs' },
                { value: 240, text: 'Past 4 Hrs' },
                { value: 480, text: 'Past 8 Hrs' }
            ]
        }],
        drillDown: true,
        axis: { xlabel: "Name of the VM or IP", ylabel: "Count" }
    },
    "TopNVictims": {
        title: "Top N Victims",
        value: WidgetName.TopNVictims,
        chartType: "Chart",
        widgetType: ChartTypes.barChart,
        category: widgetConfig.categories.SecurityEvent,
        otherConfig: [{
            label: 'Time Interval',
            model: 'timeInterval',
            options: [
                { value: 30, text: 'Past 30 min' },
                { value: 60, text: 'Past 1 Hr' },
                { value: 120, text: 'Past 2 Hrs' },
                { value: 240, text: 'Past 4 Hrs' },
                { value: 480, text: 'Past 8 Hrs' }
            ]
        }],
        drillDown: true,
        axis: { xlabel: "Name of the VM", ylabel: "Count" }
    },
    "TopNTalkersbyVMname": {
        title: "Top N VMs by Number of Connections",
        value: WidgetName.TopNTalkersbyVMname,
        chartType: "Chart",
        widgetType: ChartTypes.barChart,
        category: widgetConfig.categories.SecurityEvent,
        otherConfig: [{
            label: 'Time Interval',
            model: 'timeInterval',
            options: [
                { value: 30, text: 'Past 30 min' },
                { value: 60, text: 'Past 1 Hr' },
                { value: 120, text: 'Past 2 Hrs' },
                { value: 240, text: 'Past 4 Hrs' },
                { value: 480, text: 'Past 8 Hrs' }
            ]
        }],
        drillDown: true,
        axis: { xlabel: "Name of the VM", ylabel: "Count" }
    },
    "TopNTalkersbyResourceGroup": {
        title: "Top N Resource Groups by Number of Connections",
        value: WidgetName.TopNTalkersbyResourceGroup,
        chartType: "Chart",
        widgetType: ChartTypes.barChart,
        category: widgetConfig.categories.SecurityEvent,
        otherConfig: [{
            label: 'Time Interval',
            model: 'timeInterval',
            options: [
                { value: 30, text: 'Past 30 min' },
                { value: 60, text: 'Past 1 Hr' },
                { value: 120, text: 'Past 2 Hrs' },
                { value: 240, text: 'Past 4 Hrs' },
                { value: 480, text: 'Past 8 Hrs' }
            ]
        }],
        drillDown: true,
        axis: { xlabel: "Name of the Server domain", ylabel: "Count" }
    },
    "TopNBlockedClients": {
        title: "Top N Blocked Clients",
        value: WidgetName.TopNBlockedClients,
        chartType: "Chart",
        widgetType: ChartTypes.barChart,
        category: widgetConfig.categories.SecurityEvent,
        otherConfig: [{
            label: 'Time Interval',
            model: 'timeInterval',
            options: [
                { value: 30, text: 'Past 30 min' },
                { value: 60, text: 'Past 1 Hr' },
                { value: 120, text: 'Past 2 Hrs' },
                { value: 240, text: 'Past 4 Hrs' },
                { value: 480, text: 'Past 8 Hrs' }
            ]
        }],
        drillDown: true,
        axis: { xlabel: "Name of the VM", ylabel: "Count" }
    },
    "TopNServedDomains": {
        title: "Top N Served Domains",
        value: WidgetName.TopNServedDomains,
        chartType: "Chart",
        widgetType: ChartTypes.barChart,
        category: widgetConfig.categories.SecurityEvent,
        otherConfig: [{
            label: 'Time Interval',
            model: 'timeInterval',
            options: [
                { value: 30, text: 'Past 30 min' },
                { value: 60, text: 'Past 1 Hr' },
                { value: 120, text: 'Past 2 Hrs' },
                { value: 240, text: 'Past 4 Hrs' },
                { value: 480, text: 'Past 8 Hrs' }
            ]
        }],
        drillDown: true,
        axis: { xlabel: "Name of the Server domain", ylabel: "Count" }
    },
    "TopNConversations": {
        title: "Top N VMs by Data Transferred (measured in bytes) ",
        value: WidgetName.TopNConversations,
        chartType: "Chart",
        widgetType: ChartTypes.barChart,
        category: widgetConfig.categories.SecurityEvent,
        otherConfig: [{
            label: 'Time Interval',
            model: 'timeInterval',
            options: [
                { value: 30, text: 'Past 30 min' },
                { value: 60, text: 'Past 1 Hr' },
                { value: 120, text: 'Past 2 Hrs' },
                { value: 240, text: 'Past 4 Hrs' },
                { value: 480, text: 'Past 8 Hrs' }
            ]
        }],
        drillDown: true,
        axis: { xlabel: "Names of the pair of VMs", ylabel: "Count" }
    },
    "IOP": {
        title: "Indicator of Pivot",
        value: WidgetName.IOP,
        chartType: "Chart",
        widgetType: ChartTypes.tables,
        category: widgetConfig.categories.SecurityEvent,
        otherConfig: [{
            label: 'Time Interval',
            model: 'timeInterval',
            options: [
                { value: 1*24*60, text: 'Past 1 Day' },
                { value: 2*24*60, text: 'Past 2 Days' },
                { value: 4*24*60, text: 'Past 4 Days' },
                { value: 9*24*60, text: 'Past 9 Days' }
            ]
        }],
        drillDown: true,
        axis: { xlabel: "", ylabel: "" }
    },
    "NewApplications": {
        title: "New Applications",
        value: WidgetName.NewApplications,
        chartType: "Chart",
        widgetType: ChartTypes.tables,
        category: widgetConfig.categories.Anomaly,
        otherConfig: [],
        drillDown: true,
        axis: { xlabel: "", ylabel: "" }
    }
};


function ProxyData(sourceName, sourceType) {
    this.sourceName = sourceName;
    this.sourceType = sourceType;
    if (!this.sourceType) {
        this.sourceType = "txt";
    }
}

function DataWidgetConfig(chartType, widgetName, interval, queryArguments, proxyData) {
    this.proxyData = proxyData;
    this.widgetName = widgetName;
    this.chartType = chartType;
    if (interval) {
        this.interval = interval;
    } else {
        this.interval = 30;
    }

    if (queryArguments) {
        this.queryArguments = queryArguments;
    } else {
        this.queryArguments = [];
    }

    this.otheroption = null;

}

DataWidgetConfig.prototype.getProxyData = function(arg) {
    return this.proxyData;
};

DataWidgetConfig.prototype.getWidgetName = function(arg) {
    return this.widgetName;
};

DataWidgetConfig.prototype.getChartType = function(arg) {
    return this.chartType;
};

ElasticSearchBucket.DATAHISTOGRAM = "date_histogram";
ElasticSearchBucket.TERMS = "terms";
ElasticSearchBucket.AVG = "avg";
ElasticSearchBucket.SUM = "sum";



function ElasticSearchField() {
    this.value = null;
    this.type = null;
}

ElasticSearchField.NUMERICAL = "numarical";
ElasticSearchField.STRING = "string";
ElasticSearchField.GENARIC = "genaric";

function ElasticSearchBucket() {
    this.containerType = "bucket";
    this.type = "";
    this.fieldName = "";
    this.otherFields = {};
}

ElasticSearchBucket.prototype.getJSON = function() {
    var json = "\"" + this.type + "\":";
    json += "{";
    json += "\"field\": \"" + this.fieldName + "\"";
    for (var property in this.otherFields) {
        if (this.otherFields.hasOwnProperty(property)) {
            var fieldRef = this.otherFields[property];
            switch (fieldRef.type) {
                case ElasticSearchField.STRING:
                    json += ",\"" + property + "\": \"" + fieldRef.value + "\"";
                    break;
                case ElasticSearchField.NUMERICAL:
                case ElasticSearchField.GENARIC:
                    json += ",\"" + property + "\":" + fieldRef.value + "";
                    break;
            }

        }
    }
    json += "}";
    return json;
};

ElasticSearchBucket.prototype.setType = function(arg) {
    this.type = arg;
};

ElasticSearchBucket.prototype.setFieldName = function(arg) {
    this.fieldName = arg;
};

ElasticSearchBucket.prototype.addFields = function(key, value) {
    this.otherFields[key] = value;
};

function ElasticSearchSort() {
    this.aggregation = null;
}

ElasticSearchSort.prototype.getJSON = function() {
    var json = "";
    return "";
};

function ElasticSearchAgg() {
    this.containerType = "aggs";
    this.name = "";
    this.nested = [];
}

ElasticSearchAgg.prototype.setName = function(arg) {
    this.name = arg;
};
ElasticSearchAgg.prototype.addBucket = function(arg) {
    this.nested.push(arg);
};

ElasticSearchAgg.prototype.addNestedArgs = function(arg) {
    this.nested.push(arg);
};

ElasticSearchAgg.prototype.getJSON = function() {
    var json = "";
    var count = 1;
    this.name = count++;
    json = "\"aggs\": {";
    json += "\"" + this.name + "\":";
    json += "{";
    for (var i = 0; i < this.nested.length; i++) {
        var rec = this.nested[i];
        if (rec) {
            if (i > 0) {
                json += ",";
            }
            if (rec.containerType === "aggs") {
                rec.name = count++;
                json += rec.getJSON();
            } else if (rec.containerType === "bucket") {
                json += rec.getJSON();
            }

        }
    }
    json += "}";
    json += "}";

    return json;
};


function ElasticSearchRequest() {
    this.index = null;
    this.searchType = null;
    this.ignoreUnavailable = null;
    this.aggregation = null;
    this.query = "";
    this.sort = false;
    this.gte = "";
    this.lte = "";
    this.exists = [];

}

ElasticSearchRequest.prototype.addExist = function(arg) {
    this.exists.push(arg);
    return this;
};

ElasticSearchRequest.prototype.setSort = function(arg) {
    this.sort = arg;
    return this;
};
ElasticSearchRequest.prototype.setSearchType = function(arg) {
    this.searchType = arg;
    return this;
};
ElasticSearchRequest.prototype.setIgnoreUnavailable = function(arg) {
    this.ignoreUnavailable = arg;
    return this;
};
ElasticSearchRequest.prototype.setIndex = function(arg) {
    this.index = arg;
    return this;
};
ElasticSearchRequest.prototype.setAggregation = function(arg) {
    this.aggregation = arg;
    return this;
};

ElasticSearchRequest.prototype.setQuery = function(arg) {
    this.query = arg;
    return this;
};

ElasticSearchRequest.prototype.setGte = function(arg) {
    this.gte = arg;
    return this;
};

ElasticSearchRequest.prototype.setlte = function(arg) {
    this.lte = arg;
    return this;
};


ElasticSearchRequest.prototype.getJSON = function() {
    var json = "";
    //header 
    json += "{";
    json += "\"index\":[\"" + this.index + "\"]";
    //json += "\"index\":\""+this.index+"\""; 
    if (this.searchType) {
        json += ",\"search_type\":\"" + this.searchType + "\"";
    }
    json += ",\"ignore_unavailable\":" + this.ignoreUnavailable + "";
    json += "}";
    json += "\r\n";
    // body
    json += "{";
    json += "\"size\":0";
    if (this.sort) {
        json += ",\"sort\": [{\"aggregate\": {\"order\": \"desc\",\"unmapped_type\": \"boolean\"}}]";
    }
    json += ",\"query\": {\"bool\":{\"must\": [";
    json += "{\"query_string\": {\"query\": \"" + this.query + "\",\"analyze_wildcard\": true}}";
    if (this.exists) {
        for (var i = 0; i < this.exists.length; i++) {
            json += ",{\"exists\": {";
            json += "\"field\": \"" + this.exists[i] + "\"";
            json += "}}";
        }
    }
    json += ", {\"range\": {\"aggregate\": {\"gte\":" + this.gte + ",\"lte\":" + this.lte + ",\"format\": \"epoch_millis\"}}}";
    json += "]";
    json += ",\"must_not\": []}}";

    if (this.aggregation) {
        json += ",";
        json += this.aggregation.getJSON();
    }
    json += "}";
    return json;
};

function WidgetDataUtil() {

}

WidgetDataUtil.parseBarChartData = function(data) {
    console.log("parseBarChatData ");
    console.dir(data);
    var piChatData = [];
    for (var i = 0; i < data.length; i++) {
        var bucket = data[i];
        piChatData.push({ "Letter": bucket.key, "Freq": bucket.doc_count });
    }
    return piChatData;
};

WidgetDataUtil.drillDownParamsWithOutSpace = function(startString, data, endString) {
    var query = startString;
    var addFirst = true;
    for (i = 1; i < data.length; i++) {
        if (!addFirst) {
            query += " OR " + data[i].split(' ').join('\\ ');
        } else if (addFirst) {
            addFirst = false;
            query += "  " + data[i].split(' ').join('\\ ');
        }
    }
    query += endString;
    return query;
};
WidgetDataUtil.drillDownIntervaloptions = [
    { value: 30, text: 'Past 30 min' },
    { value: 60, text: 'Past 1 Hr' },
    { value: 120, text: 'Past 2 Hrs' },
    { value: 240, text: 'Past 4 Hrs' },
    { value: 480, text: 'Past 8 Hrs' }
];
WidgetDataUtil.getPairedBarChartData = function(buckets){
    var subuckets = '',subbucketData ='',name = '';
    var piChatData = [];
    for(var i =0;i<buckets.length;i++){
        subuckets = buckets[i];
        name = buckets[i].key;
        subbucketData = subuckets["3"].buckets;
        for(var j=0;j<subbucketData.length;j++){
             piChatData.push({ "Letter": "(" + name + " _ " + subbucketData[j].key + ")", "Freq": subbucketData[j].doc_count, "source": name, "victim": subbucketData[j].key });
        }
    }
    return piChatData;
};

function EventVisualizationData(filterdata, queryResult,simulate) {
    this.filterdata = filterdata;
    this.queryResult = queryResult;
    this.simulate = false;
    if(simulate){
      this.simulate = simulate;
    }
    

     this.fieldConfig = {
        Src_IP: { filedName: "srcIpAddress", type:"IP", map:"source"},
        Dest_IP: { filedName: "dstIpAddress",type:"IP", map:"destination" },
        Src_RG: { filedName: "srcResourceGroup" ,type:"RG", map:"source"},
        Dest_RG: { filedName: "dstResourceGroup",type:"RG", map:"destination" },
        Dest_VM: { filedName: "dstMachineName",type:"VM", map:"destination" },
        Src_VM: { filedName: "srcMachineName",type:"VM", map:"source" },
        Application_NAME: { filedName: "applicationName",type:"AN", map:"source" },
        Victim_IP: { filedName: "VictimIp",type:"IP", map:"source" },
        Attacker_IP: { filedName: "AttackerIp",type:"IP", map:"destination" },
        Attacker_VM: { filedName: "Attacker",type:"VM", map:"destination" },
        Victim_VM: { filedName: "Victim",type:"VM", map:"source" },
        Victim_RG: { filedName: "VictimResourceGroup",type:"RG", map:"source" },
        Attacker_RG: { filedName: "AttackerResourceGroup",type:"RG", map:"destination" },
        Policy_Name: { filedName: "policyName",type:"PN", map:"source" },
        Threat_Name:{filedName: "threatName",type:"PN", map:"source"},
        Malware_Name:{filedName: "fileTag",type:"PN", map:"source"}

    };


}

EventVisualizationData.prototype.mapAxsisToType = function(axsis) {
   return  this.fieldConfig[axsis];
};

EventVisualizationData.prototype.createParser = function(queryType) {

    var parser = null;
    switch (queryType) {
        case "TWO_DIMENSIONAL":
            parser = new EventParser2DData(this.simulate);
            break;
        case "THREE_DIMENSIONAL":
            parser = new EventParser3DData(this.simulate);
            break;
    }

    return parser;
};

EventVisualizationData.prototype.createJSONFor3D = function() {

    var parser = this.createParser(this.filterdata.queryType);
    var normalizedData = parser.parse(this.queryResult.responses["0"].hits.hits, this.filterdata, this.fieldConfig);
    console.log("normalizedData  ");
    console.dir(normalizedData);
    var eventData = this.mapTo2DFormat(normalizedData);
    console.log(" final 3d data JSON Format for UI");
    console.dir(eventData);
    return eventData;

};

/*
    2D Format 
    {
      "nodesX":{
        name : this.filterdata.xAxisAttr,
        nodes:[{"name":"MYSQL"},{"name":"MONODB"}]
    },
     "nodesY":{
        name : this.filterdata.xAxisAttr,
        nodes:[{"name":"TOMCAT"}, {"name":"NGINX"}]
    },
      "links":[
         
       ]
    };
*/

EventVisualizationData.prototype.createJSONFor2D = function() {

    
    console.log("createJSON ");
    console.dir(this.filterdata);
    console.dir(this.queryResult);

    var parser = this.createParser(this.filterdata.queryType);

    var normalizedData = parser.parse(this.queryResult.responses["0"].aggregations, this.filterdata, this.fieldConfig);
    console.log("normalizedData  ");
    console.dir(normalizedData);

    var eventData = this.mapTo2DFormat(normalizedData);
    console.log(" final 2d data JSON Format for UI");
    console.dir(eventData);

    return eventData;
};

EventVisualizationData.prototype.mapTo2DFormat = function(normalizedData) {
    var eventData = {
        "nodesX": {
            name: this.filterdata.xAxisAttr,
            nodes: []
        },
        "nodesY": {
            name: this.filterdata.yAxisAttr,
            nodes: []
        },
        "links": [

        ]
    };

    for (var i = 0; i < normalizedData.xvalue.length; i++) {
        eventData.nodesX.nodes.push({ name: normalizedData.xvalue[i] });
    }

    for (var j = 0; j < normalizedData.yvalue.length; j++) {
        eventData.nodesY.nodes.push({ name: normalizedData.yvalue[j] });
    }

    for (var k = 0; k < normalizedData.data.length; k++) {
        var nodeData = normalizedData.data[k];
        var yval = nodeData.yval;
        var xVal = nodeData.xval;
        var source = _.indexOf(normalizedData.xvalue, xVal);
        var target = _.indexOf(normalizedData.yvalue, yval);
        var node = { "source": source, "target": target, "value": nodeData.data };
        eventData.links.push(node);
    }

    return eventData;
};

function EventParser2DData(simulate) {
	 this.YaxisisFirst = true;
     this.simulate = simulate;
}


EventParser2DData.prototype.parse = function(data, filterdata, fieldConfig) {
    console.log("EventParser  ");
    console.dir(data);
    var normalizedData = {
        xvalue: [],
        yvalue: [],
        data: []
    };
    var outerFielld = "";
    var innerField = "";
    if (this.YaxisisFirst) {
        outerFielld = "event."+fieldConfig[filterdata.yAxisAttr].filedName;
        innerField = "event."+fieldConfig[filterdata.xAxisAttr].filedName;
    }
    console.log("outer fileld   " + outerFielld);
    console.log("inner fileld   " + innerField);
    var outerBucket = data[outerFielld].buckets;
    var xVal = {};
    for (var i = 0; i < outerBucket.length; i++) {
        var bucket = outerBucket[i];
        var yvalue = bucket.key;
        normalizedData.yvalue.push(yvalue);
        var innerBuckets = bucket[innerField].buckets;
        for (var j = 0; j < innerBuckets.length; j++) {
            var innerBucket = innerBuckets[j];
            var xvalue = innerBucket.key;
            if (xVal[xvalue] === undefined) {
                xVal[xvalue] = true;
            }
            var eventCount = innerBucket.doc_count;

            var dataVal = { volume: eventCount };
            if(this.simulate){
                dataVal.volume = getRandomInt(0,1000);
            }
            var severity = innerBucket["event.severity"];
            if(severity)
            {
              var severityLevels =   severity.buckets;
              var severityObj = {
                  "Low":0,
                  "Critical":0,
                  "High":0,
                  "Medium":0,
                  "None":0
              };
              for(var k=0; k < severityLevels.length; k++){

                severityObj[severityLevels[k].key] = severityLevels[k].doc_count;

              }

              dataVal.severity = severityObj; 
            }

            normalizedData.data.push({ yval: yvalue, xval: xvalue, data:dataVal});
        }
    }

    console.log(" after >>>  data normalized");
    console.dir(xVal);
    for (var filedx in xVal) {
        console.log(" xvals " + filedx);
        normalizedData.xvalue.push(filedx);
    }
    console.dir(normalizedData);
    return normalizedData;
};

function EventParser3DData(simulate) {
    this.simulate = simulate;

}
EventParser3DData.prototype.parse = function(data, filterdata, fieldConfig) {

	console.log(" EventParser3DData ");
 	console.dir(data);

 	 var normalizedData = {
        xvalue: [],
        yvalue: [],
        data: []
    };

    var yAxisFielld = fieldConfig[filterdata.yAxisAttr].filedName;
    var xAxisField =  fieldConfig[filterdata.xAxisAttr].filedName;
    var xVal = {};
    var yVal = {};
    for(var i=0; i < data.length ;i++){
      var event  = data[i]._source.event;
      var timestamp = data[i]._source.timeStamp;
      var yAxisValue = event[yAxisFielld];
      var xAxisValue = event[xAxisField];

      if (xVal[xAxisValue] === undefined) {
          xVal[xAxisValue] = true;
      }

      if (yVal[yAxisValue] === undefined) {
          yVal[yAxisValue] = true;
      }
      var severityRef = event.severity;
      var dataVal = {volume: 0, threeDimValues:timestamp, severity:""};
      if(severityRef){
        dataVal.severity = severityRef;
      }
      normalizedData.data.push({ yval: yAxisValue, xval: xAxisValue, data: dataVal });
    }

    for (var filedx in xVal) {
        console.log(" xvals " + filedx);
        normalizedData.xvalue.push(filedx);
    }

    for (var filedy in yVal) {
        console.log(" yvals " + filedy);
        normalizedData.yvalue.push(filedy);
    }

    return normalizedData;
};

function EventVisualizationFilter() {
    this.actionTypeList = [];
    this.colorType = null;
    this.eventType = null;
    this.startTime = null;
    this.endTime = null;
    this.queryType = null;
    this.severity = null;
    this.xAxisAttr = null;
    this.yAxisAttr = null;
    this.attackerSourceList = [];
    this.attackerSourceType = "RG";
    this.targetDestinationList = [];
    this.targetDestinationType = "RG";
}

EventVisualizationFilter.prototype.getJSON = function(arg) {

    var postdata = {
    };

     postdata.actionTypeList = this.actionTypeList;
      if(this.colorType){
       postdata.colorType =  this.colorType;
     }

     postdata.eventType=  this.eventType;
     postdata.gte=  this.startTime;
     postdata.lte=  this.endTime;
     postdata.queryType=  this.queryType;
     if(this.severity){
     	postdata.severity=  this.severity;
     }
     postdata.xAxisAttr=  this.xAxisAttr;
     postdata.yAxisAttr=  this.yAxisAttr;

    
    postdata.attackerSourceList =  this.attackerSourceList;
    postdata.attackerSourceType = this.attackerSourceType;
    postdata.targetDestinationList = this.targetDestinationList;
    postdata.targetDestinationType = this.targetDestinationType;  
    
    return postdata;
};

EventVisualizationFilter.actions = [{ value: "PERMITTED", name: "" }, { value: "DENIED", name: "" }];
EventVisualizationFilter.colorType = [{ value: "EVENT_TYPE", name: "" }, { value: "L4_PROTOCAL", name: "" }, { value: "SEVERITY", name: "" }, { value: "ACTION_TAKEN", name: "" }];
EventVisualizationFilter.eventType = [{ value: "ACCESS_CONTROL", name: "" }, { value: "MALWARE", name: "" }, { value: "THREAT_PREVENTION", name: "" }];
EventVisualizationFilter.queryType = [{ value: "TWO_DIMESIONAL", name: "" }, { value: "THREE_DIMENSIONAL", name: "" }];
EventVisualizationFilter.severity = [{ value: "LOW", name: "" }, { value: "MEDIUM", name: "" }, { value: "HIGH", name: "" }, { value: "CRITICAL", name: "" }];

/*
 ShieldX Networks Inc. CONFIDENTIAL
 ----------------------------------
 *
 Copyright (c) 2016 ShieldX Networks Inc.
 All Rights Reserved.
 *
 NOTICE: All information contained herein is, and remains
 the property of ShieldX Networks Incorporated and its suppliers,
 if any. The intellectual and technical concepts contained
 herein are proprietary to ShieldX Networks Incorporated
 and its suppliers and may be covered by U.S. and Foreign Patents,
 patents in process, and are protected by trade secret or copyright law.
 Dissemination of this information or reproduction of this material
 is strictly forbidden unless prior written permission is obtained
 from ShieldX Networks Incorporated.
 */

function ResourceGroups() {
    this.name = "";
    this.controlPolicy = null;
    this.inline = false;
    this.tenant = null;
    this.memberList = null;
    this.subscriptionId = "";
    this.id = "";
    this.viewData = null;
}
ResourceGroups.prototype.init = function (arg) {
    this.name = arg.name;
    this.controlPolicy = arg.controlPolicy;
    this.inline = arg.inline;
    this.tenant = arg.tenant;
    this.subscriptionId = arg.subscriptionId;
    var rtemp = arg.memberList;
    this.memberList = [];
    for (var i = 0; i < rtemp.length; i++) {
        var tm = new Network();
        tm.init(rtemp[i]);
        this.memberList.push(tm);
    }
    this.id = arg.id;
    this.viewData = arg.viewData;
};

ResourceGroups.prototype.copy = function () {
    var rs = new ResourceGroups();
    rs.name = this.name;
    rs.controlPolicy = this.controlPolicy;
    rs.inline = this.inline;
    rs.tenant = this.tenant;
    rs.subscriptionId = this.subscriptionId;
    rs.memberList = [];
    if (this.memberList) {
        for (var i = 0; i < this.memberList.length; i++) {
            rs.memberList.push(this.memberList[i].copy());
        }
    }

    console.log(" ResourceGroups copy  " + rs);
    console.dir(rs);
    rs.viewData = this.viewData;
    return rs;
};

ResourceGroups.prototype.setViewData = function (key, value) {
    if (!this.viewData) {
        this.viewData = {};
    }
    this.viewData[key] = value;
};

ResourceGroups.prototype.getViewData = function (key) {
    if (this.viewData) {
        return this.viewData[key];
    }
    return null;
};

ResourceGroups.prototype.getNetworkServerFormat = function () {
    var format = [];
    if (this.memberList !== null) {
        for (var i = 0; i < this.memberList.length; i++) {
            format.push({"id": 0, "networkId": this.memberList[i].networkId});
        }
    }

    return format;
};

ResourceGroups.prototype.addNetworks = function (arg) {
    if (this.memberList !== null) {
        for (var i = 0; i < arg.length; i++) {
            this.memberList.push(arg[i]);
        }
    } else {
        this.setNetWorks(arg);
    }
};

ResourceGroups.prototype.setNetWorks = function (arg) {
    this.memberList = arg;
};

ResourceGroups.prototype.getNetWorks = function () {
    return this.memberList;
};

function Network() {
    this.name = "";
    this.id = -1;
    this.networkId = "";
    this.resourceGroupId = "";
    this.resourceGroupName = "";
}

Network.prototype.copy = function () {
    var n = new Network();
    n.networkName = this.name;
    n.id = this.id;
    n.networkId = this.networkId;
    n.resourceGroupId = this.resourceGroupId;
    n.resourceGroupName = this.resourceGroupName;
    return n;
};

Network.prototype.init = function (arg) {
  this.name = arg.name;
  this.id = arg.id;
  this.networkId = arg.networkId;
  this.resourceGroupId = arg.resourceGroupId;
  this.resourceGroupName = arg.resourceGroupName;
};


/*
 ShieldX Networks Inc. CONFIDENTIAL
 ----------------------------------
 *
 Copyright (c) 2016 ShieldX Networks Inc.
 All Rights Reserved.
 *
 NOTICE: All information contained herein is, and remains
 the property of ShieldX Networks Incorporated and its suppliers,
 if any. The intellectual and technical concepts contained
 herein are proprietary to ShieldX Networks Incorporated
 and its suppliers and may be covered by U.S. and Foreign Patents,
 patents in process, and are protected by trade secret or copyright law.
 Dissemination of this information or reproduction of this material
 is strictly forbidden unless prior written permission is obtained
 from ShieldX Networks Incorporated.
 */

(function () {



    function deploymentSpecificationsCtr($scope,
        $stateParams,
        infrastructureConnectorService,
        ipPoolServices,
        deploymentSpecificationService,
        $translate, 
        $q,
        $mdDialog,
        $mdMedia,
        $sessionStorage,
        $state,vlanService,
        userSessionMenagment) {
        "ngInject";
            clearAllSession($sessionStorage);
            var deferred = $q.defer();
            $scope.promise = deferred.promise;
            $scope.promiseCompleted = true;
            var deploymentSpecData =[];
            var promiseCtr = 0;
            var totalClouds = 0;
            var viewData = [];
            
            var deploySpecIdSet = ($stateParams && $stateParams.deploySpecId) ? parseInt($stateParams.deploySpecId) : null;
            //var deploymentSpecifications = [];
            //for tables [start]
                    
            $scope.$emit('listenHeaderText', { headerText: $translate.instant('admin.toolbar.heading') });
            $scope.$emit('quickSetupEnded',{});

            /* **** for tables [start] **** */
            $scope.selected = [];
            $scope.query = {
                order: 'name',
                limit: 10,
                page: 1
            };
            $scope.isAdornmentPanelOpen = false;    
            $scope.isSearchBarOpen = false; 

            var create_id = authorities("deploymentSpecifications_create");
            var delete_id = authorities("deploymentSpecifications_delete");
            var update_id = authorities("deploymentSpecifications_update");
            $scope.is_create_dspec = userSessionMenagment.isUserAllowd(create_id);
            $scope.is_update_dspec = userSessionMenagment.isUserAllowd(update_id);
            $scope.is_delete_dspec = userSessionMenagment.isUserAllowd(delete_id);
            
            $scope.updateAdornmentPanel = function (event, rowData){
                console.log(rowData);
                $scope.toggleAdornmentPanel();
                $scope.editMgmt = false;
                $scope.editBckPlane = false;
                $scope.editMcrSer = false;
                $scope.adornmentData = rowData;
                console.log("updateAdornmentPanel");
                console.dir($scope.adornmentData);
                $scope.vlandata = null;
                vlanService.getvlanList($scope.adornmentData.cloudid).then(function(data){
                    var filteredData =  _.find(data, function(item){
                     return item.id === $scope.adornmentData.vlanPoolId;
                   });
                  console.log("filteredData >> ");
                  console.dir(filteredData);
                  var newVlan = new Vlan();
                 //console.log($scope.newVlan);
                if(filteredData){
                    newVlan.diserialize(filteredData);
                }
                  $scope.vlandata = newVlan; 
                });
                
            };

            $scope.toggleAdornmentPanel = function() {
                    $scope.isAdornmentPanelOpen = $scope.isAdornmentPanelOpen === false ? true: false;
                    //toggleGridCols($scope.isAdornmentPanelOpen);
            };      

            $scope.toggleSearchBar = function(event) {
                $scope.isSearchBarOpen = $scope.isSearchBarOpen === false ? true: false;
                if($scope.isSearchBarOpen) angular.element(event.currentTarget.firstElementChild).css('color','#4a90e2');
                else angular.element(event.currentTarget.firstElementChild).css('color','#6d6e71');
            };      
            /* **** for tables [end] **** */

            $scope.showStatus = function (status, test) {
                    return status === test;
            };
            
            $scope.deleteDeploySpec = function(deploySpecObject) {
                toastparam = {
                    'heading': 'Deployment Specification deletion in progress',
                    'subHeading': 'Deployment specification deletion initiated.',
                    'type': 'progress',
                    'timeout': 15000
                };
                showToast(toastparam);
                var deploySpecId = deploySpecObject.id;
                var list = $scope.DeploymentSpecifications;
                var toastparam = {};
                deploymentSpecificationService.deleteDeploymentSpecfication(deploySpecId, deploySpecObject.cloudid).then(function(data){
                    if(data.status) {
                    //update rows
                        for(i=0; i<list.length ; i++) {
                            if (list[i].id === deploySpecId) {
                                list.splice(i, 1);
                            }
                        }
                        
                        toastparam = {
                            'heading': 'Deployment Specification deleted successfully',
                            'subHeading': '&nbsp;',
                            'type': 'success',
                            'timeout': 5000
                        };
                        showToast(toastparam);
                        
                    } else {
                        console.log("Unable to delete deployment specification (%s) due to %s", deploySpecObject.name, data.errorMessage);
                        //TODO to show message/something else;
                        toastparam = {
                            'heading': 'Deployment Specification deletion failed',
                            'subHeading': "Error: "+data.errorMessage,
                            'type': 'fail',
                            'timeout': 5000
                        };
                        showToast(toastparam);
                    }
                }, function(error){
                    console.log("Unable to delete deployment specification - %s due to %s", deploySpecObject.name, error.message);
                    //TODO to show message/something else;
                    toastparam = {
                        'heading': 'Deployment Specification deletion failed',
                        'subHeading': "Something went wrong",
                        'type': 'fail',
                        'timeout': 5000
                    };
                    showToast(toastparam);
                });
                
            };
            console.log($sessionStorage.viewData);
            console.log($sessionStorage.infraData);
            //if(!$sessionStorage.viewData) {
                $sessionStorage.infraData = [];

                //CALL TO GET ALL INFRAS
                infrastructureConnectorService.getListOfInfrastructures().then(function (data) {
                    totalClouds = data.length;
                    if(totalClouds === 0){
                        $scope.errorMessage = "No Infrastructures!!!";                
                        $scope.DeploymentSpecifications = []; //NO DATA FOR VIEW
                        deferred.resolve();
                        $scope.promiseCompleted = false;
                    } else {
                        for(i = 0; i < data.length; i++ ) {

                            deploymentSpecData[i] = {};
                            deploymentSpecData[i].cloud_data = {};
                            deploymentSpecData[i].pool_data = {};
                            deploymentSpecData[i].deploy_spec_data = {}; 

                            //ADDING CLOUD DATA IN DEPLOYMENT SPEC
                            deploymentSpecData[i].cloud_data = data[i];

                            //GET REST DATA (IP-pool, Host, storage, network, deploymentSpec)
                            callGetRestOfData(data[i], deploymentSpecData[i]);
                            //callGetRestOfData(data[i], deploymentSpecData[i]);
                            deploymentSpecData[i].cloudId = data[i].id;
                            $sessionStorage.infraData.push(deploymentSpecData[i]);
                        }
                        //$sessionStorage.viewData = viewData;
                        console.log($scope.DeploymentSpecifications);
                        //console.log($sessionStorage.viewData);
                    }
                }, function (error) {
                    console.log(error);
                    $scope.errorMessage = "No Infrastructures!!!";                
                    $scope.DeploymentSpecifications = []; //NO DATA FOR VIEW
                    deferred.resolve();
                    $scope.promiseCompleted = false;
                });
            /* } else {
                //console.log($sessionStorage.viewData);
                viewData = $sessionStorage.viewData;
                $scope.deploySpecLength = viewData.length;
                
                $scope.DeploymentSpecifications = moveRecordToStart(viewData, "id", deploySpecIdSet);
                deferred.resolve();
        
                $scope.promiseCompleted = false;
                console.log($scope.DeploymentSpecifications);
            }*/
            //Helper function to get name of given Id from given list
            getNameOfGivenParam = function(id, list) {    
                if(list.length > 0 || typeof id !== 'undefined' ){
                    var result = {};
                    result = _.find(list, {'id': id});
                    if(typeof result !== 'undefined'){
                        return result;
                    } else {
                        return {};
                    }
                } else {
                    return {};
                }
            };
            
            getHostDataWithName = function (srcArray, FromArray){
                
                var result = [];
                for (hst= 0; hst < srcArray.length; hst++) {                    
                    result[hst] = _.find(FromArray, {'id': parseInt(srcArray[hst])});
                }
                return result;
            };
            
            callGetRestOfData = function(cloudData, obj) {
                //GET IPPOOL DATA
                ipPoolServices.getIpPoolListByCloudId(cloudData.id).then(function(ipPoolData) {
                      obj.pool_data = ipPoolData;
                      
                      //$sessionStorage.ipPoolData.cloudData.id = ipPoolData;
                //GET HOST DATA
                deploymentSpecificationService.getHosts(cloudData.id).then(function(hostData){
                    obj.host_data = hostData;
                    //$sessionStorage.hostsData.cloudData.id = hostData;
                    //GET STORAGEDATA
                    deploymentSpecificationService.getDatastore(cloudData.id).then(function(storeData){
                        obj.store_data = storeData;
                        
                        //GET NETWORK DATA
                        ipPoolServices.getNetworkListByCloudId(cloudData.id).then(function(networkData){
                            obj.network_data =  networkData;
                            //$sessionStorage.netWorkData.cloudData.id = networkData;
                            //GET TENANT DATA
                            //if(cloudData.type === 'OPENSTACK'){
                    //call to get tenants
                                deploymentSpecificationService.getTenants(cloudData.id).then(function(data){
                                    obj.tenants = data;

                                    if (cloudData.type === 'AWS') {
                                        deploymentSpecificationService.getRegions(cloudData.id).then(function (regionData) {
                                            obj.regions = regionData;
                                        }, function (error) {
                                            console.log(error);
                                            obj.regions = [];

                                        });
                                    }


                                    //GET DEPLOYMENT SPEC DATA
                                    deploymentSpecificationService.getDeploymentSpecList(cloudData.id).then(function(deployData){

                                        for(c=0; c< deployData.length; c++) { //c for counter

                                            if(!deployData[c].backPlaneIsDhcp) {
                                                deployData[c].backPlaneIpPoolName =
                                                    getNameOfGivenParam(parseInt(deployData[c].backPlaneIpPoolId),
                                                        obj.pool_data);
                                            }else {
                                                deployData[c].backPlaneIpPoolName = {'name': 'DHCP'};
                                            }
                                            //console.log("done BackplaneIPPOOLNAME");
                                            deployData[c].backPlaneNetworkName =
                                                getNameOfGivenParam(parseInt(deployData[c].backPlaneNetworkId),
                                                    obj.network_data);
                                            //console.log("done backPlaneNetworkName == "+deployData[c].name);
                                            deployData[c].cloudName = obj.cloud_data.name;
                                            deployData[c].cloudType = obj.cloud_data.type;
                                            //console.log("done cloudName");
                                            if (!deployData[c].storageIsLocal) {
                                                deployData[c].datastoreName =
                                                    getNameOfGivenParam(deployData[c].datastoreId,
                                                        obj.store_data);
                                            } else {
                                                deployData[c].datastoreName = {'name': 'Local'};
                                            }
                                            //console.log("done datastoreName");
                                            if(!deployData[c].mgmtIsDhcp) {
                                                deployData[c].mgmtIpPoolName =
                                                    getNameOfGivenParam(deployData[c].mgmtIpPoolId,
                                                        obj.pool_data);
                                            } else {
                                                deployData[c].mgmtIpPoolName = {'name': 'DHCP'};
                                            }
                                            //console.log("done mgmtIpPoolName");
                                            deployData[c].mgmtNetworkName =
                                                getNameOfGivenParam(parseInt(deployData[c].mgmtNetworkId),
                                                    angular.copy(obj.network_data));
                                            //console.log("done mgmtNetworkName");
                                            if (deployData[c].hosts !== undefined) {
                                                deployData[c].hostsWithName =
                                                    getHostDataWithName(deployData[c].hosts,
                                                        obj.host_data);
                                            }
                                            //console.log("done hostsWithName");
                                            deployData[c].tenantName =
                                                getNameOfGivenParam(deployData[c].tenantId,
                                                    angular.copy(obj.tenants));

                                            deployData[c].regionName= deployData[c].region;
                                            //    getNameOfGivenParam(deployData[c].region)

                                            viewData.push(deployData[c]); //Push data for view.
                                        }

                                        obj.deploy_spec_data = deployData;

                                        promiseCtr += 1;
                                        //console.log("PROMISE COUNTER==="+promiseCtr);
                                        if(promiseCtr >= totalClouds) {
                                            $scope.deploySpecLength = viewData.length;
                                            $sessionStorage.viewData = viewData;
                                            deferred.resolve();
                                            console.log(viewData);
                                            $scope.promiseCompleted = false;
                                            $scope.DeploymentSpecifications = moveRecordToStart(viewData, "id", deploySpecIdSet);
                                            console.log($scope.DeploymentSpecifications);
                                            console.log($sessionStorage.viewData);

                                        }

                                    }, function(error){
                                        console.log(error);
                                        obj.deploy_spec_data = [];
                                        promiseCtr += 1;
                                        if(promiseCtr === totalClouds) {
                                            $scope.deploySpecLength = viewData.length;
                                            $sessionStorage.viewData = viewData;
                                            deferred.resolve();
                                            $scope.promiseCompleted = false;
                                            console.log($scope.DeploymentSpecifications);
                                            console.log($sessionStorage.viewData);
                                        }
                                    });

                                
                                    //}

                                //////
                                }, function(error){
                                    console.log(error);
                                    obj.tenants = [];
                                });
                            
                        }, function(error){
                            console.log(error);
                            obj.network_data = [];
                        });

                    }, function(error){
                        console.log(error);
                        obj.store_data = [];
                    });
                }, function(error){
                    console.log(error);
                    obj.host_data = [];
                });
              }, function(error){
              console.log(error);
              obj.pool_data = [];
              });
                
            };
            
        //EDIT STARTS.
        $scope.editMgmt = false;
        $scope.editBckPlane = false;
        $scope.editMcrSer = false;
        $scope.editMisc = false;
        $scope.editVlan = false;
        
        var callingStorage = false;
        var callingHosts = false;
        var callingTenant = false;   
            
        $scope.discardChanges = function(calledFrom){
            $scope.editMgmt = false;
            $scope.editBckPlane = false;
            $scope.editMcrSer = false;
            $scope.editMisc = false;
            $scope.editVlan = false;
            if(calledFrom === 'Management') {
                inBetweenNetworkCall = false;
                if($sessionStorage.Management.selectedNetworkName && $sessionStorage.Management.oldSelectedNetworkValue){
                    $scope.adornmentData.mgmtNetworkName.name = $sessionStorage.Management.selectedNetworkName;
                    $scope.deployment.managementNetwork = $sessionStorage.Management.oldSelectedNetworkValue;
                }
            } else if(calledFrom === 'Backplane') {
                inBetweenNetworkCall = false;
                if($sessionStorage.Backplane.selectedNetworkName && $sessionStorage.Backplane.oldSelectedNetworkValue){
                    $scope.adornmentData.backPlaneNetworkName.name = $sessionStorage.Backplane.selectedNetworkName ;
                    $scope.deployment.backplaneNetwork = $sessionStorage.Backplane.oldSelectedNetworkValue;
                }
            } else if(calledFrom === 'StorageHost'){
                if(callingHosts){
                    inBetweenHostCall = false;
                    if(($sessionStorage.Host.oldSelectedHosts) && $sessionStorage.Host.oldSelectedHostNames) {
                        $scope.deployment.hosts = $sessionStorage.Host.oldSelectedHosts;
                        $scope.adornmentData.hostsWithName = $sessionStorage.Host.oldSelectedHostNames ;
                    }
                } 
                if(callingStorage){
                    inBetweenStorageCall = false;
                    if(($sessionStorage.Storage.oldSelectedStorageValue >= 0) && $sessionStorage.Storage.oldSelectedStorageName) {
                        $scope.deployment.storage = $sessionStorage.Storage.oldSelectedStorageValue;
                        $scope.adornmentData.datastoreName.name = $sessionStorage.Storage.oldSelectedStorageName;
                        
                    }
                }
                if(callingTenant) {
                    inBetweenTenantCall = false;
                    if(($sessionStorage.Tenant.oldSelectedTenantValue >= 0) && $sessionStorage.Tenant.oldSelectedTenantName) {
                        $scope.deployment.tenantId = $sessionStorage.Tenant.oldSelectedTenantValue;
                        if(!$scope.adornmentData.tenantName){
                             $scope.adornmentData.tenantName = {};
                        }
                        $scope.adornmentData.tenantName.name = $sessionStorage.Tenant.oldSelectedTenantName;
                        
                    }
                }
            } else if(calledFrom === 'vlan') {
                 inBetweenNetworkCall = false;
                 if($sessionStorage.Management.selectedNetworkName && $sessionStorage.Management.oldSelectedNetworkValue){
                    $scope.adornmentData.mgmtNetworkName.name = $sessionStorage.Management.selectedNetworkName;
                    $scope.deployment.managementNetwork = $sessionStorage.Management.oldSelectedNetworkValue;
                }
            }
            else{
                
            }
        };
        
        
        $scope.editMiscData = function(deploySpecObject){
            $scope.editMisc = true;
            $scope.editMgmt = false;
            $scope.editBckPlane = false;
            $scope.editMcrSer = false;
            callingTenant = false;
            $scope.editVlan = false;
            console.log("deploySpecObject==");console.log(deploySpecObject);
            $sessionStorage.deploymentSpecForEdit = deploySpecObject;
            editDeploySpecData('editMisc');
        };
        
        $scope.editManagementData = function(deploySpecObject){
            $sessionStorage.Management={};
            $scope.editMgmt = true;
            $scope.editBckPlane = false;
            $scope.editMcrSer = false;
            $scope.editMisc = false;
            $scope.editVlan = false;
            //$scope.adornmentDataForEdit = deploySpecObject;
            //console.log("adornmentDataForEdit==");console.log($scope.adornmentDataForEdit);
            $sessionStorage.deploymentSpecForEdit = deploySpecObject;
            editDeploySpecData('editMgmt');
        };
        
        $scope.editBackPlaneData = function(deploySpecObject){
            $sessionStorage.Backplane={};
            $scope.editBckPlane = true;
            $scope.editMgmt = false;
            $scope.editMcrSer = false;
            $scope.editMisc = false;
            $scope.editVlan = false;
            //console.log("deploySpecObject==");console.log(deploySpecObject);
            $sessionStorage.deploymentSpecForEdit = deploySpecObject;
            editDeploySpecData('editBckPlane');
        };
        
        $scope.editMicroServiceData = function(deploySpecObject){
            $scope.editMcrSer = true;
            $scope.editMgmt = false;
            $scope.editBckPlane = false;
            $scope.editMisc = false;
            $scope.editVlan = false;
            callingStorage = false;
            callingHosts = false;            
            //console.log("deploySpecObject==");console.log(deploySpecObject);
            $sessionStorage.deploymentSpecForEdit = deploySpecObject;
            editDeploySpecData('editMcrSer');
        };
        $scope.editVlanServiceData = function(deploySpecObject){
            $scope.editMcrSer = false;
            $scope.editMgmt = false;
            $scope.editBckPlane = false;
            $scope.editMisc = false;
            $scope.editVlan = true;
            callingStorage = false;
            callingHosts = false;            
            //console.log("deploySpecObject==");console.log(deploySpecObject);
            $sessionStorage.deploymentSpecForEdit = deploySpecObject;
            editDeploySpecData('editVlan');
        };
        $scope.$on('changeSelectedName', function(event, arg){
            if(arg.label === 'Management') {
                $scope.adornmentData.mgmtNetworkName.name = arg.name;
            } else {
               $scope.adornmentData.backPlaneNetworkName.name = arg.name; 
            }
        });
        
        $scope.$on('listenManagementNetworkEdit', function (event, args) {
            console.log('listenManagementNetworkEdit' + args);
            $scope.deployment.managementNetwork = args.id;
            $scope.adornmentData.mgmtNetworkName.name = args.name;
        });

        $scope.$on('listenBackplaneNetworkEdit', function (event, args) {
            console.log('listenBackplaneNetworkEdit' + args);
            //$scope.deployment.backplaneNetworkSelected = args;
            $scope.deployment.backplaneNetwork = args.id;
            $scope.adornmentData.backPlaneNetworkName.name = args.name;

        });
        var inBetweenNetworkCall = false;
        $scope.showNetworkDialog = function(label, networks, selectedNetworks, selectedNetworkName, ev){
                
                console.log("Calling Show Network Dialogue");
                $mdDialog.show({
                    skipHide: true,
                    controller: networkPopupController,
                    templateUrl: 'core/components/administration/deployment-specifications/networks.tmpl.html',
                    parent: angular.element(document.body),
                    targetEvent: ev,
                    locals: {'label': label, 'networks' : networks, 'selectedNetworks': selectedNetworks, 'selectedNetworkName': selectedNetworkName}
                })
                  .then(function() {
                    
                });
            };
            
            function networkPopupController($rootScope, $scope, $sessionStorage, networks, selectedNetworks, label, selectedNetworkName){
                console.log(networks);
                $scope.label = label;
                var networkLists = [];
                $scope.networksList = networkLists = angular.copy(networks);
                console.log(selectedNetworks);
                var arg = {};
                if(label === 'Management') {
                    if(!$sessionStorage.Management) {
                        $sessionStorage.Management={};
                    }
                    if(inBetweenNetworkCall === true){
                        selectedNetworkName = $sessionStorage.Management.selectedNetworkName;
                        arg = {'label': label, 'name': $sessionStorage.Management.selectedNetworkName};
                        $rootScope.$broadcast('changeSelectedName', arg);
                        selectedNetworks = $scope.selectedNetworkValue = $sessionStorage.Management.oldSelectedNetworkValue ;
                    } else {
                        inBetweenNetworkCall = true;
                        $sessionStorage.Management.selectedNetworkName = selectedNetworkName;
                        $scope.selectedNetworkValue = $sessionStorage.Management.oldSelectedNetworkValue = (selectedNetworks)?selectedNetworks:0;
                    }
                    //$sessionStorage.Management.selectedNetworkName = selectedNetworkName;
                    //$scope.selectedNetworkValue = $sessionStorage.Management.oldSelectedNetworkValue = (selectedNetworks)?selectedNetworks:0;
                } else {
                    if(!$sessionStorage.Backplane) {
                        $sessionStorage.Backplane={};
                    }
                    if(inBetweenNetworkCall === true){
                        selectedNetworkName = $sessionStorage.Backplane.selectedNetworkName;
                        arg = {'label': label, 'name': $sessionStorage.Backplane.selectedNetworkName};
                        $rootScope.$broadcast('changeSelectedName', arg);
                        selectedNetworks = $scope.selectedNetworkValue = $sessionStorage.Backplane.oldSelectedNetworkValue;
                    } else {
                        inBetweenNetworkCall = true;
                        //$sessionStorage.Backplane={};
                        $sessionStorage.Backplane.selectedNetworkName = selectedNetworkName;
                        $scope.selectedNetworkValue = $sessionStorage.Backplane.oldSelectedNetworkValue = (selectedNetworks)?selectedNetworks:0;
                    }
                }
                console.log($scope.selectedNetworkValue);
                
                $scope.cancelDialogue = function() {
                    $mdDialog.cancel();
                };
                
                $scope.done = function(){
                    if(label === 'Management') {
                        for(i=0; i < networkLists.length; i++) {                            
                            if (networks[i].id === parseInt($scope.selectedNetworkValue)) {
                                $rootScope.$broadcast('listenManagementNetworkEdit', networks[i]);
                                $mdDialog.hide();
                            }
                        }
                    } 
                    if(label === 'Backplane') {
                        for(i=0; i < networkLists.length; i++) {                            
                            if (networks[i].id === parseInt($scope.selectedNetworkValue)) {
                                $rootScope.$broadcast('listenBackplaneNetworkEdit', networks[i]);
                                $mdDialog.hide();
                            }
                        }
                    }
                };
            }
            //Edit Host popup
            $scope.$on('listenSelectedHostsEdit', function (event, args) {
                var hostIds = [];
                var hostNames = [];
                for(i=0; i<args.length; i++) {
                    hostIds[i] = args[i].id;
                    hostNames[i] = args[i].name;
                }
                //$scope.deployment.numberOfHosts = args.length;
                //$scope.deployment.selectedHostObjects = args;
                $scope.deployment.hosts = hostIds;
                $scope.adornmentData.hostsWithName = args;
                console.log($scope.deployment.hostNames);
                
            });
            $scope.$on('changeSelectedHostsName', function (event, arg) {
                $scope.adornmentData.hostsWithName = arg;
            });
            var inBetweenHostCall = false;
                $scope.callpopuphost = function(hosts, selectedHosts, selectedHostsName, ev){
                    console.log(hosts);                    
                    $mdDialog.show({
                        controller: hostPopupController,
                        skipHide: true,
                        templateUrl: 'core/components/administration/deployment-specifications/hosts.tmpl.html',
                        parent: angular.element(document.body),
                        targetEvent: ev,
                        locals: {'hosts': hosts, 'selectedHosts': selectedHosts, 'selectedHostsName': selectedHostsName}
                    });
                };
                /*HOST RELATED FUNCTION*/
                function hostPopupController($rootScope, $scope, $mdDialog, hosts, selectedHosts, selectedHostsName) {
                    $scope.deployment_designate_host = $translate.instant("wizardinfrastucture.button.designate_host");
                    //$scope.deployment_designate_storage = $translate.instant("wizardinfrastucture.button.designate_storage");
                    //$scope.host_activated = true;
                    if(!$sessionStorage.Host) {
                        $sessionStorage.Host={};
                    }
                    if(inBetweenHostCall === true){
                        selectedHosts = $sessionStorage.Host.oldSelectedHosts ;
                        selectedHostsName = $sessionStorage.Host.oldSelectedHostNames;
                        $rootScope.$broadcast('changeSelectedHostsName', selectedHostsName);
                    } else {
                        inBetweenHostCall = true;
                        $sessionStorage.Host.oldSelectedHosts = selectedHosts;
                        $sessionStorage.Host.oldSelectedHostNames = selectedHostsName;
                    }
                            callingHosts = true;
                            (function(){  
                                console.log(hosts);
                                //var selectedHostsList = [];
                                $scope.items = hosts ;
                                $scope.no_of_hosts = hosts.length;
                                console.log("selectedHosts");
                                console.log(selectedHosts);
                                //getselectedhosts objects
                                var selectedHostsObjects = [];
                                for(j=0;j<selectedHosts.length;j++){
                                    selectedHostsObjects.push( _.find(hosts, { 'id': selectedHosts[j] }));
                                }
                                console.log("selectedHostsObjects");
                                console.log(selectedHostsObjects);
                                $scope.selected = (selectedHostsObjects)?selectedHostsObjects:[];
                                if ($scope.selected) {
                                    $scope.no_of_selected_hosts = $scope.selected.length;
                                } else {
                                    $scope.no_of_selected_hosts = 0;
                                }
                                console.log($scope.selected);
                                $scope.cancelDialogue = function() {
                                    $mdDialog.cancel();
                                };
                                $scope.doneHosts = function() {
                                    $rootScope.$broadcast('listenSelectedHostsEdit', $scope.selected);
                                        $mdDialog.hide();
                                };
                                $scope.toggle = function (item, list) {
                                    var isDeleted = false;
                                    for (i = 0; i < list.length; i++) {
                                        if (list[i].id === item.id) {
                                        list.splice(i, 1);
                                                isDeleted = true;
                                        }
                                    }
                                    if (!isDeleted) {
                                        list.push(item);
                                    }
                                    $scope.no_of_selected_hosts = $scope.selected.length;
                                };
                                    $scope.exists = function (item, list) {
                                        for (i = 0; i < list.length; i++) {
                                            if (list[i].id === item.id) {
                                            return true;
                                            }
                                        }
                                        return false;
                                    };
                                    $scope.isIndeterminate = function () {
                                        return ($scope.selected.length !== 0 &&
                                            $scope.selected.length !== $scope.items.length);
                                    };
                                    $scope.isChecked = function () {
                                        return $scope.selected.length === $scope.items.length;
                                    };
                                    $scope.toggleAll = function () {
                                        if ($scope.selected.length === $scope.items.length) { //uncheck all
                                            $scope.selected = [];
                                        } else if ($scope.selected.length === 0 || $scope.selected.length > 0) {
                                            $scope.selected = $scope.items.slice(0); //check all
                                        }
                                        $scope.no_of_selected_hosts = $scope.selected.length;
                                    };
                                //}
                            })();
                        }
            
            //Edit Host popup Ends
            //Edit Storage popup
            var inBetweenStorageCall = false;
            $scope.$on('listenSelectedStoragesEdit', function (event, args) {
                //$scope.deployment.selectedStorage = args;
                $scope.deployment.storage = args.id;
                $scope.adornmentData.datastoreName.name = args.name;
                //$scope.deployment.storageName = args.name;
                //console.log($scope.deployment.storageName);
                
            });
            $scope.$on('changeSelectedNameOfStorage', function (event, arg) {
                $scope.adornmentData.datastoreName.name = arg;
                
            });
            
            $scope.$on('changeSelectedNameOfTenant', function (event, arg) {
                $scope.adornmentData.tenantName.name = arg;
                
            });
            
            $scope.$on('listenSelectedTenantsEdit', function (event, args) {
                $scope.deployment.selectedTenants = args;
                $scope.deployment.tenantId = args.id;
                $scope.adornmentData.tenantName.name = args.name;
                
                //$scope.checkNext();
            });
            
            $scope.callpopupstorage = function(storages, selectedStorage, selectedStorageName, ev){
                $mdDialog.show({
                        controller: storagePopupController,
                        skipHide: true,
                        templateUrl: 'core/components/administration/deployment-specifications/storages.tmpl.html',
                        parent: angular.element(document.body),
                        targetEvent: ev,
                        locals: {'storages': storages, 'selectedStorage': selectedStorage, 'selectedStorageName': selectedStorageName}
                    });
            };
            
            function storagePopupController($rootScope, $scope, $mdDialog, storages, selectedStorage,selectedStorageName) {
                    //$scope.deployment_designate_host = $translate.instant("wizardinfrastucture.button.designate_host");
                    $scope.deployment_designate_storage = $translate.instant("wizardinfrastucture.button.designate_storage");
                    $scope.storage_activated = true;
                    callingStorage = true;
                    console.log("from main Dspec ");
                    console.dir(storages);
                    if(!$sessionStorage.Storage){
                        $sessionStorage.Storage = {};
                    }
                    
                    if(inBetweenStorageCall === true) {
                        selectedStorage = $sessionStorage.Storage.oldSelectedStorageValue;
                        selectedStorageName = $sessionStorage.Storage.oldSelectedStorageName;
                        $rootScope.$broadcast('changeSelectedNameOfStorage', selectedStorageName);
                    } else {
                        inBetweenStorageCall = true;
                        $sessionStorage.Storage.oldSelectedStorageValue = selectedStorage;
                        $sessionStorage.Storage.oldSelectedStorageName = selectedStorageName;
                    }
                    (function(){
                        $scope.dataStores = storages ;
                        $scope.selectedStoragesValue = (selectedStorage)? selectedStorage : 0;
                        $scope.cancelDialogue = function() {
                            $mdDialog.cancel();
                        };
                        $scope.done = function() {
                            console.log($scope.selectedStoragesValue);
                            var storageItems = $scope.dataStores;
                            for (i = 0; i < storageItems.length; i++) {
                                if (storageItems[i].id === parseInt($scope.selectedStoragesValue)) {
                                    console.log(storageItems[i]);
                                    $rootScope.$broadcast('listenSelectedStoragesEdit', storageItems[i]);
                                    $mdDialog.hide();
                                }
                            }
                        };
                    })();
                }


        //region popup
        var inBetweenRegionCall = false;
        $scope.$on('listenSelectedRegionEdit', function (event, args) {
            //$scope.deployment.selectedStorage = args;
            $scope.deployment.region = args.id;
            $scope.adornmentData.regionName.name = args.name;
            //$scope.deployment.storageName = args.name;
            //console.log($scope.deployment.storageName);

        });
        $scope.$on('changeSelectedNameOfRegion', function (event, arg) {
            $scope.adornmentData.regionName.name = arg;

        });
        $scope.callpopupregions = function(regions, selectedRegion, selectedRegionName, ev){
            console.log("In region popup ");
            $mdDialog.show({
                controller: regionPopupController,
                skipHide: true,
                templateUrl: 'core/components/administration/deployment-specifications/regions.tmpl.html',
                parent: angular.element(document.body),
                targetEvent: ev,
                locals: {'regions': regions, 'selectedRegion': selectedRegion, 'selectedRegionName': selectedRegionName}
            });
        };

        function regionPopupController($rootScope, $scope, $mdDialog, regions, selectedRegion, selectedRegionName) {
            console.log("In region popup controller");
            //$scope.deployment_designate_host = $translate.instant("wizardinfrastucture.button.designate_host");
            $scope.deployment_designate_region = $translate.instant("wizardinfrastucture.button.designate_region");
            $scope.region_activated = true;
            callingregion = true;
            console.log("from main Dspec ");
            console.dir(regions);
            if(!$sessionStorage.Region){
                $sessionStorage.Region = {};
            }

            if(inBetweenRegionCall === true) {
                selectedRegion = $sessionStorage.Storage.oldSelectedRegionValue;
                selectedRegionName = $sessionStorage.Storage.oldSelectedRegionName;
                $rootScope.$broadcast('changeSelectedNameOfRegion', selectedRegionName);
            } else {
                inBetweenRegionCall = true;
                $sessionStorage.Storage.oldSelectedRegionValue = selectedRegion;
                $sessionStorage.Storage.oldSelectedRegionName = selectedRegionName;
            }
            (function(){
                $scope.regions = regions ;
                $scope.selectedRegionValue = (selectedRegion)? selectedRegion : 0;
                $scope.cancelDialogue = function() {
                    $mdDialog.cancel();
                };
                $scope.done = function() {
                    console.log($scope.selectedRegionValue);
                    var regionItems = $scope.regions;
                    for (i = 0; i < regionItems.length; i++) {
                        if (regionItems[i].id === parseInt($scope.selectedRegionValue)) {
                            console.log(regionItems[i]);
                            $rootScope.$broadcast('listenSelectedStoragesEdit', regionItems[i]);
                            $mdDialog.hide();
                        }
                    }
                };
            })();
        }

            //Edit Storage Popup end
            var inBetweenTenantCall = false;
            $scope.callpopuptenants = function(tenants, selectedTenants, selectedTenantsName, ev){
                    $mdDialog.show({
                        controller: tenantPopupController,
                        skipHide: true,
                        templateUrl: 'core/components/administration/quick-setup/deployment-specification/tenants.tmpl.html',
                        parent: angular.element(document.body),
                        targetEvent: ev,
                        locals: {'tenants': tenants, 'selectedTenants': selectedTenants, 'selectedTenantsName': selectedTenantsName}
                    })
                    .then(function() {
                        console.log($scope.selectedTenants);
                        $sessionStorage.cloudData.selectedTenants = $scope.selectedTenants;
                        console.log($sessionStorage.cloudData.selectedTenants);
                    });
                };

                function tenantPopupController($rootScope, $scope, $mdDialog, selectedTenants, tenants, selectedTenantsName) {
                    $scope.tenant_activated = true;
                    callingTenant = true;
                    if(!$sessionStorage.Tenant){
                        $sessionStorage.Tenant = {};
                    }
                    
                    if(inBetweenTenantCall === true) {
                        selectedTenants = $sessionStorage.Tenant.oldSelectedTenantValue;
                        selectedTenantsName = $sessionStorage.Tenant.oldSelectedTenantName;
                        $rootScope.$broadcast('changeSelectedNameOfTenant', selectedTenantsName);
                    } else {
                        inBetweenTenantCall = true;
                        $sessionStorage.Tenant.oldSelectedTenantValue = selectedTenants;
                        $sessionStorage.Tenant.oldSelectedTenantName = selectedTenantsName;
                    }
                    
                    (function(){
                        if(!$sessionStorage.cloudData){
                            $sessionStorage.cloudData = {};
                        }
                        $scope.items = $scope.tenants = $sessionStorage.cloudData.tenants = tenants;                        
                        console.log($scope.items);
                        $sessionStorage.cloudData.selectedTenants = {};
                        if(selectedTenants) {
                            $sessionStorage.cloudData.selectedTenants.id = selectedTenants;
                        } else {
                            $sessionStorage.cloudData.selectedTenants.id = $scope.items[0].id;
                        }
                        commonPopupfunctions();
                        $scope.tenant_activated = false;

                        function commonPopupfunctions() {
                            $scope.selectedTenantsValue = $sessionStorage.cloudData.selectedTenants.id;
                            $scope.cancelDialogue = function() {
                                $mdDialog.cancel();
                            };

                            $scope.done = function() {
                                var tenantsItems = $scope.items;
                                for(i=0; i < tenantsItems.length; i++) {                            
                                    if (tenantsItems[i].id === parseInt($scope.selectedTenantsValue)) {
                                        $rootScope.$broadcast('listenSelectedTenantsEdit', tenantsItems[i]);
                                        $mdDialog.hide();
                                    }
                                }
                            };
                        }
                    })();
                }
        
        function editDeploySpecData(calledFrom){
            //FUNCTIONALITY TO EDIT DEPLOY SPEC
            console.log("$sessionStorage.deploymentSpecForEdit==");console.log($sessionStorage.deploymentSpecForEdit);
            $scope.deployment = {};
            $scope.deployment.id = $sessionStorage.deploymentSpecForEdit.id;
            $scope.deployment.name = $sessionStorage.deploymentSpecForEdit.name;
            $scope.deployment.infrastructure = $sessionStorage.deploymentSpecForEdit.cloudid;
            $scope.deployment.hosts = $sessionStorage.deploymentSpecForEdit.hosts;
            $scope.deployment.storage = ($sessionStorage.deploymentSpecForEdit.datastoreId) ? $sessionStorage.deploymentSpecForEdit.datastoreId : 0;
            $scope.deployment.backplaneIPPool = ($sessionStorage.deploymentSpecForEdit.backPlaneIpPoolId) ? $sessionStorage.deploymentSpecForEdit.backPlaneIpPoolId : 0;
            $scope.deployment.backplaneNetwork = $sessionStorage.deploymentSpecForEdit.backPlaneNetworkId;
            $scope.deployment.managementIPPool = ($sessionStorage.deploymentSpecForEdit.mgmtIpPoolId) ? $sessionStorage.deploymentSpecForEdit.mgmtIpPoolId : 0;
            $scope.deployment.managementNetwork= $sessionStorage.deploymentSpecForEdit.mgmtNetworkId;
            $scope.deployment.region= $sessionStorage.deploymentSpecForEdit.region;
            $scope.deployment.tenantId= $sessionStorage.deploymentSpecForEdit.tenantId;
            $scope.cloudType =  $sessionStorage.deploymentSpecForEdit.cloudType;
             
            if(!$sessionStorage.Management){
               $sessionStorage.Management = {}; 
            } 
            if(!$sessionStorage.Backplane){
                $sessionStorage.Backplane = {};
            }
               
            $sessionStorage.Management.oldSelectedNetworkValue = $sessionStorage.deploymentSpecForEdit.mgmtNetworkId;
            $sessionStorage.Backplane.oldSelectedNetworkValue =  $sessionStorage.deploymentSpecForEdit.backPlaneNetworkId;

            $scope.clouds = [];
            $scope.storages = [];
            $scope.pools = [];
            $scope.networks =[];
            var defaultDatastorage = [];
            var defaultIPPool = [];
            //$scope.deployment = {};
            console.log($sessionStorage.infraData);
            for (i = 0; i < $sessionStorage.infraData.length; i++) {
                $scope.clouds[i] = angular.copy($sessionStorage.infraData[i].cloud_data);
            }
            
            $scope.selectedCloudObject = {};
            if ($scope.deployment.infrastructure) {
                console.log($scope.deployment.infrastructure);
                var localDataOfInfraData = angular.copy($sessionStorage.infraData);
                $scope.selectedCloudObject = angular.copy(_.find(localDataOfInfraData, {'cloudId': $scope.deployment.infrastructure}));
                console.log("selected object==");
                console.log($scope.selectedCloudObject);
                $scope.tenants = angular.copy($scope.selectedCloudObject.tenants);
                if(calledFrom === 'editMcrSer') {
                    $scope.hosts = $scope.selectedCloudObject.host_data;

                    defaultDatastorage = [{
                            "id": 0,
                            "name": "Local",
                            "cloudId": $scope.selectedCloudObject.cloudId
                        }];
                    $scope.storages = defaultDatastorage.concat($scope.selectedCloudObject.store_data);
                    //$scope.storages = $scope.selectedCloudObject.store_data;
                }
                if(calledFrom === 'editBckPlane' || calledFrom === 'editMgmt') {
                    defaultIPPool = [{
                            "cloudId": $scope.selectedCloudObject.cloudId,
                            "id": 0,
                            "name": "DHCP"
                        }];
                    $scope.pools = defaultIPPool.concat($scope.selectedCloudObject.pool_data);
                    $scope.networks = angular.copy($scope.selectedCloudObject.network_data);
                }

            }            
        } //EDIT ENDS.
        $scope.vlanpoolDataUpdate =  function (objectData) {
              $scope.toggleAdornmentPanel();
            $scope.editMgmt = false;
            $scope.editBckPlane = false;
            $scope.editMcrSer = false;
            $scope.editMisc = false;
            $scope.editVlan = false;
                toastparam = {
                    'heading': 'Deployment Specification update in progress',
                    'subHeading': 'Deployment specification update initiated.',
                    'type': 'progress',
                    'timeout': 25000
                };
            showToast(toastparam);
            objectData.cloudName = $scope.clouds[0].name;
            objectData.cloudid = parseInt($scope.deployment.infrastructure); 
            var isLocalStorage = false;
            var isBackPlaneDHCP = false;
            var isManagementDHCP = false;
            if (parseInt($scope.deployment.storage) === 0) {
                isLocalStorage = true;
            }
            if (parseInt($scope.deployment.backplaneIPPool) === 0) {
                isBackPlaneDHCP = true;
            }
            if (parseInt($scope.deployment.managementIPPool) === 0) {
                isManagementDHCP = true;
            }
             /*objectData.deploy_spec_data */
             objectData.deploy_spec_data = {
                    "backPlaneIpPoolId": parseInt($scope.deployment.backplaneIPPool),
                    "backPlaneIsDhcp": isBackPlaneDHCP,
                    "backPlaneNetworkId": parseInt($scope.deployment.backplaneNetwork),
                    "cloudid": parseInt($scope.deployment.infrastructure),
                    "datastoreId": parseInt($scope.deployment.storage),
                    "hosts": $scope.deployment.hosts,
                    "id": $scope.deployment.id,
                    "mgmtIpPoolId": parseInt($scope.deployment.managementIPPool),
                    "mgmtIsDhcp": isManagementDHCP,
                    "mgmtNetworkId": parseInt($scope.deployment.managementNetwork),
                    "name": $scope.deployment.name,
                    "storageIsLocal": isLocalStorage
                };
                var serializeData = new Vlan();
                serializeData.ranges = objectData.ranges;
                objectData.ranges = serializeData.serializeRanges();
               // objectData.ranges = serializeData.ranges;
                objectData.active = false;
             vlanService.updateVlanPool(objectData, objectData.cloudid).then(function(){
                
                //update rows
               /* for(i=0; i<list.length ; i++) {
                    if (list[i].id === objectData.id) {
                        //list.splice(i, 1);
                        list[i] = objectData;
                    }
                }
*/
                toastparam = {
                    'heading': 'VLAN Pool (' + objectData.name + ') updated successfully',
                    'subHeading': '&nbsp;',
                    'type': 'success',
                    'timeout': 5000
                };
                showToast(toastparam);
                $scope.promiseCompleted = false;
                
            }, function(error){
                console.log("Unable to update VLAN Pool - %s due to %s", objectData.name, error.data.message);
                //TODO to show message/something else;
                toastparam = {
                    'heading': 'VLAN Pool update failed',
                    'subHeading': "ERROR: "+error.data.message,
                    'type': 'fail',
                    'timeout': 5000
                };
                showToast(toastparam);
                $scope.promiseCompleted = false;
            });
        };
        $scope.$on('invalidRangeFormData', function (event, data) {
                $scope.invalidrangeformdata = data;
            });
          
        $scope.editDeploySpec = function (calledFrom) {
            $scope.toggleAdornmentPanel();
            $scope.editMgmt = false;
            $scope.editBckPlane = false;
            $scope.editMcrSer = false;
            $scope.editMisc = false;
            $scope.editVlan = false;
                toastparam = {
                    'heading': 'Deployment Specification update in progress',
                    'subHeading': 'Deployment specification update initiated.',
                    'type': 'progress',
                    'timeout': 25000
                };
                showToast(toastparam);
                console.log($scope.deployment);
                //CALL TO CREATE NEW DEPLOYMENT SPECIFICATION
                var isLocalStorage = false;
                var isBackPlaneDHCP = false;
                var isManagementDHCP = false;

                if (parseInt($scope.deployment.storage) === 0) {
                    isLocalStorage = true;
                }
                if (parseInt($scope.deployment.backplaneIPPool) === 0) {
                    isBackPlaneDHCP = true;
                }
                if (parseInt($scope.deployment.managementIPPool) === 0) {
                    isManagementDHCP = true;
                }
                paramObject = {
                    "backPlaneIpPoolId": parseInt($scope.deployment.backplaneIPPool),
                    "backPlaneIsDhcp": isBackPlaneDHCP,
                    "backPlaneNetworkId": parseInt($scope.deployment.backplaneNetwork),
                    "cloudid": parseInt($scope.deployment.infrastructure),
                    "datastoreId": parseInt($scope.deployment.storage),
                    "hosts": $scope.deployment.hosts,
                    "id": $scope.deployment.id,
                    "mgmtIpPoolId": parseInt($scope.deployment.managementIPPool),
                    "mgmtIsDhcp": isManagementDHCP,
                    "mgmtNetworkId": parseInt($scope.deployment.managementNetwork),
                    "name": $scope.deployment.name,
                    "storageIsLocal": isLocalStorage
                };
                 if($scope.cloudType === 'OPENSTACK'){ 
                    //SET only if cloudType is openstack
                    paramObject.region = $scope.deployment.region;
                    paramObject.tenantId = $scope.deployment.tenantId;
                    paramObject.cloudType = $scope.cloudType;
                }
                console.log(paramObject);
                var objSelected = $scope.selectedCloudObject;
                var deploySpecId = paramObject.id;
                var list = viewData;
                    
                deploymentSpecificationService.updateDeploymentSpecfication(paramObject).then(function () {
                    //UPDATE THE DATA GRID and show TOAST
                    if (isBackPlaneDHCP === false) {
                        paramObject.backPlaneIpPoolName =
                                getNameOfGivenParam(paramObject.backPlaneIpPoolId, objSelected.pool_data);
                    } else {
                        paramObject.backPlaneIpPoolName = {'name': 'DHCP'};
                    }
                    if (isManagementDHCP === false) {
                        paramObject.mgmtIpPoolName =
                                getNameOfGivenParam(paramObject.mgmtIpPoolId, objSelected.pool_data);
                    } else {
                        paramObject.mgmtIpPoolName = {'name': 'DHCP'};
                    }
                    //NETWORKNAME 
                    paramObject.backPlaneNetworkName =
                            getNameOfGivenParam(paramObject.backPlaneNetworkId, objSelected.network_data);

                    paramObject.mgmtNetworkName =
                            getNameOfGivenParam(paramObject.mgmtNetworkId, objSelected.network_data);

                    //CLOUD NAME
                    paramObject.cloudName = objSelected.cloud_data.name;

                    //STORAGE NAME
                    if (isLocalStorage === false) {
                        paramObject.datastoreName =
                                getNameOfGivenParam(paramObject.datastoreId, objSelected.store_data);
                    } else {
                        paramObject.datastoreName = {'name': 'Local'};
                    }

                    //HOST NAME
                    console.log("paramObject.hosts");
                    console.log(paramObject.hosts);
                    console.log(objSelected.host_data);
                    paramObject.hostsWithName = getHostDataWithName(paramObject.hosts,
                            objSelected.host_data);
                    
                    console.log(paramObject.hostsWithName);
                    
                    if($scope.cloudType === 'OPENSTACK'){ //Only if it is openstack.
                        paramObject.tenantName =  getNameOfGivenParam(paramObject.tenantId, objSelected.tenants);
                    }
                   
                    //update rows in Table
                    for(i=0; i<list.length ; i++) {
                        if (list[i].id === deploySpecId) {
                            list[i] = paramObject;
                        }
                    }
                    
                    toastparam = {
                        'heading': 'Deployment Specification updated successfully',
                        'subHeading': 'New Deployment specification with name <b>'+paramObject.name+ '</b> has been updated successfully.',
                        'type': 'success',
                        'timeout': 5000
                    };
                    showToast(toastparam);
                    if(calledFrom === 'Management' || calledFrom === 'Backplane' ){
                        inBetweenNetworkCall = false;
                    }
                    if(calledFrom === 'StorageHost' && callingStorage){
                        inBetweenStorageCall = false;
                    }
                    if(calledFrom === 'StorageHost' && callingHosts){
                        inBetweenHostCall = false;
                    }
                    
                    inBetweenTenantCall = false;
                    

                }, function (error) {
                    //SHOW TOAST WITH FAILURE MESSAGE
                    console.log(error);
                    toastparam = {
                        'heading': 'Deployment Specification update failed',
                        'subHeading': error.data.message,
                        'type': 'fail',
                        'timeout': 10000
                    };
                    showToast(toastparam);
                    if(calledFrom === 'Management'){
                        inBetweenNetworkCall = false;
                        $sessionStorage.deploymentSpecForEdit.mgmtNetworkId = parseInt($sessionStorage.Management.oldSelectedNetworkValue);
                        paramObject.mgmtNetworkId = parseInt($sessionStorage.Management.oldSelectedNetworkValue);
                        $scope.deployment.managementNetwork = parseInt($sessionStorage.Management.oldSelectedNetworkValue);
                        $scope.adornmentData.mgmtNetworkName.name = $sessionStorage.Management.selectedNetworkName;
                    }
                    if(calledFrom === 'Backplane'){
                        inBetweenNetworkCall = false;
                        $sessionStorage.deploymentSpecForEdit.backPlaneNetworkId = parseInt($sessionStorage.Backplane.oldSelectedNetworkValue);
                        paramObject.backPlaneNetworkId = parseInt($sessionStorage.Backplane.oldSelectedNetworkValue);
                        $scope.deployment.backplaneNetwork = parseInt($sessionStorage.Backplane.oldSelectedNetworkValue);
                        $scope.adornmentData.backPlaneNetworkName.name = $sessionStorage.Backplane.selectedNetworkName;
                    }
                    if(calledFrom === 'StorageHost' && callingStorage){
                        inBetweenStorageCall = false;
                        $sessionStorage.deploymentSpecForEdit.datastoreId = parseInt($sessionStorage.Storage.oldSelectedStorageValue);
                        paramObject.datastoreId = parseInt($sessionStorage.Storage.oldSelectedStorageValue);
                        $scope.deployment.storage = parseInt($sessionStorage.Storage.oldSelectedStorageValue);
                        $scope.adornmentData.datastoreName.name = $sessionStorage.Storage.oldSelectedStorageName;
                    }
                    
                    if(calledFrom === 'StorageHost' && callingHosts){
                        inBetweenHostCall = false;
                        $sessionStorage.deploymentSpecForEdit.hosts = $sessionStorage.Host.oldSelectedHosts;
                        paramObject.hosts = $sessionStorage.Host.oldSelectedHosts;
                        $scope.deployment.hosts = $sessionStorage.Host.oldSelectedHosts;
                        $scope.adornmentData.hostsWithName = $sessionStorage.Host.oldSelectedHostNames;
                    }
                    if(callingTenant && $scope.cloudType === 'OPENSTACK'){
                        inBetweenTenantCall = false;
                        $sessionStorage.deploymentSpecForEdit.tenantId = parseInt($sessionStorage.Tenant.oldSelectedTenantValue);
                        paramObject.tenantId = parseInt($sessionStorage.Tenant.oldSelectedTenantValue);
                        $scope.deployment.tenantId = parseInt($sessionStorage.Tenant.oldSelectedTenantValue);
                        $scope.adornmentData.tenantName.name = $sessionStorage.Tenant.oldSelectedTenantName;
                    }
                    
                    /*$scope.deployment.id = parseInt($sessionStorage.deploymentSpecForEdit.id);
                    $scope.deployment.name = $sessionStorage.deploymentSpecForEdit.name;
                    $scope.deployment.infrastructure = parseInt($sessionStorage.deploymentSpecForEdit.cloudid);
                    $scope.deployment.hosts = $sessionStorage.deploymentSpecForEdit.hosts;
                    $scope.deployment.storage = ($sessionStorage.Storage.oldSelectedStorageValue) ? parseInt($sessionStorage.Storage.oldSelectedStorageValue) : 0;
                    $scope.deployment.backplaneIPPool = ($sessionStorage.deploymentSpecForEdit.backPlaneIpPoolId) ? parseInt($sessionStorage.deploymentSpecForEdit.backPlaneIpPoolId) : 0;
                    $scope.deployment.backplaneNetwork = parseInt($sessionStorage.Backplane.oldSelectedNetworkValue);
                    $scope.deployment.managementIPPool = ($sessionStorage.deploymentSpecForEdit.mgmtIpPoolId) ? parseInt($sessionStorage.deploymentSpecForEdit.mgmtIpPoolId) : 0;
                    $scope.deployment.managementNetwork= parseInt($sessionStorage.Management.oldSelectedNetworkValue);*/
                
                    $scope.deployment.id = $sessionStorage.deploymentSpecForEdit.id;
                    $scope.deployment.name = $sessionStorage.deploymentSpecForEdit.name;
                    $scope.deployment.infrastructure = $sessionStorage.deploymentSpecForEdit.cloudid;
                    $scope.deployment.hosts = $sessionStorage.deploymentSpecForEdit.hosts;
                    $scope.deployment.storage = ($sessionStorage.deploymentSpecForEdit.datastoreId) ? $sessionStorage.deploymentSpecForEdit.datastoreId : 0;
                    $scope.deployment.backplaneIPPool = ($sessionStorage.deploymentSpecForEdit.backPlaneIpPoolId) ? $sessionStorage.deploymentSpecForEdit.backPlaneIpPoolId : 0;
                    $scope.deployment.backplaneNetwork = $sessionStorage.deploymentSpecForEdit.backPlaneNetworkId;
                    $scope.deployment.managementIPPool = ($sessionStorage.deploymentSpecForEdit.mgmtIpPoolId) ? $sessionStorage.deploymentSpecForEdit.mgmtIpPoolId : 0;
                    $scope.deployment.managementNetwork= $sessionStorage.deploymentSpecForEdit.mgmtNetworkId;
                    if($scope.cloudType === 'OPENSTACK'){
                        $scope.deployment.region =$sessionStorage.deploymentSpecForEdit.region;
                        $scope.deployment.tenantId = $sessionStorage.deploymentSpecForEdit.tenantId;
                    }
                    //NETWORKNAME 
                    
                    
                    paramObject.backPlaneNetworkName = 
                            getNameOfGivenParam($scope.deployment.backplaneNetwork, objSelected.network_data);

                    paramObject.mgmtNetworkName =
                            getNameOfGivenParam($scope.deployment.managementNetwork, objSelected.network_data);

                    var deploySpecId = paramObject.id;
                    var list = viewData;
                    
                    paramObject.mgmtIpPoolId = $sessionStorage.deploymentSpecForEdit.mgmtIpPoolId;
                    paramObject.backPlaneIpPoolId = $sessionStorage.deploymentSpecForEdit.backPlaneIpPoolId;
                
                    if ($sessionStorage.deploymentSpecForEdit.backPlaneIpPoolId>0) {
                        paramObject.backPlaneIpPoolName =
                                getNameOfGivenParam($sessionStorage.deploymentSpecForEdit.backPlaneIpPoolId, objSelected.pool_data);
                    } else {
                        paramObject.backPlaneIpPoolName = {'name': 'DHCP'};
                    }
                    if ($sessionStorage.deploymentSpecForEdit.mgmtIpPoolId > 0) {
                        paramObject.mgmtIpPoolName =
                                getNameOfGivenParam($sessionStorage.deploymentSpecForEdit.mgmtIpPoolId, objSelected.pool_data);
                    } else {
                        paramObject.mgmtIpPoolName = {'name': 'DHCP'};
                    }
                    //NETWORKNAME 
                    paramObject.backPlaneNetworkName =
                            getNameOfGivenParam($sessionStorage.deploymentSpecForEdit.backPlaneNetworkId, objSelected.network_data);

                    paramObject.mgmtNetworkName =
                            getNameOfGivenParam($sessionStorage.deploymentSpecForEdit.mgmtNetworkId, objSelected.network_data);

                    //CLOUD NAME
                    paramObject.cloudName = objSelected.cloud_data.name;

                    //STORAGE NAME
                    
                    if ($scope.deployment.storage>0) {
                        paramObject.storageIsLocal = false;
                        paramObject.datastoreName =
                                getNameOfGivenParam($scope.deployment.storage, objSelected.store_data);
                    } else {
                        paramObject.storageIsLocal = true;
                        paramObject.datastoreName = {'name': 'Local'};
                    }

                    //HOST NAME
                    paramObject.hostsWithName = getHostDataWithName($sessionStorage.deploymentSpecForEdit.hosts,
                            objSelected.host_data);
                            
                    if($scope.cloudType === 'OPENSTACK'){
                        paramObject.tenantName =  getNameOfGivenParam(paramObject.tenantId, objSelected.tenants);
                    }
                    //update rows
                    for(i=0; i<list.length ; i++) {
                        if (list[i].id === deploySpecId) {
                            list[i] = paramObject;
                        }
                    }
                });                
            };
        //EDIT ENDS. 
        
        //ADD STARTS
        $scope.callpopupToAddDeploySpec = function(ev){
            $mdDialog.show({
                controller: addDeploySpecPopupCtr,
                templateUrl: 'core/components/administration/deployment-specifications/addDeploySpec.tmpl.html',
                parent: angular.element(document.body),
                targetEvent: ev,
                fullscreen: true, 
                openFrom : {top: 1100, height: 0 },
                closeTo : {left: 1500}
            }).then(function() {

            });            
        };
        
        function addDeploySpecPopupCtr($rootScope, $scope, $sessionStorage,vlanService){
            //FUNCTIONALITY TO ADD DEPLOY SPEC
            $scope.enableRestButtons = false;
            $scope.showMainAddDeployForm = true;
            $scope.showMgmtNetworkForm = false; 
            $scope.showBckplnNetworkForm = false; 
            $scope.showMicroServForm = false;
            $scope.BackplaneFormDone = false;
            $scope.ManagementFormDone = false;
            
            $scope.deployment = {};
            $scope.deployment.backplaneIPPool = -1;
            $scope.deployment.managementIPPool = -1;
            $scope.deployment.storage = 0; //Default Local selected
            $scope.deployment.storageName = "Local";
            $scope.deployment.numberOfHosts = 0;        
            $scope.formInProgress = true;

            $scope.rangesParent = [];
            $scope.newVlan = new Vlan();
            $scope.selectedVlan = null;
            $scope.selectOption = null;

            $scope.hideRightPanel = false;

             $scope.active_help_id = "deploy_spec_title_help_wizard";

            $scope.helpButtonClicked = function(id){
                $scope.active_help_id = id;
                console.log("  helpButtonClicked ");
                $scope.bordcastEventHelpButtonClicked($scope.active_help_id);
            }; 
            $scope.bordcastEventHelpButtonClicked = function(helpId){
                $scope.$broadcast('onHelpButtonClicked', {
                   helpIDString: helpId 
                });
             };  

            $scope.toggleHelpPanel = function () {
                $scope.hideRightPanel = !($scope.hideRightPanel);
            };

            $scope.onOptionChanged = function(value){
              $scope.selectOption = value;
               $scope.newVlan = new Vlan();
              if(value === "new"){
                $scope.selectedVlan = -1;      
              }

              if(value === "existing" || value === "new"){
                   $scope.formInProgress = true;
                 }else if(value ===  "novlan"){
                    $scope.checkFormCompleted();
                }
            }; 


             $scope.$on('newRangeValueChanged', function (event, data) {
             if($scope.newVlan.isPopulated()){
                $scope.checkFormCompleted();
             }
            });

            $scope.onVlanSelected = function(value){
                 $scope.selectedVlan = value;
                 console.log(" onVlanSelected "+$scope.selectedVlan);
                 $scope.selectOption = "existing";
                 $scope.checkFormCompleted();
                 
            };


            $scope.hide = function() {
                $mdDialog.hide();
            };
            $scope.cancel = function() {
                $mdDialog.cancel();
            };
            
            $scope.saveManagementForm = function() {
                console.log($scope.deployment);
                if($scope.deployment.mgmtselectedData === 'existing') {
                    $scope.deployment.managementIPPool = JSON.parse($scope.deployment.managementIPPoolData).id;
                    $scope.deployment.managementIPPoolName = JSON.parse($scope.deployment.managementIPPoolData).name;
                } else {
                    $scope.deployment.managementIPPool = 0;
                    $scope.deployment.managementIPPoolName = 'DHCP';
                }
                $scope.ManagementFormDone = true;
                $scope.showMainAddDeploymentForm();
            };
            
            $scope.saveBackplaneForm = function() {
                console.log($scope.deployment);
                if($scope.deployment.bkplnselectedData === 'existing') {
                    $scope.deployment.backplaneIPPool = JSON.parse($scope.deployment.backplaneIPPoolData).id;
                    $scope.deployment.backplaneIPPoolName = JSON.parse($scope.deployment.backplaneIPPoolData).name;
                } else {
                    $scope.deployment.backplaneIPPool = 0;
                    $scope.deployment.backplaneIPPoolName = 'DHCP';
                }
                $scope.BackplaneFormDone = true;
                $scope.showMainAddDeploymentForm();
            };
            
            
            $scope.showMainAddDeploymentForm = function(){
                $scope.showMainAddDeployForm = true;
                $scope.showMgmtNetworkForm = false;
                $scope.showBckplnNetworkForm = false;
                $scope.showMicroServForm = false;
            };
            
            $scope.showManagmentNetworkDialogForm = function(){
                $scope.showMainAddDeployForm = false;
                $scope.showMgmtNetworkForm = true;
                $scope.showBckplnNetworkForm = false;
                $scope.showMicroServForm = false;
            };
            
            $scope.showBackplaneNetworkDialogForm = function(){
                $scope.showMainAddDeployForm = false;
                $scope.showMgmtNetworkForm = false;
                $scope.showBckplnNetworkForm = true;
                $scope.showMicroServForm = false;
            };
            
            $scope.showMicroserviceHostsDialogForm = function(){
                $scope.showMainAddDeployForm = false;
                $scope.showMgmtNetworkForm = false;
                $scope.showBckplnNetworkForm = false;
                $scope.showMicroServForm = true;
            };
            
            $scope.$on('listenManagementNetwork', function (event, args) {
                console.log('listenManagementNetwork' + args);
                $scope.deployment.managementNetworkSelected = args;
                $scope.deployment.managementNetwork = args.id;
                $scope.deployment.managementNetworkSelectedName = args.name;
                console.log($scope.deployment.managementNetwork);
               
            });
            
            $scope.$on('listenBackplaneNetwork', function (event, args) {
                console.log('listenBackplaneNetwork' + args);
                $scope.deployment.backplaneNetworkSelected = args;
                $scope.deployment.backplaneNetwork = args.id;
                $scope.deployment.backplaneNetworkSelectedName = args.name;
                console.log($scope.deployment.backplaneNetworkSelectedName);
                
            });
            $scope.$on('listenSelectedHosts', function (event, args) {
                var hostIds = [];
                var hostNames = [];
                for(i=0; i<args.length; i++) {
                    hostIds[i] = args[i].id;
                    hostNames[i] = args[i].name;
                }
                $scope.deployment.numberOfHosts = args.length;
                $scope.deployment.selectedHostObjects = args;
                $scope.deployment.hosts = hostIds;
                $scope.deployment.hostNames = hostNames;
                console.log($scope.deployment.hostNames);
                
            });
            $scope.$on('listenSelectedStorages', function (event, args) {
                $scope.deployment.selectedStorage = args;
                $scope.deployment.storage = args.id;
                $scope.deployment.storageName = args.name;
                console.log($scope.deployment.storageName);
                
            });
            $scope.$on('listenSelectedTenants', function (event, args) {
                $scope.deployment.selectedTenants = args;
                $scope.selectedTenants = args;
                $sessionStorage.cloudData.selectedTenants = $scope.selectedTenants;
                $scope.deployment.tenant = args.id;
            });
            $scope.$on('listenSelectedRegion', function (event, args) {
                $scope.deployment.selectedRegion = args;
                $scope.deployment.region = args.id;
                $scope.deployment.regionName = args.name;
                console.log($scope.deployment.storageName);

            });

            
            $scope.showNetworkDialog = function(label, networks, selectedNetworks, ev){
                console.log("Calling Show Network Dialogue");
                $mdDialog.show({
                    skipHide: true,
                    controller: networkPopupController,
                    templateUrl: 'core/components/administration/deployment-specifications/networks.tmpl.html',
                    parent: angular.element(document.body),
                    targetEvent: ev,
                    locals: {'label': label, 'networks' : networks, 'selectedNetworks': selectedNetworks}
                })
                  .then(function() {
                    
                });
            };
            
            function networkPopupController($rootScope, $scope, $sessionStorage, networks, selectedNetworks, label){
                console.log(networks);
                $scope.label = label;
                $scope.networksList = networks;
                $scope.networks = networks;
                console.log(selectedNetworks);
                $scope.selectedNetworkValue = (selectedNetworks)?selectedNetworks.id:0;
                console.log($scope.selectedNetworkValue);
                
                $scope.cancelDialogue = function() {
                    $mdDialog.cancel();
                };
                
                $scope.done = function(){
                    if(label === 'Management') {
                        for(i=0; i < networks.length; i++) {                            
                            if (networks[i].id === parseInt($scope.selectedNetworkValue)) {
                                $rootScope.$broadcast('listenManagementNetwork', networks[i]);
                                $mdDialog.hide();
                            }
                        }
                    } 
                    if(label === 'Backplane') {
                        for(i=0; i < networks.length; i++) {                            
                            if (networks[i].id === parseInt($scope.selectedNetworkValue)) {
                                $rootScope.$broadcast('listenBackplaneNetwork', networks[i]);
                                $mdDialog.hide();
                            }
                        }
                    }
                };
            }
            $scope.startedAddDeploySpec = function(){
                console.log(" startedAddDeploySpec ");
               if($scope.cloudType === 'VMWARE'){
                 if($scope.selectOption){
                     switch($scope.selectOption){
                      case "new":
                       // console.dir($scope.newVlan); 
                       // console.log(" startCreatingDeploymentspec new  1"+$scope.newVlan.isPopulated());

                       if($scope.newVlan && $scope.newVlan.isPopulated())
                       {
                         var data = {
                            "cloudid": parseInt($scope.deployment.infrastructure),
                            "id": 0,
                            "name": $scope.newVlan.name,
                            "ranges": $scope.newVlan.serializeRanges()
                         };
                         // console.log(" startCreatingDeploymentspec new  2"+ $scope.newVlan.serializeRanges()); 
                         vlanService.createVlanPool(data, parseInt($scope.deployment.infrastructure)).then(function(data){
                         // console.log(" startCreatingDeploymentspec new  3"+ data); 
                            $scope.addDeploySpec(parseInt(data));
                         },function(error){
                            console.log("failed to create vlan ");
                         }); 
                       }else{
                         console.log("no new vlan info found");
                       }
                      break;
                      case "existing":
                          console.log(" $scope.selectedVlan "+$scope.selectedVlan); 
                          if($scope.selectedVlan){
                            $scope.addDeploySpec(parseInt($scope.selectedVlan));
                          }else{
                             $scope.addDeploySpec(0);
                          }
                      break;
                       case "novlan":
                         $scope.addDeploySpec(0);
                       break;  
                     }
                  }else{  
                    $scope.addDeploySpec(0);
                  }
               } else {
                $scope.addDeploySpec(0);
               } 
               
            };
            $scope.addDeploySpec = function (vlanId) {
                toastparam = {
                    'heading': 'Deployment Specification creation in progress',
                    'subHeading': 'New Deployment specification creation initiated.',
                    'type': 'progress',
                    'timeout': 25000
                };
                showToast(toastparam);
                    
                console.log($scope.deployment);
                //CALL TO CREATE NEW DEPLOYMENT SPECIFICATION
                var isLocalStorage = false;
                var isBackPlaneDHCP = false;
                var isManagementDHCP = false;

                if (parseInt($scope.deployment.storage) === 0) {
                    isLocalStorage = true;
                }
                if (parseInt($scope.deployment.backplaneIPPool) === 0) {
                    isBackPlaneDHCP = true;
                }
                if (parseInt($scope.deployment.managementIPPool) === 0) {
                    isManagementDHCP = true;
                }

                paramObject = {
                    "backPlaneIpPoolId": parseInt($scope.deployment.backplaneIPPool),
                    "backPlaneIsDhcp": isBackPlaneDHCP,
                    "backPlaneNetworkId": parseInt($scope.deployment.backplaneNetwork),
                    "cloudid": parseInt($scope.deployment.infrastructure),
                    "datastoreId": parseInt($scope.deployment.storage),
                    "hosts": $scope.deployment.hosts,
                    "id": 0,
                    "mgmtIpPoolId": parseInt($scope.deployment.managementIPPool),
                    "mgmtIsDhcp": isManagementDHCP,
                    "mgmtNetworkId": parseInt($scope.deployment.managementNetwork),
                    "name": $scope.deployment.name,
                    "vlanPoolId" : vlanId,
                    // "region": "", //Empty for VMWARE and value will come for OPENSTACK
                    "storageIsLocal": isLocalStorage
                            // "tenantId": 0 //Empty for VMWARE and value will come for OPENSTACK
                };
                console.log("paramObject ");
                console.dir(paramObject);
                if($scope.cloudType === 'OPENSTACK'){
                    paramObject.region = $scope.deployment.region;
                    paramObject.tenantId = $scope.deployment.tenant;
                    paramObject.cloudType = $scope.cloudType;
                }
                if($scope.cloudType === 'AWS') {
                    //paramObject.region = $scope.deployment.region;
                    paramObject.tenantId = $scope.deployment.tenant;
                    paramObject.cloudType = $scope.cloudType;
                    //remove fields not applicable to AWS
                    delete paramObject.backPlaneIpPoolId;
                    delete paramObject.mgmtIpPoolId;
                    delete paramObject.hosts;
                    delete paramObject.storageIsLocal;
                }
                console.log(paramObject);
                var objSelected = $scope.selectedCloudObject;
                $mdDialog.hide();
                deploymentSpecificationService.createDeploymentSpecfication(paramObject).then(function (data) {
                    //UPDATE THE DATA GRID and show TOAST
                    if (isBackPlaneDHCP === false) {
                        paramObject.backPlaneIpPoolName =
                                getNameOfGivenParam(paramObject.backPlaneIpPoolId, objSelected.pool_data);
                    } else {
                        paramObject.backPlaneIpPoolName = {'name': 'DHCP'};
                    }
                    if (isManagementDHCP === false) {
                        paramObject.mgmtIpPoolName =
                                getNameOfGivenParam(paramObject.mgmtIpPoolId, objSelected.pool_data);
                    } else {
                        paramObject.mgmtIpPoolName = {'name': 'DHCP'};
                    }
                    //NETWORKNAME 
                    paramObject.backPlaneNetworkName =
                            getNameOfGivenParam(paramObject.backPlaneNetworkId, objSelected.network_data);

                    paramObject.mgmtNetworkName =
                            getNameOfGivenParam(paramObject.mgmtNetworkId, objSelected.network_data);

                    //CLOUD NAME
                    paramObject.cloudName = objSelected.cloud_data.name;

                    //STORAGE NAME
                    if (isLocalStorage === false) {
                        paramObject.datastoreName =
                                getNameOfGivenParam(paramObject.datastoreId, objSelected.store_data);
                    } else {
                        paramObject.datastoreName = {'name': 'Local'};
                    }

                    //HOST NAME
                    if($scope.cloudType !== 'AWS') {
                        paramObject.hostsWithName = getHostDataWithName(paramObject.hosts,
                            objSelected.host_data);
                    }
                    
                    paramObject.id = data; //Newly created Id
                    
                    if($scope.cloudType !== 'VMWARE'){
                        paramObject.tenantName =  getNameOfGivenParam(paramObject.tenantId, objSelected.tenants);
                    }
                    
                    //ADD IT AT TOP OF TABLE
                    viewData.unshift(paramObject);
                    $rootScope.$broadcast('newDPCreated',{});
                    toastparam = {
                        'heading': 'Deployment Specification created successfully',
                        'subHeading': 'New Deployment specification with name <b>'+paramObject.name+ '</b> has been created successfully. You can see it on the top of table.',
                        'type': 'success',
                        'timeout': 5000
                    };
                    showToast(toastparam);
                    
                    $mdDialog.hide();

                }, function (error) {
                    //SHOW TOAST WITH FAILURE MESSAGE
                    toastparam = {
                        'heading': 'Deployment Specification creation failed',
                        'subHeading': error.data.message,
                        'type': 'fail',
                        'timeout': 5000
                    };
                    showToast(toastparam);
                    //$mdDialog.hide();
                });
            };

            $scope.clouds = [];
            console.log($sessionStorage.infraData);
            for (i = 0; i < $sessionStorage.infraData.length; i++) {
                $scope.clouds[i] = $sessionStorage.infraData[i].cloud_data;
            }
            $scope.checkFormCompleted = function(){
                if($scope.cloudType === 'VMWARE'){
                    if($scope.deployment.infrastructure  && $scope.deployment.name && $scope.deployment.hosts && $scope.deployment.hosts.length > 0 && $scope.deployment.storage >= 0 && ($scope.deployment.backplaneIPPool >=0) && $scope.deployment.backplaneNetwork && ($scope.deployment.managementIPPool >=0) && $scope.deployment.managementNetwork){
                        $scope.formInProgress = false;
                    } else {
                        $scope.formInProgress = true;
                    }
                } else if ( $scope.cloudType === 'OPENSTACK') {
                    if($scope.deployment.infrastructure  && $scope.deployment.name && $scope.deployment.hosts && $scope.deployment.hosts.length > 0 && $scope.deployment.storage >= 0 && ($scope.deployment.backplaneIPPool >=0) && $scope.deployment.backplaneNetwork && ($scope.deployment.managementIPPool >=0) && $scope.deployment.managementNetwork && $scope.deployment.tenant && $scope.deployment.region && $scope.deployment.region.length <= 40){
                        $scope.formInProgress = false;
                    } else {
                        $scope.formInProgress = true;
                    }
                } else if ( $scope.cloudType === 'AWS') {
                    if($scope.deployment.infrastructure  && $scope.deployment.name  && $scope.deployment.backplaneNetwork && $scope.deployment.managementNetwork && $scope.deployment.tenant && $scope.deployment.region) {
                        $scope.formInProgress = false;
                    } else {
                        $scope.formInProgress = true;
                    }
                }

                console.log("called checkFormCompleted, value of formInProgress == "+ $scope.formInProgress);
            };
            $scope.$watch('deployment.name', function() { $scope.checkFormCompleted();});
            $scope.$watch('deployment.storage', function() { $scope.checkFormCompleted();});
            $scope.$watch('deployment.hosts', function() { $scope.checkFormCompleted();});
            $scope.$watch('deployment.backplaneIPPool', function() { $scope.checkFormCompleted();});
            $scope.$watch('deployment.backplaneNetwork', function() { $scope.checkFormCompleted();});
            $scope.$watch('deployment.managementIPPool', function() { $scope.checkFormCompleted();});
            $scope.$watch('deployment.managementNetwork', function() { $scope.checkFormCompleted();});
            $scope.$watch('deployment.region', function() {
                $scope.checkFormCompleted();
                if ($scope.selectedCloudObject !== undefined) {
                    console.log($scope.selectedCloudObject.tenants);
                    console.log($scope.deployment.region);
                    $scope.tenants = _.filter($scope.selectedCloudObject.tenants, {'regionId': $scope.deployment.region});
                    console.log($scope.tenants);
                    $scope.deployment.selectedTenants = $scope.tenants[0];
                    console.log($scope.deployment.selectedTenants);
                    $scope.deployment.tenant = $scope.deployment.selectedTenants.id;
                }
            });

            $scope.$watch('deployment.tenant', function () {
                if ($scope.selectedCloudObject !== undefined && $scope.selectedCloudObject.cloud_data.type === 'AWS') {
                    $scope.networks = _.filter($scope.selectedCloudObject.network_data, {'tenantId': $scope.deployment.tenant});
                }
            });

            
            $scope.$watch('deployment.infrastructure', function () {                
                $scope.deployment.storage = 0;
                $scope.deployment.numberOfHosts = 0;
                $scope.deployment.selectedHostObjects = [];
                $scope.deployment.hosts = [];
                $scope.deployment.hostNames = '';
                $scope.deployment.tenants = [];
                $scope.deployment.regions = [];
                $scope.deployment.selectedTenants = {};
                $scope.deployment.backplaneNetwork = 0;
                $scope.deployment.managementNetwork = 0;
                $scope.deployment.backplaneIPPool = -1;
                $scope.deployment.managementIPPool = -1;
                $scope.BackplaneFormDone = false;
                $scope.ManagementFormDone = false;
                
                $scope.selectedCloudObject = {};
                if ($scope.deployment.infrastructure) {
                    console.log($scope.deployment.infrastructure);
                    //var selectedCloudId = $scope.deployment.infrastructure;
                    for (j = 0; j < $sessionStorage.infraData.length; j++) {
                        if (parseInt($sessionStorage.infraData[j].cloudId) === parseInt($scope.deployment.infrastructure)) {
                            $scope.selectedCloudObject = $sessionStorage.infraData[j];
                        }
                    }
                    $scope.cloudType = $scope.selectedCloudObject.cloud_data.type;
                    if($scope.selectedCloudObject.cloud_data.type === 'OPENSTACK' ){
                            //FOR TESTING NEED TO REMOVE THIS HARDCODED VALUE.
                            if($scope.selectedCloudObject.tenants.length <=0){
                               $scope.selectedCloudObject.tenants = [
                                                                        {
                                                                          "cloudId": $scope.selectedCloudObject.cloudId,
                                                                          "id": $scope.selectedCloudObject.cloudId,
                                                                          "name": "Hardcoded Default For Testing"
                                                                        }
                                                                    ]; 
                            }
                        $scope.tenants = $scope.selectedCloudObject.tenants;
                        $scope.deployment.selectedTenants = $scope.tenants[0];
                        $scope.deployment.tenant = $scope.deployment.selectedTenants.id;
                    }
                    if( $scope.selectedCloudObject.cloud_data.type === 'AWS'){
                        //FOR TESTING NEED TO REMOVE THIS HARDCODED VALUE.
                        $scope.regions = $scope.selectedCloudObject.regions;
                        //$scope.deployment.selectedRegion = $scope.regions[0];
                        //$scope.deployment.region = $scope.deployment.selectedRegion.id;
                    }
                    //$scope.selectedCloudObject = _.find($sessionStorage.infraData, {'cloudId': $scope.deployment.infrastructure});
                    console.log("selected object==");
                    console.log($scope.selectedCloudObject);
                    $scope.hosts = $scope.selectedCloudObject.host_data;
                    var defaultDatastorage = [{
                            "cloudId": $scope.selectedCloudObject.cloudId,
                            "id": 0,
                            "name": "Local"
                        }];
                    $scope.storages = defaultDatastorage.concat($scope.selectedCloudObject.store_data);
                    $scope.deployment.storage = 0; //Default Local selected
                    $scope.deployment.storageName = "Local";
                    /*var defaultIPPool = [{
                            "cloudId": $scope.selectedCloudObject.cloudId,
                            "id": 0,
                            "name": "DHCP"
                        }];
                    $scope.pools = defaultIPPool.concat($scope.selectedCloudObject.pool_data);*/
                    $scope.pools = $scope.selectedCloudObject.pool_data;
                    $scope.networks = $scope.selectedCloudObject.network_data;
                    if($scope.selectedCloudObject.cloud_data.type === 'OPENSTACK') {
                        $scope.deployment.mgmtselectedData = 'dhcp';
                        $scope.deployment.bkplnselectedData = 'dhcp';
                    } else {
                         $scope.deployment.mgmtselectedData = '';
                        $scope.deployment.bkplnselectedData = '';
                    }
                    $scope.checkFormCompleted();
                    $scope.enableRestButtons = true;
                }
            });           
            //$scope.storages = _.find($sessionStorage.hostData, {}) //result = _.find(list, {'id': id});
                $scope.callpopuphost = function(hosts, selectedHosts, ev){
                    console.log(hosts);
                    $mdDialog.show({
                        controller: hostPopupController,
                        skipHide: true,
                        templateUrl: 'core/components/administration/deployment-specifications/hosts.tmpl.html',
                        parent: angular.element(document.body),
                        targetEvent: ev,
                        locals: {'hosts': hosts, 'selectedHosts': selectedHosts}
                    });
                };
                $scope.callpopupstorage = function(storages, selectedStorage, ev){
                    $mdDialog.show({
                            controller: storagePopupController,
                            skipHide: true,
                            templateUrl: 'core/components/administration/deployment-specifications/storages.tmpl.html',
                            parent: angular.element(document.body),
                            targetEvent: ev,
                            locals: {'storages': storages, 'selectedStorage': selectedStorage}
                        });
                };
            $scope.callpopupregions = function(regions, selectedRegion, ev){
                console.log("In region popup ");
                $mdDialog.show({
                    controller: regionPopupController,
                    skipHide: true,
                    templateUrl: 'core/components/administration/deployment-specifications/regions.tmpl.html',
                    parent: angular.element(document.body),
                    targetEvent: ev,
                    locals: {'regions': regions, 'selectedRegion': selectedRegion}
                });
            };
                /*HOST RELATED FUNCTION*/
                function hostPopupController($rootScope, $scope, $mdDialog, hosts, selectedHosts) {
                        $scope.deployment_designate_host = $translate.instant("wizardinfrastucture.button.designate_host");
                                //$scope.deployment_designate_storage = $translate.instant("wizardinfrastucture.button.designate_storage");
                                //$scope.host_activated = true;
                            (function(){  
                                console.log(hosts);
                                //var selectedHostsList = [];
                                $scope.items = hosts ;
                                $scope.no_of_hosts = hosts.length;
                                
                                $scope.selected = (selectedHosts)?selectedHosts:[];
                                if ($scope.selected) {
                                    $scope.no_of_selected_hosts = $scope.selected.length;
                                } else {
                                    $scope.no_of_selected_hosts = 0;
                                }
                                console.log($scope.selected);
                                $scope.cancelDialogue = function() {
                                    $mdDialog.cancel();
                                };
                                $scope.doneHosts = function() {
                                    $rootScope.$broadcast('listenSelectedHosts', $scope.selected);
                                        $mdDialog.hide();
                                };
                                $scope.toggle = function (item, list) {
                                    var isDeleted = false;
                                    for (i = 0; i < list.length; i++) {
                                        if (list[i].id === item.id) {
                                        list.splice(i, 1);
                                                isDeleted = true;
                                        }
                                    }
                                    if (!isDeleted) {
                                        list.push(item);
                                    }
                                    $scope.no_of_selected_hosts = $scope.selected.length;
                                };
                                    $scope.exists = function (item, list) {
                                        for (i = 0; i < list.length; i++) {
                                            if (list[i].id === item.id) {
                                            return true;
                                            }
                                        }
                                        return false;
                                    };
                                    $scope.isIndeterminate = function () {
                                        return ($scope.selected.length !== 0 &&
                                            $scope.selected.length !== $scope.items.length);
                                    };
                                    $scope.isChecked = function () {
                                        return $scope.selected.length === $scope.items.length;
                                    };
                                    $scope.toggleAll = function () {
                                        if ($scope.selected.length === $scope.items.length) { //uncheck all
                                            $scope.selected = [];
                                        } else if ($scope.selected.length === 0 || $scope.selected.length > 0) {
                                            $scope.selected = $scope.items.slice(0); //check all
                                        }
                                        $scope.no_of_selected_hosts = $scope.selected.length;
                                    };
                                //}
                            })();
                        }

                function storagePopupController($rootScope, $scope, $mdDialog, storages, selectedStorage) {
                    //$scope.deployment_designate_host = $translate.instant("wizardinfrastucture.button.designate_host");
                    $scope.deployment_designate_storage = $translate.instant("wizardinfrastucture.button.designate_storage");
                    $scope.storage_activated = true;
                    (function(){
                        $scope.dataStores = storages;
                        $scope.selectedStoragesValue = (selectedStorage)? selectedStorage.id : 0;
                        $scope.cancelDialogue = function() {
                            $mdDialog.cancel();
                        };
                        $scope.done = function() {
                            console.log($scope.selectedStoragesValue);
                            var storageItems = $scope.dataStores;
                            for (i = 0; i < storageItems.length; i++) {
                                if (storageItems[i].id === parseInt($scope.selectedStoragesValue)) {
                                    console.log(storageItems[i]);
                                    $rootScope.$broadcast('listenSelectedStorages', storageItems[i]);
                                    $mdDialog.hide();
                                }
                            }
                        };
                    })();
                }
            function regionPopupController($rootScope, $scope, $mdDialog, regions, selectedRegion) {
                //$scope.deployment_designate_host = $translate.instant("wizardinfrastucture.button.designate_host");
                $scope.deployment_designate_region = $translate.instant("wizardinfrastucture.button.designate_region");
                $scope.region_activated = true;
                (function(){
                    console.log("Regions: "+regions);
                    $scope.regions = regions;
                    $scope.selectedRegionValue = (selectedRegion)? selectedRegion.id : 0;
                    $scope.cancelDialogue = function() {
                        $mdDialog.cancel();
                    };
                    $scope.done = function() {
                        console.log($scope.selectedRegionValue);
                        var regionItems = $scope.regions;
                        for (i = 0; i < regionItems.length; i++) {
                            if (regionItems[i].id === parseInt($scope.selectedRegionValue)) {
                                console.log(regionItems[i]);
                                $rootScope.$broadcast('listenSelectedRegion', regionItems[i]);
                                $mdDialog.hide();
                            }
                        }
                    };
                })();
            }
                
                $scope.callpopuptenants = function(tenants, selectedTenants, ev){
                    $mdDialog.show({
                        controller: tenantPopupController,
                        skipHide: true,
                        templateUrl: 'core/components/administration/deployment-specifications/tenants.tmpl.html',
                        parent: angular.element(document.body),
                        targetEvent: ev,
                        locals: {'tenants': tenants, 'selectedTenants': selectedTenants}
                    });
                };

                function tenantPopupController($rootScope, $scope, $mdDialog, selectedTenants, tenants) {

                    $scope.tenant_activated = true;
                    if(!$sessionStorage.cloudData){
                        $sessionStorage.cloudData = {};
                    }
                    console.log(selectedTenants);
                    $sessionStorage.cloudData.selectedTenants = selectedTenants;
                    (function(){
                        $scope.items = $scope.tenants = $sessionStorage.cloudData.tenants = angular.copy(tenants);

                        if(!$sessionStorage.cloudData.selectedTenants.id) {
                            $sessionStorage.cloudData.selectedTenants.id = $scope.items[0].id;
                        }
                        commonPopupfunctions();
                        $scope.tenant_activated = false;

                        function commonPopupfunctions() {
                            $scope.selectedTenantsValue = $sessionStorage.cloudData.selectedTenants.id;
                            $scope.cancelDialogue = function() {
                                $mdDialog.cancel();
                            };

                            $scope.done = function() {
                                var tenantsItems = tenants;
                                for(i=0; i < tenantsItems.length; i++) {                            
                                    if (tenantsItems[i].id === parseInt($scope.selectedTenantsValue)) {
                                        $rootScope.$broadcast('listenSelectedTenants', tenantsItems[i]);
                                        $mdDialog.hide();
                                    }
                                }
                            };
                        }
                    })();
                }
                
            }
        $scope.callCacheBurst = function () {
            console.log('Bursting cache data and reloading from server');
            //$sessionStorage.viewData = false;
            clearMasterSession($sessionStorage, $state);
            
        };
        
        $scope.$on('newDPCreated', function(event){ 
            console.log($scope.query);
            $scope.query.page = 1;
        });
        
        $scope.$on('$viewContentLoaded', function(event){ 
            console.log(event);
            fixContainerHeight(1);
        });
    }
    
    angular.module('shieldxApp').controller('deploymentSpecificationsCtr', deploymentSpecificationsCtr);


})();
/*
 ShieldX Networks Inc. CONFIDENTIAL
 ----------------------------------
 *
 Copyright (c) 2016 ShieldX Networks Inc.
 All Rights Reserved.
 *
 NOTICE: All information contained herein is, and remains
 the property of ShieldX Networks Incorporated and its suppliers,
 if any. The intellectual and technical concepts contained
 herein are proprietary to ShieldX Networks Incorporated
 and its suppliers and may be covered by U.S. and Foreign Patents,
 patents in process, and are protected by trade secret or copyright law.
 Dissemination of this information or reproduction of this material
 is strictly forbidden unless prior written permission is obtained
 from ShieldX Networks Incorporated.
 */

(function () {
    function infrastructureConnectorsCtr($scope,
        $translate,
        infrastructureConnectorService,
        ipPoolServices,
        deploymentSpecificationService,
        resourceGroupService,
        vlanService,
        $q,
        $sessionStorage,
        $state,
        $mdDialog,
        userSessionMenagment) {
            "ngInject";
            
            clearAllSession($sessionStorage);
            var InfraListData = [];
            var deferred = $q.defer();
            $scope.promise = deferred.promise; 
            $scope.promiseCompleted = true;
            var promiseCtr = 0;
            var totalClouds = 0;
            $scope.infrasAvailable = false;
            $scope.editMiscState = false;
            //$scope.loadingRelatedData = false;
            /*$scope.freshData = (!$sessionStorage.hasOwnProperty('InfraList') || 
                    typeof $sessionStorage.InfraList === "undefined" || 
                    $sessionStorage.InfraList === false || 
                    $sessionStorage.InfraList.length === 0);*/
            
            var infraCtr = 0;
            $scope.infrastructureConnections = [];

            
            //for tables [start]
                    
            $scope.$emit('listenHeaderText', { headerText: $translate.instant('admin.toolbar.heading') });
            $scope.$emit('quickSetupEnded',{});

            /* **** for tables [start] **** */
            $scope.selected = [];
            $scope.query = {
                order: 'name',
                limit: 10,
                page: 1
            };


        $scope.isAdornmentPanelOpen = false;
        $scope.isSearchBarOpen = false;
       
        var create_id = authorities("infrastructureConnectors_create");
        var delete_id = authorities("infrastructureConnectors_delete");
        var update_id = authorities("infrastructureConnectors_update");
        var read_vlanPool = authorities("vlanPools_read");
        var read_deploy = authorities("deploymentSpecifications_read");
        var read_groups = authorities("resourceGroups_read");
        var read_ippool = authorities("ipPools_read");
        $scope.is_read_vlanpool = userSessionMenagment.isUserAllowd(read_vlanPool);
        $scope.is_read_groups = userSessionMenagment.isUserAllowd(read_groups); 
        $scope.is_read_deployspec = userSessionMenagment.isUserAllowd(read_deploy);
        $scope.is_read_ippools = userSessionMenagment.isUserAllowd(read_ippool); 
        $scope.is_create_infra = userSessionMenagment.isUserAllowd(create_id);
        $scope.is_update_infra = userSessionMenagment.isUserAllowd(update_id);
        $scope.is_delete_infra = userSessionMenagment.isUserAllowd(delete_id);


        $scope.updateAdornmentPanel = function (event, rowData, index) {
            $scope.toggleAdornmentPanel();
            $scope.adornmentData = rowData;
            console.log($scope.adornmentData);
            cloudId = rowData.cloud_data.id;
            if($scope.isAdornmentPanelOpen){
                InfraListData[index] = {};
                InfraListData[index].cloud_data = {};
                InfraListData[index].pool_data = {};
                InfraListData[index].deploy_spec_data = [];
                InfraListData[index].group_data = [];
                InfraListData[index].vlan_data = [];
                InfraListData[index].cloud_data = rowData.cloud_data;
                InfraListData[index].status = 'Online';
                $scope.initialadorementDataForObj = InfraListData[index];
                if($scope.is_read_vlanpool)
                    getVlanPoolData(cloudId, InfraListData[index], index);
                if($scope.is_read_groups)
                    getResGroupData(cloudId, InfraListData[index], index);
                if($scope.is_read_deployspec)
                    getDeploymentSpecData(cloudId, InfraListData[index], index);
                if($scope.is_read_ippools)
                    getIpoolData(cloudId, InfraListData[index], index);
            }   
        };

        $scope.toggleAdornmentPanel = function () {
            $scope.isAdornmentPanelOpen = $scope.isAdornmentPanelOpen === false ? true : false;
        };

        $scope.toggleSearchBar = function (event) {
            $scope.isSearchBarOpen = $scope.isSearchBarOpen === false ? true : false;
            if ($scope.isSearchBarOpen)
                angular.element(event.currentTarget.firstElementChild).css('color', '#4a90e2');
            else
                angular.element(event.currentTarget.firstElementChild).css('color', '#6d6e71');
        };
        /* **** for tables [end] **** */

        $scope.showStatus = function (status, test) {
            return status === test;
        };

        //if ($scope.freshData) {
        $sessionStorage.InfraList = [];

        infrastructureConnectorService.getListOfInfrastructures().then(function (data) {
            totalClouds = data.length;
            $scope.infraIntialData = data;
            $scope.promiseCompleted = false;
            deferred.resolve();
            if (totalClouds === 0) {
                $scope.infrasAvailable = false;
            } else {
                $scope.infrasAvailable = true;
                var cloudId = "";
                
                 for (var i = 0; i < $scope.infraIntialData.length; i++) {

                    cloudId = data[i].id;

                    InfraListData[i] = {};
                    InfraListData[i].cloud_data = {};
                    InfraListData[i].pool_data = {};
                    InfraListData[i].deploy_spec_data = [];
                    InfraListData[i].group_data = [];
                    InfraListData[i].vlan_data = [];

                    InfraListData[i].cloud_data = data[i];
                    InfraListData[i].status = 'Online';


                    //GET REST DATA
                    //getRestData(cloudId, InfraListData[i], i);

                }
                $scope.infrastructureConnections = InfraListData;
            }

        }, function (error) {
            console.log(error);
            $scope.errorMessage = "ERROR occured while getting Infrastructure List!!!";
            InfraListData = [];
            $scope.infrastructureConnections = [];
            deferred.resolve();
            $scope.promiseCompleted = false;
            $scope.infrasAvailable = false;
        });
        /*} else {
         $scope.infrastructureConnections = InfraListData = $sessionStorage.InfraList;
         if($sessionStorage.InfraList.length > 0){
         $scope.infrasAvailable = true;
         } else {
         $scope.infrasAvailable = false;
         }
         deferred.resolve();
         $scope.promiseCompleted = false;
         }*/

        getVlanPoolData = function (cloudId, obj, index) {
            $scope.isvlanPoolDataPresent = false;
            $scope.initialadorementDataForObj = obj;
            vlanService.getvlanList(cloudId).then(function (vlanData) {
                obj.vlan_data = vlanData;
                $scope.isvlanPoolDataPresent = true;
                    
               // }
            }, function (error) {
                console.log(error);
                obj.vlan_data = [];
            });
        };
        getResGroupData = function(cloudId, obj, index){
            $scope.isresgroupDataPresent = false;
            $scope.initialadorementDataForObj = obj;
            resourceGroupService.getGroupList(cloudId).then(function (groupData) {
                $scope.isresgroupDataPresent = true;
                obj.group_data = groupData;
            }, function (error) {
                obj.group_data = [];
            });
        };
        getIpoolData = function(cloudId, obj, index){
            $scope.isippoolsDataPresent = false;
            $scope.initialadorementDataForObj = obj;
            ipPoolServices.getIpPoolListByCloudId(cloudId).then(function (ipPoolData) {
                obj.pool_data = ipPoolData;
                $scope.isippoolsDataPresent = true;
            }, function (error) {
                obj.pool_data = [];
            });
        };
        
        getDeploymentSpecData = function(cloudId, obj, index){
            $scope.isdeploymentDataPresent = false;
            $scope.initialadorementDataForObj = obj;
            deploymentSpecificationService.getDeploymentSpecList(cloudId).then(function (deployData) {
                    $scope.isdeploymentDataPresent = true;
                    obj.deploy_spec_data = deployData;
                    $sessionStorage.InfraList[index] = obj;
               }, function (error) {
                    console.log(error);
                    obj.deploy_spec_data = [];

                });
        };
                

                

        $scope.discoverInfraStructure = function (infraObj) {
            var toastparam = {};
            infrastructureConnectorService.discoverInfrastructure(infraObj.cloud_data.id).then(function (data) {
                if (data.status) {
                    toastparam = {
                        'heading': 'Infrastructure connector discovered successfully',
                        'subHeading': '',
                        'type': 'success',
                        'timeout': 5000
                    };
                    showToast(toastparam);

                } else {
                    //TODO to show message/something else;
                    toastparam = {
                        'heading': 'Infrastructure connector discovery failed',
                        'subHeading': "Error:" + data.errorMessage,
                        'type': 'fail',
                        'timeout': 5000
                    };
                    showToast(toastparam);
                }
            }, function (error) {
                console.log(error);
                toastparam = {
                    'heading': 'Infrastructure connector discovery failed',
                    'subHeading': "Something went wrong",
                    'type': 'fail',
                    'timeout': 5000
                };
                showToast(toastparam);
            });
        };

        $scope.deleteInfraStructure = function (infraObj) {
            toastparam = {
                'heading': 'Infrastructure connector deletion in progress',
                'subHeading': 'Infrastructure connector deletion initiated.',
                'type': 'progress',
                'timeout': 15000
            };
            showToast(toastparam);
            console.log(infraObj);
            var toastparam = {};
            infrastructureConnectorService.deleteInfrastructure(infraObj.cloud_data.id).then(function (data) {
                if (data.status) {
                    //update rows
                    for (i = 0; i < InfraListData.length; i++) {
                        if (InfraListData[i].cloud_data.id === infraObj.cloud_data.id) {
                            InfraListData.splice(i, 1);
                        }
                    }
                    $sessionStorage.InfraList = InfraListData;
                    toastparam = {
                        'heading': 'Infrastructure connector deleted successfully',
                        'subHeading': '',
                        'type': 'success',
                        'timeout': 5000
                    };
                    showToast(toastparam);

                } else {
                    //TODO to show message/something else;
                    toastparam = {
                        'heading': 'Infrastructure connector deletion failed',
                        'subHeading': "Error: " + data.errorMessage,
                        'type': 'fail',
                        'timeout': 5000
                    };
                    showToast(toastparam);
                }
            }, function (error) {
                console.log(error);
                toastparam = {
                    'heading': 'Infrastructure connector deletion failed',
                    'subHeading': "Error: " + error.data.errorMessage,
                    'type': 'fail'
                };
                showToast(toastparam);
            });
        };

        $scope.callpopupToAddInfra = function (ev) {
            $mdDialog.show({
                controller: addInfraPopupCtr,
                templateUrl: 'core/components/administration/infrastructure-connectors/addInfra.tmpl.html',
                parent: angular.element(document.body),
                targetEvent: ev,
                fullscreen: true,
                openFrom: {top: 1100, height: 0},
                closeTo: {left: 1500}
            }).then(function () {

            });
        };

        $scope.clearInfraListFromSession = function () {
            clearMasterSession($sessionStorage, $state);
            /*$sessionStorage.InfraList = false;
             $state.reload();*/
        };


        $scope.editMiscInfraData = function () {
            if(typeof $scope.adornmentData.cloud_data.password !== "undefined") {
                $scope.adornmentData.cloud_data.password = null;
            }
            $scope.tempInfraData = angular.copy($scope.adornmentData.cloud_data);
            $scope.infraFormValid = false;
            $scope.editMiscState = true;
        };

        $scope.discardMiscChanges = function(){
            if (typeof $scope.adornmentData.cloud_data.password !== "undefined") {
                $scope.adornmentData.cloud_data.password = null;
            }
            $scope.editMiscState = false;
        };
        
        var updateInfraStarted = {
            'heading': 'Infrastructure connector update started',
            'subHeading': '&nbsp;',
            'type': 'progress',
            'timeout': 5000
        };

        var infraUpdated = {
            'heading': 'Infrastructure connector updated successfully',
            'subHeading': '&nbsp;',
            'type': 'success',
            'timeout': 5000,
            'callback': function () {
                $state.reload();
            }
        };

        var infraUpdateFailed = {
            'heading': 'Infrastructure connector Update failed',
            'subHeading': '&nbsp;',
            'type': 'fail',
            'timeout': 5000,
            'callback': function () {
                $state.reload();
            }
        };
        
        $scope.updateInfraData = function () {
            if ($scope.editMiscState && $scope.tempInfraData.password) {
                $scope.editMiscState = false;
                var infrastructureObject = {
                    "id": $scope.tempInfraData.id,
                    "ip": $scope.tempInfraData.ip,
                    "name": $scope.tempInfraData.name,
                    "password": $scope.tempInfraData.password,
                    "type": $scope.tempInfraData.type,
                    "username": $scope.tempInfraData.username,
                    "https": $scope.tempInfraData.https,
                    "domain": $scope.tempInfraData.domain
                };
                console.log(infrastructureObject);
                showToast(updateInfraStarted);
                infrastructureConnectorService.updateInfrastructure(infrastructureObject).then(function (response) {
                    showToast(infraUpdated);
                }, function (error) {
                    infraUpdateFailed.subHeading = error.data.message;
                    showToast(infraUpdateFailed);
                });
            }
        };
        
        $scope.pwdType = 'password';
        
        $scope.togglePasswordType = function () {
            $scope.pwdType = $scope.pwdType === 'password' ? 'text' : 'password';
        };

        $scope.infraFormValid = false;
        
        $scope.validateInfraForm =  function () {
            var cloudData = $scope.tempInfraData;
            if (cloudData.type === 'OPENSTACK') {
                if (
                        cloudData.domain &&
                        cloudData.type &&
                        cloudData.name &&
                        cloudData.ip &&
                        cloudData.username &&
                        cloudData.username.length <= 50 && 
                        cloudData.password) {
                    $scope.infraFormValid = true;
                } else {
                    $scope.infraFormValid = false;
                }
            } else if (cloudData.type === 'VMWARE') {
                if (
                        cloudData.type &&
                        cloudData.name &&
                        cloudData.ip &&
                        cloudData.username &&
                        cloudData.username.length <= 50 &&
                        cloudData.password
                        ) {
                    $scope.infraFormValid = true;
                } else {
                    $scope.infraFormValid = false;
                }
            } else if (cloudData.type === 'AWS') {
                if (
                    cloudData.type &&
                    cloudData.name &&
                    cloudData.accessKeyId &&
                    cloudData.secretAccessKey
                ) {
                    $scope.infraFormValid = true;
                } else {
                    $scope.infraFormValid = false;
                }
            }
        };

        function addInfraPopupCtr($rootScope, $scope, $sessionStorage){
            
            //FUNCTIONALITY TO ADD INFRA
            $scope.active_help_id = "infra_type_help_wizard";
      $scope.helpButtonClicked = function(id){
            $scope.active_help_id = id;
            console.log("  helpButtonClicked ");
            $scope.bordcastEventHelpButtonClicked($scope.active_help_id);
          }; 
         $scope.bordcastEventHelpButtonClicked = function(helpId){
            $scope.$broadcast('onHelpButtonClicked', {
               helpIDString: helpId 
            });
         };     

            $scope.pwdType = 'password';
            $scope.togglePasswordType = function () {
                $scope.pwdType = $scope.pwdType === 'password' ? 'text' : 'password';
            };

            $scope.infrastructure_heading = $translate.instant('wizardinfrastucture.heading.provide_infrastructure_access');
            $scope.infrastructure_subheading = $translate.instant('wizardinfrastucture.subheading.message');

            $scope.infrastucture_type = $translate.instant('wizardinfrastucture.label.infrastructure_type');

            $scope.infrastucture_name = $translate.instant("wizardinfrastucture.placeholder.name");
            $scope.infrastucture_ipaddress_fqdn = $translate.instant("wizardinfrastucture.placeholder.ip_address_fqdn");
            $scope.infrastucture_login = $translate.instant("wizardinfrastucture.placeholder.infrastructure_login");
            $scope.infrastucture_password = $translate.instant("wizardinfrastucture.placeholder.infrastructure_password");
            $scope.create_infrastructure = $translate.instant("wizardinfrastucture.button.create_infrastructure");

            $scope.activLink = 'Infrastructure Access';

            $scope.infra = {
                'types': [
                    {'name': 'VMWARE ESXi', 'value': 'VMWARE'},
                    {'name': 'Amazon AWS', 'value': 'AWS'},
                    {'name': 'OpenStack', 'value': 'OPENSTACK'},
                    {'name': 'MS Azure', 'value': 'MS Azure'}
                ]
            };
            $scope.infrastructure = {};

            $scope.infrastructure.type = 'VMWARE';

            $scope.hide = function () {
                $mdDialog.hide();
            };
            $scope.cancel = function () {
                $mdDialog.cancel();
            };

            
            $scope.hideRightPanel = false;

            $scope.toggleHelpPanel = function () {
                $scope.hideRightPanel = !($scope.hideRightPanel);
            };


            $scope.addInfra = function () {
                console.log($scope.infrastructure);
                var infrastructureObject = $scope.infrastructure;
                var startInfraCreationMessage = {
                    'heading': 'Create Infrastructure Connector',
                    'subHeading': 'This should take only a few minutes max.',
                    'type': 'progress',
                    'timeout': 5000
                };
                var successfulInfraCreationMessage = {
                    'heading': 'Infrastructure Connector Created',
                    'subHeading': 'Infrastructure connector created successfully.',
                    'type': 'success',
                    'timeout': 5000
                };
                var startInfraDiscoveryMessage = {
                    'heading': 'Discovery Started',
                    'subHeading': 'Discovery Started',
                    'type': 'progress',
                    'timeout': 10000
                };

                var completedInfraDiscoveryMessage = {
                    'heading': 'Discovery Completed',
                    'subHeading': 'Discovery Completed',
                    'type': 'success',
                    'timeout': 5000
                };

                var failedInfraDiscoveryMessage = {
                    'heading': 'Discovery Failed',
                    'type': 'fail',
                    'timeout': 5000
                };
                showToast(startInfraCreationMessage);
                infrastructureConnectorService.createInfrastructure(infrastructureObject).then(function (data) {
                    if (data) {
                        var newData = {};
                        newData.cloud_data = infrastructureObject;

                        console.log(InfraListData);
                        showToast(successfulInfraCreationMessage);

                        $sessionStorage.cloudData = {}; //Need new cloudData object and then need new data of this cloud

                        $sessionStorage.cloudData.cloudId = data;
                        infrastructureObject.id = data;
                        $sessionStorage.cloudData.infrastructure = infrastructureObject;
                        $sessionStorage.infrastructure = $sessionStorage.cloudData.infrastructure;
                        $sessionStorage.cloudData.infrastructure.id = data;

                        showToast(startInfraDiscoveryMessage);

                        discoverInfrastructure(infrastructureObject).then(function (data) {
                            showToast(completedInfraDiscoveryMessage);
                            ipPoolServices.getIpPoolListByCloudId(infrastructureObject.id).then(function (ipPoolData) {
                                newData.pool_data = ipPoolData;
                            }, function (error) {
                                console.log(error);
                                newData.pool_data = [];
                            });
                            return data;
                        }, function (error) {
                            failedInfraDiscoveryMessage.subHeading = "Error: " + error.data.message;
                            showToast(failedInfraDiscoveryMessage);
                            console.log(error);
                            //showError
                        });
                        InfraListData.unshift(newData);
                        console.log(InfraListData);
                        $sessionStorage.InfraList = InfraListData;
                        $rootScope.$broadcast('newInfracreated', {});
                    }
                }, function (error) {
                    var failureInfraCreation = {
                        'heading': 'Infrastructure creation failed',
                        'subHeading': "Error: " + error.data.message,
                        'type': 'fail',
                        'timeout': 10000
                    };
                    showToast(failureInfraCreation);
                    $sessionStorage.cloudData = {};
                });
                $mdDialog.hide();
            };

            function discoverInfrastructure(infrastructureObject) {
                var infrastructureId = infrastructureObject.id;
                return infrastructureConnectorService.discoverInfrastructure(infrastructureId).then(function (data) {
                    return data;
                }, function (error) {
                    console.log(error);
                    //showError
                });
            }

            $scope.isFormValid = function () {
                if ($scope.infrastructure.type === 'VMWARE') {
                    //validate form data
                    console.log($scope.infrastructure);
                    if ($scope.infrastructure.type && $scope.infrastructure.name && $scope.infrastructure.ip && $scope.infrastructure.username && $scope.infrastructure.username.length <= 50 && $scope.infrastructure.password) {
                        return true;
                    } else {
                        return false;
                    }
                } else if ($scope.infrastructure.type === 'OPENSTACK'){
                    //OPEN STACK
                    if ($scope.infrastructure.domain && $scope.infrastructure.type && $scope.infrastructure.name && $scope.infrastructure.ip && $scope.infrastructure.username && $scope.infrastructure.username.length <= 50 && $scope.infrastructure.password) {
                        return true;
                    } else {
                        return false;
                    }
                } else if ($scope.infrastructure.type === 'AWS'){
                    //AWS
                    if ($scope.infrastructure.type && $scope.infrastructure.name && $scope.infrastructure.accessKeyId && $scope.infrastructure.secretAccessKey) {
                        return true;
                    } else {
                        return false;
                    }
                }
            };
        }
        $scope.$on('newInfracreated', function (event) {
            console.log($scope.query);
            $scope.query.page = 1;
        });
        $scope.$on('$viewContentLoaded', function (event) {
            console.log(event);
            fixContainerHeight(1);
        });
    }

    angular.module('shieldxApp').controller('infrastructureConnectorsCtr', infrastructureConnectorsCtr);
})();

/*
 ShieldX Networks Inc. CONFIDENTIAL
 ----------------------------------
 *
 Copyright (c) 2016 ShieldX Networks Inc.
 All Rights Reserved.
 *
 NOTICE: All information contained herein is, and remains
 the property of ShieldX Networks Incorporated and its suppliers,
 if any. The intellectual and technical concepts contained
 herein are proprietary to ShieldX Networks Incorporated
 and its suppliers and may be covered by U.S. and Foreign Patents,
 patents in process, and are protected by trade secret or copyright law.
 Dissemination of this information or reproduction of this material
 is strictly forbidden unless prior written permission is obtained
 from ShieldX Networks Incorporated.
 */

(function () {
    function integrationsCtr(
            $scope,
            $state,
            $translate,
            managementService,
            userSessionMenagment) {


        $scope.selected = null;
        $scope.fireEyeDetails = null;
        $scope.newfireEyeDetails = null;
        $scope.editFireEyeData = false;
        $scope.isAdornmentPanelOpen = false;
        $scope.fireEyeDetailsHttps = true;

        $scope.pwdType = 'password';

        var fireEyeIntegrationConfigStarted = {
            'heading': 'FireEye Integration configuration update initiating',
            'subHeading': '&nbsp;',
            'type': 'progress',
            'timeout': $scope.toastTimeout
        };

        var fireEyeIntegrationConfigured = {
            'heading': 'FireEye Integration configuration updated',
            'subHeading': '&nbsp;',
            'type': 'success',
            'timeout': $scope.toastTimeout,
            'callback': function () {
                $state.reload();
            }
        };

        var fireEyeIntegrationConfigFailed = {
            'heading': 'FireEye Integration configuration update failed',
            'subHeading': '&nbsp;',
            'type': 'failure',
            'timeout': $scope.toastTimeout,
            'callback': function () {
                $state.reload();
            }

        };
        $scope.active_help_id = "admin_system_integrations_help";
        $scope.helpButtonClicked = function(id){
            $scope.active_help_id = id;
            console.log("  helpButtonClicked ");
            $scope.bordcastEventHelpButtonClicked($scope.active_help_id);
        }; 
        $scope.bordcastEventHelpButtonClicked = function(helpId){
            $scope.$broadcast('onHelpButtonClicked', {
               helpIDString: helpId 
            });
        };
        $scope.$emit('listenHeaderText', {headerText: $translate.instant('admin.toolbar.heading')});
       
        var red_id = authorities("integrations_read");
        var update_id = authorities("integrations_update");
        $scope.is_integrations_read = userSessionMenagment.isUserAllowd(red_id);
        $scope.is_integrations_update = userSessionMenagment.isUserAllowd(update_id);

        $scope.togglePasswordType = function () {
            $scope.pwdType = $scope.pwdType === 'password' ? 'text' : 'password';
        };

        $scope.updateAdornmentPanel = function () {
            console.log("updateAdornmentPanel called");
            $scope.toggleAdornmentPanel();
        };

        $scope.toggleAdornmentPanel = function () {
            $scope.isAdornmentPanelOpen = $scope.isAdornmentPanelOpen === false ? true : false;
        };

        $scope.fireEyeIntegration = function () {
            managementService.getFireEyeIntegrationDetails().then(function (fireEyeDetails) {
                $scope.fireEyeDetails = fireEyeDetails;
                $scope.newfireEyeDetails = angular.copy($scope.fireEyeDetails);
            }, function (error) {
                console.log(error);
            });
        };


        $scope.fireEyeIntegration();

        $scope.updateFireEye = function (fireEyeDetailsObj, updateAdornmentPanel) {

            showToast(fireEyeIntegrationConfigStarted);

            var formattedfireEyeDetails = {
                'id': fireEyeDetailsObj.id,
                'enabled': fireEyeDetailsObj.enabled,
                'ip': fireEyeDetailsObj.ip,
                'username': fireEyeDetailsObj.username,
                'password': fireEyeDetailsObj.password,
                'https': $scope.fireEyeDetailsHttps
            };


            managementService.updateFireEyeIntegrationDetails(formattedfireEyeDetails).then(function () {
                $scope.fireEyeDetails = formattedfireEyeDetails;
                if ($scope.editFireEyeData === true) {
                    $scope.newfireEyeDetails.enabled = $scope.fireEyeDetails.enabled;
                }
                if (updateAdornmentPanel) {
                    $scope.editFireEyeData = false;
                }
                showToast(fireEyeIntegrationConfigured);
//                $state.reload();
            }, function (error) {
                fireEyeIntegrationConfigFailed.subHeading = "Error: " + error.data.message;
                showToast(fireEyeIntegrationConfigFailed);
                console.log(error);
            });
        };

        $scope.discardMiscChanges = function () {
            $scope.newfireEyeDetails = angular.copy($scope.fireEyeDetails);
            $scope.editFireEyeData = false;
            $scope.pwdType = 'text';
        };


        $scope.enableEditFireData = function () {
            $scope.editFireEyeData = true;
        };

        $scope.$on('$viewContentLoaded', function (event) {
            console.log(event);
            fixContainerHeight(1);
        });
    }

    angular.module('shieldxApp').controller('integrationsCtr', integrationsCtr);
})();
/*
 ShieldX Networks Inc. CONFIDENTIAL
 ----------------------------------
 *
 Copyright (c) 2016 ShieldX Networks Inc.
 All Rights Reserved.
 *
 NOTICE: All information contained herein is, and remains
 the property of ShieldX Networks Incorporated and its suppliers,
 if any. The intellectual and technical concepts contained
 herein are proprietary to ShieldX Networks Incorporated
 and its suppliers and may be covered by U.S. and Foreign Patents,
 patents in process, and are protected by trade secret or copyright law.
 Dissemination of this information or reproduction of this material
 is strictly forbidden unless prior written permission is obtained
 from ShieldX Networks Incorporated.
 */

(function () {

    function editIPPoolRangeDialogboxCtr($scope, ipPoolServices, $mdDialog, editIPoolData, ipdata) {

        $scope.editIPoolData = editIPoolData;
        $scope.ipdata = ipdata;
        console.log(" editIPPoolRangeDialogboxCtr " + editIPoolData);
        console.dir($scope.editIPoolData);
        $scope.cancel = function () {
            $mdDialog.cancel();
        };

        $scope.updateIPPoolRange = function () {

            console.log("updateIPPoolRange clicked  ipdata ");
            console.dir(ipdata);
            $mdDialog.hide(true);
        };

        $scope.datValueChanged = function (data) {

        };
    }

    angular.module('shieldxApp').controller('editIPPoolRangeDialogboxCtr', editIPPoolRangeDialogboxCtr);

    function editIPRangeCtr($scope) {

        var newIPData = $scope.editIPoolData;
        // console.log(" editIPRangeCtr newIPData "+newIPData);  
        $scope.ipRangeRows = newIPData.getIPRangeRows();

        // console.log(" editIPRangeCtr ");
        //console.dir($scope.ipRangeRows);    

        $scope.addNewIPRangeRow = function (event) {
            //console.log(" addNewIPRangeRow clicked");
            newIPData.addNewIPRangeRow();

        };

        $scope.createRangeStartMessage = function (projectForm, index) {
            return   projectForm["rangeStart" + index].$error;
        };

        $scope.createRangeEndtMessage = function (projectForm, index) {
            return   projectForm["rangeEnd" + index].$error;
        };

        $scope.createCIDRMessage = function (projectForm, index) {
            return   projectForm["cidr" + index].$error;
        };

        $scope.startIpRangeKeyDown = function ($event, ipRangeRowData) {
            //console.log(" startIpRangeKeyDown ");
            //console.dir(ipRangeRowData);

            if (ipRangeRowData.rangeStartValue || ipRangeRowData.rangeEndtValue) {
                ipRangeRowData.cidrValue = "";
                ipRangeRowData.rangeCIDREnableState = false;
            } else
            {
                ipRangeRowData.rangeCIDREnableState = true;
            }


            $scope.datValueChanged($scope.editIPoolData.ranges);
        };

        $scope.endIPRangeKeyDown = function ($event, ipRangeRowData) {
            //console.log(" endIPRangeKeyDown "); 
            // console.dir(ipRangeRowData);

            if (ipRangeRowData.rangeStartValue || ipRangeRowData.rangeEndtValue) {
                ipRangeRowData.cidrValue = "";
                ipRangeRowData.rangeCIDREnableState = false;
            } else
            {
                ipRangeRowData.rangeCIDREnableState = true;
            }


            $scope.datValueChanged($scope.editIPoolData.ranges);
        };

        $scope.cidrIPRangeKeyDown = function ($event, ipRangeRowData) {
            //console.log(" cidrIPRangeKeyDown ");
            //console.dir(ipRangeRowData);

            if (ipRangeRowData.cidrValue) {
                ipRangeRowData.rangeStartValue = "";
                ipRangeRowData.rangeEndtValue = "";
                ipRangeRowData.rangeStartEnableState = false;
                ipRangeRowData.rangeEndEnableState = false;
            } else {
                ipRangeRowData.rangeStartEnableState = true;
                ipRangeRowData.rangeEndEnableState = true;
            }

            $scope.datValueChanged($scope.editIPoolData.ranges);
        };

        $scope.deleteIPPool = function (event, ipRangeRowData, key) {
            newIPData.deleteIPRangeRow(key);
        };
    }
    angular.module('shieldxApp').controller('editIPRangeCtr', editIPRangeCtr);

})();
/*
 ShieldX Networks Inc. CONFIDENTIAL
 ----------------------------------
 *
 Copyright (c) 2016 ShieldX Networks Inc.
 All Rights Reserved.
 *
 NOTICE: All information contained herein is, and remains
 the property of ShieldX Networks Incorporated and its suppliers,
 if any. The intellectual and technical concepts contained
 herein are proprietary to ShieldX Networks Incorporated
 and its suppliers and may be covered by U.S. and Foreign Patents,
 patents in process, and are protected by trade secret or copyright law.
 Dissemination of this information or reproduction of this material
 is strictly forbidden unless prior written permission is obtained
 from ShieldX Networks Incorporated.
 */

(function () {
    function ipPoolsCtr($scope, $state, infrastructureConnectorService, ipPoolServices, deploymentSpecificationService, $translate, $q, $mdDialog, $stateParams, $sessionStorage,userSessionMenagment) {

        "ngInject";
        clearAllSession($sessionStorage);
        $scope.$emit('listenHeaderText', {
            headerText: $translate.instant('admin.toolbar.heading')
        });
        $scope.$emit('quickSetupEnded', {});
        //console.info(" ipPoolsCtr admin initialized ");

        /* **** for tables [start] **** */
        $scope.deferred = $q.defer();
        $scope.promise = $scope.deferred.promise;
        $scope.deploySpecFetched = false;
        $scope.selected = [];
        $scope.query = {
            order: 'name',
            limit: 10,
            page: 1
        };
        $scope.isAdornmentPanelOpen = false;
        $scope.isSearchBarOpen = false;

        $scope.toggleSearchBar = function (event) {
            $scope.isSearchBarOpen = $scope.isSearchBarOpen === false ? true : false;
            if ($scope.isSearchBarOpen)
                angular.element(event.currentTarget.firstElementChild).css('color', '#4a90e2');
            else
                angular.element(event.currentTarget.firstElementChild).css('color', '#6d6e71');
        };

        var poolId = ($stateParams && $stateParams.poolId) ? parseInt($stateParams.poolId) : null;
        //$scope.ipPoolsRows = [];


        $scope.freshData = (!$sessionStorage.ipPoolList || ($sessionStorage.ipPoolList && $sessionStorage.ipPoolList.length === 0));


        /* **** for tables [end] **** */

        var cloudData = null;
        var cloudFetched = -1;
        var ipoolData = [];
        var activeCloudData = null;
        var selectedIPRowData = null;
        var rowPoolData = [];
        $scope.promiseCompleted = true;

        var create_id = authorities("ipPools_create");
        var delete_id = authorities("ipPools_delete");
        var update_id = authorities("ipPools_update");
        $scope.is_create_ippool = userSessionMenagment.isUserAllowd(create_id);
        $scope.is_update_ippool = userSessionMenagment.isUserAllowd(update_id);
        $scope.is_delete_ippool = userSessionMenagment.isUserAllowd(delete_id);


        var onDeploymentSpecInfoFetched = function (data) {
            //console.debug("onDeploymentSpecInfoFetched  " + data);
            //console.dir(data);
            //console.dir($scope.adornmentData);
            selectedIPRowData.dpoySpec = data;
            var IpPoolToDeploySpec = mapIPToDeploySpec(selectedIPRowData.ipPool, selectedIPRowData.dpoySpec);
            //console.debug("ipoool id   " + $scope.adornmentData.ipdata.ipPoolData.id);
            $scope.adornmentData.deploySpecData = IpPoolToDeploySpec[$scope.adornmentData.ipdata.ipPoolData.id.toString()];
            $scope.deploySpecFetched = true;
            console.debug(" $scope.deploySpecFetched   " + $scope.deploySpecFetched);

        };

        var fetchDeploymentSpecInfo = function (rowData) {
            // console.debug(" fetchDeploymentSpecInfo ");
            // console.dir(rowData);
            deploymentSpecificationService.getDeploymentSpecList(rowData.ipPoolData.cloudid).then(onDeploymentSpecInfoFetched);
        };


        $scope.updateAdornmentPanel = function (event, rowData) {
            $scope.deploySpecFetched = false;
            $scope.adornmentData = {};
            $scope.adornmentData.readOnlyranges = [];
            $scope.adornmentData.ipdata = rowData;
            $scope.adornmentData.ipoolData = new NewIPDate();
            $scope.adornmentData.ipoolData.initializeFromIPData(rowData.ipPoolData);
            $scope.adornmentData.editIPoolData = $scope.adornmentData.ipoolData.clone();
            var rangeArrary = [];
            //console.log("rowData.ipPoolData.ranges $$$$$  ");
            selectedIPRowData = {};
            selectedIPRowData.ipPool = rowData.ipPoolData;
            //console.log(" $scope.adornmentData.ipdata ");
            //console.dir($scope.adornmentData.ipdata);
            //console.log("selectedIPRowData.ipoolData >>>>>>>>>>>>>>> ");
            //console.dir($scope.adornmentData.ipoolData);   
            //console.log("$scope.adornmentData.editIPoolData");
            //console.dir($scope.adornmentData.editIPoolData);         
            $scope.updateIPRangeReadOnlyArray();

            //console.dir(rangeArrary);    
            $scope.toggleAdornmentPanel();
            //console.log(" rowData "+rowData);
            //console.dir(rowData);  
            fetchDeploymentSpecInfo(rowData);
        };

        $scope.updateIPRangeReadOnlyArray = function () {
            var ranges = $scope.adornmentData.editIPoolData.ranges;
            var rangeArrary = [];
            for (var i = 0; i < ranges.length; i++) {
                var rangeRef = ranges[i];
                if (!rangeRef.rangeCIDREnableState) {
                    rangeArrary.push({type: "range", start: rangeRef.rangeStartValue, end: rangeRef.rangeEndtValue});
                } else {
                    rangeArrary.push({type: "cidr", value: rangeRef.cidrValue});
                }

            }
            $scope.adornmentData.readOnlyranges = rangeArrary;
        };
        $scope.updateIPPoolRow = function (updatedData) {
            /*  update row data */
            $scope.adornmentData.ipdata.name = $scope.adornmentData.editIPoolData.name;

            var rangeRef = $scope.adornmentData.editIPoolData.convertIPRangeToString();
            console.log(" updateIPPoolRow  >>>>>>>>>> " + rangeRef);
            var rangeValues = rangeRef.split(",");
            //console.dir(rangeRef);
            //console.dir(rangeValues);
            var ranges = "";
            var showMore = false;
            if (rangeValues.length > 1) {
                ranges = rangeValues[0];
                moreRange = " +" + (rangeValues.length - 1) + "more";
                showMore = true;
            } else {
                ranges = rangeValues[0];
                moreRange = "";
            }
            //console.log(" updateIPPoolRow  before update ");        
            //console.dir($scope.adornmentData);
            //
            //
            console.log(" moreRange  " + moreRange);
            $scope.adornmentData.ipdata.ranges = ranges;
            $scope.adornmentData.ipdata.moreRange = moreRange;
            $scope.adornmentData.ipdata.gateway = $scope.adornmentData.editIPoolData.gateway;
            $scope.adornmentData.ipdata.mask = $scope.adornmentData.editIPoolData.mask;
            /* update row data */
            $scope.adornmentData.ipdata.ipPoolData.gateway = $scope.adornmentData.editIPoolData.gateway;
            $scope.adornmentData.ipdata.ipPoolData.name = $scope.adornmentData.editIPoolData.name;
            $scope.adornmentData.ipdata.ipPoolData.prefix = $scope.adornmentData.editIPoolData.mask;
            $scope.adornmentData.ipdata.ipPoolData.ranges = rangeRef;

            $scope.adornmentData.ipoolData = new NewIPDate();
            $scope.adornmentData.ipoolData.initializeFromIPData($scope.adornmentData.ipdata.ipPoolData);
            $scope.adornmentData.editIPoolData = $scope.adornmentData.ipoolData.clone();

            //console.log(" updateIPPoolRow  after update ");        
            //console.dir($scope.adornmentData);

            $scope.updateIPRangeReadOnlyArray();
        };

        $scope.toggleAdornmentPanel = function () {
            $scope.isAdornmentPanelOpen = $scope.isAdornmentPanelOpen === false ? true : false;
        };


        $scope.showStatus = function (status, test) {
            return status === test;
        };

        $scope.deleteIPPool = function (event, rowData) {
            toastparam = {
                'heading': 'IP Pool deletion in progress',
                'subHeading': 'IP Pool deletion initiated.',
                'type': 'progress',
                'timeout': 15000
            };
            showToast(toastparam);
            //console.info(" deleteIPPool called" + rowData.ipPoolData.id);
            ipPoolServices.deleteIPPool(rowData.ipPoolData.id, rowData.ipPoolData.cloudid).then(function (data) {
                //console.debug(" ip pool deleted " + data);
                $scope.removeRowFromTable(rowData);
                toastparam = {
                    'heading': 'IP Pool deleted successfully.',
                    'subHeading': '',
                    'type': 'success',
                    'timeout': 5000
                };
                showToast(toastparam);
            }, function (error) {
                //console.debug(error);

                toastparam = {
                    'heading': 'IP Pool deletion failed',
                    'subHeading': "Error: " + error.data.message,
                    'type': 'fail',
                    'timeout': 5000
                };
                showToast(toastparam);
            });
        };


        $scope.removeRowFromTable = function (rowData) {
            //console.log(" removeRowFromTable activeCloudData " + rowData);
            //console.dir(rowData);
            var index = -1;
            index = _.findIndex($scope.ipPoolsRows, function (o) {
                // console.info(" findIndex o.ipPoolData.id ");
                //console.dir(o);
                //console.info(" findIndex rowData.ipPoolData.id ");
                //console.dir(rowData);
                return o.ipPoolData.id == rowData.ipPoolData.id;
            });
            if (index != -1) {
                $scope.ipPoolsRows.splice(index, 1);
            }
            //console.debug(" removeRowFromTable >> result " + index);
        };

        $scope.createNewIPPool = function (infraRefID, infraName, discription, gateway, name, mask, ranges) {
            toastparam = {
                'heading': 'IP Pool creation in progress',
                'subHeading': 'IP Pool creation initiated.',
                'type': 'progress',
                'timeout': 15000
            };
            showToast(toastparam);
            var rangeRef = ranges;

            ipPoolServices.createNewIPPool(infraRefID, discription, gateway, name, mask, ranges).then(function (data) {
                var id = data;


                var rangeValues = rangeRef.split(",");
                var ranges = "";
                var showMore = false;
                if (rangeValues.length > 1) {
                    ranges = rangeValues[0];
                    moreRange = " +" + (rangeValues.length - 1) + "more";
                    showMore = true;
                } else {
                    ranges = rangeValues[0];
                    moreRange = "";
                }

                console.log(" moreRange " + moreRange);
                var tempIPPoolData = {
                    cloudid: infraRefID, descr: discription, gateway: gateway, id: id, name: name, prefix: mask, ranges: rangeRef
                };
                $scope.ipPoolsRows.unshift({
                    infraName: infraName, name: name, descrition: discription, ranges: ranges, moreRange: moreRange, showMore: showMore, gateway: gateway, mask: mask, deploySpecData: {}, ipPoolData: tempIPPoolData
                });


                toastparam = {
                    'heading': 'IP Pool created successfully',
                    'subHeading': '',
                    'type': 'success',
                    'timeout': 5000
                };
                showToast(toastparam);
            }, function (error) {

                toastparam = {
                    'heading': 'IP Pool creation failed',
                    'subHeading': "Error: " + error.data.message,
                    'type': 'fail',
                    'timeout': 5000
                };
                showToast(toastparam);
            });
        };
        $scope.showNewIPPoolDialogbox = function (ev) {
            //console.info(" showNewIPPoolDialogbox ");
            $mdDialog.show({
                controller: 'newIPPoolsDialogboxCtr', templateUrl: 'core/components/administration/ip-pools/new-ip-pools-dialogbox.html', parent: angular.element(document.body), targetEvent: ev, clickOutsideToClose: true
            }).then(function (answer) {
                //console.debug(" answer " + answer);
                //console.dir(answer);infraRefID,infraName,discription,gateway, name, mask,ranges
                $scope.createNewIPPool(answer.infrastructureInfo.id, answer.infrastructureInfo.name, answer.newIPDate.discription, answer.newIPDate.gateway, answer.newIPDate.name, answer.newIPDate.mask, answer.newIPDate.convertIPRangeToString());

            }, function () {});
        };



        /**
         This method map depoyment specification to the IP pool that it uses
         **/
        var mapIPToDeploySpec = function (ipPoolData, deploySpecData) {
            //console.log(" mapIPToDeploySpec  ");
            //console.dir(deploySpecData);
            var ipPoolToSpecMap = {};
            var tempdeploySpecData = null;
            for (var j = 0; j < deploySpecData.length; j++) {
                tempdeploySpecData = deploySpecData[j];
                //console.info(" tempdeploySpecData  ");
                //console.dir(tempdeploySpecData);
                if (!tempdeploySpecData.backPlaneIsDhcp) {
                    var tempBackDS = ipPoolToSpecMap[tempdeploySpecData.backPlaneIpPoolId.toString()];
                    //console.debug(" backpanel id found    " + tempBackDS + " tempdeploySpecData.backPlaneIpPoolId " + tempdeploySpecData.backPlaneIpPoolId.toString());
                    if (tempBackDS === undefined || tempBackDS === null) {
                        ipPoolToSpecMap[tempdeploySpecData.backPlaneIpPoolId.toString()] = [];
                        tempBackDS = ipPoolToSpecMap[tempdeploySpecData.backPlaneIpPoolId.toString()];
                    }
                    //console.debug(" backpanel id data pused     " + j);
                    tempBackDS.push(tempdeploySpecData);
                }
                if (!tempdeploySpecData.mgmtIsDhcp) {
                    // console.log( " tempdeploySpecData.mgmtIpPoolId "+tempdeploySpecData.mgmtIpPoolId);
                    var tempMgmtDS = ipPoolToSpecMap[tempdeploySpecData.mgmtIpPoolId.toString()];
                    //console.log(" manmagment id found    "+tempMgmtDS+" mgmtNetworkId "+tempdeploySpecData.mgmtNetworkId);
                    if (tempMgmtDS === undefined || tempMgmtDS === null) {
                        ipPoolToSpecMap[tempdeploySpecData.mgmtIpPoolId.toString()] = [];
                        tempMgmtDS = ipPoolToSpecMap[tempdeploySpecData.mgmtIpPoolId.toString()];
                    }
                    //console.debug(" manmagment id data pused     " + j);
                    tempMgmtDS.push(tempdeploySpecData);
                }
            }
            return ipPoolToSpecMap;
        };

        /**
         This method is called when all infrastructure data available for further processing
         **/
        var completCloudResourceFetched = function () {
            //console.info(" completCloudeResourceFetched  ");
            if (activeCloudData.ipPool !== null) {
                //console.info(" cloude fetched  ");
                //console.dir(activeCloudData);
                for (var i = 0; i < activeCloudData.ipPool.length; i++) {
                    //console.debug("**** name:activeCloudData.ipPool[i].id ******** " + activeCloudData.ipPool[i].id);
                    var rangeValues = activeCloudData.ipPool[i].ranges.split(",");
                    //console.dir(activeCloudData.ipPool[i].ranges);
                    /// console.dir(rangeValues);
                    var ranges = "";
                    var showMore = false;
                    if (rangeValues.length > 1) {
                        ranges = rangeValues[0];
                        moreRange = " + " + (rangeValues.length - 1) + " more";
                        showMore = true;
                    } else {
                        ranges = rangeValues[0];
                        moreRange = "";
                    }
                    var dataToSave = {
                        infraName: activeCloudData.cloudRef.name, name: activeCloudData.ipPool[i].name, descrition: activeCloudData.ipPool[i].descr, ranges: ranges, moreRange: moreRange, showMore: showMore, gateway: activeCloudData.ipPool[i].gateway, mask: activeCloudData.ipPool[i].prefix, ipPoolData: activeCloudData.ipPool[i], ipPoolId: activeCloudData.ipPool[i].id
                    };
                    rowPoolData.push(dataToSave);
                }
                fetchNextCloudData();
            }
        };

        /**
         this is a call back method , It is called when all ip Pool data
         has been fetched for a infrastructure
         **/

        var onIpPoolDataFetched = function (result) {
            activeCloudData.ipPool = result;
            completCloudResourceFetched();
        };


        /**
         fetch next infrastructure data present in the sequence in from cloudData araray
         **/
        var fetchNextCloudData = function () {
            cloudFetched++;
            if (cloudFetched < cloudData.length) {
                activeCloudData = {
                    cloudRef: cloudData[cloudFetched], ipPool: null, dpoySpec: null
                };
                fetchIPPoolInformation(cloudData[cloudFetched]);
            } else {
                $scope.ipPoolsRows = moveRecordToStart(rowPoolData, 'ipPoolId', poolId);
                $sessionStorage.ipPoolList = $scope.ipPoolsRows;
                $scope.deferred.resolve();
                $scope.promiseCompleted = false;
            }
        };

        /**
         fetch all ipp pool information related to one infrastructure 
         
         **/
        var fetchIPPoolInformation = function (data) {
            // console.debug(" getCloudResource cloud name   " + data.name);
            ipPoolServices.getIpPoolListByCloudId(data.id).then(onIpPoolDataFetched);
        };

        /**
         call back method for getListOfInfrastructures() service method
         **/
        var onGettingAllInfraData = function (data) {
            // console.info("getAllInfraData ");
            // console.dir(data);
            cloudData = data;
            fetchNextCloudData();
        };

        $scope.clearIpPoolListFromSession = function () {
            clearMasterSession($sessionStorage, $state);
            /*$sessionStorage.ipPoolList = [];
             $state.reload();*/
        };

        if ($scope.freshData) {
            $sessionStorage.ipPoolList = [];
            infrastructureConnectorService.getListOfInfrastructures().then(onGettingAllInfraData);
        } else {
            $scope.ipPoolsRows = moveRecordToStart($sessionStorage.ipPoolList, 'ipPoolId', poolId);
            $scope.deferred.resolve();
            $scope.promiseCompleted = false;

        }

        $scope.$on('$viewContentLoaded', function (event) {
            console.log(event);
            fixContainerHeight(1);
        });
    }
    angular.module('shieldxApp').controller('ipPoolsCtr', ipPoolsCtr);
})();
/*
 ShieldX Networks Inc. CONFIDENTIAL
 ----------------------------------
 *
 Copyright (c) 2016 ShieldX Networks Inc.
 All Rights Reserved.
 *
 NOTICE: All information contained herein is, and remains
 the property of ShieldX Networks Incorporated and its suppliers,
 if any. The intellectual and technical concepts contained
 herein are proprietary to ShieldX Networks Incorporated
 and its suppliers and may be covered by U.S. and Foreign Patents,
 patents in process, and are protected by trade secret or copyright law.
 Dissemination of this information or reproduction of this material
 is strictly forbidden unless prior written permission is obtained
 from ShieldX Networks Incorporated.
 */

(function () {
    function ipPoolsRightHandPanelCtr($scope, ipPoolServices, $mdDialog) {
        "ngInject";
        // console.log(" ipPoolsRightHandPanelCtr initialize ");      
        $scope.editMiscMode = false;
        $scope.editIPRangeMode = false;
        $scope.editIPPoolData = {};
        $scope.editMiscellaneousData = function () {
            $scope.editMiscMode = true;

        };

        $scope.applyMiscellaneousDataChanges = function () {
            $scope.editMiscMode = false;
            //cloudId, discription, gateway, name, prefix, ranges
            $scope.updateIPPool();
        };

        $scope.discardMiscellaneousDataChanges = function () {
            $scope.adornmentData.editIPoolData = $scope.adornmentData.ipoolData.clone();
            $scope.editMiscMode = false;
        };
        $scope.updateRightPanelData = function () {
            // commit changes 

            $scope.updateIPPoolRow();
        };
        $scope.editIPRange = function () {
            $scope.editIPRangeMode = true;
            //console.log("$scope.adornmentData.editIPoolData");
            //console.dir($scope.adornmentData.editIPoolData);  
            $mdDialog.show({
                controller: 'editIPPoolRangeDialogboxCtr', templateUrl: 'core/components/administration/ip-pools/edit-ip-pool-range-dialogbox.html', parent: angular.element(document.body), targetEvent: event, clickOutsideToClose: true, locals: {editIPoolData: $scope.adornmentData.editIPoolData, ipdata: $scope.adornmentData.ipdata}
            }).then(function (answer) {
                $scope.editIPRangeMode = false;
                console.log("updateIPPool success >> ");
                console.dir(answer);
                $scope.updateIPPool();


            }, function () {
                $scope.editIPRangeMode = false;
            });
        };

        $scope.updateIPPool = function () {
            var cloudId = $scope.adornmentData.ipdata.ipPoolData.cloudid;
            var discription = "discription";
            var gateway = $scope.adornmentData.editIPoolData.gateway;
            var name = $scope.adornmentData.editIPoolData.name;
            var prefix = $scope.adornmentData.editIPoolData.mask;
            var ranges = $scope.adornmentData.editIPoolData.convertIPRangeToString();
            var id = $scope.adornmentData.editIPoolData.id;
            //console.log(" ranges "+ranges); 
            //console.dir($scope.adornmentData.editIPoolData);
            toastparam = {
                'heading': 'IP Pool Update in progress',
                'subHeading': 'IP Pool Update initiated.',
                'type': 'progress',
                'timeout': 15000
            };
            showToast(toastparam);
            ipPoolServices.updateIPPool(cloudId, id, discription, gateway, name, prefix, ranges).then(function (data) {
                // console.log("updateIPPool success >> ");
                toastparam = {
                    'heading': 'IP Pool Update completed successfully',
                    'subHeading': '',
                    'type': 'success',
                    'timeout': 5000
                };
                showToast(toastparam);
                $scope.updateRightPanelData();
            },
                    function (error) {
                        //console.log("updateIPPool failed "); 
                        //console.dir(error);
                        toastparam = {
                            'heading': 'IP Pool update failed',
                            'subHeading': "Error: " + error.data.message,
                            'type': 'fail',
                            'timeout': 5000
                        };
                        showToast(toastparam);
                    });

        };
        $scope.applyIPRange = function () {
            $scope.editIPRangeMode = false;
        };

        $scope.discardIPRange = function () {
            $scope.editIPRangeMode = false;
        };

        $scope.addNewIPRange = function () {

        };

    }

    angular.module('shieldxApp').controller('ipPoolsRightHandPanelCtr', ipPoolsRightHandPanelCtr);



})();
/*
ShieldX Networks Inc. CONFIDENTIAL
----------------------------------
*
Copyright (c) 2016 ShieldX Networks Inc.
All Rights Reserved.
*
NOTICE: All information contained herein is, and remains
the property of ShieldX Networks Incorporated and its suppliers,
if any. The intellectual and technical concepts contained
herein are proprietary to ShieldX Networks Incorporated
and its suppliers and may be covered by U.S. and Foreign Patents,
patents in process, and are protected by trade secret or copyright law.
Dissemination of this information or reproduction of this material
is strictly forbidden unless prior written permission is obtained
from ShieldX Networks Incorporated.
*/

(function () {
    function newIPPoolsDialogboxCtr($scope,
            $state,
            infrastructureConnectorService,
            ipPoolServices,
            $translate, $mdDialog) {
        "ngInject";
        console.log("initialize ");
        $scope.availableInfrastructures = [{id: 1, Name: "infra1"}, {id: 2, Name: "infra2"}];
        $scope.enableDoneButton = false;
        $scope.infrastructureSelected = "";
        $scope.newIPDate = new NewIPDate();
        $scope.datValueChanged = function (data) {

            if ($scope.newIPDate.isPopulated() && $scope.infrastructureSelected !== "") {
                $scope.enableDoneButton = true;
            }

        };
        $scope.addNewIPPool = function () {
            var infraRef = JSON.parse($scope.infrastructureSelected);
            var ipPoolData = {
                infrastructureInfo: infraRef,
                newIPDate: $scope.newIPDate,
            };
            $mdDialog.hide(ipPoolData);

        };
        $scope.cancel = function () {
            $mdDialog.cancel();
        };

        var getAllInfraData = function (data) {
            console.info("newIPPoolsDialogboxCtr  getAllInfraData ");
            console.dir(data);
            //Only Non Open Stack Infra type for creation
            data = _.filter(data, function (o) {
                return o.type !== 'OPENSTACK';
            });
            console.dir(data);
            $scope.availableInfrastructures = data;
        };


        $scope.$watch('infrastructureSelected', function () {
            $scope.datValueChanged();
        });

        $scope.$watch('newIPDate.name', function () {

            $scope.datValueChanged();
        });


        $scope.$watch('newIPDate.gateway', function () {

            $scope.datValueChanged();
        });

        $scope.$watch('newIPDate.mask', function () {

            $scope.datValueChanged();
        });


        infrastructureConnectorService.getListOfInfrastructures().then(getAllInfraData);

    }
    angular.module('shieldxApp').controller('newIPPoolsDialogboxCtr', newIPPoolsDialogboxCtr);

    function newIPRangeCtr($scope, ipPoolServices) {

        $scope.ipRangeRows = $scope.newIPDate.getIPRangeRows();

        console.log(" managmentIPRangeCtr ");
        console.dir($scope.ipRangeRows);
        $scope.createRangeStartMessage = function (projectForm, index) {
            return   projectForm["rangeStart" + index].$error;
        };

        $scope.createRangeEndtMessage = function (projectForm, index) {
            return   projectForm["rangeEnd" + index].$error;
        };

        $scope.createCIDRMessage = function (projectForm, index) {
            return   projectForm["cidr" + index].$error;
        };

        $scope.addNewIPRangeRow = function (event) {
            console.log(" addNewIPRangeRow clicked");
            $scope.newIPDate.addNewIPRangeRow();

        };

        $scope.startIpRangeKeyDown = function ($event, ipRangeRowData) {
            console.log(" startIpRangeKeyDown ");
            console.dir(ipRangeRowData);
            if (ipRangeRowData.rangeStartValue || ipRangeRowData.rangeEndtValue) {
                ipRangeRowData.cidrValue = "";
                ipRangeRowData.rangeCIDREnableState = false;
            } else
            {
                ipRangeRowData.rangeCIDREnableState = true;
            }
            $scope.datValueChanged($scope.newIPDate.ranges);
        };

        $scope.endIPRangeKeyDown = function ($event, ipRangeRowData) {
            console.log(" endIPRangeKeyDown ");
            console.dir(ipRangeRowData);
            if (ipRangeRowData.rangeStartValue || ipRangeRowData.rangeEndtValue) {
                ipRangeRowData.cidrValue = "";
                ipRangeRowData.rangeCIDREnableState = false;
            } else
            {
                ipRangeRowData.rangeCIDREnableState = true;
            }
            $scope.datValueChanged($scope.newIPDate.ranges);
        };

        $scope.cidrIPRangeKeyDown = function ($event, ipRangeRowData) {
            console.log(" cidrIPRangeKeyDown ");
            console.dir(ipRangeRowData);
            if (ipRangeRowData.cidrValue) {
                ipRangeRowData.rangeStartValue = "";
                ipRangeRowData.rangeEndtValue = "";
                ipRangeRowData.rangeStartEnableState = false;
                ipRangeRowData.rangeEndEnableState = false;
            } else {
                ipRangeRowData.rangeStartEnableState = true;
                ipRangeRowData.rangeEndEnableState = true;
            }
            $scope.datValueChanged($scope.newIPDate.ranges);
        };

        $scope.deleteIPPool = function (event, ipRangeRowData, key) {
            $scope.newIPDate.deleteIPRangeRow(key);
        };
    }
    angular.module('shieldxApp').controller('newIPRangeCtr', newIPRangeCtr);

})();
/*
 ShieldX Networks Inc. CONFIDENTIAL
 ----------------------------------
 *
 Copyright (c) 2016 ShieldX Networks Inc.
 All Rights Reserved.
 *
 NOTICE: All information contained herein is, and remains
 the property of ShieldX Networks Incorporated and its suppliers,
 if any. The intellectual and technical concepts contained
 herein are proprietary to ShieldX Networks Incorporated
 and its suppliers and may be covered by U.S. and Foreign Patents,
 patents in process, and are protected by trade secret or copyright law.
 Dissemination of this information or reproduction of this material
 is strictly forbidden unless prior written permission is obtained
 from ShieldX Networks Incorporated.
 */

(function () {
    function licenseCtr($scope,
                        $state,
                        $sessionStorage,
                        $translate,
                        licenseService) {

        "ngInject";

        // calling license if exist any
        licenseService.callGetLicense($sessionStorage.licenseId).then(function (data) {
            $scope.license = angular.fromJson(data);
        }, function (error) {
            console.log(error);
        });

        $scope.$emit('listenHeaderText', {headerText: $translate.instant('admin.toolbar.heading')});

        var licenseActivationStarted = {
            'heading': 'Activating License',
            'subHeading': '&nbsp;',
            'type': 'progress',
            'timeout': $scope.toastTimeout
        };
        var licenseActivated = {
            'heading': 'License activated successfully',
            'subHeading': '&nbsp;',
            'type': 'success',
            'timeout': $scope.toastTimeout,
            'callback': function () {
                $state.reload();
            }
        };
        var licenseActivationFailed = {
            'heading': 'License activation Failed',
            'type': 'failure',
            'timeout': $scope.toastTimeout,
            'callback': function () {
                $state.reload();
            }
        };


        // calling activate license based on UUID provides
        $scope.callActivateLicense = function () {
            showToast(licenseActivationStarted);
            var uuid = $scope.uuid;
            licenseService.callActivateLicense(uuid).then(function (data) {
                $scope.license = angular.fromJson(data);
                //updating session storage to store new license id
                $sessionStorage.licenseId = uuid;
                showToast(licenseActivated);
            }, function (error) {
                console.log(error);
                licenseActivationFailed.subHeading = "Error: " + error.data.message;
                showToast(licenseActivationFailed);
            });
        };

        fixContainerHeight(1);
    }

    angular.module('shieldxApp').controller('licenseCtr', licenseCtr);
})();

/*
 ShieldX Networks Inc. CONFIDENTIAL
 ----------------------------------
 *
 Copyright (c) 2016 ShieldX Networks Inc.
 All Rights Reserved.
 *
 NOTICE: All information contained herein is, and remains
 the property of ShieldX Networks Incorporated and its suppliers,
 if any. The intellectual and technical concepts contained
 herein are proprietary to ShieldX Networks Incorporated
 and its suppliers and may be covered by U.S. and Foreign Patents,
 patents in process, and are protected by trade secret or copyright law.
 Dissemination of this information or reproduction of this material
 is strictly forbidden unless prior written permission is obtained
 from ShieldX Networks Incorporated.
 */

(function () {
    function logsCtr(
            $scope,
            $state,
            $translate,
            managementService,
            userSessionMenagment) {

        var logsUploadStarted = {
            'heading': 'Logs upload initiating',
            'subHeading': '&nbsp;',
            'type': 'progress',
            'timeout': $scope.toastTimeout
        };
        var logsUploaded = {
            'heading': 'Logs uploaded successfully',
            'subHeading': '&nbsp;',
            'type': 'success',
            'timeout': $scope.toastTimeout,
            'callback': function () {
                $state.reload();
            }
        };

        var logsUploadFailed = {
            'heading': 'Logs upload Failed',
            'type': 'failure',
            'timeout': $scope.toastTimeout,
            'callback': function () {
                $state.reload();
            }
        };

        $scope.active_help_id = "admin_system_logs_help";
        $scope.helpButtonClicked = function(id){
            $scope.active_help_id = id;
            console.log("  helpButtonClicked ");
            $scope.bordcastEventHelpButtonClicked($scope.active_help_id);
        }; 
        $scope.bordcastEventHelpButtonClicked = function(helpId){
            $scope.$broadcast('onHelpButtonClicked', {
               helpIDString: helpId 
            });
         };
        $scope.$emit('listenHeaderText', {headerText: $translate.instant('admin.toolbar.heading')});
        var log_id = authorities("logs_upload");
        $scope.is_log_update = userSessionMenagment.isUserAllowd(log_id);

        $scope.disablelogsUpload = (parseInt($scope.currentTime) - $scope.callout.uploadLogs < $scope.disableTimeout);
        $scope.disableSaveLogs = (parseInt($scope.currentTime) - $scope.callout.downloadEventLogs < $scope.disableTimeout);

        $scope.callUploadLogs = function () {

            $scope.disableCallout('uploadLogs');

            showToast(logsUploadStarted);

            managementService.callUploadLogs().then(function () {

                showToast(logsUploaded);

            }, function (error) {
                console.log(error);
                logsUploadFailed.subHeading = "Error: " + error.data.message;
                showToast(logsUploadFailed);

            });
        };

        $scope.callDownloadEventLogs = function () {

//            $scope.disableCallout('downloadEventLogs');

//            managementService.callDownloadEventLogs();

            var url = '/shieldxapi/manage/downloadcsv';

            document.getElementById('my_iframe').src = url;

        };

        fixContainerHeight(1);
    }

    angular.module('shieldxApp').controller('logsCtr', logsCtr);
})();

/*
 ShieldX Networks Inc. CONFIDENTIAL
 ----------------------------------
 *
 Copyright (c) 2016 ShieldX Networks Inc.
 All Rights Reserved.
 *
 NOTICE: All information contained herein is, and remains
 the property of ShieldX Networks Incorporated and its suppliers,
 if any. The intellectual and technical concepts contained
 herein are proprietary to ShieldX Networks Incorporated
 and its suppliers and may be covered by U.S. and Foreign Patents,
 patents in process, and are protected by trade secret or copyright law.
 Dissemination of this information or reproduction of this material
 is strictly forbidden unless prior written permission is obtained
 from ShieldX Networks Incorporated.
 */

(function () {
    function managementPlaneCtr(
            $scope,
            $state,
            $translate,
            managementService,
            infrastructureConnectorService,
            deploymentSpecificationService,
            userSessionMenagment) {

        $scope.$emit('listenHeaderText', {headerText: $translate.instant('admin.toolbar.heading')});


        var updateControlPlaneSettingStarted = {
            'heading': 'Update Control Plane Setting Initiating',
            'subHeading': '&nbsp;',
            'type': 'progress',
            'timeout': $scope.toastTimeout
        };
        var updateControlPlaneSet = {
            'heading': 'Update Control Plane Set',
            'subHeading': '&nbsp;',
            'type': 'success',
            'timeout': $scope.toastTimeout,
            'callback': function () {
                $state.reload();
            }
        };

        var updateControlPlaneSettingFailed = {
            'heading': 'Update Control Plane Setting Failed',
            'subHeading': '&nbsp;',
            'type': 'failure',
            'timeout': $scope.toastTimeout
        };
        $scope.active_help_id = "admin_deploy_components_add_mgmt_plane_help";
        $scope.helpButtonClicked = function(id){
            $scope.active_help_id = id;
            console.log("  helpButtonClicked ");
            $scope.bordcastEventHelpButtonClicked($scope.active_help_id);
        }; 
        $scope.bordcastEventHelpButtonClicked = function(helpId){
            $scope.$broadcast('onHelpButtonClicked', {
               helpIDString: helpId 
            });
        };
        var controlplane_read = authorities("shieldxUpdates_controlplane_read");
        var controlplane_update = authorities("shieldxUpdates_controlplane_update");
        $scope.is_controlplane_read = userSessionMenagment.isUserAllowd(controlplane_read);
        $scope.is_controlplane_update = userSessionMenagment.isUserAllowd(controlplane_update);

        fixContainerHeight(1);

        // control Plane Setting controller

        $scope.clouds = [];

        infrastructureConnectorService.getListOfInfrastructures().then(function (data) {

            $scope.infraAvailable = (data.length > 0) ? true : false;

            $scope.clouds = data;

        });

        $scope.deploymentSpecDataNotAvailable = true;

        $scope.showDeploymentSpecOptions = function (infraId) {
            $scope.enableNext = false;
            $scope.deploymentSpecList = [];
            $scope.selectedDspec= parseInt(infraId);
            deploymentSpecificationService.getDeploymentSpecList(parseInt(infraId)).then(
                    function (delpoymentSpecList) {
                        $scope.deploymentSpecList = delpoymentSpecList;
                        if (delpoymentSpecList.length !== 0) {
                            $scope.deploymentSpecDataNotAvailable = false;
                        }
                    }
            );
        };

        $scope.updateControlPlaneSetting = function(infraId,dspecId) {
            console.log(infraId);
            console.log(dspecId);
            var controlPlaneSetting = {};
            showToast(updateControlPlaneSettingStarted);

            controlPlaneSetting.datapathDeploySpecId =  parseInt(dspecId);/*$scope.deploymentSpecId;*/
            controlPlaneSetting.cloudId =  parseInt(infraId);/*$scope.infrastructureId;*/
            managementService.updateControlPlaneSetting(controlPlaneSetting).then(function() {
            showToast(updateControlPlaneSet);
            }, function (error) {
                console.log(error);
                updateControlPlaneSettingFailed.subHeading = "Error: " + error.data.message;
                showToast(contentUpgradeFailed);
            });
        };


        $scope.$on('$viewContentLoaded', function (event) {
            console.log(event);
            fixContainerHeight(1);
        });

    }

    angular.module('shieldxApp').controller('managementPlaneCtr', managementPlaneCtr);
})();

(function () {
    function backupSchedulerCtr(
        $scope,
        $state,
        $translate,
        schedulerService,
        $q,
        $sessionStorage,
        $mdDialog) {
            "ngInject";
            
            clearAllSession($sessionStorage);
            var schedulerConfigData;
            var deferred = $q.defer();
            $scope.promise = deferred.promise; 
            $scope.promiseCompleted = true;
            var promiseCtr = 0;
            var totalClouds = 0;
            $scope.schedulerConfigAvailable = false;
            $scope.editMiscState = false;

            $scope.isAdornmentPanelOpen = false;
            $scope.isSearchBarOpen = false;
                      
            $scope.$emit('listenHeaderText', {headerText: $translate.instant('admin.maintenance.heading')});            

            var started = {
                'heading': 'Scheduler Configuration Initiating',
                'subHeading': 'Scheduler Configuration Initiating..',
                'type': 'progress',
                'timeout': $scope.toastTimeout
            };
            var saved = {
                'heading': 'Scheduler Configuration Completed',
                'subHeading': 'Scheduler Configuration Completed',
                'type': 'success',
                'timeout': $scope.toastTimeout,
                'callback': function () {
                    $state.reload();
                }
            };

            var failed = {
                'heading': 'Scheduler Configuration Failed',
                'subHeading': '&nbsp;',
                'type': 'fail',
                'timeout': $scope.toastTimeout,
                'callback': function () {
                    $state.reload();
                }
            };


            $scope.backuptypes = {
                'types': [
                    //{'name': 'Configuration', 'value': 1},  //QTAD-2532
                    {'name': 'Events', 'value': 2}
                ]
            };
            $scope.backupscheduler = {};

            $scope.backupscheduler.type='Configuration';
            $scope.backupscheduler_defdirloc='Default Target Backup Directory';
            $scope.backupscheduler.defdirloc = '/usr/local/shieldx/config/';   // Get this from SMB Config settings

            $scope.backupscheduler_targetdirloc='Target Backup Directory';

            $scope.backupscheduler_enable='Enable';
            $scope.backupscheduler_frequency = 'Frequency';
            $scope.backupscheduler_starttime = 'Start Time';

            //Schedule backup for configuration and events data
            $scope.scheduleBackup = function () {

                var backupSchedulerSettings = $scope.backupscheduler;
                console.log(" Scheduled backup config details = "+backupSchedulerSettings);
                var enable = ($scope.backupscheduler.enable == 1)?true:false;
                var datetime = $scope.backupscheduler.time;
                console.log("Start Time --->> "+datetime);
                var dt = new Date(datetime);
                var hours = dt.getHours(); // Will be local time
                var minutes = dt.getMinutes(); // Will be local time
                var startTime = (hours <= 9? "0"+hours : hours)+":"+(minutes <= 9? "0"+minutes : minutes);
                backupSchedulerSettings.enable = enable;
                backupSchedulerSettings.time = startTime;
                showToast(started);
                console.log("Backup scheduled for type : "+backupSchedulerSettings.type+" Frequency Daily = "+backupSchedulerSettings.frequencydaily);
                
                schedulerService.scheduleBackup(backupSchedulerSettings).then(function () {
                    console.log("Request to schedule db backup for type = "+backupSchedulerSettings.type+" posted successfully!!!");
                    showToast(saved);

                }, function (error) {
                    console.log(error);
                    failed.subHeading = "Error: " + error.data.message;
                    showToast(failed);
                });                                
            };


            schedulerService.getSchedulerConfig().then(function (data) {

                console.log("Get Scheduler configuration details");

                if (!data) {
                    $scope.schedulerConfigAvailable = false;
                } else {
                    console.log(" Enable = "+data.enable+" Frequency is daily = "+data.daily+"  Start Time = "+data.time);

                    $scope.schedulerConfigAvailable = true;
                    $scope.backupscheduler = data;
                    $scope.backupscheduler.enable = (data.enable)?1:0;
                    var time = data.time.split(":");
                    var dateTime = new Date();
                    dateTime.setHours(time[0]);
                    dateTime.setMinutes(time[1]);
                    $scope.backupscheduler.time = dateTime;

                    console.log($scope.backupscheduler);
                }
            }, function (error) {
                $scope.schedulerConfigAvailable = false;
                console.log(error);
                var getschedulerfailed = {
                    'heading': 'Failed to get scheduler configuration',
                    'subHeading': '&nbsp;',
                    'type': 'fail',
                    'timeout': 3000
                };
                getschedulerfailed.subHeading = "Failed to get scheduler configuration details."+error.data.message;
                showToast(getschedulerfailed);
            });


            $scope.showStatus = function (status, test) {
                return status === test;
            };

            $scope.hide = function () {
                $mdDialog.hide();
            };

            $scope.cancel = function () {
                $mdDialog.cancel();
            };


        $scope.$on('$viewContentLoaded', function (event) {
            console.log(event);
            fixContainerHeight(1);
        });

    }
    angular.module('shieldxApp').controller('backupSchedulerCtr', backupSchedulerCtr);

})();
(function () {
    function backupRestoreCtr(
        $scope,
        $state,
        $translate,
        backupRestoreService,
        $q,
        $sessionStorage,
        $mdDialog,
        userSessionMenagment) {
            "ngInject";
            
            clearAllSession($sessionStorage);
            var backupConfigData = [];
            var deferred = $q.defer();
            $scope.promise = deferred.promise; 
            $scope.promiseCompleted = true;
            var promiseCtr = 0;
            var totalClouds = 0;
            $scope.backupConfigAvailable = false;
            $scope.editMiscState = false;

            $scope.isAdornmentPanelOpen = false;
            $scope.isSearchBarOpen = false;

            var bcCtr = 0;
            $scope.backupConfigurations = [];
            
            var update_id = authorities("maintenance_update");
            $scope.is_update_maintenance = userSessionMenagment.isUserAllowd(update_id);

            $scope.$emit('listenHeaderText', {headerText: $translate.instant('admin.maintenance.heading')});            

            /* **** for tables [start] **** */
            $scope.selected = [];
            $scope.query = {
                order: 'name',
                limit: 5,
                page: 1
            };

            var backupStarted = {
                'heading': 'Backup Initiating',
                'subHeading': 'Backup Initiating..',
                'type': 'progress',
                'timeout': $scope.toastTimeout
            };
            var backupCompleted = {
                'heading': 'Backup Completed',
                'subHeading': 'Backup Completed',
                'type': 'success',
                'timeout': $scope.toastTimeout,
                'callback': function () {
                    $state.reload();
                }
            };

            var backupFailed = {
                'heading': 'Backup Failed',
                'subHeading': '&nbsp;',
                'type': 'fail',
                'timeout': $scope.toastTimeout,
                'callback': function () {
                    $state.reload();
                }
            };

            $scope.backuptypes = {
                'types': [
                    {'name': 'Configuration', 'value': 'Configuration'},
                    {'name': 'Events', 'value': 'Events'}
                ]
            };
            $scope.backuprestore = {};

            $scope.backuprestore.type='Configuration';

            $scope.backuprestore_filename='File Name';

            $scope.backuprestore_defdirloc='Default Target Backup Directory';
            $scope.backuprestore.defdirloc = '/usr/local/shieldx/config/';   // Get this from SMB Config settings

            $scope.backuprestore_altdirloc='Target Backup Directory';

            $scope.backuprestore_desc='Description';

            $scope.backuprestore_filepath='Relative file path to restore';

            $scope.backuprestore_enable='Enable';
            $scope.backuprestore_frequency = 'Frequency';
            $scope.backuprestore_starttime = 'Start Time';

            //Backup data
            $scope.backup = function () {
                var type = $scope.backuprestore.type;
                var fileName = $scope.backuprestore.filename;
                var desc = $scope.backuprestore.desc;
                var def_location = $scope.backuprestore.defdirloc;
                var alt_location = $scope.backuprestore.altdirloc;
                var location = (!alt_location)?def_location:alt_location;                

                var backupConfigDetails = {
                    'type' : type,
                    'fileName': fileName,
                    'description': desc,
                    'targetDirectory': location
                };

                showToast(backupStarted);
                console.log("backupRestoreCtr : backup was called. File Name = "+fileName+" description = "+desc);
                
                backupRestoreService.backupData(backupConfigDetails).then(function () {
                    console.log("Request to backup data posted successfully!!!");
                    showToast(backupCompleted);

                }, function (error) {
                    console.log(error);
                    backupFailed.subHeading = "Error: " + error.data.message;
                    showToast(backupFailed);
                });
                //$mdDialog.hide();
            };

            //Restore data
            $scope.restore = function() {

                //var file = $scope.backupFile;
                //var fileName = file.name;
                //var path = (window.URL || window.webkitURL).createObjectURL(file);
                //var filePath = file.webkitRelativePath;

                var filePath = $scope.backuprestore.relativepath;
                console.log(" File Path  : "+filePath);

                var res = filePath.split("/");
                var fileName = res[res.length-1];
                var restorefile = {
                    'fileName' : fileName,
                    'filePath' : filePath
                };

                var restoreStarted = {
                    'heading': 'Restore started',
                    'subHeading': 'Restore of backup data has started.',
                    'type': 'progress',
                    'timeout': 3000
                };

                var restoreCompleted = {
                    'heading': 'Restore completed',
                    'subHeading': 'Restore completed for backup file '+fileName,
                    'type': 'success',
                    'timeout': 3000,
                    'callback': function () {
                        $state.reload();
                    }
                };

                showToast(restoreStarted);

                backupRestoreService.restoreData(restorefile).then(function() {
                    console.log("Request to restore data posted successfully!!!");
                    showToast(restoreCompleted);
                }, function error(err) {
                    console.log("Restore Failed due to "+err.data.message);
                    var restoreFailed = {
                        'heading': 'Restore failed.',
                        'subHeading': '&nbsp;',
                        'type': 'fail',
                        'timeout': 3000,
                    };
                    restoreFailed.subHeading = "Error: " + err.data.message;
                    showToast(restoreFailed);
                });
            };


            //Get Config Backups
            $sessionStorage.backupList = [];
            backupRestoreService.getBackupConfigList().then(function (data) {
                console.log("Config backups len = "+data);
                totalConfigs = data.length;
                console.log("Total configs = "+totalConfigs);
                if (totalConfigs === 0) {

                    deferred.resolve();
                    $scope.promiseCompleted = false;
                    $scope.backupConfigAvailable = false;

                } else {
                    console.log("Config backups available = "+data);
                    $scope.backupConfigAvailable = true;
                    
                    //$scope.backupConfigurations = data;

                    for (var i = 0; i < data.length; i++) {
                        console.log(" data -> "+data[i]);
                        backupConfigData[i] = {};
                        backupConfigData[i] = data[i];
                    }
                    
                    deferred.resolve();                    
                    $scope.promiseCompleted = false;                                        
                    $scope.backupConfigurations = backupConfigData;

                    console.log(backupConfigData);
                }

            }, function (error) {
                console.log(error);
                $scope.errorMessage = "ERROR occured while getting backup config list!!!";
                backupConfigData = [];
                $scope.backupConfigurations = [];
                deferred.resolve();
                $scope.promiseCompleted = false;
                $scope.backupConfigAvailable = false;
            });


            //Configure Backup 
            $scope.configureBackup = function(ev){
                console.log("Launch configure backup dialog.");                             
                $mdDialog.show({
                    controller: backupRestoreCtr,
                    skipHide: true,
                    templateUrl: 'core/components/administration/backup-and-restore/addbackupconfig.html',
                    parent: angular.element(document.body),
                    targetEvent: ev,
                    fullscreen: true,
                    openFrom: {top: 1100, height: 0},
                    closeTo: {left: 1500}
                    //locals: {'cloudData': cloudData}
                }).then(function () {

                });
            };


            $scope.fileInputText = "No File Chosen";

            $scope.fileNameChanged =  function(element){
                $scope.fileInputText = element.files[0].name;
            };

            $scope.toggleSearchBar = function (event) {
                $scope.isSearchBarOpen = $scope.isSearchBarOpen === false ? true : false;
                if ($scope.isSearchBarOpen)
                    angular.element(event.currentTarget.firstElementChild).css('color', '#4a90e2');
                else
                    angular.element(event.currentTarget.firstElementChild).css('color', '#6d6e71');
            };
            /* **** for tables [end] **** */

            $scope.showStatus = function (status, test) {
                return status === test;
            };

            $scope.hide = function () {
                $mdDialog.hide();
            };

            $scope.cancel = function () {
                $mdDialog.cancel();
            };

            $scope.cancelDialog = function() {
                $mdDialog.cancel();
            };

        $scope.$on('newInfracreated', function (event) {
            console.log($scope.query);
            $scope.query.page = 1;
        });
        $scope.$on('$viewContentLoaded', function (event) {
            console.log(event);
            fixContainerHeight(1);
        });

    }
    angular.module('shieldxApp').controller('backupRestoreCtr', backupRestoreCtr);

})();
(function () {
    function contentDownloadSchedulerCtr(
        $scope,
        $state,
        $translate,
        contentDownloadService,
        $q,
        $sessionStorage,
        $mdpTimePicker,
        $mdDialog) {
            "ngInject";
            
            clearAllSession($sessionStorage);
            $scope.schedulerConfigAvailable = false;
            $scope.editMiscState = false;

            $scope.schedulerConfigDetails ={}; 

            $scope.$emit('listenHeaderText', {headerText: $translate.instant('admin.maintenance.heading')});            

            var started = {
                'heading': 'Scheduler Configuration Initiating',
                'subHeading': 'Scheduler Configuration Initiating..',
                'type': 'progress',
                'timeout': $scope.toastTimeout
            };
            var completed = {
                'heading': 'Scheduler Configuration Completed',
                'subHeading': 'Scheduler Configuration Completed',
                'type': 'success',
                'timeout': $scope.toastTimeout,
                'callback': function () {
                    $state.reload();
                }
            };

            var failed = {
                'heading': 'Scheduler Configuration Failed',
                'subHeading': '&nbsp;',
                'type': 'fail',
                'timeout': $scope.toastTimeout,
                'callback': function () {
                    $state.reload();
                }
            };

            //var currentDate = new Date();
            $scope.contentdownload = {};
            $scope.contentdownload.starttime = '';
            var schedulertype = 3;
            $scope.contentdownload.dayoftheweek = 1;
            $scope.daysInWeek =   [{ "id": 1, "day": "Sunday"}, 
                                    { "id": 2, "day": "Monday"}, 
                                    { "id": 3, "day": "Tuesday"},
                                    { "id": 4, "day": "Wednesday"},
                                    { "id": 5, "day": "Thursday"},
                                    { "id": 6, "day": "Friday"},
                                    { "id": 7, "day": "Saturday"}];

            ///////////     Get scheduler config details ////////////////
            //$sessionStorage.schedulerConfigData;
            var tenantId = 1;
            contentDownloadService.getContentDownloadSchedulerDetails(tenantId).then(function (data) {

                console.log("Get scheduler config details for tenant id "+tenantId);

                if (!data) {
                    $scope.schedulerConfigAvailable = false;
                } else {
                    $scope.schedulerConfigAvailable = true;
                    schedulerConfigDetails = data;
                    console.log(" Enabled = "+data.enable+" Frequency = "+data.frequency+"  Start Time = "+data.starttime);
                    $scope.contentdownload.enable = (data.enable)?1:0;
                    $scope.contentdownload.frequency = data.frequency;
                    var time = data.starttime.split(":");
                    var dateTime = new Date();
                    dateTime.setHours(time[0]);
                    dateTime.setMinutes(time[1]);
                    $scope.contentdownload.starttime = dateTime;
                    $scope.contentdownload.dayoftheweek = data.dayoftheweek;
                    console.log($scope.contentdownload);
                }
            }, function (error) {
                console.log(error);
                $scope.errorMessage = "ERROR occured while getting scheduler config details!!!";
                $scope.schedulerConfigAvailable = false;
            });


            //Schedule Content Download
            $scope.scheduleContentDownload = function () {
                var isEnable = ($scope.contentdownload.enable == 1)?true:false;
                var frequency = $scope.contentdownload.frequency;
                var datetime = $scope.contentdownload.starttime;
                console.log("Start Time --->> "+datetime);
                var dt = new Date(datetime);
                var hours = dt.getHours(); // Will be local time
                var minutes = dt.getMinutes(); // Will be local time
                var startTime = (hours <= 9? "0"+hours : hours)+":"+(minutes <= 9? "0"+minutes : minutes);
                //var recurrencefreq = $scope.contentdownload.recurfreq;
                var weekDay = $scope.contentdownload.dayoftheweek;

                var contentSchedulerConfig = {
                    'enable' : isEnable,
                    'frequency' : frequency,
                    'starttime': startTime,
                    //'recurrenceFrequency': recurrencefreq,
                    'dayoftheweek': weekDay
                };

                console.log(" Content download config details = "+contentSchedulerConfig);

                showToast(started);
                console.log("Content Download scheduled. frequency : "+frequency+
                    " Start Time : "+startTime+" day of the week : "+contentSchedulerConfig.dayoftheweek);
                
                contentDownloadService.autodownloadcontent(contentSchedulerConfig).then(function () {
                    console.log("Request to schedule content download and deployment was successful!!");
                    showToast(completed);

                }, function (error) {
                    console.log(error);
                    failed.subHeading = "Error: " + error.data.message;
                    showToast(failed);
                });                                
            };


            $scope.showStatus = function (status, test) {
                return status === test;
            };

            $scope.hide = function () {
                $mdDialog.hide();
            };

            $scope.cancel = function () {
                $mdDialog.cancel();
            };


        $scope.$on('$viewContentLoaded', function (event) {
            console.log(event);
            fixContainerHeight(1);
        });

    }
    angular.module('shieldxApp').controller('contentDownloadSchedulerCtr', contentDownloadSchedulerCtr);

})();
(function() {
    function maintenanceCtr(
        $scope,
        userSessionMenagment
    ) {

        $scope.$emit('listenHeaderText', { headerText: "Maintenance" });
        var update_id = authorities("maintenance_update");
        $scope.is_update_maintenance = userSessionMenagment.isUserAllowd(update_id);    

    }

    angular.module('shieldxApp').controller('maintenanceCtr', maintenanceCtr);
})();

(function () {
    function maintenanceTasksCtr(
        $scope,
        $state,
        backupRestoreService,
        $q
    ) {

        $scope.$emit('listenHeaderText', { headerText: "Maintenance" });
        var url = $state.current.url;
        
        if (url.indexOf("backupnow") > 0) {
            $state.go('home.maintenance.maintenancetasks.backup');
        } else if (url.indexOf("schedule-backup") >0 ) {
            $state.go('home.maintenance.maintenancetasks.schedulebackup');
        } else if (url.indexOf("restore") >0 ) {
            $state.go('home.maintenance.maintenancetasks.restore');
        } else if (url.indexOf("schedule-pruning") >0 ) {
            $state.go('home.maintenance.maintenancetasks.schedulepruning');
        } else if (url.indexOf("autocontentdownload") >0 ) {
            $state.go('home.maintenance.maintenancetasks.autocontentdownload');
        }else {
            $state.go('home.maintenance.maintenancetasks.backup');    
        }
        $scope.$on('$stateChangeSuccess', function(event, toState, toParams, fromState, fromParams) {
            if (toState.data) {
                $scope.currentTab = toState.data.selectedTab;
            }

        });

        $scope.active_help_id = "admin_system_maintenance_help";
        $scope.helpButtonClicked = function(id){
            $scope.active_help_id = id;
            console.log("  helpButtonClicked ");
            $scope.bordcastEventHelpButtonClicked($scope.active_help_id);
        }; 
        $scope.bordcastEventHelpButtonClicked = function(helpId){
            $scope.$broadcast('onHelpButtonClicked', {
               helpIDString: helpId 
            });
        };
        $scope.$on('$viewContentLoaded', function (event) {
            fixContainerHeight(1);
        });

    }
    angular.module('shieldxApp').controller('maintenanceTasksCtr', maintenanceTasksCtr);
})();
(function () {
    function pruningSchedulerCtr(
        $scope,
        $state,
        $translate,
        purgeDataService,
        $q,
        $sessionStorage,
        $mdDialog) {
            "ngInject";
            
            clearAllSession($sessionStorage);
            var schedulerConfigData;
            var deferred = $q.defer();
            $scope.promise = deferred.promise; 
            $scope.promiseCompleted = true;
            var promiseCtr = 0;
            var totalClouds = 0;
            $scope.schedulerConfigAvailable = false;
            $scope.editMiscState = false;

            $scope.isAdornmentPanelOpen = false;
            $scope.isSearchBarOpen = false;
                      
            $scope.$emit('listenHeaderText', {headerText: $translate.instant('admin.maintenance.heading')});            

            var started = {
                'heading': 'Scheduler Configuration Initiating',
                'subHeading': 'Scheduler Configuration Initiating..',
                'type': 'progress',
                'timeout': $scope.toastTimeout
            };
            var completed = {
                'heading': 'Scheduler Configuration Completed',
                'subHeading': 'Scheduler Configuration Completed',
                'type': 'success',
                'timeout': $scope.toastTimeout,
                'callback': function () {
                    $state.reload();
                }
            };

            var failed = {
                'heading': 'Scheduler Configuration Failed',
                'subHeading': '&nbsp;',
                'type': 'fail',
                'timeout': $scope.toastTimeout,
                'callback': function () {
                    $state.reload();
                }
            };


            $scope.pruning = {};

            $scope.pruning_enable='Enable';
            $scope.pruning_frequency = 'Frequency';
            $scope.pruning_starttime = 'Start Time';

            //Schedule Pruning for events
            $scope.schedulePruning = function () {
                var isEnable = $scope.pruning.enable;
                var frequency = $scope.pruning.frequency;
                var startTime = $scope.pruning.time;
                var maxdays = $scope.pruning.maxdays;
                var maxcapacity = $scope.pruning.maxcapacity;

                var pruningConfigDetails = {
                    'enable' : isEnable,
                    'frequency' : frequency,
                    'starttime': startTime,
                    'maxdays': maxdays,
                    'maxcapacity': maxcapacity
                };

                console.log(" Pruning Config Details = "+pruningConfigDetails);                   

                showToast(started);
                console.log("pruning scheduled. frequency : "+frequency+" Start Time : "+startTime+" max days : "+maxdays+ " max capacity : "+maxcapacity);                
                
                purgeDataService.schedulepruning(pruningConfigDetails).then(function () {
                    console.log("Request to schedule db purge posted successfully!!");
                    showToast(completed);

                }, function (error) {
                    console.log(error);
                    failed.subHeading = "Error: " + error.data.message;
                    showToast(failed);
                });                                
            };

            //Schedule backup for configuration and events data
            $scope.scheduleBackup = function () {
                var isEnable = $scope.pruning.enable;
                var frequency = $scope.pruning.frequency;
                var startTime = $scope.pruning.time;
                var targetDir = $scope.pruning.maxdays;
                var backupType = $scope.pruning.type;

                var backupSchedulerSettings = {
                    'enable' : isEnable,
                    'frequency' : frequency,
                    'starttime': startTime,
                    'targetDir': targetDir,
                    'backuptype' : backupType                    
                };

                console.log(" Scheduled backup config details = "+backupSchedulerSettings);                   

                showToast(started);
                console.log("Backup scheduled for type : "+backupType);                
                
                schedulerService.schedulebackup(backupSchedulerSettings).then(function () {
                    console.log("Request to schedule db backup for type = "+backupType+" posted successfully!!!");
                    showToast(completed);

                }, function (error) {
                    console.log(error);
                    backupFailed.subHeading = "Error: " + error.data.message;
                    showToast(failed);
                });                                
            };


            $scope.showStatus = function (status, test) {
                return status === test;
            };

            $scope.hide = function () {
                $mdDialog.hide();
            };

            $scope.cancel = function () {
                $mdDialog.cancel();
            };


        $scope.$on('$viewContentLoaded', function (event) {
            console.log(event);
            fixContainerHeight(1);
        });

    }
    angular.module('shieldxApp').controller('pruningSchedulerCtr', pruningSchedulerCtr);

})();
(function() {
    function emailnotificationCtr(
        $scope,
        $rootScope,
        $http,
        $state,
        $translate,
        $sessionStorage,
        infrastructureConnectorService, 
		policyService,
        emailService,
        $timeout,
        $q,
        $mdDialog
    ) {
        "ngInject";

        clearAllSession($sessionStorage);

        $scope.recipientemails = [];
        $scope.recipientsAvailable = false;
        $scope.emailNotificationProfileAvailable = false;
        var totalRecipients = 0;
        //////////////////     Start Email notification Configuration  //////////////////
        //FUNCTIONALITY TO ADD email notifcation
        
        $scope.active_help_id = "user_type_help_wizard";
        $scope.helpButtonClicked = function(id){
            $scope.active_help_id = id;
            console.log("  helpButtonClicked ");
            $scope.bordcastEventHelpButtonClicked($scope.active_help_id);
        }; 
        
        $scope.bordcastEventHelpButtonClicked = function(helpId){
            $scope.$broadcast('onHelpButtonClicked', {
             helpIDString: helpId 
            });
        };                 

        $scope.emailnotification = {};
        $scope.emailnotification.enable = 0;
        $scope.emailnotification.isEnabledForThreat = 0;
        $scope.emailnotification.isMatchingSeverity = 0;
        $scope.emailnotification.suppressionTime = 10;
        $scope.emailnotification.severityRange=2;
        $scope.severityRanges = [{ "id": 0, "name": "Severity Low and Above"},
                                    { "id": 1, "name": "Severity Medium and Above"},
                                    { "id": 2, "name": "Severity High and Above"},
                                    { "id": 3, "name": "Severity Critical"}];
       
        //$scope.emailnotification.messagepref=$translate.instant("admin.setup.syslog.default.message");

        $scope.recipientemails = [];

        $scope.emailnotification.subject = $translate.instant("admin.setup.email.message.subject");

        $scope.emailnotification.body = $translate.instant("admin.setup.email.message.body");

        var messagetoken = $translate.instant("admin.setup.syslog.message.tokens");                                     
        //$scope.syslogMsgTokens = messagetoken.split(",");
        $scope.emailMsgTokens = [
                    {"tokenkey":"$TIMESTAMP$","value":"TIMESTAMP"},
                    {"tokenkey":"$EVENT_TYPE$","value":"EVENT_TYPE"},
                    {"tokenkey":"$THREAT_NAME$","value":"THREAT_NAME"},
                    {"tokenkey":"$SEVERITY$","value":"SEVERITY"},
                    {"tokenkey":"$DESTINATION_IP$","value":"DESTINATION_IP"},
                    {"tokenkey":"$DESTINTATION_PORT$","value":"DESTINTATION_PORT"},
                    {"tokenkey":"$DESTINATION_VM_NAME$","value":"DESTINATION_VM_NAME"},
                    {"tokenkey":"$DESTINATION_RESOURCE_GROUP$","value":"DESTINATION_RESOURCE_GROUP"},
                    {"tokenkey":"$SOURCE_IP$","value":"SOURCE_IP"},
                    {"tokenkey":"$SOURCE_PORT$","value":"SOURCE_PORT"},
                    {"tokenkey":"$SOURCE_RESOURCE_GROUP$","value":"SOURCE_RESOURCE_GROUP"},
                    {"tokenkey":"$SOURCE_VM_NAME$","value":"SOURCE_VM_NAME"},
                    {"tokenkey":"$PROTOCOL$","value":"PROTOCOL"},
                    {"tokenkey":"$APPLICATION_NAME$","value":"APPLICATION_NAME"},
                    {"tokenkey":"$POLICY_TYPE$","value":"POLICY_TYPE"},
                    {"tokenkey":"$POLICY_NAME$","value":"POLICY_NAME"},
                    {"tokenkey":"$SECURITY_POLICY_SET$","value":"SECURITY_POLICY_SET"},
                    {"tokenkey":"$RESULT_STATUS$","value":"RESULT_STATUS"},
                    {"tokenkey":"$ACTION_TAKEN$","value":"ACTION_TAKEN"},
                    {"tokenkey":"$ATTACKER_RESOURCE_GROUP$","value":"ATTACKER_RESOURCE_GROUP"},
                    {"tokenkey":"$VICTIM_RESOURCE_GROUP$","value":"VICTIM_RESOURCE_GROUP"},
                    {"tokenkey":"$DOMAIN$","value":"DOMAIN"},
                    {"tokenkey":"$DOMAIN_TAG$","value":"DOMAIN_TAG"},
                    {"tokenkey":"$CERTIFICATE_TAG$","value":"CERTIFICATE_TAG"},
                    {"tokenkey":"$FILE_SIGNATURE$","value":"FILE_SIGNATURE"},
                    {"tokenkey":"$FILE_HASH$","value":"FILE_HASH"},
                    {"tokenkey":"$START_TIME$","value":"START_TIME"},
                    {"tokenkey":"$END_TIME$","value":"END_TIME"},
                    {"tokenkey":"$TCP_SESSION_START_EVENT$","value":"TCP_SESSION_START_EVENT"},
                    {"tokenkey":"$TCP_SESSION_END_EVENT$","value":"TCP_SESSION_END_EVENT"},
                    {"tokenkey":"$TCP_RECV_FLAGS$","value":"TCP_RECV_FLAGS"},
                    {"tokenkey":"$TCP_SENT_FLAGS$","value":"TCP_SENT_FLAGS"},
                    {"tokenkey":"$BYTES_RECEIVED$","value":"BYTES_RECEIVED"},
                    {"tokenkey":"$BYTES_SENT$","value":"BYTES_SENT"},
                    {"tokenkey":"$EVENTS_SENT_COUNT$","value":"EVENTS_SENT_COUNT"},
                    {"tokenkey":"$EVENTS_RECV_COUNT$","value":"EVENTS_RECV_COUNT"},
                    {"tokenkey":"$IOP_THREAT_NAME$","value":"IOP_THREAT_NAME"},
                    {"tokenkey":"$IOP_THREAT_TIMESTAMP$","value":"IOP_THREAT_TIMESTAMP"},
                    {"tokenkey":"$IOP_RULE_ID$","value":"IOP_RULE_ID"},
                    {"tokenkey":"$IOP_DETECTION_ID$","value":"IOP_DETECTION_ID"},
                    {"tokenkey":"$CHASSIS_ID$","value":"CHASSIS_ID"},
                    {"tokenkey":"$MICROSERVICE_TYPE$","value":"MICROSERVICE_TYPE"},
                    {"tokenkey":"$MICROSERVICE_INSTANCE_ID$","value":"MICROSERVICE_INSTANCE_ID"}
        ];


        emailService.getSMTPNotificationProfile(1).then(function (data) {

            console.log("Get SMTP notification profile for tenant id 1 ");

            if (!data) {
                console.log("No data available");
                $scope.emailNotificationProfileAvailable = false;
            } else {
                if(!data.enable) {
                    console.log("SMTP notification profile is not enabled.");
                    $scope.emailNotificationProfileAvailable = false;
                    $scope.emailnotification.subject = $translate.instant("admin.setup.email.message.subject");
                    $scope.emailnotification.body = $translate.instant("admin.setup.email.message.body");
                    $scope.emailnotification.suppressionTime = 10;
                    $scope.emailnotification.severityRange=2;
                }else {
                    $scope.emailNotificationProfileAvailable = true;
                    $scope.emailnotification = data;
                    console.log("**Enabled = " + data.enable + " Suppression Time = " + data.suppressionTime + "  email subject = " + data.subject);
                    console.log($scope.emailnotification);
                }
            }
        }, function (error) {
            $scope.errorMessage = "ERROR occured while getting SMTP notification profile details!!!";
            $scope.emailNotificationProfileAvailable = false;
            console.log(error);
        });


        $scope.addEmailNotificationProfile = function () {

            console.log(" Add email notification -->> "+$scope.emailnotification);

            var emailNotificationProfile = $scope.emailnotification;

            //var tenantId = $scope.selectedTenantObj.id;
            var tenantId = 1;
            console.log("Tenant Id = "+tenantId);

            emailNotificationProfile.tenantId = tenantId;

            var startAddEmailNotificationMessage = {
                'heading': 'Create Email Notification Profile',
                'subHeading': 'This should take only a few minutes max.',
                'type': 'progress',
                'timeout': 5000
            };
            var successfulEmailNotificationMessage = {
                'heading': 'Email Notification Created',
                'subHeading': 'Email notification created successfully.',
                'type': 'success',
                'timeout': 5000
            };
            showToast(startAddEmailNotificationMessage);
            emailService.createEmailNotificationProfile(tenantId, emailNotificationProfile).then(function (data) {
                console.log(" Email Notification Profile has been saved.");
                if (data) {
                    var newData = emailNotificationProfile;
                    console.log(emailNotificationProfile);
                    showToast(successfulEmailNotificationMessage);

                    //syslogProfilesData.unshift(newData);
                    //console.log(syslogProfilesData);
                    //$sessionStorage.syslogProfilesList = syslogProfilesData;
                    //$scope.syslogProfiles=syslogProfilesData;
                    //$rootScope.$broadcast('newSyslogForwarderCreated', {});
                }
            }, function (error) {
                var failureEmailNotificationCreation = {
                    'heading': 'Email notification creation failed',
                    'subHeading': "Error: " + error.data.message,
                    'type': 'fail',
                    'timeout': 10000
                };
                showToast(failureEmailNotificationCreation);
            });
            //$mdDialog.hide();
        };


        $scope.msgTokensPerRow = 6;

        function messageTokensCtr($rootScope, $scope) {
            $scope.getMessageTokens = function() {

                $http.get('message-tokens.json').success(function(data) {

                    $scope.emailMsgTokens = data;

                });

                console.log("Message Tokens = "+$scope.emailMsgTokens);
            };
        }

        $scope.customMessageBuilder = function(customMsg){
            console.log("Message Token -->> "+customMsg);                             
            //$scope.messagepref=customMsg;
            $rootScope.$broadcast('customMessageBuilder', customMsg);
        };

        emailService.getRecipients(1).then(function (data) {
            console.log("Get recipient emails.");
            $scope.recipientemails = data;
            console.log("Recipients length = "+$scope.recipientemails.length);
            console.log("Recipients length = "+$scope.recipientemails[0].emailaddress);
        }, function (error) {
            console.log(error);
            $scope.errorMessage = "ERROR occured while getting recipeints data!!!";
            $scope.recipientemails = [];
        });


        $scope.hide = function () {
            $mdDialog.hide();
        };

        $scope.cancel = function () {
            $mdDialog.cancel();
        };
        
        $scope.hideRightPanel = false;

        $scope.toggleHelpPanel = function () {
            $scope.hideRightPanel = !($scope.hideRightPanel);
        };

        $scope.callpopupTenats = function(event) {
            $mdDialog.show({
                skipHide: true,
                preserveScope: true,
                controller: tenantListCtr,
                bindToController: true,
                templateUrl: 'core/components/administration/policy/tenants.html',
                parent: angular.element(document.body),
                targetEvent: event,
                fullscreen: false,
                scope: $scope,
                openFrom: { top: 1100, height: 0 },
                closeTo: { left: 1500 }
            }).then(function() {

            });
        };


        function tenantListCtr($scope, $mdDialog, policyService) {
             $scope.tenantselected = false;
             $scope.selectedTenantsValue = '';
            $scope.canceltenantDialogue = function() {
                //tenantSelection();
                $mdDialog.cancel();
            };
            $scope.tenantSelected = false;
            $scope.tenants = $scope.tenantsList;
            $scope.onSelectTenantChanged = function() {
                console.log(" onSelectionChanged >> ");
                $scope.tenantSelected = true;
            };
            $scope.tenantdone = function(value) {
                $scope.tenantselected = true;
                $scope.selectedTenantObj = JSON.parse(value);
                $mdDialog.hide();
            };
        }

        $scope.getTenantDataForCloud = function(cloudObj) {
            
            console.log("getTenantDataForCloud called for cloud "+cloudObj);
            
            $scope.tenantsList = [];
            policyService.getDataBasedOnId("infras", cloudObj.id + "/tenants", "").then(function(tenants) {
                
                _.each(tenants, function(tenant) {
                    console.log("getTenantDataForCloud : Cloud Name = "+cloudObj.name);
                    tenant.cloudName = cloudObj.name;
                    $scope.tenantsList.push(tenant);
                });
                $scope.cloudsLength = $scope.cloudsLength -1;
                if($scope.cloudsLength === 0){
                    $scope.tennatsListCompleted = false;    
                }
            });
            
            console.log("tenantsList contains "+$scope.tenantsList);
        };

        $scope.getTenants = function() {
            console.log("getTenants() called ...");
            infrastructureConnectorService.getListOfInfrastructures().then(function(clouds) {
                $scope.cloudsLength = clouds.length;
                _.each(clouds, function(cloud) {
                    $scope.getTenantDataForCloud(cloud);
                });
            });
        };
        $scope.getTenants();
        
        $scope.callpopupAddRecipients = function(event) {
            $mdDialog.show({
                skipHide: true,
                preserveScope: true,
                controller: addRecipientsCtr,
                bindToController: true,
                templateUrl: 'core/components/administration/notification/add-recipient.html',
                parent: angular.element(document.body),
                targetEvent: event,
                fullscreen: false,
                scope: $scope,
                openFrom: { top: 1100, height: 0 },
                closeTo: { left: 1500 }
            }).then(function() {

            });
        };


        //////////////////     Start Add Recipients   //////////////////
        function addRecipientsCtr($rootScope, $scope) {
                      
            $scope.recipient = {};

            $scope.recipient.name='';
            $scope.recipient.emailaddress='';

            $scope.recipient.recipeintEmails = 'addRecipientsCtr';

            $scope.addRecipientEmail = function () {

                console.log(" Add recipient email -->> "+$scope.recipient);

                var recipientvo = $scope.recipient;

                //var tenantId = $scope.selectedTenantObj.id;
                var tenantId = 1;
                console.log("Tenant Id = "+tenantId);

                recipientvo.tenantId = tenantId;

                var recipientCreated = {
                    'heading': 'Add Recipient Email',
                    'subHeading': 'Recipient email has been saved successfully.',
                    'type': 'success',
                    'timeout': 2000,
                    'callback': function () {
                        $state.reload();
                    }
                };

                emailService.addRecipient(tenantId, recipientvo).then(function (data) {
                    console.log(" Recipient details has been saved.");
                    showToast(recipientCreated);
                    if (data) {
                        var newData = recipientvo;
                        console.log(newData);
                    }
                }, function (error) {
                    var failed = {
                        'heading': 'Failed to add email recipient.',
                        'subHeading': "Error: " + error.data.message,
                        'type': 'fail',
                        'timeout': 3000
                    };
                    showToast(failed);
                });
                $mdDialog.hide();
            };


            $scope.cancelAddRecipientDialog = function() {
                $mdDialog.cancel();
            };
        }

        //////////////////     End email notification configuration   //////////////////

    }

    angular.module('shieldxApp').controller('emailnotificationCtr', emailnotificationCtr);
})();        
(function () {
    function notificationSettingsCtr(
        $scope,
        $state,
        $q
    ) {

        $scope.$emit('listenHeaderText', { headerText: "Notification" });
		
        var url = $state.current.url;        
		console.log(" Notification Controller : url -->> "+url);
		if(url.indexOf("syslog") > 0 ) {
            $state.go('home.notification.settings.syslog');    
        } else if(url.indexOf("email") > 0 ) {
            $state.go('home.notification.settings.email');    
        } else {
            $state.go('home.notification.settings.syslog');    
        }
		
        $scope.$on('$stateChangeSuccess', function(event, toState, toParams, fromState, fromParams) {
            if (toState.data) {
                $scope.currentTab = toState.data.selectedTab;
            }

        });
        
        $scope.$on('$viewContentLoaded', function (event) {
            fixContainerHeight(1);
        });

    }
    angular.module('shieldxApp').controller('notificationSettingsCtr', notificationSettingsCtr);
})();
(function() {
    function notificationCtr(
        $scope
        
    ) {

        $scope.$emit('listenHeaderText', { headerText: "Notification" });    

    }

    angular.module('shieldxApp').controller('notificationCtr', notificationCtr);
})();

(function() {
    function syslogforwarderCtr(
        $scope,
        $rootScope,
        $http,
        $state,
        $translate,
        $sessionStorage,
        infrastructureConnectorService, 
		policyService,
        syslogForwardingService,      
        $timeout,
        $q,
        $mdDialog
    ) {
        "ngInject";

        clearAllSession($sessionStorage);
        
        var deferred = $q.defer();
        $scope.promise = deferred.promise; 
        $scope.promiseCompleted = true;
        
        var promiseCtr = 0;
        var totalClouds = 0;
        var totalSyslogProfiles = 0;
        var syslogProfilesData = [];
        $scope.syslogProfilesAvailable = false;
        var syslogServersData = [];
        $scope.editMiscState = false;

        var syslogKeysCtr = 0;
        $scope.syslogProfiles = [];

        $scope.syslogServerProfiles= [];        

        $scope.$emit('listenHeaderText', { headerText: "Notification" });    


        ///////////// Tables Start  //////////////
        $scope.selected = [];
        $scope.query = {
            order: 'profilename',
            limit: 5,
            page: 1
        };

        $scope.isAdornmentPanelOpen = false;
        $scope.isSearchBarOpen = false;

        $scope.updateAdornmentPanel = function (event, rowData) {
            $scope.toggleAdornmentPanel();
            $scope.adornmentData = rowData;
            console.log($scope.adornmentData);
        };

        $scope.toggleAdornmentPanel = function () {
            $scope.isAdornmentPanelOpen = $scope.isAdornmentPanelOpen === false ? true : false;
        };

        $scope.toggleSearchBar = function (event) {
            $scope.isSearchBarOpen = $scope.isSearchBarOpen === false ? true : false;
            if ($scope.isSearchBarOpen)
                angular.element(event.currentTarget.firstElementChild).css('color', '#4a90e2');
            else
                angular.element(event.currentTarget.firstElementChild).css('color', '#6d6e71');
        };            
        ////////// Tables end /////////
        

        
        ///////////     Get All Syslog Forwarder config Profiles ////////////////
        $sessionStorage.syslogProfilesList = [];

        syslogForwardingService.getSyslogProfiles(1).then(function (data) {
            console.log("Get Syslog forwarder config profiles for tenant id 1.");
            totalSyslogProfiles = data.length;
            if (totalSyslogProfiles === 0) {
                deferred.resolve();
                $scope.promiseCompleted = false;
                $scope.syslogProfilesAvailable = false;
            } else {
                $scope.syslogProfilesAvailable = true;
                $scope.promiseCompleted = false;
                deferred.resolve();
                var profileName = "";
                for (var i = 0; i < data.length; i++) {

                    profileName = data[i].profilename;
                    console.log(" Syslog Profile Name = "+profileName);
                    syslogProfilesData[i] = data[i];

                }
                $scope.syslogProfiles = syslogProfilesData;
                console.log(syslogProfilesData);
            }

        }, function (error) {
            console.log(error);
            $scope.errorMessage = "ERROR occured while getting Syslog Profiles List!!!";
            syslogProfilesData = [];
            $scope.syslogProfiles = [];
            deferred.resolve();
            $scope.promiseCompleted = false;
            $scope.syslogProfilesAvailable = false;
        });


        $scope.deleteSyslogProfile = function (data) {

            var startDeleteSyslogForwarderProfile = {
                'heading': 'Delete Syslog Forwarder Profile',
                'subHeading': 'This should take only a few minutes max.',
                'type': 'progress',
                'timeout': 5000
            };
            var successfulDeletedSyslogForwarderProfile = {
                'heading': 'Syslog forwarder deleted',
                'subHeading': 'Syslog forwarder deleted successfully.',
                'type': 'success',
                'timeout': 5000,
                'callback': function () {
                    $state.reload();
                }
            };
            showToast(startDeleteSyslogForwarderProfile);
            syslogForwardingService.deleteSyslogProfile(1).then(function (data) {
                console.log(" Delete Syslog forwarder profile.");
                if (data) {
                    showToast(successfulDeletedSyslogForwarderProfile);
                }
            }, function (error) {
                var failureSyslogForwarderDeletion = {
                    'heading': 'Syslog forwarder deletion failed',
                    'subHeading': "Error: " + error.data.message,
                    'type': 'fail',
                    'timeout': 10000
                };
                showToast(failureSyslogForwarderDeletion);
            });
        };


        $scope.clearSyslogProfilesListFromSession = function () {
            clearMasterSession($sessionStorage, $state);
        };

            	
        $scope.callpopupToAddNewSyslogForwarder = function(ev) {

            console.log(" callpopupToAddNewSyslogForwarder called.."+ev);

            $mdDialog.show({
                //skipHide: true,
                controller: addSyslogForwarderCtr,
                //bindToController: true,
                templateUrl: 'core/components/administration/notification/add-syslog-profile.html',
                parent: angular.element(document.body),
                targetEvent: ev,
                fullscreen: true,
                //scope: $scope,
                openFrom: { top: 1100, height: 0 },
                closeTo: { left: 1500 }
            }).then(function() {
                console.log("**** failed to open popup");
            });
        };


        //////////////////     Start Syslog Forwarder Profile  Configuration  //////////////////
        //FUNCTIONALITY TO ADD Syslog Forwarder
        function addSyslogForwarderCtr($rootScope, $scope, $sessionStorage){            
            
            $scope.active_help_id = "user_type_help_wizard";
            $scope.helpButtonClicked = function(id){
                $scope.active_help_id = id;
                console.log("  helpButtonClicked ");
                $scope.bordcastEventHelpButtonClicked($scope.active_help_id);
            }; 
            
            $scope.bordcastEventHelpButtonClicked = function(helpId){
                $scope.$broadcast('onHelpButtonClicked', {
                 helpIDString: helpId 
                });
            };                 

            $scope.syslogprofile = {};
            $scope.syslogprofile.profilename = "";
            $scope.syslogprofile.serverProfileName ="";
            $scope.syslogprofile.messagepref=$translate.instant("admin.setup.syslog.default.message");

            $scope.syslogprofile.serverProfileId=0;
            /*$scope.syslogServerProfiles = {'profiles': [{ "serverProfileId": 1, "name": "Server-Profile-1", "tagetserver": "172.16.33.43", "port":"514", "protocol":"UDP" }, 
                                                    { "serverProfileId": 2, "name": "Test-Profile-2", "tagetserver": "172.16.35.144", "port":"514", "protocol":"UDP" }]};
            */
            $scope.syslogprofile.facility = 0;
            $scope.facilityList = {'facilities': [{ "id": 0, "name": "kernel messages"}, 
                                                    { "id": 1, "name": "user-level messages"}, 
                                                    { "id": 2, "name": "mail system"}, 
                                                    { "id": 3, "name": "System daemons"}, 
                                                    { "id": 4, "name": "security/authorization messages"}, 
                                                    { "id": 6, "name": "line printer subsystem"},
                                                    { "id": 7, "name": "network news subsystem"},
                                                    { "id": 8, "name": "UUCP subsystem"},
                                                    { "id": 9, "name": "clock daemon"},
                                                    { "id": 10, "name": "security authorization messages"}
                                                    ]};

            $scope.syslogprofile.logtype = 0;
            $scope.logtypeList = {'logtypes': [{ "id": 0, "name": "ShieldX Alerts"}, 
                                                    { "id": 1, "name": "ShieldX Events"}, 
                                                    { "id": 2, "name": "ShieldX Logs"} ]};

            $scope.syslogprofile.severityLevelLow = 6;
            $scope.syslogprofile.severityLevelMedium = 5;
            $scope.syslogprofile.severityLevelHigh = 4;
            $scope.syslogprofile.severityLevelCritical = 2;
            $scope.severityLevels = {'severities': [{ "id": 0, "name": "Emergency: system is unusable"}, 
                                                    { "id": 1, "name": "Alert: action must be taken immediately"}, 
                                                    { "id": 2, "name": "Critical: critical conditions"}, 
                                                    { "id": 3, "name": "Error: error conditions"}, 
                                                    { "id": 4, "name": "Warning: warning conditions"}, 
                                                    { "id": 5, "name": "Notice: normal but significant condition"}, 
                                                    { "id": 6, "name": "Informational: informational messages"},
                                                    { "id": 7, "name": "Debug: debug messages"}]};

            var messagetoken = $translate.instant("admin.setup.syslog.message.tokens");                                     
            //$scope.syslogMsgTokens = messagetoken.split(",");
            $scope.syslogMsgTokens = [
                            {"tokenkey":"$TIMESTAMP$","value":"TIMESTAMP"},
                            {"tokenkey":"$EVENT_TYPE$","value":"EVENT_TYPE"},
                            {"tokenkey":"$THREAT_NAME$","value":"THREAT_NAME"},
                            {"tokenkey":"$SEVERITY$","value":"SEVERITY"},
                            {"tokenkey":"$DESTINATION_IP$","value":"DESTINATION_IP"},
                            {"tokenkey":"$DESTINTATION_PORT$","value":"DESTINTATION_PORT"},
                            {"tokenkey":"$DESTINATION_VM_NAME$","value":"DESTINATION_VM_NAME"},
                            {"tokenkey":"$DESTINATION_OS$","value":"DESTINATION_OS"},
                            {"tokenkey":"$DESTINATION_MAC_ADDRESS$","value":"DESTINATION_MAC_ADDRESS"},
                            {"tokenkey":"$DESTINATION_RESOURCE_GROUP$","value":"DESTINATION_RESOURCE_GROUP"},
                            {"tokenkey":"$SOURCE_IP$","value":"SOURCE_IP"},
                            {"tokenkey":"$SOURCE_PORT$","value":"SOURCE_PORT"},
                            {"tokenkey":"$SOURCE_MAC_ADDRESS$","value":"SOURCE_MAC_ADDRESS"},
                            {"tokenkey":"$SOURCE_OS$","value":"SOURCE_OS"},
                            {"tokenkey":"$SOURCE_RESOURCE_GROUP$","value":"SOURCE_RESOURCE_GROUP"},
                            {"tokenkey":"$SOURCE_VM_NAME$","value":"SOURCE_VM_NAME"},
                            {"tokenkey":"$PROTOCOL_NAME$","value":"PROTOCOL_NAME"},
                            {"tokenkey":"$APPLICATION_NAME$","value":"APPLICATION_NAME"},
                            {"tokenkey":"$POLICY_TYPE$","value":"POLICY_TYPE"},
                            {"tokenkey":"$POLICY_NAME$","value":"POLICY_NAME"},
                            {"tokenkey":"$SECURITY_POLICY_SET$","value":"SECURITY_POLICY_SET"},
                            {"tokenkey":"$RESULT_STATUS$","value":"RESULT_STATUS"},
                            {"tokenkey":"$ACTION_TAKEN$","value":"ACTION_TAKEN"},
                            {"tokenkey":"$PACKET_ID$","value":"PACKET_ID"},
                            {"tokenkey":"$ATTACKER_IP$","value":"ATTACKER_IP"},
                            {"tokenkey":"$ATTACKER_RESOURCE_GROUP$","value":"ATTACKER_RESOURCE_GROUP"},
                            {"tokenkey":"$VICTIM_IP$","value":"VICTIM_IP"},
                            {"tokenkey":"$VICTIM_RESOURCE_GROUP$","value":"VICTIM_RESOURCE_GROUP"},
                            {"tokenkey":"$MANAGEMENT_RESPONSE$","value":"MANAGEMENT_RESPONSE"},
                            {"tokenkey":"$SENSOR_RESPONSE$","value":"SENSOR_RESPONSE"},
                            {"tokenkey":"$DOMAIN$","value":"DOMAIN"},
                            {"tokenkey":"$DOMAIN_TAG$","value":"DOMAIN_TAG"},
                            {"tokenkey":"$CERTIFICATE_TAG$","value":"CERTIFICATE_TAG"},
                            {"tokenkey":"$FILE_SIGNATURE$","value":"FILE_SIGNATURE"},
                            {"tokenkey":"$FILE_HASH$","value":"FILE_HASH"},
                            {"tokenkey":"$START_TIME$","value":"START_TIME"},
                            {"tokenkey":"$END_TIME$","value":"END_TIME"},
                            {"tokenkey":"$TCP_SESSION_START_EVENT$","value":"TCP_SESSION_START_EVENT"},
                            {"tokenkey":"$TCP_SESSION_END_EVENT$","value":"TCP_SESSION_END_EVENT"},
                            {"tokenkey":"$TCP_RECV_FLAGS$","value":"TCP_RECV_FLAGS"},
                            {"tokenkey":"$TCP_SENT_FLAGS$","value":"TCP_SENT_FLAGS"},
                            {"tokenkey":"$BYTES_RECEIVED$","value":"BYTES_RECEIVED"},
                            {"tokenkey":"$BYTES_SENT$","value":"BYTES_SENT"},
                            {"tokenkey":"$EVENTS_SENT_COUNT$","value":"EVENTS_SENT_COUNT"},
                            {"tokenkey":"$EVENTS_RECV_COUNT$","value":"EVENTS_RECV_COUNT"},
                            {"tokenkey":"$IOP_THREAT_NAME$","value":"IOP_THREAT_NAME"},
                            {"tokenkey":"$IOP_THREAT_TIMESTAMP$","value":"IOP_THREAT_TIMESTAMP"},
                            {"tokenkey":"$IOP_RULE_ID$","value":"IOP_RULE_ID"},
                            {"tokenkey":"$IOP_DETECTION_ID$","value":"IOP_DETECTION_ID"},
                            {"tokenkey":"$CHASSIS_ID$","value":"CHASSIS_ID"},
                            {"tokenkey":"$MICROSERVICE_TYPE$","value":"MICROSERVICE_TYPE"},
                            {"tokenkey":"$MICROSERVICE_INSTANCE_ID$","value":"MICROSERVICE_INSTANCE_ID"}
                        ];

            $scope.msgTokensPerRow = 6;     

            function messageTokensCtr($rootScope, $scope) {
                $scope.getMessageTokens = function() {

                    $http.get('message-tokens.json').success(function(data) {

                        $scope.syslogMsgTokens = data;

                    });

                    console.log("Message Tokens = "+$scope.syslogMsgTokens);
                };
            }

            $scope.customMessageBuilder = function(customMsg){
                console.log("Message Token -->> "+customMsg);                             
                //$scope.messagepref=customMsg;
                $rootScope.$broadcast('customMessageBuilder', customMsg);
            }; 

            $scope.hide = function () {
                $mdDialog.hide();
            };

            $scope.cancel = function () {
                $mdDialog.cancel();
            };
            
            $scope.hideRightPanel = false;

            $scope.toggleHelpPanel = function () {
                $scope.hideRightPanel = !($scope.hideRightPanel);
            };


            ///////////     Get All Syslog Server Profiles ////////////////
            $sessionStorage.syslogServersList = [];
            syslogForwardingService.getSyslogServerProfiles(1).then(function (data) {
                console.log("!!!!!!Get Syslog Server profiles for tenant id 1.");

                $scope.syslogServerProfiles = data;

                /*_.each($scope.syslogServerProfiles, function(value, key) {
                    console.log("!!!!!! Server profile Name -->> "+value.serverProfileName);
                    console.log("!!!!!! Server profile Id -->> "+value.serverProfileId);
                    console.log("!!!!!! Server port -->> "+value.port);
                });
                */
            }, function (error) {
                console.log(error);
                $scope.errorMessage = "ERROR occured while getting Syslog Server Profiles List!!!";
                $scope.serverprofiles = [];
            });

            $scope.addSyslogForwarderProfile = function () {
                
                console.log(" Add Syslog Forwader -->> "+$scope.syslogprofile);
                
                var syslogFwdProfile = $scope.syslogprofile;

                var sevLevelLow = syslogFwdProfile.severityLevelLow;
                var sevLevelMed = syslogFwdProfile.severityLevelMedium;
                var sevLevelHigh = syslogFwdProfile.severityLevelHigh;
                var sevLevelCritical = syslogFwdProfile.severityLevelCritical;
                var sevLevels = sevLevelLow+","+sevLevelMed+","+sevLevelHigh+","+sevLevelCritical;
                syslogFwdProfile.severityLevels = sevLevels;
                console.log("Server Profile Id = "+syslogFwdProfile.serverProfileId);
                var serverprofile = syslogFwdProfile.serverProfileId.split(":");
                console.log("Syslog Server Profile Id = "+serverprofile[0]+" , Profile Name = "+serverprofile[1]);
                syslogFwdProfile.serverProfileId = parseInt(serverprofile[0]);
                syslogFwdProfile.serverProfileName = serverprofile[1];
                var tenantId = 1;
                syslogFwdProfile.tenantId = tenantId;

                var startAddSyslogForwarderMessage = {
                    'heading': 'Add Syslog Forwarding Profile',
                    'subHeading': 'Add syslog forwarding profile in progess.',
                    'type': 'progress',
                    'timeout': 2000
                };

                var successfulSyslogForwarderMessage = {
                    'heading': 'Syslog Forwarding Profile Created',
                    'subHeading': 'Syslog forwarding profile created successfully.Reloading the page please wait...',
                    'type': 'success',
                    'timeout': 2000,
                    'callback': function () {
                        $state.reload();
                    }
                };
                showToast(startAddSyslogForwarderMessage);
                syslogForwardingService.createSyslogProfile(tenantId, syslogFwdProfile).then(function (data) {
                    console.log(" Add Syslog forwarder profile.");
                    if (data) {
                        var newData = syslogFwdProfile;
                        console.log(syslogProfilesData);
                        showToast(successfulSyslogForwarderMessage);
                    
                        syslogProfilesData.unshift(newData);
                        console.log(syslogProfilesData);
                        $sessionStorage.syslogProfilesList = syslogProfilesData;
                        $scope.syslogProfiles=syslogProfilesData;
                        $rootScope.$broadcast('newSyslogForwarderCreated', {});
                    }
                }, function (error) {
                    console.log("Failed to create syslog forwarding profile, "+error.data.message);
                    var failureSyslogForwarderCreation = {
                        'heading': 'Syslog forwarding profile creation failed',
                        'subHeading': "Error: " + error.data.message,
                        'type': 'fail',
                        'timeout': 3000
                    };
                    showToast(failureSyslogForwarderCreation);
                });
                $mdDialog.hide();
            };

            $scope.isFormValid = function () {
                //validate form data
                //console.log($scope.syslogprofile);
                //console.log($scope.syslogprofile.profilename);
                //console.log($scope.syslogprofile.messagepref);
                if ($scope.syslogprofile.profilename && $scope.syslogprofile.serverProfileId && $scope.syslogprofile.messagepref) {
                    return true;
                } else {
                    return false;
                }            
            };

            $scope.callpopupTenats = function(event) {
                $mdDialog.show({
                    skipHide: true,
                    preserveScope: true,
                    controller: tenantListCtr,
                    bindToController: true,
                    templateUrl: 'core/components/administration/policy/tenants.html',
                    parent: angular.element(document.body),
                    targetEvent: event,
                    fullscreen: false,
                    scope: $scope,
                    openFrom: { top: 1100, height: 0 },
                    closeTo: { left: 1500 }
                }).then(function() {

                });
            };

            /*function tenantListCtr($scope, $mdDialog, policyService) {
                $scope.canceltenantDialogue = function() {
                    //tenantSelection();
                    $mdDialog.cancel();
                };
                $scope.tenantSelected = false;
                policyService.getTenantsBasedonId("infras/1/tenants").then(function(res) {
                    $scope.tenants = res;
                }, function(err) {
                    $scope.tenants = [{ "cloudId": 1, "id": 1, "name": "default-tenant" }, { "cloudId": 1, "id": 2, "name": "tenant-2" }];
                    console.log("to get list of tenants failed");
                });
                $scope.$watch("selectedTenantsValue", function(newvalue, oldvalue) {
                    if (newvalue) {
                        $scope.tenantSelected = true;
                        $scope.selectedTenantObj = _.each($scope.tenants, function(value, key) {
                            if (value.id === parseInt($scope.selectedTenantsValue)) {
                                return value;
                            }
                        });
                        $scope.selectedTenantObj = $scope.selectedTenantObj[0];
                    }

                });
                $scope.tenantdone = function() {
                    //tenantSelection();
                    $mdDialog.cancel();
                };

            }*/

            function tenantListCtr($scope, $mdDialog, policyService) {
                 $scope.tenantselected = false;
                 $scope.selectedTenantsValue = '';
                $scope.canceltenantDialogue = function() {
                    //tenantSelection();
                    $mdDialog.cancel();
                };
                $scope.tenantSelected = false;
                $scope.tenants = $scope.tenantsList;
                $scope.onSelectTenantChanged = function() {
                    console.log(" onSelectionChanged >> ");
                    $scope.tenantSelected = true;
                };
                $scope.tenantdone = function(value) {
                    $scope.tenantselected = true;
                    $scope.selectedTenantObj = JSON.parse(value);
                    $mdDialog.hide();
                };
            }

			$scope.getTenantDataForCloud = function(cloudObj) {
				
				console.log("getTenantDataForCloud called for cloud "+cloudObj);
				
				$scope.tenantsList = [];
				policyService.getDataBasedOnId("infras", cloudObj.id + "/tenants", "").then(function(tenants) {
					
					_.each(tenants, function(tenant) {
						console.log("getTenantDataForCloud : Cloud Name = "+cloudObj.name);
						tenant.cloudName = cloudObj.name;
						$scope.tenantsList.push(tenant);
					});
					$scope.cloudsLength = $scope.cloudsLength -1;
					if($scope.cloudsLength === 0){
						$scope.tennatsListCompleted = false;    
					}
				});
				
				console.log("tenantsList contains "+$scope.tenantsList);
			};

			$scope.getTenants = function() {
				console.log("getTenants() called ...");
				infrastructureConnectorService.getListOfInfrastructures().then(function(clouds) {
					$scope.cloudsLength = clouds.length;
					_.each(clouds, function(cloud) {
						$scope.getTenantDataForCloud(cloud);
					});
				});
			};
			$scope.getTenants();
			
            $scope.callpopupAddServerProfile = function(event) {
                $mdDialog.show({
                    skipHide: true,
                    preserveScope: true,
                    controller: serverProfilesListCtr,
                    bindToController: true,
                    templateUrl: 'core/components/administration/notification/add-server-profile.html',
                    parent: angular.element(document.body),
                    targetEvent: event,
                    fullscreen: false,
                    scope: $scope,
                    openFrom: { top: 1100, height: 0 },
                    closeTo: { left: 1500 }
                }).then(function() {

                });
            };

            //////////////////     Start Syslog Server Profile   //////////////////
            function serverProfilesListCtr($rootScope, $scope) {
                
                $scope.serverProfileSelected = false;
                
                $scope.serverprofile = {};

                $scope.serverprofile.protocol='2';
                $scope.protocoltypes = {
                    'protocols': [
                        {'name': 'TCP', 'value': '1'},
                        {'name': 'UDP', 'value': '2'}
                    ]
                };
                
                $scope.serverprofile.serverProfileName = "";
                $scope.serverprofile.serverFqdnOrIp = "";
                $scope.serverprofile.port = "";
                $scope.serverprofile.usessl = "";
                $scope.serverprofile.certFile = "";

                $scope.serverprofile.targetServerProfile='serverProfilesListCtr';

                $scope.cancelServerProfileDialog = function() {
                    //tenantSelection();
                    $mdDialog.cancel();
                };
                

                $scope.addSyslogServerProfile = function () {
                    
                    console.log(" Add Syslog Server Profile -->> "+$scope.serverprofile);
                    
                    var syslogServerProfile = $scope.serverprofile;

                    var tenantId = 1;
                    syslogServerProfile.tenantId = tenantId;

                    var startAddSyslogServerMessage = {
                        'heading': 'Create Syslog Server Profile',
                        'subHeading': 'This should take only a few minutes max.',
                        'type': 'progress',
                        'timeout': 5000
                    };
                    var successfulSyslogServerMessage = {
                        'heading': 'Syslog Server Created',
                        'subHeading': 'Syslog Server created successfully.',
                        'type': 'success',
                        'timeout': 5000
                    };
                    showToast(startAddSyslogServerMessage);
                    syslogForwardingService.createSyslogServerProfile(tenantId, syslogServerProfile).then(function (data) {
                        console.log(" Add Syslog Server profile.");
                        if (data) {
                            var newData = syslogServerProfile;
                            console.log(syslogServersData);
                            showToast(successfulSyslogServerMessage);
                        
                            syslogServersData.unshift(newData);
                            console.log(syslogServersData);
                            $sessionStorage.syslogServersList = syslogServersData;
                            $scope.syslogServerProfiles=syslogServersData;
                            //$rootScope.$broadcast('newSyslogServerCreated', {});
                        }
                    }, function (error) {
                        var failureSyslogServerCreation = {
                            'heading': 'Syslog Server creation failed',
                            'subHeading': "Error: " + error.data.message,
                            'type': 'fail',
                            'timeout': 10000
                        };
                        showToast(failureSyslogServerCreation);
                    });
                    $mdDialog.hide();
                };
               
                $scope.serverprofileCreated = function() {
                    //tenantSelection();
                    $mdDialog.cancel();
                };

                $scope.fileNameChanged =  function(element){
                    $scope.fileInputText = element.files[0].name;
                };                
            }
            //////////////////     End Syslog Server Profile   //////////////////


        } //End addSyslogForwarderCtr
        //////////////////     End Syslog Fowarder Configuration   //////////////////

        		
        $scope.$on('newSyslogForwarderCreated', function (event) {
            console.log($scope.query);
            $scope.query.page = 1;
        });
        $scope.$on('$viewContentLoaded', function (event) {
            console.log(event);
            fixContainerHeight(1);
        });        
    }

    angular.module('shieldxApp').controller('syslogforwarderCtr', syslogforwarderCtr);
})();

/*
 ShieldX Networks Inc. CONFIDENTIAL
 ----------------------------------
 *
 Copyright (c) 2016 ShieldX Networks Inc.
 All Rights Reserved.
 *
 NOTICE: All information contained herein is, and remains
 the property of ShieldX Networks Incorporated and its suppliers,
 if any. The intellectual and technical concepts contained
 herein are proprietary to ShieldX Networks Incorporated
 and its suppliers and may be covered by U.S. and Foreign Patents,
 patents in process, and are protected by trade secret or copyright law.
 Dissemination of this information or reproduction of this material
 is strictly forbidden unless prior written permission is obtained
 from ShieldX Networks Incorporated.
 */

(function () {
    function quickSetupCtr($scope,
            $translate,
            sideNav,
            $location,
            $state) {
        "ngInject";

        $scope.$emit('listenHeaderText', {headerText: $translate.instant('quicksetup.header.quick_setup')});


        $scope.quicksetup_heading = $translate.instant('quicksetup.heading.create_detect_protect');
        $scope.quicksetup_subheading = $translate.instant('quicksetup.subheading.our_wizard_will_get_you_setup_started_as_quick_as_flash');
        $scope.administration = $translate.instant('wizardbreadcrumb.label.administration');
        $scope.quicksetup = $translate.instant('wizardbreadcrumb.label.quicksetup');
        $scope.provide_infrastructure_access = $translate.instant('wizardbreadcrumb.label.provide_infrastructure_access');
        $scope.specifiy_ip_addressing = $translate.instant('wizardbreadcrumb.label.specifiy_ip_addressing');
        $scope.create_deployment_specification = $translate.instant('wizardbreadcrumb.label.create_deployment_specification');
        $scope.create_virtual_chassis = $translate.instant('wizardbreadcrumb.label.create_virtual_chassis');
        $scope.networks_to_monitor_in_chassis = $translate.instant('wizardbreadcrumb.label.networks_to_monitor_in_chassis');
        $scope.back = $translate.instant('wizardbreadcrumb.label.back');
        $scope.next = $translate.instant('wizardbreadcrumb.label.next');
        $scope.commit = $translate.instant('wizardbreadcrumb.label.commit');
        $scope.configure_management_network = $translate.instant('wizardbreadcrumb.label.configure_management_network');
        $scope.configure_backplane_network = $translate.instant('wizardbreadcrumb.label.configure_backplane_network');

        $scope.headerValues = [];
        $scope.toggleRight = sideNav.buildToggler('right');
        $scope.hideRightPanel = false;

        $scope.prevState = null;
        $scope.nextState = null;

        $scope.prevEnableState = true;
        $scope.nextEnableState = false;
        $scope.activeScreenName = 'infrastructure-connector';
        
        $scope.showVchassisCreationInProgress = false;

        $scope.maximize = false;
        
        $scope.breadcrumbs = {
            '/quickSetup/infrastructure-connector': {
                'name': 'infrastructure-connector',
                'text': $scope.provide_infrastructure_access,
                'url': '/quickSetup/infrastructure-connector',
                'prev': 'home.quickSetup.quickSetup-begin',
                'next': 'home.quickSetup.ip-pools-management',
                'step': 1
            },
            '/quickSetup/ip-pools-management': {
                'name': 'ip-pools-management',
                'text': $scope.configure_management_network,
                'url': '/quickSetup/ip-pools-management',
                'prev': 'home.quickSetup.infrastructure-connector',
                'next': 'home.quickSetup.ip-pools-backplane',
                'step': 2
            },
            '/quickSetup/ip-pools-backplane': {
                'name': 'ip-pools-backplane',
                'text': $scope.configure_backplane_network,
                'url': '/quickSetup/ip-pools-backplane',
                'prev': 'home.quickSetup.ip-pools-management',
                'next': 'home.quickSetup.deployment-specifications',
                'step': 3
            },
            '/quickSetup/deployment-specifications': {
                'name': 'deployment-specifications',
                'text': $scope.create_deployment_specification,
                'url': '/quickSetup/deployment-specifications',
                'prev': 'home.quickSetup.ip-pools-backplane',
                'next': 'home.quickSetup.virtual-chassis',
                'step': 4
            },
            '/quickSetup/virtual-chassis': {
                'name': 'virtual-chassis',
                'text': $scope.create_virtual_chassis,
                'url': '/quickSetup/virtual-chassis',
                'prev': 'home.quickSetup.deployment-specifications',
                'next': 'home.quickSetup.monitor-networks',
                'step': 5
            },
            '/quickSetup/monitor-networks': {
                'name': 'monitor-networks',
                'text': $scope.networks_to_monitor_in_chassis,
                'url': '/quickSetup/monitor-networks',
                'prev': 'home.quickSetup.virtual-chassis',
                'next': null,
                'step': 6
            }
        };
        $scope.$on('$viewContentLoaded', function (event) {
            if (typeof $scope.breadcrumbs[$location.path()] != 'undefined') {
                $scope.activeScreenName = $scope.breadcrumbs[$location.path()].name;
                $scope.updateBreadcrumbUI();
            }
        });

        $scope.$on('fullscreen', function (event, data) {
            $scope.maximize = !$scope.maximize;
        });

        $scope.updateBreadcrumbUI = function () {
            if (!document.querySelector('.quick-setup-steper'))
                return;
            //get width of parent section
            var qsStepperWidth = angular.element(document.querySelector('.quick-setup-steper'))[0].getBoundingClientRect().width;
            //position of active crumb
            //var activeCrumbPos = angular.element(document.querySelector('.currentPage')).prop('offsetLeft');
            //width of active crumb
            //var activeCrumbWidth = angular.element(document.querySelector('.currentPage'))[0].getBoundingClientRect().width;
            var avgElemWidth = 230;
            if (($scope.breadcrumbs[$location.path()].step * avgElemWidth) > qsStepperWidth * 0.75) {
                if ($scope.breadcrumbs[$location.path()].step >= 5) {
                    angular.element(document.querySelector('.content-mask')).css('left', (qsStepperWidth - 1390) + 'px');
                    angular.element(document.querySelector('.left-mask')).css('visibility', 'visible');
                    angular.element(document.querySelector('.right-mask')).css('visibility', 'hidden');
                }
            } else if (($scope.breadcrumbs[$location.path()].step * avgElemWidth) < qsStepperWidth * 0.75) {
                if ($scope.breadcrumbs[$location.path()].step <= 3) {
                    angular.element(document.querySelector('.content-mask')).css('left', 0 + 'px');
                    angular.element(document.querySelector('.left-mask')).css('visibility', 'hidden');
                    angular.element(document.querySelector('.right-mask')).css('visibility', 'visible');
                }
            }

        };

        //to dynamically position right mask
        $scope.getPos = function () {
            var qsStepperWidth = angular.element(document.querySelector('.quick-setup-steper'))[0].getBoundingClientRect().width;
            return 'left:' + (qsStepperWidth - 200) + 'px';
        };

        $scope.getPrevPage = function () {
            $scope.prevState = $scope.breadcrumbs[$location.path()].prev;
            if ($scope.prevState === "home.quickSetup.quickSetup-begin") {
                $scope.$emit('quickSetupEnded', {});
            }
            $state.go($scope.prevState);

        };

        $scope.getNextPage = function () {
            $scope.nextState = $scope.breadcrumbs[$location.path()].next;
            $state.go($scope.nextState);
            $scope.disableNextButton();

        };

        $scope.showBreadCrumb = function () {
            return angular.isDefined($scope.breadcrumbs[$location.path()]);
        };

        $scope.showPrev = function () {
            return ($scope.breadcrumbs[$location.path()] && $scope.breadcrumbs[$location.path()].prev);
        };

        $scope.showNext = function () {
            return ($scope.breadcrumbs[$location.path()] && $scope.breadcrumbs[$location.path()].next);
        };

        $scope.showCommit = function () {
            return ($scope.breadcrumbs[$location.path()] && $scope.breadcrumbs[$location.path()].prev && ($scope.breadcrumbs[$location.path()].next === null)
                    );
        };

        $scope.isCurrentPage = function (locationUrl) {
            if ($scope.breadcrumbs[$location.path()] && (locationUrl === $scope.breadcrumbs[$location.path()].url)) {
                $scope.currentIndex = $scope.breadcrumbs[$location.path()].step;
            }
            return (($scope.breadcrumbs[$location.path()] && (locationUrl === $scope.breadcrumbs[$location.path()].url)));
        };

        $scope.isPreviousPage = function (step) {
            var stepIndex = step + 1;
            return stepIndex < $scope.currentIndex;
        };

        $scope.setLastQuickSetupPage = function () {
            $scope.lastQuickSetupPage = $location.path();
        };
        $scope.disableNextButton = function () {
            $scope.nextEnableState = false;
        };
        $scope.enableNextButton = function () {
            $scope.nextEnableState = true;
        };

        $scope.clickNextButton = function (event) {
            var data = {stopNextClick: false};
            $scope.$broadcast('nextClicked', data);
            if($location.path() === "/quickSetup/monitor-networks") {
                $scope.showVchassisCreationInProgress = true;
            }
            console.log(" nextClicked " + data.stopNextClick);
            if (!data.stopNextClick) {
                $scope.getNextPage();
            }
        };
        $scope.toggleHelpPanel = function () {
            console.log($scope.hideRightPanel);
            $scope.hideRightPanel = !($scope.hideRightPanel);
        };
    }

    angular.module('shieldxApp').controller('quickSetupCtr', quickSetupCtr);
})();


/*
 ShieldX Networks Inc. CONFIDENTIAL
 ----------------------------------
 *
 Copyright (c) 2016 ShieldX Networks Inc.
 All Rights Reserved.
 *
 NOTICE: All information contained herein is, and remains
 the property of ShieldX Networks Incorporated and its suppliers,
 if any. The intellectual and technical concepts contained
 herein are proprietary to ShieldX Networks Incorporated
 and its suppliers and may be covered by U.S. and Foreign Patents,
 patents in process, and are protected by trade secret or copyright law.
 Dissemination of this information or reproduction of this material
 is strictly forbidden unless prior written permission is obtained
 from ShieldX Networks Incorporated.
 */

(function () {
    function addPolicyCtr(
            $scope,
            $q,
            policyService,
            $mdDialog,
            $state,
            infrastructureConnectorService,
            $rootScope
            ) {

        $scope.$emit('listenHeaderText', {headerText: "Policy"});

        $scope.redirectInSPS = function(){
            $state.go('home.policy.policylist.securitypolicyset');
        };
    }

    angular.module('shieldxApp').controller('addPolicyCtr', addPolicyCtr);
})();

/*
 ShieldX Networks Inc. CONFIDENTIAL
 ----------------------------------
 *
 Copyright (c) 2016 ShieldX Networks Inc.
 All Rights Reserved.
 *
 NOTICE: All information contained herein is, and remains
 the property of ShieldX Networks Incorporated and its suppliers,
 if any. The intellectual and technical concepts contained
 herein are proprietary to ShieldX Networks Incorporated
 and its suppliers and may be covered by U.S. and Foreign Patents,
 patents in process, and are protected by trade secret or copyright law.
 Dissemination of this information or reproduction of this material
 is strictly forbidden unless prior written permission is obtained
 from ShieldX Networks Incorporated.
 */

(function () {
    function addPolicySetCtr(
            $scope,
            $q,
            policyService,
            $mdDialog,
            $state,
            infrastructureConnectorService,
            $rootScope
            ) {

        $scope.$emit('listenHeaderText', {headerText: "Policy"});

        var deferred = $q.defer();
        $scope.promise = deferred.promise;

        $scope.malwarepolicy = null;
        $scope.accesscontrolpolicy = null;
        $scope.threatpreventionpolicy = null;
        $scope.policyName = null;
        $scope.showSPSCreationProgress = false;
        $scope.aclDataRetrieved = false;
        $scope.malwareDataRetrieved = false;
        $scope.threatDetectionDataRetrieved = false;


        $scope.malwarepolicyList = [];
        $scope.accesscontrolpolicyList = [];
        $scope.threatpreventionpolicyList = [];


        $scope.policy = {};
        $scope.disablAdd = true;

        $scope.sopTenant = $scope.$parent.sopTenant;

        $q.all([
            policyService.getDataBasedOnId("policy", "malwarepolicy").then(function (data) {
                console.log(data);
                $scope.malwareDataRetrieved = true;
                $scope.malwarepolicyList = data;
            }),
            policyService.getDataBasedOnId("policy", "accesscontrolpolicy").then(function (data) {
                console.log(data);
                $scope.aclDataRetrieved = true;
                $scope.accesscontrolpolicyList = data;
            }),
            policyService.getDataBasedOnId("policy", "threatpreventionpolicy").then(function (data) {
                $scope.threatDetectionDataRetrieved = true;
                console.log(data);
                $scope.threatpreventionpolicyList = data;
            })
        ]).then(function () {
            deferred.resolve();
        });

        $scope.policy.accessControlPolicyId = null;
        $scope.policy.threatPreventionPolicyId = null;
        $scope.policy.malwarePolicyId = null;
        $scope.policy.tenantId = null;
        $scope.policy.id = null;
        $scope.policy.name = null;

        /*// to be removed once tenant data is available
        $scope.policy.tenantId = 1;
        $scope.policy.tenantName = "Default";*/


        // to be uncommented once md-input-container is resolved
//        $scope.disableAddButton = (!$scope.policy.name || !$scope.policy.tenantId) ? true : false;

        $scope.callpopupTenats = function(event,selectedtenant) {
            $mdDialog.show({
                skipHide: true,
                preserveScope: true,
                controller: tenantListCtr,
                bindToController: true,
                templateUrl: 'core/components/administration/policy/tenants-dialogbox.html',
                parent: angular.element(document.body),
                targetEvent: event,
                fullscreen: false,
                scope: $scope,
                openFrom: { top: 1100, height: 0 },
                closeTo: { left: 1500 },
                locals: {'selectedtenant': selectedtenant}

            }).then(function() {

            });
        };
        

        function tenantListCtr($scope, $mdDialog, policyService,$rootScope,selectedtenant) {
             $scope.tenantSelected = false;
             $scope.selectedTenantsValue = selectedtenant;

             
            $scope.canceltenantDialogue = function() {
                //tenantSelection();
                $mdDialog.cancel();
            };
            $scope.tenantSelected = false;
            $scope.tenants = $scope.tenantsList;
            

            $scope.onSelectTenantChanged = function() {
                console.log(" onSelectionChanged >> ");
                $scope.tenantSelected = true;
            };
            $scope.tenantdone = function(value) {
                $scope.tenantSelected = true;
                if($scope.selectedTenantsValue){
                 var fo =  _.find($scope.tenants, function(sel){
                     return sel.id === parseInt($scope.selectedTenantsValue);
                  });
                 
                 if(fo){
                  $scope.selectedTenantObj = fo;  
                  $rootScope.$broadcast('listenPolicyChange', $scope.selectedTenantObj, 'tenantId');
                 }
                  
                }
                $mdDialog.hide();
            };
        }

        $scope.getTenantDataForCloud = function(cloudObj) {
            $scope.tenantsList = [];
             policyService.getDataBasedOnId("infras", cloudObj.id + "/tenants", "").then(function(tenants) {
                _.each(tenants, function(tenant) {
                    tenant.cloudName = cloudObj.name;
                    $scope.tenantsList.push(tenant);
                });
                $scope.cloudsLength = $scope.cloudsLength -1;
                if($scope.cloudsLength === 0){
                    $scope.tennatsListCompleted = false;    
                }
            });
        };
        $scope.getTenants = function() {
            infrastructureConnectorService.getListOfInfrastructures().then(function(clouds) {
                $scope.cloudsLength = clouds.length;
                _.each(clouds, function(cloud) {
                    $scope.getTenantDataForCloud(cloud);
                });
            });
        };


        if(!$scope.sopTenant){
            $scope.getTenants();    
        }else{
            $scope.selectedTenantObj = $scope.$parent.selectedTenantObj;
        }

        $scope.cancel = function () {            
            $scope.$parent.redirectInSPS(true);
        };

        $scope.addSecurityPolicy = function () {
            $scope.disablAdd = true;
            $scope.showSPSCreationProgress = true;
            
            var d = new Date();
            var n = d.getTime();

            var param = {};


            param.lastModified = n;
            param.name = $scope.policy.name;
            //param.tenantId = $scope.policy.tenantId;

            if ($scope.policy.accessControlPolicy && $scope.policy.accessControlPolicy.id) {
                param.accessControlPolicyId = $scope.policy.accessControlPolicy.id;
            }

            if ($scope.policy.malwarePolicy && $scope.policy.malwarePolicy.id) {
                param.malwarePolicyId = $scope.policy.malwarePolicy.id;
            }

            if ($scope.policy.threatPreventionPolicy && $scope.policy.threatPreventionPolicy.id) {
                param.threatPreventionPolicyId = $scope.policy.threatPreventionPolicy.id;
            }

            if ($scope.selectedTenantObj && $scope.selectedTenantObj.id) {
                param.tenantId = $scope.selectedTenantObj.id;
            }
//            var accessControlPolicyId = ($scope.policy.accessControlPolicy &&
//                    $scope.policy.accessControlPolicy.id) ? $scope.policy.accessControlPolicy.id : null;
//
//            var malwarePolicyId = ($scope.policy.malwarePolicy &&
//                    $scope.policy.malwarePolicy.id) ? $scope.policy.malwarePolicy.id : null;
//
//            var threatPreventionPolicyId = ($scope.policy.threatPreventionPolicy &&
//                    $scope.policy.threatPreventionPolicy.id) ? $scope.policy.threatPreventionPolicy.id : null;
//
//            param = {
//                "accessControlPolicyId": accessControlPolicyId,
//                "lastModified": n,
//                "malwarePolicyId": malwarePolicyId,
//                "name": $scope.policy.name,
//                "tenantId": $scope.policy.tenantId,
//                "threatPreventionPolicyId": threatPreventionPolicyId
//            };

            var startPolicyCreation = {
                'heading': 'Security Policy Creation Started',
                'subHeading': 'Security Policy Creation Started.',
                'type': 'progress',
                'timeout': 5000
            };
            var policyUpdated = {
                'heading': 'Security Policy Created',
                'subHeading': 'Security Policy Created.',
                'type': 'success',
                'timeout': 5000,
                'callback': function () {
                    $scope.$parent.redirectInSPS();
                }
            };
            var policyUpdateFailed = {
                'heading': 'Security Policy Creation Failed',
                'subHeading': 'Security Policy Creation Failed.',
                'type': 'fail',
                'timeout': 5000,
                'callback': function () {
                    $scope.$parent.redirectInSPS();
               }
            };

            showToast(startPolicyCreation);
            policyService.createPolicyData("policy/securitypolicyset", param).then(function (data) {
                console.log(data);                

                if($scope.sopTenant){
                    $scope.$parent.policy.name = $scope.policy.name;
                }

                showToast(policyUpdated);                
            }, function (err) {
                console.log(err);
                $scope.disablAdd = false;
                $scope.showSPSCreationProgress = false;
                showToast(policyUpdateFailed);
            });
        };

        $scope.clearPolicy = function (policytype) {
            if (typeof $scope.policy[policytype] !== "undefined") {
                delete($scope.policy[policytype]);
            }

            if(!($scope.policy.accessControlPolicy || $scope.policy.malwarePolicy || $scope.policy.threatPreventionPolicy )){
                 $scope.disablAdd = true;
             }
        };

        $scope.onNameChanged =function(){
          $rootScope.$broadcast('listenPolicyChange', $scope.policy.name, 'name');
        };

        $scope.$on('listenPolicyChange', function (event, paramValue, paramtype) {

            var searchObj = {"id": paramValue};
            switch (paramtype) {
                case "accessControlPolicyId":
                    $scope.policy.accessControlPolicy = _.find($scope.accesscontrolpolicyList, searchObj);
                    break;
                case "malwarePolicyId":
                    $scope.policy.malwarePolicy = _.find($scope.malwarepolicyList, searchObj);
                    break;
                case "threatPreventionPolicyId":
                    $scope.policy.threatPreventionPolicy = _.find($scope.threatpreventionpolicyList, searchObj);
                    break;
                case "name":
                    $scope.policy.name = paramValue;
                    break;
                case "tenantId":
                    $scope.policy.tenantId = paramValue;
                    break;
                default:
            }

            if($scope.sopTenant){
                if($scope.policy.name && ($scope.policy.accessControlPolicy || $scope.policy.malwarePolicy || $scope.policy.threatPreventionPolicy) ){
                    $scope.disablAdd = false;
                }
            }else{
                if($scope.policy.name && $scope.policy.tenantId && ($scope.policy.accessControlPolicy || $scope.policy.malwarePolicy || $scope.policy.threatPreventionPolicy) ){
                    $scope.disablAdd = false;
                }
            }
             
        });

        $scope.callAccessControlPopup = function (accesscontrolpolicy, aclDataRetrieved, accesscontrolpolicyList, ev, selectedid) {
            $mdDialog.show({
                skipHide: true,
                preserveScope: true,
                controller: accessControlPopupController,
                templateUrl: 'core/components/administration/policy/policy.accesscontrolPopup.html',
                parent: angular.element(document.body),
                targetEvent: ev,
                locals: {'accesscontrolpolicy': accesscontrolpolicy,
                    'aclDataRetrieved': aclDataRetrieved,
                    'accesscontrolpolicyList': accesscontrolpolicyList,
                    'selectedid':selectedid}
            }).then(function () {
//                        console.log($scope.selectedTenants);
//                        $sessionStorage.cloudData.selectedTenants = $scope.selectedTenants;
//                        console.log($sessionStorage.cloudData.selectedTenants);
            });
        };

        function accessControlPopupController($rootScope, $scope, $mdDialog, accesscontrolpolicy, aclDataRetrieved, accesscontrolpolicyList, selectedid) {
//            $scope.tenant_activated = true;
//            if (!$sessionStorage.cloudData.selectedTenants) {
//                $sessionStorage.cloudData.selectedTenants = {};
//            }
            (function () {
                $scope.accesscontrolpolicy = $scope.selectedPolicy = accesscontrolpolicy;
                $scope.aclDataRetrieved = aclDataRetrieved;
                $scope.accesscontrolpolicyList = accesscontrolpolicyList;
                $scope.selectedPolicy = selectedid;
                $scope.cancelDialog = function () {
                    $mdDialog.cancel();
                };

                $scope.done = function () {
                    console.log($scope.selectedPolicy);
                    $rootScope.$broadcast('listenPolicyChange', parseInt($scope.selectedPolicy), 'accessControlPolicyId');
//                    $rootScope.$broadcast('listenSelectedHosts', $scope.selected);
                    $mdDialog.hide();
                };
            })();

        }

        $scope.callMalwarePopup = function (malwarepolicy, malwareDataRetrieved, malwarepolicyList, ev,selectedmalwarepolicy) {
            $mdDialog.show({
                skipHide: true,
                preserveScope: true,
                controller: malwarePopupController,
                templateUrl: 'core/components/administration/policy/policy.malwarePopup.html',
                parent: angular.element(document.body),
                targetEvent: ev,
                locals: {'malwarepolicy': malwarepolicy,
                    'malwareDataRetrieved': malwareDataRetrieved,
                    'malwarepolicyList': malwarepolicyList}
            })
                    .then(function () {
//                        console.log($scope.selectedTenants);
//                        $sessionStorage.cloudData.selectedTenants = $scope.selectedTenants;
//                        console.log($sessionStorage.cloudData.selectedTenants);
                    });
        };

        function malwarePopupController($rootScope, $scope, $mdDialog, malwarepolicy, malwareDataRetrieved, malwarepolicyList) {
//            $scope.tenant_activated = true;
//            if (!$sessionStorage.cloudData.selectedTenants) {
//                $sessionStorage.cloudData.selectedTenants = {};
//            }
            (function () {
                $scope.malwarepolicy = malwarepolicy;
                $scope.malwareDataRetrieved = malwareDataRetrieved;
                $scope.malwarepolicyList = malwarepolicyList;
                $scope.selectedPolicy = malwarepolicy;

                $scope.cancelDialog = function () {
                    $mdDialog.cancel();
                };

                $scope.done = function () {
                    console.log($scope.selectedPolicy);
                    $rootScope.$broadcast('listenPolicyChange', parseInt($scope.selectedPolicy), 'malwarePolicyId');
                    $mdDialog.hide();
                };
            })();

        }
        $scope.callThreatDetectionPopup = function (threatpreventionpolicy, threatDetectionDataRetrieved, threatpreventionpolicyList, ev) {
            $mdDialog.show({
                skipHide: true,
                preserveScope: true,
                controller: threatDetectionPopupController,
                templateUrl: 'core/components/administration/policy/policy.threatDetectionPopup.html',
                parent: angular.element(document.body),
                targetEvent: ev,
                locals: {'threatpreventionpolicy': threatpreventionpolicy,
                    'threatDetectionDataRetrieved': threatDetectionDataRetrieved,
                    'threatpreventionpolicyList': threatpreventionpolicyList}
            })
                    .then(function () {
//                        console.log($scope.selectedTenants);
//                        $sessionStorage.cloudData.selectedTenants = $scope.selectedTenants;
//                        console.log($sessionStorage.cloudData.selectedTenants);
                    });
        };

        function threatDetectionPopupController($rootScope, $scope, $mdDialog, threatpreventionpolicy, threatDetectionDataRetrieved, threatpreventionpolicyList) {
//            $scope.tenant_activated = true;
//            if (!$sessionStorage.cloudData.selectedTenants) {
//                $sessionStorage.cloudData.selectedTenants = {};
//            }
            (function () {
                $scope.threatpreventionpolicy = threatpreventionpolicy;
                $scope.threatDetectionDataRetrieved = threatDetectionDataRetrieved;
                $scope.threatpreventionpolicyList = threatpreventionpolicyList;
                $scope.selectedPolicy = threatpreventionpolicy;
                $scope.cancelDialog = function () {
                    $mdDialog.cancel();
                };

                $scope.done = function () {
                    console.log($scope.selectedPolicy);
                    $rootScope.$broadcast('listenPolicyChange', parseInt($scope.selectedPolicy), 'threatPreventionPolicyId');
//                    $rootScope.$broadcast('listenSelectedHosts', $scope.selected);
                    $mdDialog.hide();
                };
            })();

        }
       /* $scope.$on('$viewContentLoaded', function(event){ 
            console.log(event);*/
            fixContainerHeight(1);
        /*});*/
    }

    angular.module('shieldxApp').controller('addPolicySetCtr', addPolicySetCtr);
})();

/*
 ShieldX Networks Inc. CONFIDENTIAL
 ----------------------------------
 *
 Copyright (c) 2016 ShieldX Networks Inc.
 All Rights Reserved.
 *
 NOTICE: All information contained herein is, and remains
 the property of ShieldX Networks Incorporated and its suppliers,
 if any. The intellectual and technical concepts contained
 herein are proprietary to ShieldX Networks Incorporated
 and its suppliers and may be covered by U.S. and Foreign Patents,
 patents in process, and are protected by trade secret or copyright law.
 Dissemination of this information or reproduction of this material
 is strictly forbidden unless prior written permission is obtained
 from ShieldX Networks Incorporated.
 */

(function() {
    function allthreatsCtrl(
        $scope,
        $state,
        $translate,
        $sessionStorage,
        policyService,
        $timeout,
        $q,
        $mdDialog,
        infrastructureConnectorService,
        deploymentSpecificationService,
        filterFilter,
        $filter,
        userSessionMenagment
    ) {
        var deferred = $q.defer();
        $scope.promise = deferred.promise;
        $scope.promiseCompleted = true;
        $scope.threatResponse = [];
        $scope.enabledThreats = 0;
        $scope.policyData = {};
        $scope.differCount = 0;
        $scope.responseSet = {
                            "enabled":false,
                            "enabledNot":false,
                            "logPacket":false,
                            "logPacketNot":false,
                            "alert":false,
                            "alertNot":false,
                            "block":false,
                            "blockNot":false,
                            "notifySMTP":false,
                            "notifySMTPNot":false,
                            "notifySysLog":false,
                            "notifySysLogNot":false
                        };
        /*$scope.disableSavePolicy = true;*/
        $scope.policyselected = [];
        $scope.selected = [];
        $scope.isSearchBarOpen = false;
        $scope.saveupdatepolicyAdd = true;
        $scope.addNewPolicyArray = [];
        $scope.policyname = "";
        $scope.selectAll = false;
        $scope.policyId = $state.params.policyId;
        $scope.query = {
            order: 'name',
            limit: 8,
            page: 1
        };

        var update_id = authorities("policy_update");
        $scope.is_update_policy = userSessionMenagment.isUserAllowd(update_id);
        
        $scope.resetData = function (){
            $scope.responseSet = {
                            "enabled":false,
                            "enabledNot":false,
                            "logPacket":false,
                            "logPacketNot":false,
                            "alert":false,
                            "alertNot":false,
                            "block":false,
                            "blockNot":false,
                            "notifySMTP":false,
                            "notifySMTPNot":false,
                            "notifySysLog":false,
                            "notifySysLogNot":false
                        };
            $scope.threatResponse = [];
            $scope.policyselected =[];
        };
        $scope.openThreatPopup = function(event,policyName,threatReferenceData){
            $mdDialog.show({
                skipHide: true,
                controller: threatRefenceController,
                templateUrl: 'core/components/administration/policy/threatReferenceList.html',
                parent: angular.element(document.body),
                event: event,
                scope: $scope,
                preserveScope: true,
                locals:{'policyName':policyName,'threatReferenceData':threatReferenceData}
            }).then(function() {

            });
        };
        function threatRefenceController($rootScope, $scope, $mdDialog,threatReferenceData,policyName) {
            (function() {
                $scope.items = threatReferenceData;
                $scope.threatName = policyName;
                $scope.cancelDialogue = function() {
                    $mdDialog.hide();
                };
            })();
        }
        $scope.onReorder = function(order){
            $scope.policythreatData =  $filter('orderBy')($scope.policythreatData,order);
        };
        $scope.filterset = {};
        
        policyService.getPolicyDetail("threatpreventionpolicy","policy","severity").then(function(severityData) {
            $scope.severitylevels = severityData;
        }, function(err) {
            console.log("new threat rule error");
        });
        $scope.malwarePolicy = true;
        $scope.malwareselected = [];
        $scope.updateResponse = function(event,responseType,value){
            _.each($scope.policyselected,function(singleThreat){
                singleThreat.threatResponseData.policyId = $scope.policyId;
                var alreadyPresent = _.find($scope.threatResponse,{"protocolId":singleThreat.protocolID,"threatId":singleThreat.threatID});
                if(typeof alreadyPresent !== 'undefined'){
                    alreadyPresent[responseType] = value;
                } else {
                    $scope.threatResponse.push(singleThreat.threatResponseData);
                    $scope.threatResponse[$scope.threatResponse.length - 1][responseType] = value;
                }
            });
            $scope.responseSet[responseType+"Not"] = !value; 
            $scope.responseSet[responseType] = value;
        };
        $scope.getSelectedText = function(receivedData,totalength){
            if(typeof receivedData === 'undefined' || receivedData.length >= totalength)
                return "ALL";
            return receivedData.length + " Selected";
        };
        $scope.clearEdits = function(){
            $scope.resetData();
            $scope.onReorder("name");
            $scope.filterset = {"_status":["Enabled","Disabled"],"severity":["Medium","High","Critical","Low","Fixme"],"protectionType":["SERVER","CLIENT"],"response":["Block-true","Alert-true","Log-true","Block-false","Alert-false","Log-false"],"action":["notifySMTP-true","notifySysLog-true","notifySMTP-false","notifySysLog-false"]};
            $scope.policythreatData = angular.copy($scope.policythreatDataCopy);
        };
        $scope.resetToGlobal = function(){
            var arrayTopass = [];
            $scope.enabledThreats = 0;
            _.each($scope.policythreatData,function(singleThreat){
                var globalResponsePresent = _.find($scope.globalresponseData,{"protocolId":singleThreat.protocolID,"threatId":singleThreat.threatID});
                if(typeof globalResponsePresent !== "undefined"){
                    singleThreat.threatResponseData.enabled = globalResponsePresent.enabled;
                    singleThreat.threatResponseData.alert = globalResponsePresent.alert;
                    singleThreat.threatResponseData.block = globalResponsePresent.block;
                    singleThreat.threatResponseData.logPacket = globalResponsePresent.logPacket;
                    singleThreat.threatResponseData.notifySMTP = globalResponsePresent.notifySMTP;
                    singleThreat.threatResponseData.notifySysLog = globalResponsePresent.notifySysLog;
                    singleThreat.threatResponseData.policyId = $scope.policyId;
                    //singleThreat.threatResponseData.inherited = true;
                    arrayTopass.push(singleThreat.threatResponseData);
                    singleThreat._alertdiff = false;
                    singleThreat._blockdiff = false;
                    singleThreat._logPacketdiff = false;
                    singleThreat._notifySMTPdiff = false;
                    singleThreat._notifySysLogdiff = false;
                    if(singleThreat.threatResponseData.enabled){
                        $scope.enabledThreats++;
                    }
                }
            });
            var dataTosend = {"id":$scope.policyId,"responses":arrayTopass};
            toastparam = {
                    'heading': 'Update of Threats in progress',
                    'subHeading': 'Update of Threats initiated.',
                    'type': 'progress',
                    'timeout': 5000
                };
            showToast(toastparam);
            policyService.updateExistingPolicyData("policy/threatresponses",dataTosend).then(function(responseData){
                $scope.policythreatDataCopy = angular.copy($scope.policythreatData);
                $scope.differCount = 0;
                toastparam = {
                    'heading': 'Update of Threats Completed',
                    'subHeading': 'Threats Updated.',
                    'type': 'success',
                    'timeout': 5000
                };
                showToast(toastparam);
                $scope.resetData();
            });

        };
        $scope.updateEdits = function(){
            var dataTosend = {"id":$scope.policyId,"responses":$scope.threatResponse};
            toastparam = {
                    'heading': 'Update of Threats in progress',
                    'subHeading': 'Update of Threats initiated.',
                    'type': 'progress',
                    'timeout': 5000
                };
            showToast(toastparam);
            policyService.updateExistingPolicyData("policy/threatresponses",dataTosend).then(function(responseData){
                $scope.policythreatDataCopy = angular.copy($scope.policythreatData);
                $scope.differCount = 0;
                $scope.enabledThreats  = 0;
                _.each($scope.policythreatData,function(singleThreat){
                    var globalUpdatedResponse = _.find($scope.globalresponseData,{"protocolId":singleThreat.protocolID,"threatId":singleThreat.threatID});
                    if(typeof globalUpdatedResponse !== "undefined"){
                        if(globalUpdatedResponse.alert === singleThreat.threatResponseData.alert){
                            singleThreat._alertdiff = false;
                        } else {
                            singleThreat._alertdiff = true;
                            $scope.differCount++;
                        }
                        if(globalUpdatedResponse.block === singleThreat.threatResponseData.block){
                            singleThreat._blockdiff = false;
                        } else {
                            singleThreat._blockdiff = true;
                            $scope.differCount++;
                        }
                        if(globalUpdatedResponse.logPacket === singleThreat.threatResponseData.logPacket){
                            singleThreat._logPacketdiff = false;
                        } else {
                            singleThreat._logPacketdiff = true;
                            $scope.differCount++;
                        }
                        if(globalUpdatedResponse.notifySMTP === singleThreat.threatResponseData.notifySMTP){
                            singleThreat._notifySMTPdiff = false;
                        } else {
                            singleThreat._notifySMTPdiff = true;
                            $scope.differCount++;
                        }
                        if(globalUpdatedResponse.notifySysLog === singleThreat.threatResponseData.notifySysLog){
                            singleThreat._notifySysLogdiff = false;
                        } else {
                            singleThreat._notifySysLogdiff = true;
                            $scope.differCount++;
                        }
                        if(singleThreat.threatResponseData.enabled){
                            $scope.enabledThreats++;
                        }
                    }
                });
                $scope.resetData();
                toastparam = {
                    'heading': 'Update of Threats Completed',
                    'subHeading': 'Threats Updated.',
                    'type': 'success',
                    'timeout': 5000
                };
                showToast(toastparam);
            },function(error){
                toastparam = {
                    'heading': 'Update of Threats Failed.',
                    'subHeading': 'Threats failed to update.',
                    'type': 'fail',
                    'timeout': 5000
                };
                showToast(toastparam);
                console.log(error);
            });
        };
        $scope.getCount = function(){
            if(typeof $scope.policythreatData !== "undefined")
                return filterFilter( $scope.policythreatData, $scope.filterset).length;
            else
                return 0;
        };
        policyService.getPolicyDetail("threatpreventionpolicy","policy",$scope.policyId).then(function(threatdata) {
            $scope.policyData = threatdata;
        });
        policyService.getPolicyDetail( $scope.policyId,"policy","threats").then(function(data) {
            $scope.promiseCompleted = false;
                policyService.getPolicyDetail($scope.policyId,"policy","threatresponses").then(function(responseData){
                    data.map(function(currentObj){
                        currentObj.threatResponseData =  _.find(responseData,{"protocolId":currentObj.protocolID,"threatId":currentObj.threatID});
                        currentObj._numthreatID = parseInt(currentObj.threatID);
                        currentObj._numprotocolID = parseInt(currentObj.protocolID);
                        if(typeof currentObj.threatResponseData !== 'undefined'){
                            if(currentObj.threatResponseData.enabled){
                                currentObj._status =  "Enabled";
                                $scope.enabledThreats++;
                            } else {
                                currentObj._status = "Disabled";
                            }
                        }
                        else
                           currentObj._status = "Disabled";
                        /*currentObj._response = parseInt(currentObj.protocolID);*/
                    });
                    policyService.getPolicyDetail("0","policy","threatresponses").then(function(globalresponseData){
                        $scope.globalresponseData = globalresponseData;
                        policyService.getDataBasedOnId("policy","protocol").then(function(protocolData) {
                            _.each(data,function(singleThreat){
                                var globalResponse = _.find(globalresponseData,{"protocolId":singleThreat.protocolID,"threatId":singleThreat.threatID});
                                var matchedProtocol = _.find(protocolData,{"protocolID" : singleThreat.protocolID});
                                
                                if(matchedProtocol)
                                    singleThreat.protocolName = matchedProtocol.protocolName;
                                else
                                    singleThreat.protocolName = "";

                                if(typeof globalResponse !== "undefined"){
                                    if(globalResponse.alert === singleThreat.threatResponseData.alert){
                                        singleThreat._alertdiff = false;
                                    } else {
                                        singleThreat._alertdiff = true;
                                        $scope.differCount++;
                                    }
                                    if(globalResponse.block === singleThreat.threatResponseData.block){
                                        singleThreat._blockdiff = false;
                                    } else {
                                        singleThreat._blockdiff = true;
                                        $scope.differCount++;
                                    }
                                    if(globalResponse.logPacket === singleThreat.threatResponseData.logPacket){
                                        singleThreat._logPacketdiff = false;
                                    } else {
                                        singleThreat._logPacketdiff = true;
                                        $scope.differCount++;
                                    }
                                    if(globalResponse.notifySMTP === singleThreat.threatResponseData.notifySMTP){
                                        singleThreat._notifySMTPdiff = false;
                                    } else {
                                        singleThreat._notifySMTPdiff = true;
                                        $scope.differCount++;
                                    }
                                    if(globalResponse.notifySysLog === singleThreat.threatResponseData.notifySysLog){
                                        singleThreat._notifySysLogdiff = false;
                                    } else {
                                        singleThreat._notifySysLogdiff = true;
                                        $scope.differCount++;
                                    }
                                }
                            });


                            $scope.policythreatData = data;
                            $scope.policythreatDataCopy = angular.copy(data);
                            console.log("threat data is this ",$scope.policythreatData);
                            
                            $scope.getCount();
                            deferred.resolve();
                        });
                    });
                    
            });
            
        }, function(err) {
            console.log("policy error data");
            deferred.reject();
            $scope.promiseCompleted = false;
        });
        


        $scope.toggleSearchBar = function(event) {
            $scope.isSearchBarOpen = $scope.isSearchBarOpen === false ? true : false;
            if ($scope.isSearchBarOpen)
                angular.element(event.currentTarget.firstElementChild).css('color', '#4a90e2');
            else
                angular.element(event.currentTarget.firstElementChild).css('color', '#6d6e71');
        };

        $scope.$on('$viewContentLoaded', function(event){ 
            console.log(event);
            fixContainerHeight(1);
        });

    }

    angular.module('shieldxApp').controller('allthreatsCtr', allthreatsCtrl);
})();

/*
 ShieldX Networks Inc. CONFIDENTIAL
 ----------------------------------
 *
 Copyright (c) 2016 ShieldX Networks Inc.
 All Rights Reserved.
 *
 NOTICE: All information contained herein is, and remains
 the property of ShieldX Networks Incorporated and its suppliers,
 if any. The intellectual and technical concepts contained
 herein are proprietary to ShieldX Networks Incorporated
 and its suppliers and may be covered by U.S. and Foreign Patents,
 patents in process, and are protected by trade secret or copyright law.
 Dissemination of this information or reproduction of this material
 is strictly forbidden unless prior written permission is obtained
 from ShieldX Networks Incorporated.
 */

(function () {
    function editPolicyCtr(
            $stateParams,
            $scope,
            $state,
            policyService,
            $mdDialog,
            $q,
            infrastructureConnectorService,
            userSessionMenagment
            ) {

        var deferred = $q.defer();
        $scope.promise = deferred.promise;

        $scope.$emit('listenHeaderText', {headerText: "Policy"});

        $scope.policyselected = [];

        var policyId = null;
        $scope.policy = null;
        $scope.malwarepolicy = null;
        $scope.accesscontrolpolicy = null;
        $scope.threatpreventionpolicy = null;
        $scope.policyName = null;

        $scope.aclDataRetrieved = false;
        $scope.malwareDataRetrieved = false;
        $scope.threatDetectionDataRetrieved = false;

        var update_id = authorities("policy_update");
        $scope.is_update_policy = userSessionMenagment.isUserAllowd(update_id);

        $scope.malwarepolicyList = [];
        $scope.accesscontrolpolicyList = [];
        $scope.threatpreventionpolicyList = [];

        $scope.updatePolicyName = function (policyName) {
            $scope.$emit("listenPolicyChange", policyName, "name");
        };


        $scope.setEditMode = function (key, value) {
            if (!key) {
                $scope.editPolicyName = false;
                $scope.editTenant = false;
                $scope.editACLPolicy = false;
                $scope.editMalwarePolicy = false;
                $scope.editThreatPolicy = false;
            } else {
                $scope[key] = value;
            }
        };

        var policyIdSet = ($stateParams && $stateParams.policyId) ? parseInt($stateParams.policyId) : null;

        if (policyIdSet) {
            policyId = $stateParams.policyId;
            policyService.getPolicyDetail("securitypolicyset", "policy", policyId).then(function (data) {
                $scope.policy = data;
                $scope.policyName = angular.copy($scope.policy.name);
                $q.all([
                    policyService.getPolicyDetail("malwarepolicy", "policy", data.malwarePolicyId).then(function (data) {
                        console.log(data);
                        $scope.malwarepolicy = data;
                    }),
                    policyService.getListOfPoliciesDetails("malwarepolicy", "policy").then(function (data) {
                        console.log(data);
                        $scope.malwareDataRetrieved = true;
                        $scope.malwarepolicyList = data;
                    }),
                    policyService.getPolicyDetail("accesscontrolpolicy", "policy", data.accessControlPolicyId).then(function (data) {
                        console.log(data);
                        $scope.accesscontrolpolicy = data;
                    }),
                    policyService.getListOfPoliciesDetails("accesscontrolpolicy", "policy").then(function (data) {
                        console.log(data);
                        $scope.aclDataRetrieved = true;
                        $scope.accesscontrolpolicyList = data;
                    }),
                    policyService.getPolicyDetail("threatpreventionpolicy", "policy", data.threatPreventionPolicyId).then(function (data) {
                        console.log(data);
                        $scope.threatpreventionpolicy = data;
                    }),
                    policyService.getListOfPoliciesDetails("threatpreventionpolicy", "policy").then(function (data) {
                        $scope.threatDetectionDataRetrieved = true;
                        console.log(data);
                        $scope.threatpreventionpolicyList = data;
                    })
                ]).then(function () {
                    deferred.resolve();
                });


                var d = new Date(data.lastModified);
                $scope.policy.modifiedDate = d.getDate() + '/' + (d.getMonth()+1) + '/' + d.getFullYear();

                policyService.getDataBasedOnId("infras", data.tenantId + "/tenants", "").then(function(tenants) {
                    _.each(tenants, function(tenant) {
                        $scope.selectedTenantObj = tenant;
                    });
                });

            }, function (err) {
                console.log("policy error data");
                deferred.reject();
                $scope.promiseCompleted = false;
            });

            $scope.clearPolicy = function (policytype) {
                if (typeof $scope.policy[policytype] !== "undefined") {
                   // delete($scope.policy[policytype]);
                    $scope.$emit("listenPolicyChange", undefined, policytype);
                }
            };

            $scope.$on('listenPolicyChange', function (event, paramValue, paramtype) {

                var policy = {};

                policy.accessControlPolicyId = angular.copy($scope.policy.accessControlPolicyId);
                policy.threatPreventionPolicyId = angular.copy($scope.policy.threatPreventionPolicyId);
                policy.malwarePolicyId = angular.copy($scope.policy.malwarePolicyId);
                policy.id = angular.copy($scope.policy.id);
                policy.name = angular.copy($scope.policy.name);
                policy.tenantId = angular.copy($scope.policy.tenantId);

                switch (paramtype) {
                    case "accessControlPolicyId":
                        policy.accessControlPolicyId = paramValue;
                        break;
                    case "malwarePolicyId":
                        policy.malwarePolicyId = paramValue;
                        break;
                    case "threatPreventionPolicyId":
                        policy.threatPreventionPolicyId = paramValue;
                        break;
                    case "name":                        
                        policy.name = paramValue;                        
                        break;
                    case "tenantId":
                        policy.tenantId = paramValue;
                        break;
                    default:
                }
                $scope.updatePolicySet(policy);
            });

            $scope.updatePolicySet = function (policy) {
                var d = new Date();
                var n = d.getTime();

                var startPolicyUpdate = {
                    'heading': 'Security Policy Update Started',
                    'subHeading': 'Security Policy Update Started.',
                    'type': 'progress',
                    'timeout': 5000
                };
                var policyUpdated = {
                    'heading': 'Security Policy Updated',
                    'subHeading': 'Security Policy Updated.',
                    'type': 'success',
                    'timeout': 5000,
                    'callback': function () {
                        $state.reload();
                    }
                };
                var policyUpdateFailed = {
                    'heading': 'Security Policy Update Failed',
                    'subHeading': 'Security Policy Update Failed.',
                    'type': 'fail',
                    'timeout': 5000,
                    'callback': function () {
                        $state.reload();
                    }
                };

                var param = {};

                param.lastModified = n;
                param.name = policy.name;
                param.tenantId = policy.tenantId;
                param.id = parseInt($stateParams.policyId,10);

                if (policy.accessControlPolicyId) {
                    param.accessControlPolicyId = policy.accessControlPolicyId;
                }

                if (policy.malwarePolicyId) {
                    param.malwarePolicyId = policy.malwarePolicyId;
                }

                if (policy.threatPreventionPolicyId) {
                    param.threatPreventionPolicyId = policy.threatPreventionPolicyId;
                }

                showToast(startPolicyUpdate);
                policyService.updatePolicyData("policy/securitypolicyset/", param).then(function (data) {
                    console.log(data);
                    console.log(data);
                    showToast(policyUpdated);
                }, function (err) {
                    console.log(err);
                    showToast(policyUpdateFailed);
                });
            };

        }

        $scope.updatePolicy = function () {
            alert("updatePolicy called");
            $scope.setEditMode();
        };


        $scope.callAccessControlPopup = function (accesscontrolpolicy, aclDataRetrieved, accesscontrolpolicyList, ev, selectedid) {
            $mdDialog.show({
                controller: accessControlPopupController,
                templateUrl: 'core/components/administration/policy/policy.accesscontrolPopup.html',
                parent: angular.element(document.body),
                targetEvent: ev,
                locals: {'accesscontrolpolicy': accesscontrolpolicy,
                    'aclDataRetrieved': aclDataRetrieved,
                    'accesscontrolpolicyList': accesscontrolpolicyList}
            }).then(function () {
//                        console.log($scope.selectedTenants);
//                        $sessionStorage.cloudData.selectedTenants = $scope.selectedTenants;
//                        console.log($sessionStorage.cloudData.selectedTenants);
            });
        };

        function accessControlPopupController($rootScope, $scope, $mdDialog, accesscontrolpolicy, aclDataRetrieved, accesscontrolpolicyList) {
//            $scope.tenant_activated = true;
//            if (!$sessionStorage.cloudData.selectedTenants) {
//                $sessionStorage.cloudData.selectedTenants = {};
//            }
            (function () {
                $scope.accesscontrolpolicy = $scope.selectedPolicy = accesscontrolpolicy;
                $scope.aclDataRetrieved = aclDataRetrieved;
                $scope.accesscontrolpolicyList = accesscontrolpolicyList;
                $scope.cancelDialog = function () {
                    $mdDialog.cancel();
                };

                $scope.done = function () {
                    console.log($scope.selectedPolicy);
                    $rootScope.$broadcast('listenPolicyChange', parseInt($scope.selectedPolicy), 'accessControlPolicyId');
//                    $rootScope.$broadcast('listenSelectedHosts', $scope.selected);
                    $mdDialog.hide();
                };
            })();

        }
        $scope.callMalwarePopup = function (malwarepolicy, malwareDataRetrieved, malwarepolicyList, ev) {
            $mdDialog.show({
                controller: malwarePopupController,
                templateUrl: 'core/components/administration/policy/policy.malwarePopup.html',
                parent: angular.element(document.body),
                targetEvent: ev,
                locals: {'malwarepolicy': malwarepolicy,
                    'malwareDataRetrieved': malwareDataRetrieved,
                    'malwarepolicyList': malwarepolicyList}
            })
                    .then(function () {
//                        console.log($scope.selectedTenants);
//                        $sessionStorage.cloudData.selectedTenants = $scope.selectedTenants;
//                        console.log($sessionStorage.cloudData.selectedTenants);
                    });
        };

        function malwarePopupController($rootScope, $scope, $mdDialog, malwarepolicy, malwareDataRetrieved, malwarepolicyList) {
//            $scope.tenant_activated = true;
//            if (!$sessionStorage.cloudData.selectedTenants) {
//                $sessionStorage.cloudData.selectedTenants = {};
//            }
            (function () {
                $scope.malwarepolicy = malwarepolicy;
                $scope.malwareDataRetrieved = malwareDataRetrieved;
                $scope.malwarepolicyList = malwarepolicyList;
                $scope.selectedPolicy = malwarepolicy;

                $scope.cancelDialog = function () {
                    $mdDialog.cancel();
                };

                $scope.done = function () {
                    console.log($scope.selectedPolicy);
                    $rootScope.$broadcast('listenPolicyChange', parseInt($scope.selectedPolicy), 'malwarePolicyId');
                    $mdDialog.hide();
                };
            })();

        }
        $scope.callThreatDetectionPopup = function (threatpreventionpolicy, threatDetectionDataRetrieved, threatpreventionpolicyList, ev) {
            $mdDialog.show({
                controller: threatDetectionPopupController,
                templateUrl: 'core/components/administration/policy/policy.threatDetectionPopup.html',
                parent: angular.element(document.body),
                targetEvent: ev,
                locals: {'threatpreventionpolicy': threatpreventionpolicy,
                    'threatDetectionDataRetrieved': threatDetectionDataRetrieved,
                    'threatpreventionpolicyList': threatpreventionpolicyList}
            })
                    .then(function () {
//                        console.log($scope.selectedTenants);
//                        $sessionStorage.cloudData.selectedTenants = $scope.selectedTenants;
//                        console.log($sessionStorage.cloudData.selectedTenants);
                    });
        };

        function threatDetectionPopupController($rootScope, $scope, $mdDialog, threatpreventionpolicy, threatDetectionDataRetrieved, threatpreventionpolicyList) {
//            $scope.tenant_activated = true;
//            if (!$sessionStorage.cloudData.selectedTenants) {
//                $sessionStorage.cloudData.selectedTenants = {};
//            }
            (function () {
                $scope.threatpreventionpolicy = threatpreventionpolicy;
                $scope.threatDetectionDataRetrieved = threatDetectionDataRetrieved;
                $scope.threatpreventionpolicyList = threatpreventionpolicyList;
                $scope.selectedPolicy = threatpreventionpolicy;
                $scope.cancelDialog = function () {
                    $mdDialog.cancel();
                };

                $scope.done = function () {
                    console.log($scope.selectedPolicy);
                    $rootScope.$broadcast('listenPolicyChange', parseInt($scope.selectedPolicy), 'threatPreventionPolicyId');
//                    $rootScope.$broadcast('listenSelectedHosts', $scope.selected);
                    $mdDialog.hide();
                };
            })();

        }

        $scope.editTenantPopUp = function(event,selectedtenant) {
            $scope.setEditMode('editTenant', true);
            $mdDialog.show({
                skipHide: true,
                preserveScope: true,
                controller: tenantListCtr,
                bindToController: true,
                templateUrl: 'core/components/administration/policy/tenants-dialogbox.html',
                parent: angular.element(document.body),
                targetEvent: event,
                fullscreen: false,
                scope: $scope,
                openFrom: { top: 1100, height: 0 },
                closeTo: { left: 1500 },
                locals: {'selectedtenant': selectedtenant}
            }).then(function() {

            });
        };

        function tenantListCtr($rootScope, $scope, $mdDialog, policyService,selectedtenant) {
            $scope.tenantselected = false;
            $scope.selectedTenantsValue = selectedtenant;

            $scope.canceltenantDialogue = function() {
                $mdDialog.cancel();
            };
            $scope.tenantSelected = false;
            $scope.tenants = $scope.tenantsList;
            $scope.onSelectTenantChanged = function() {
                console.log(" onSelectionChanged >> ");
                $scope.tenantSelected = true;
            };
            $scope.tenantdone = function(value) {
                $scope.tenantselected = true;
                if($scope.selectedTenantsValue){
                 var fo =  _.find($scope.tenants, function(sel){
                     return sel.id === parseInt($scope.selectedTenantsValue);
                  });
                 
                 if(fo){
                  $scope.selectedTenantObj = fo;  
                  $rootScope.$broadcast('listenPolicyChange', $scope.selectedTenantObj.id, 'tenantId');
                 }
                  
                }

                /*$scope.selectedTenantObj = JSON.parse(value);
                $rootScope.$broadcast('listenPolicyChange', parseInt($scope.selectedTenantObj.id), 'tenantId');*/
                $mdDialog.hide();
            };
        }


        $scope.getTenantDataForCloud = function(cloudObj) {
            $scope.tenantsList = [];
             policyService.getDataBasedOnId("infras", cloudObj.id + "/tenants", "").then(function(tenants) {
                _.each(tenants, function(tenant) {
                    tenant.cloudName = cloudObj.name;
                    $scope.tenantsList.push(tenant);
                });
                $scope.cloudsLength = $scope.cloudsLength -1;
                if($scope.cloudsLength === 0){
                    $scope.tennatsListCompleted = false;    
                }
            });
        };
        $scope.getTenants = function() {
            infrastructureConnectorService.getListOfInfrastructures().then(function(clouds) {
                $scope.cloudsLength = clouds.length;
                _.each(clouds, function(cloud) {
                    $scope.getTenantDataForCloud(cloud);
                });
            });
        };
        $scope.getTenants();
        $scope.$on('$viewContentLoaded', function(event){ 
            console.log(event);
            fixContainerHeight(1);
        });


    }

    angular.module('shieldxApp').controller('editPolicyCtr', editPolicyCtr);
})();

/*
 ShieldX Networks Inc. CONFIDENTIAL
 ----------------------------------
 *
 Copyright (c) 2016 ShieldX Networks Inc.
 All Rights Reserved.
 *
 NOTICE: All information contained herein is, and remains
 the property of ShieldX Networks Incorporated and its suppliers,
 if any. The intellectual and technical concepts contained
 herein are proprietary to ShieldX Networks Incorporated
 and its suppliers and may be covered by U.S. and Foreign Patents,
 patents in process, and are protected by trade secret or copyright law.
 Dissemination of this information or reproduction of this material
 is strictly forbidden unless prior written permission is obtained
 from ShieldX Networks Incorporated.
 */

(function() {
    function editthreatRuleCtrl(
        $scope,
        $rootScope,
        $state,
        $translate,
        $sessionStorage,
        policyService,
        $timeout,
        $q,
        $mdDialog,
        deploymentSpecificationService,
        infrastructureConnectorService,
        commonDataManagement
    ) {
        var deferred = $q.defer();
        $scope.promise = deferred.promise;
        $scope.promiseCompleted = true;
        $scope.disableSavePolicy = true;
        var initializing = true;
        $scope.policyselected = [];
        $scope.malwareAddForm = [];
        $scope.isSearchBarOpen = false;
        $scope.selected = [];
        $scope.policyDetails = {};
        $scope.saveupdatepolicyAdd = true;
        $scope.addNewPolicyArray = [];
        $scope.policyname = "";
        $scope.allRuleThreats = [];
        $scope.newRule = {};
        $scope.targets = ["Any","Client","Server"];
        $scope.severities = [];
        $scope.selectedOS = [];
        $scope.selectedApp = [];
        $scope.selectedProtocols = [];

        policyService.getPolicyDetail("threatpreventionpolicy","policy","severity").then(function(severityData) {
            $scope.severities = severityData;
        }, function(err) {
            console.log("new threat rule error");
        });
        var ruleData = commonDataManagement.getObj();
        console.log(ruleData);
        if(! angular.equals(ruleData, {})){
            $scope.newRule = ruleData;
            $scope.selectedOS = ruleData.osNames;
            $scope.selectedApp = ruleData.appNames;
            $scope.selectedProtocols = ruleData.protocolNames;

        } else {
            $state.go('home.policy.policylist.threatdetection');
        }
        $scope.showPopupList = function(eve,titletext,typeOfData,receivedData) {
            $mdDialog.show({
                skipHide: true,
                controller: rulePopupController,
                templateUrl: 'core/components/administration/policy/commonpopup.html',
                parent: angular.element(document.body),
                targetEvent: eve,
                fullscreen: true,
                scope: $scope,
                preserveScope: true,
                locals:{'titletext':titletext,'typeOfData':typeOfData,'receivedData' : receivedData}
            }).then(function() {

            });
        };
        $scope.addNewRule = function(){
            //add target here later {"protocolID": 0,"threatID": 0}
            var dataSet = {
                            'appNames':$scope.selectedApp.map(function(obj){return obj.name;}),
                            'osNames':$scope.selectedOS.map(function(obj){return obj.name;}),
                            'protocolNames':$scope.selectedProtocols.map(function(obj){return obj.protocolName;})
                            };
            var mainRuleObject = {"name" : $scope.newRule.name , "appNames": dataSet.appNames,"enabled": true,"orderNum": 0,"osNames": dataSet.osNames,"protocolNames": dataSet.protocolNames,"target" : $scope.newRule.target,"severities": [$scope.newRule.severity],"specificThreats": []};
            //set data to pass to parent
            commonDataManagement.setData(mainRuleObject);
            $state.go($rootScope.previousState,{policyId: ruleData.policyId});

        };
        $scope.cancelNewRule = function(){
            if(typeof $rootScope.previousState !== 'undefined')
                $state.go($rootScope.previousState,{policyId: ruleData.policyId});
            else
                $state.go('home.policy.policylist.threatdetection');

        };
        $rootScope.$on('$stateChangeStart',
            function(event, toState, toParams, fromState, fromParams){
                $rootScope.previousState = fromState;
        });
        function rulePopupController($scope, $mdDialog,policyService,titletext,typeOfData,receivedData) {
            $scope.typeOfData = typeOfData;
            $scope.titletext = titletext;
            $scope.selected = receivedData;
            $scope.items = [];
            $scope.host_activated = false;
            if(typeOfData === 'protocol'){
                policyService.getDataBasedOnId("policy","protocol").then(function(protocolData) {
                    $scope.items = protocolData.map(function(obj){return obj.protocolName;});
                    $scope.host_activated = true;
                }, function(err) {
                    $scope.host_activated = true;
                    console.log("new threat rule error");
                });
            } else {
                policyService.getPolicyDetail("threatpreventionpolicy","policy",typeOfData).then(function(responseData) {
                    $scope.items = responseData.map(function(obj){return obj.name;});
                    $scope.host_activated = true;
                }, function(err) {
                    $scope.host_activated = true;
                    console.log("new threat rule error");
                });
            }
            $scope.closeDialog = function() {
                    $mdDialog.hide();
            };
            (function(){  
                $scope.no_of_hosts = $scope.items.length;
                
                if ($scope.selected) {
                    $scope.no_of_selected_hosts = $scope.selected.length;
                } else {
                    $scope.no_of_selected_hosts = 0;
                }
                console.log($scope.selected);
                $scope.doneHosts = function() {
                    //$rootScope.$broadcast('listenSelectedHosts', $scope.selected);
                    $mdDialog.hide();
                };
                $scope.toggle = function (item, list) {
                    var isDeleted = false;
                    for (i = 0; i < list.length; i++) {
                            if (list[i] === item) {
                                list.splice(i, 1);
                                isDeleted = true;
                            }
                        }                        
                    if (!isDeleted) {
                        list.push(item);
                    }
                    $scope.no_of_selected_hosts = $scope.selected.length;
                };
                    $scope.exists = function (item, list) {
                        for (i = 0; i < list.length; i++) {
                            if (list[i] === item) {
                                return true;
                            }
                        }
                        return false;
                    
                    };
                    $scope.isIndeterminate = function () {
                        return ($scope.selected.length !== 0 &&
                            $scope.selected.length !== $scope.items.length);
                    };
                    $scope.isChecked = function () {
                        return $scope.selected.length === $scope.items.length;
                    };
                    $scope.toggleAll = function () {
                        if ($scope.selected.length === $scope.items.length) { //uncheck all
                            $scope.selected = [];
                        } else if ($scope.selected.length === 0 || $scope.selected.length > 0) {
                            $scope.selected = $scope.items.slice(0); //check all
                        }
                        $scope.no_of_selected_hosts = $scope.selected.length;
                    };
                //}
            })();
        }

    }

    angular.module('shieldxApp').controller('editthreatRuleCtr', editthreatRuleCtrl);
})();

/*
 ShieldX Networks Inc. CONFIDENTIAL
 ----------------------------------
 *
 Copyright (c) 2016 ShieldX Networks Inc.
 All Rights Reserved.
 *
 NOTICE: All information contained herein is, and remains
 the property of ShieldX Networks Incorporated and its suppliers,
 if any. The intellectual and technical concepts contained
 herein are proprietary to ShieldX Networks Incorporated
 and its suppliers and may be covered by U.S. and Foreign Patents,
 patents in process, and are protected by trade secret or copyright law.
 Dissemination of this information or reproduction of this material
 is strictly forbidden unless prior written permission is obtained
 from ShieldX Networks Incorporated.
 */

(function() {
    function newthreatDetectionCtrl(
        $scope,
        $rootScope,
        $state,
        $translate,
        $sessionStorage,
        policyService,
        $timeout,
        $q,
        $mdDialog,
        deploymentSpecificationService,
        infrastructureConnectorService,
        commonDataManagement
    ) {
        var deferred = $q.defer();
        $scope.promise = deferred.promise;
        $scope.promiseCompleted = true;
        $scope.disableSavePolicy = true;
        var initializing = true;
        $scope.policyselected = [];
        $scope.malwareAddForm = [];
        $scope.isSearchBarOpen = false;
        $scope.selected = [];
        $scope.saveupdatepolicyAdd = true;
        $scope.addNewPolicyArray = [];
        $scope.policyname = "";
        $scope.allRuleThreats = [];
        $scope.policyDetails = {};
        $scope.policyDetails.rules = [];
        var policyobject = $state.params.policyobject;
        var ruleData = $state.params.ruleobject;
        var existingrules = $state.params.existingrules;

        var policyCreateFailed = {
            'heading': 'Policy Creation failed',
            'subHeading': '&nbsp;',
            'type': 'fail',
            'timeout': 5000,
            'callback': function () {
                $state.reload();
            }
        };
        var policyCreateSuccess = {
            'heading': 'Policy Created Successfully',
            'subHeading': '&nbsp;',
            'type': 'success',
            'timeout': 5000
            
        };
        var policyCreateProgress = {
            'heading': 'Policy Create Inprogress',
            'subHeading': '&nbsp;',
            'type': 'success',
            'timeout': 5000
            
        };
        

        $scope.editRule = function(singleRule){
            singleRule.action = "edit";
            $state.go('home.policy.addthreatdetectionrule',{'policyobject':{'threatName':$scope.policyDetails.name,'tenantdetails':$scope.selectedTenantObj },'ruleobject':singleRule,'existingrules':$scope.policyDetails.rules});
        };

        
        if(policyobject){
            $scope.policyDetails.name = policyobject.threatName;
            $scope.selectedTenantObj = policyobject.tenantdetails;
            $scope.tenantSelected = true;
        }
        if(existingrules){
            $scope.policyDetails.rules = existingrules;
        }
         $scope.getTenantDataForCloud = function(cloudObj) {
            $scope.tenantsList = [];
            deploymentSpecificationService.getTenants(cloudObj.id).then(function(tenants) {
                _.each(tenants, function(tenant) {
                    tenant.cloudName = cloudObj.name;
                    $scope.tenantsList.push(tenant);
                });
            });
        };
        $scope.getTenants = function() {
            infrastructureConnectorService.getListOfInfrastructures().then(function(clouds) {
                _.each(clouds, function(cloud) {
                    $scope.getTenantDataForCloud(cloud);
                });
            });
        };
        $scope.getTenants();

        $scope.addNewThreat = function(){
            showToast(policyCreateProgress);
            console.log($scope.policyDetails);
            var threatMainObj = $scope.policyDetails;
            threatMainObj.id = 0;
            threatMainObj.isEditable = true;
            threatMainObj.tenantId = $scope.selectedTenantObj.id;
            threatMainObj.lastModified = Math.round(new Date().getTime()/1000);
            policyService.updateMalwarePolicyData("policy/threatpreventionpolicy",threatMainObj).then(function(returnData){
                console.log(returnData);
                showToast(policyCreateSuccess);
                commonDataManagement.clearData();
                $state.go('home.policy.policylist.threatdetection', { 'newPolicy': returnData });
            },function(error){
                showToast(policyCreateFailed);
                console.log(error);
            });
            console.log(threatMainObj);

        };
        
        $scope.cancelNewThreat = function(){
            $state.go('home.policy.policylist.threatdetection');
        };
        $scope.getStringData = function(appArray,protocolArray){
            var returnString = "";
            if(appArray && appArray.length)
                returnString = appArray.join();
            if(returnString && protocolArray && protocolArray.length)
                returnString += ","+protocolArray.join();
            else if(protocolArray && protocolArray.length)
                returnString = protocolArray.join();
            return returnString;
        };

        $scope.addthreatRule = function(){
            var  singleRule = {action:"add",id:0};
            $state.go('home.policy.addthreatdetectionrule',{'policyobject':{'threatName':$scope.policyDetails.name,'tenantdetails':$scope.selectedTenantObj },'ruleobject':singleRule,'existingrules':$scope.policyDetails.rules});
        };
        function tenantListCtr($scope, $mdDialog, policyService) {
                    $scope.canceltenantDialogue = function() {
                        //tenantSelection();
                        $mdDialog.cancel();
                    };
                    $scope.tenantSelected = false;
                    $scope.tenants = $scope.tenantsList;

                    $scope.$watch("selectedTenantsValue", function(newvalue, oldvalue) {
                        if (newvalue) {
                            $scope.tenantSelected = true;
                            $scope.selectedTenantObj = JSON.parse(newvalue);
                        }

                    });
                    $scope.tenantdone = function() {
                        //tenantSelection();
                        $mdDialog.cancel();
                    };
                }
        $scope.callpopupTenats = function(event) {
                    $mdDialog.show({
                        skipHide: true,
                        preserveScope: true,
                        controller: tenantListCtr,
                        bindToController: true,
                        templateUrl: 'core/components/administration/policy/tenants.html',
                        parent: angular.element(document.body),
                        targetEvent: event,
                        fullscreen: false,
                        scope: $scope,
                        openFrom: { top: 1100, height: 0 },
                        closeTo: { left: 1500 }
                    }).then(function() {

                    });
                };
        $scope.showMoreItemPopUp = function(event,data,name){
                $scope.showmorePopUpData = data;
                $scope.showMoreDataName = name;
                $mdDialog.show({
                    skipHide: true,
                    preserveScope: true,
                    controller: showMoreDataCtrl,
                    bindToController: true,
                    templateUrl: 'core/components/administration/policy/more-data.html',
                    parent: angular.element(document.body),
                    targetEvent: event,
                    fullscreen: false,
                    scope: $scope,
                    openFrom: { top: 1100, height: 0 },
                    closeTo: { left: 1500 }
                }).then(function() {

                });
            };
            function showMoreDataCtrl($mdDialog,$scope){
                $scope.cancelShowMoreDataPopup = function(){
                    $mdDialog.cancel();
                };
            }
    }

    angular.module('shieldxApp').controller('newthreatDetectionCtr', newthreatDetectionCtrl);
})();

/*
 ShieldX Networks Inc. CONFIDENTIAL
 ----------------------------------
 *
 Copyright (c) 2016 ShieldX Networks Inc.
 All Rights Reserved.
 *
 NOTICE: All information contained herein is, and remains
 the property of ShieldX Networks Incorporated and its suppliers,
 if any. The intellectual and technical concepts contained
 herein are proprietary to ShieldX Networks Incorporated
 and its suppliers and may be covered by U.S. and Foreign Patents,
 patents in process, and are protected by trade secret or copyright law.
 Dissemination of this information or reproduction of this material
 is strictly forbidden unless prior written permission is obtained
 from ShieldX Networks Incorporated.
 */

(function() {
    function newthreatRuleCtrl(
        $scope,
        $rootScope,
        $state,
        $translate,
        $sessionStorage,
        policyService,
        $timeout,
        $q,
        $mdDialog,
        deploymentSpecificationService,
        infrastructureConnectorService,
        commonDataManagement
    ) {
        var deferred = $q.defer();
        $scope.promise = deferred.promise;
        $scope.promiseCompleted = true;
        $scope.disableSavePolicy = true;
        $scope.selectedType = "type2";
        $scope.blockType = "app";
        var initializing = true;
        $scope.policyselected = [];
        $scope.malwareAddForm = [];
        $scope.isSearchBarOpen = false;
        $scope.selected = [];
        $scope.policyDetails = {};
        $scope.saveupdatepolicyAdd = true;
        $scope.addNewPolicyArray = [];
        $scope.policyname = "";
        $scope.allRuleThreats = [];
        $scope.newRule = {};
        $scope.targets = ["CLIENT","SERVER"];
        $scope.severities = [];
        $scope.selectedOS = [];
        $scope.selectedApp = [];
        $scope.selectedProtocols = [];
        $scope.rulepageTitle = "Add Rule";
        $scope.showMoreAppIds= false;
        $scope.showMoreProtocol = false;
        $scope.showMoreOS = false;
        $scope.showMoreThreatsList = false;
        $scope.allthreatdata = [];
        $scope.transitState = 0;
        var policyobject = $state.params.policyobject;
        var ruleData = $state.params.ruleobject;
        var existingRules = $state.params.existingrules;
        var indexToupdate = -1;
        console.log("state params",$state);
        $scope.promiseCompleted = false;
        policyService.getPolicyDetail("threatpreventionpolicy","policy","severity").then(function(severityData) {
            $scope.severities = severityData;
        }, function(err) {
            console.log("new threat rule error");
        });
        policyService.getListOfPoliciesDetails("threats",0).then(function(allthreatdata) {
            console.log("This is all threat data here");
            console.log(allthreatdata);
            //allthreatdata.length = 1000;
            $scope.allthreatdata = angular.copy(allthreatdata);
            $scope.globalThreatList = angular.copy(allthreatdata);
            $scope.selectedThreats = [];
            if(ruleData.action === "edit"){
                _.each(ruleData.specificThreats,function(singleSpecific){
                    var matchedValue = _.find($scope.globalThreatList,{"protocolID":singleSpecific.protocolID.toString(),"threatID":singleSpecific.threatID.toString()});
                    $scope.selectedThreats.push(matchedValue);
                });
            }
            $scope.promiseCompleted = true;
        }, function(err) {
            console.log("threat prevention policy error data");
        });
        console.log(ruleData);
        console.log("This is the value that we get");
        console.log(ruleData);
        $scope.newRule = ruleData;
        if(ruleData.action === "edit"){
            $scope.rulepageTitle = "Edit Rule";
            if(ruleData.osNames || ruleData.osNames || ruleData.protocolNames){
                $scope.selectedType = "type2";    
            }else{
                $scope.selectedType = "type1";    
            }
            
            $scope.selectedOS = (ruleData.osNames) ? ruleData.osNames : [];
            $scope.selectedApp = (ruleData.appNames) ? ruleData.appNames : [];
            $scope.selectedProtocols = (ruleData.protocolNames) ? ruleData.protocolNames : [];
            $scope.blockType = ($scope.selectedProtocols.length > 0)?"protocol":"app";
            indexToupdate = _.findIndex(existingRules,ruleData);
        } 
        $scope.checkOther = function(changeType){
            if(changeType === 'app' && $scope.selectedApp.length){
                /*$scope.clearmsg = "To detect/block Protocols you must first clear Applications ";*/
                $scope.transitState = 1;
            } else if(changeType === 'protocol' && $scope.selectedProtocols.length) {
                /*$scope.clearmsg = "To detect/block Applications you must first clear Protocols";*/
                $scope.transitState = 2;
            } else {
                /*$scope.transit = false;*/
                $scope.transitState = 0;
            }
        };
        $scope.clearState = function(dataToclear){
            dataToclear.length = 0;
            $scope.transitState = 0;
        };
        $scope.showPopupList = function(eve,titletext,typeOfData,receivedData) {
            $mdDialog.show({
                skipHide: true,
                controller: rulePopupController,
                templateUrl: 'core/components/administration/policy/commonpopup.html',
                parent: angular.element(document.body),
                targetEvent: eve,
                fullscreen: true,
                scope: $scope,
                preserveScope: true,
                locals:{'titletext':titletext,'typeOfData':typeOfData,'receivedData' : receivedData}
            }).then(function(selectStatus) {
                if(selectStatus){
                    console.log("selected is this ",$scope.selected);
                    switch (typeOfData) {
                    case "protocol":
                        $scope.selectedProtocols = $scope.selected;
                        break;
                    case "os":
                        $scope.selectedOS = $scope.selected;
                        break;
                    case "appid":
                        $scope.selectedApp = $scope.selected;
                        break;
                    }
                }
            });
        };
        $scope.showSSList = function(event,receivedData){
            $mdDialog.show({
                skipHide: true,
                controller: specificThreatPopupController,
                templateUrl: 'core/components/administration/policy/specific-threats.html',
                parent: angular.element(document.body),
                targetEvent: event,
                fullscreen: true,
                onComplete: function(scope, element, options){
                    //console.log("calling on onComplete",scope, element, options);
                    scope.items = scope.globalThreatList;
                    $scope.no_of_hosts = $scope.items.length;
                    $scope.host_activated = true;
                },
                scope: $scope,
                preserveScope: true,
                locals:{'receivedData' : receivedData, globalThreatList:$scope.globalThreatList}
            }).then(function() {
                $scope.selectedThreats = angular.copy($scope.selected);

            });
        };
        $scope.deleteSelected = function () {
            $scope.globalThreatList = angular.copy($scope.allthreatdata);
            $scope.items = angular.copy($scope.allthreatdata);
            $scope.selected=[];
            $scope.selectedThreats=[];
            $scope.selected.length = 0;
            $scope.selectedThreats.length = 0;
        };
        function specificThreatPopupController($scope, $mdDialog,policyService,Webworker,receivedData){
            $scope.host_activated = false;
            var temp = angular.copy(receivedData);
            //$scope.no_of_hosts = $scope.items.length;
            if(temp)
            {
               $scope.selected =  temp;  
            } else {
                $scope.selected =  [];
            }
            
            $scope.closeDialog = function() {
                    $mdDialog.hide();
            };
            
            /*$scope.no_of_hosts = $scope.items.length;*/
            
            if ($scope.selected) {
                $scope.no_of_selected_hosts = $scope.selected.length;
            } else {
                $scope.no_of_selected_hosts = 0;
            }
            $scope.doneHosts = function() {
                //$rootScope.$broadcast('listenSelectedHosts', $scope.selected);
                $scope.selected = [];
                for(var i=0; i < $scope.items.length; i++){
                   if($scope.items[i].check){
                    $scope.selected.push($scope.items[i]);
                   } 
                }
                console.log("Selected SS ",$scope.selected);
                $mdDialog.hide();
            };
            $scope.toggle = function (item, list) {
                var isDeleted = false;
                /* for (i = 0; i < list.length; i++) {
                        if (list[i].protocolID === item.protocolID && list[i].threatID === item.threatID) {
                            list.splice(i, 1);
                            isDeleted = true;
                        }
                    }                        
                if (!isDeleted) {
                    list.push(item);
                }
                */
                $scope.selected.push(item);
                $scope.no_of_selected_hosts = $scope.selected.length;
            };
            $scope.exists = function (item, list) {
                   /*if($scope.toggleAllClicked){
                     return true;
                   }*/
                   /* for (i = 0; i < list.length; i++) {
                        if (list[i].protocolID === item.protocolID && list[i].threatID === item.threatID) {
                            return true;
                        }
                    }
                    return false;*/
                
                };
                $scope.isIndeterminate = function () {
                    return $scope.toggleAllClicked === false;
                };
                $scope.isChecked = function () {
                    return $scope.toggleAllClicked;
                };
                $scope.toggleAllClicked = false;
                $scope.checkUncheck = function(item, checkvalue){
                     function selectDeselectAll(array, value) {
                        console.log('selectDeselectAll  start');

                         for(var i=0; i < array.length; i++){
                           array[i].check = value;
                        }
                        console.log('selectDeselectAll  ends');
                        console.dir(array);
                        complete(array);
                     }
                    var myWorker = Webworker.create(selectDeselectAll, {async: true });
                    myWorker.run(item, checkvalue).then(function(result) {
                        // promise is resolved.
                       console.log("web worker finish");
                       console.dir(result);
                       $scope.globalThreatList = result;
                       $scope.items = result;
                    }, function(error){
                        console.log(progress);
                    }, function(progress) {
                         console.log(progress);
                    });
                };
                $scope.toggleAll = function () {
                    $scope.toggleAllClicked = ! $scope.toggleAllClicked;
                    $scope.checkUncheck($scope.items, $scope.toggleAllClicked);
                    if($scope.toggleAllClicked){
                       $scope.no_of_selected_hosts = $scope.items.length; 
                   } else {
                      $scope.no_of_selected_hosts = 0;
                   } 
                    
                };
        }

        $scope.addNewRule = function(){
            //add target here later {"protocolID": 0,"threatID": 0}
            var mainRuleObject = {};
            if($scope.selectedType === "type1"){
                mainRuleObject = {"id" : $scope.newRule.id ,"name" : $scope.newRule.name , "appNames": null,"enabled": true,"orderNum": 0,"osNames": null,"protocolNames": null,"protectionType" : null,"severities": [],"specificThreats": $scope.selectedThreats};
            } else {
                var appNames = ($scope.selectedApp.length) ? $scope.selectedApp : null;
                var protocolNames = ($scope.selectedProtocols.length) ? $scope.selectedProtocols : null;
                var osNames = ($scope.selectedOS.length) ? $scope.selectedOS : null;
                mainRuleObject = {"id" : $scope.newRule.id ,"name" : $scope.newRule.name , "appNames": appNames,"enabled": true,"orderNum": 0,"osNames": osNames,"protocolNames": protocolNames,"protectionType" : $scope.newRule.protectionType,"severities": [$scope.newRule.severity],"specificThreats": []};
                
            }
            mainRuleObject.isdirty = true;
            console.log("values set");
            console.log(mainRuleObject);
            if(indexToupdate === -1){
                existingRules.push(mainRuleObject);
            } else {
                existingRules[indexToupdate] = mainRuleObject;
            }
            if(typeof policyobject.policyId !== 'undefined')
                $state.go($rootScope.previousState,{policyId: policyobject.policyId,'policyobject' : policyobject,'existingrules' : existingRules});
            else
                $state.go($rootScope.previousState,{'policyobject' : policyobject,'existingrules' : existingRules});
            
        };
        
        $scope.cancelNewRule = function(){
            if(typeof $rootScope.previousState !== 'undefined'){
                if($scope.newRule.id === 0){
                    if(typeof policyobject.policyId !== 'undefined'){
                        $state.go($rootScope.previousState,{policyId: policyobject.policyId,'policyobject' : policyobject,'existingrules' : existingRules});
                    } else{
                        $state.go($rootScope.previousState,{'policyobject' : policyobject,'existingrules' : existingRules});
                    }
                } 
                else {
                        $state.go($rootScope.previousState,{policyId: policyobject.policyId,'policyobject' : policyobject,'existingrules' : existingRules});
                    }
            }
            else
                $state.go('home.policy.policylist.threatdetection');

        };
        
        function rulePopupController($scope, $mdDialog,policyService,titletext,typeOfData,receivedData) {
            $scope.typeOfData = typeOfData;
            $scope.titletext = titletext;
            $scope.selected = angular.copy(receivedData);
            $scope.items = [];
            $scope.host_activated = false;
            console.log("Selected OS ",$scope.selectedOS);
            if(typeOfData === 'protocol'){
                policyService.getDataBasedOnId("policy","protocol").then(function(protocolData) {
                    $scope.items = protocolData.map(function(obj){return obj.protocolName;});
                    $scope.host_activated = true;
                }, function(err) {
                    $scope.host_activated = true;
                    console.log("new threat rule error");
                });
            } else {
                policyService.getPolicyDetail("threatpreventionpolicy","policy",typeOfData).then(function(responseData) {
                    $scope.items = responseData.map(function(obj){return obj.name;});
                    $scope.host_activated = true;
                }, function(err) {
                    $scope.host_activated = true;
                    console.log("new threat rule error");
                });
            }
            $scope.closeDialog = function() {
                    $mdDialog.hide(false);
            };
            (function(){  
                $scope.no_of_hosts = $scope.items.length;
                
                if ($scope.selected) {
                    $scope.no_of_selected_hosts = $scope.selected.length;
                } else {
                    $scope.no_of_selected_hosts = 0;
                }
                $scope.doneHosts = function() {
                    //$rootScope.$broadcast('listenSelectedHosts', $scope.selected);
                    console.log("Selected OS ",$scope.selectedOS);
                    $mdDialog.hide(true);
                };
                $scope.toggle = function (item, list) {
                    var isDeleted = false;
                    for (i = 0; i < list.length; i++) {
                            if (list[i] === item) {
                                list.splice(i, 1);
                                isDeleted = true;
                            }
                        }                        
                    if (!isDeleted) {
                        list.push(item);
                    }
                    $scope.no_of_selected_hosts = $scope.selected.length;
                };
                    $scope.exists = function (item, list) {
                        for (i = 0; i < list.length; i++) {
                            if (list[i] === item) {
                                return true;
                            }
                        }
                        return false;
                    
                    };
                    $scope.isIndeterminate = function () {
                        return ($scope.selected.length !== 0 &&
                            $scope.selected.length !== $scope.items.length);
                    };
                    $scope.isChecked = function () {
                        return $scope.selected.length === $scope.items.length;
                    };
                    $scope.toggleAll = function () {
                        if ($scope.selected.length === $scope.items.length) { //uncheck all
                            $scope.selected = [];
                        } else if ($scope.selected.length === 0 || $scope.selected.length > 0) {
                            $scope.selected = $scope.items.slice(0); //check all
                        }
                        $scope.no_of_selected_hosts = $scope.selected.length;
                    };
                //}
            })();
        }

        $scope.$on('$viewContentLoaded', function(event){ 
            console.log(event);
            fixContainerHeight(1);
        });
        $scope.showMoreItemPopUp = function(event,data,name){
            if(name === 'Threats'){
                data = data.map(function(singleObject){
                    return singleObject.name;
                });
            }
                $scope.showmorePopUpData = data;
                $scope.showMoreDataName = name;
                $mdDialog.show({
                    skipHide: true,
                    preserveScope: true,
                    controller: showMoreDataCtrl,
                    bindToController: true,
                    templateUrl: 'core/components/administration/policy/more-data.html',
                    parent: angular.element(document.body),
                    targetEvent: event,
                    fullscreen: false,
                    scope: $scope,
                    openFrom: { top: 1100, height: 0 },
                    closeTo: { left: 1500 }
                }).then(function() {

                });
            };
            function showMoreDataCtrl($mdDialog,$scope){
                $scope.cancelShowMoreDataPopup = function(){
                    $mdDialog.cancel();
                };
            }
    }

    angular.module('shieldxApp').controller('newthreatRuleCtr', newthreatRuleCtrl);
})();

/*
 ShieldX Networks Inc. CONFIDENTIAL
 ----------------------------------
 *
 Copyright (c) 2016 ShieldX Networks Inc.
 All Rights Reserved.
 *
 NOTICE: All information contained herein is, and remains
 the property of ShieldX Networks Incorporated and its suppliers,
 if any. The intellectual and technical concepts contained
 herein are proprietary to ShieldX Networks Incorporated
 and its suppliers and may be covered by U.S. and Foreign Patents,
 patents in process, and are protected by trade secret or copyright law.
 Dissemination of this information or reproduction of this material
 is strictly forbidden unless prior written permission is obtained
 from ShieldX Networks Incorporated.
 */

(function() {
    function policyCtr(
        $scope
        
    ) {

        $scope.$emit('listenHeaderText', { headerText: "Policy" });    

    }

    angular.module('shieldxApp').controller('policyCtr', policyCtr);
})();

/*
 ShieldX Networks Inc. CONFIDENTIAL
 ----------------------------------
 *
 Copyright (c) 2016 ShieldX Networks Inc.
 All Rights Reserved.
 *
 NOTICE: All information contained herein is, and remains
 the property of ShieldX Networks Incorporated and its suppliers,
 if any. The intellectual and technical concepts contained
 herein are proprietary to ShieldX Networks Incorporated
 and its suppliers and may be covered by U.S. and Foreign Patents,
 patents in process, and are protected by trade secret or copyright law.
 Dissemination of this information or reproduction of this material
 is strictly forbidden unless prior written permission is obtained
 from ShieldX Networks Incorporated.
 */

(function () {
    function policyListCtrl(
        $scope,
        $state,
        policyService,
        $q,
        userSessionMenagment
    ) {

        $scope.$emit('listenHeaderText', { headerText: "Policy" });
        var url = $state.current.url;
        if (url.indexOf("threatdetection") > 0 ) {
            $state.go('home.policy.policylist.threatdetection');
        } else if (url.indexOf("malware") >0 ) {
            $state.go('home.policy.policylist.malware');
        } else if (url.indexOf("securitypolicyset") >0 ) {
            $state.go('home.policy.policylist.securitypolicyset');
        } else if (url.indexOf("globalthreat") >0 ) {
            $state.go('home.policy.policylist.globalthreat');
        } 
        else {
            $state.go('home.policy.policylist.accesscontrol');
        }

        $scope.$on('$stateChangeSuccess', function(event, toState, toParams, fromState, fromParams) {
            if (toState.data) {
                $scope.currentTab = toState.data.selectedTab;
            }

        });

        var deferred = $q.defer();
        $scope.promise = deferred.promise;
        $scope.promiseInProgress = true;
        $scope.policyselected = [];
        $scope.selected = [];
        $scope.policyList = [];
        $scope.query = {
            order: 'name',
            limit: 10,
            page: 1
        };

        /*policyService.getSecurityPolicySet().then(function (policyData) {
            $scope.promiseInProgress = false;
            $scope.policyList = policyData;
            deferred.resolve();
        }, function (err) {
            deferred.reject();
            $scope.promiseInProgress = false;
        });*/

        $scope.toggleSearchBar = function (event) {
            $scope.isSearchBarOpen = $scope.isSearchBarOpen === false ? true : false;
            if ($scope.isSearchBarOpen)
                angular.element(event.currentTarget.firstElementChild).css('color', '#4a90e2');
            else
                angular.element(event.currentTarget.firstElementChild).css('color', '#6d6e71');
        };


      
        var create_id = authorities("policy_create");
        var delete_id = authorities("policy_delete");
        var update_id = authorities("policy_update");
        $scope.is_create_policy = userSessionMenagment.isUserAllowd(create_id);
        $scope.is_update_policy = userSessionMenagment.isUserAllowd(update_id);
        $scope.is_delete_policy = userSessionMenagment.isUserAllowd(delete_id);
       
        /*$scope.gotoAddPolicySetView = function() {
            $state.go("home.policy.policydetail");
        };*/

        /*$scope.deletePolicy = function(id) {
            policyService.deletePolicyBasedOnID("policy/securitypolicyset", id).then(function(res) {
                var toastparam = {
                    'heading': 'Policy deleted  Successfully',
                    'subHeading': 'Policy deleted  Successfully',
                    'type': 'success',
                    'timeout': 5000,
                    'callback': function () {
                        $state.reload();
                    }
                };
                showToast(toastparam);

            }, function (err) {
                    var toastparam = {
                        'heading': 'Policy delete  failed',
                        'subHeading': 'Policy deletion failed with error ' + err.message,
                        'type': 'fail',
                        'timeout': 5000
                    };
                    showToast(toastparam);

            });
        };*/

        $scope.$on('$viewContentLoaded', function (event) {
            fixContainerHeight(1);
        });

    }
    angular.module('shieldxApp').controller('policyListCtrl', policyListCtrl);
})();
/*
 ShieldX Networks Inc. CONFIDENTIAL
 ----------------------------------
 *
 Copyright (c) 2016 ShieldX Networks Inc.
 All Rights Reserved.
 *
 NOTICE: All information contained herein is, and remains
 the property of ShieldX Networks Incorporated and its suppliers,
 if any. The intellectual and technical concepts contained
 herein are proprietary to ShieldX Networks Incorporated
 and its suppliers and may be covered by U.S. and Foreign Patents,
 patents in process, and are protected by trade secret or copyright law.
 Dissemination of this information or reproduction of this material
 is strictly forbidden unless prior written permission is obtained
 from ShieldX Networks Incorporated.
 */

(function () {
    function spsPolicyListCtr(
        $scope,
        $state,
        $translate,
        policyService,
        $q,
        deploymentSpecificationService,
        infrastructureConnectorService,
        commonDataManagement
    ) {
        commonDataManagement.clearData();
        var deferred = $q.defer();
        $scope.promise = deferred.promise;
        $scope.promiseCompleted = true;
         $scope.tenantsListCompleted = true;
        $scope.promiseInProgress = true;
        $scope.policyselected = [];
        $scope.selected = [];
        $scope.policyList = [];
        $scope.query = {
            order: 'name',
            limit: 10,
            page: 1
        };
        policyService.getTotalTenats().then(function(data){
            $scope.tenantsList = data;
            $scope.tenantsListCompleted = false;
            renderData();
        },function(err){
            console.log("unable to fetch tenants");
            $scope.tenantsListCompleted = false;
            renderData();
        });
        policyService.getSecurityPolicySet().then(function (policyData) {
            
            $scope.ogPolicyData = policyData;
            /*  var PromiseData = _.each(policyData,function(item){
                        policyService.getPolicyDetail("policyassignments", "chassis", item.id).then(function(assignmentdata) {
                            console.log(item.id);
                            console.log(assignmentdata);
                            item.assignmentData= assignmentdata[item.id];
                        });
                    });*/
            $q.all(
                _.each(policyData,function(item){
                        policyService.getPolicyDetail("policyassignments", "chassis", item.id).then(function(assignmentdata) {
                            console.log(item.id);
                            console.log(assignmentdata);
                            item.assignmentData= assignmentdata[item.id];
                        });
                    })
                ).then(function(){
                    $scope.promiseInProgress = false;
                    renderData();    
                });
           /* _.each(policyData,function(item){
                console.log(item.id);

                policyService.getPolicyDetail("policyassignments", "chassis", item.id).then(function(assignmentdata) {
                    console.log(assignmentdata);
                    item.assignmentData= assignmentdata;
                }).finally(function(){
                    renderData();    
                });
            });*/
            deferred.resolve();
        }, function (err) {
            deferred.reject();
            $scope.promiseCompleted = false;
            $scope.promiseInProgress = false;
            renderData();
        });

        renderData = function(){
            if(!$scope.promiseInProgress && !$scope.tennatsListCompleted){
                $scope.promiseCompleted = false;
                $scope.policyList =  $scope.ogPolicyData;
                _.each($scope.tenantsList, function(value) {
                    for (var i = 0; i < $scope.policyList.length; i++) {
                        if ($scope.policyList[i].tenantId === value.id) {
                            $scope.policyList[i].tenantName = value.name;
                        }
                    }
                }); 
            }
        };

     /*   $scope.getTenantDataForCloud = function(cloudObj) {
            $scope.tenantsList = [];
            policyService.getDataBasedOnId("infras", cloudObj.id + "/tenants", "").then(function(tenants) {
                _.each(tenants, function(tenant) {
                    tenant.cloudName = cloudObj.name;
                    $scope.tenantsList.push(tenant);
                });
                $scope.cloudsLength = $scope.cloudsLength -1;
                if($scope.cloudsLength === 0){
                    $scope.tennatsListCompleted = false;  
                    renderData();  
                }
            });
        };

        $scope.getTenants = function() {
            infrastructureConnectorService.getListOfInfrastructures().then(function(clouds) {
                $scope.cloudsLength = clouds.length;
                _.each(clouds, function(cloud) {
                    $scope.getTenantDataForCloud(cloud);
                });
            });
        };
        $scope.getTenants();*/

        $scope.toggleSearchBar = function (event) {
            $scope.isSearchBarOpen = $scope.isSearchBarOpen === false ? true : false;
            if ($scope.isSearchBarOpen)
                angular.element(event.currentTarget.firstElementChild).css('color', '#4a90e2');
            else
                angular.element(event.currentTarget.firstElementChild).css('color', '#6d6e71');
        };

        $scope.gotoAddPolicySetView = function() {
            $state.go("home.policy.policydetail.securitypolicyset");
        };

        $scope.deletePolicy = function(policy) {
            policyService.deletePolicyBasedOnID("policy/securitypolicyset", policy.id).then(function(res) {
                var toastparam = {
                    'heading': 'Policy deleted  Successfully',
                    'subHeading': 'Policy deleted  Successfully',
                    'type': 'success',
                    'timeout': 5000,
                    'callback': function () {
                        $state.reload();
                    }
                };
                showToast(toastparam);

        }, function (err) {
                var toastparam = {
                    'heading': 'Policy delete  failed',
                    'subHeading': 'Policy deletion failed with error ' + err.message,
                    'type': 'fail',
                    'timeout': 5000
                };
                showToast(toastparam);

        });
        };


        $scope.callpopupDuplicatePolicy = function(data) {
                var copyData = angular.copy(data);
                copyData.id = 0;
                copyData.name = copyData.name + ' copy';
                copyData.isEditable = true;
                var date = new Date();
                copyData.lastModified = date.getTime();
                var path = "policy/securitypolicyset";
                toastparam = {
                    'heading': 'Security Policy Set creation in progress',
                    'subHeading': 'Security Policy Set creation intiated with name ' + copyData.name,
                    'type': 'progress',
                    'timeout': 15000
                };
                showToast(toastparam);
                policyService.createPolicyData(path, copyData).then(function(data) {
                    $scope.newPolicyCreated = data;
                    toastparam = {
                        'heading': 'Security Policy Set created successfully',
                        'subHeading': 'New Security Policy Set created with name ' + copyData.name,
                        'type': 'success',
                        'timeout': 5000
                    };
                    showToast(toastparam);

                }, function(err) {
                    toastparam = {
                        'heading': 'Security Policy Set creation failed',
                        'subHeading': 'Security Policy Set ' + err.message,
                        'type': 'fail',
                        'timeout': 5000
                    };
                    showToast(toastparam);

                 }).finally(function() {
                    $state.go('home.policy.policylist.securitypolicyset', { 'newPolicy': $scope.newPolicyCreated,'duplicated':'d' });
                });
       };

        $scope.$on('$viewContentLoaded', function (event) {
            fixContainerHeight(1);
        });

    }
    angular.module('shieldxApp').controller('spsPolicyListCtr', spsPolicyListCtr);
})();
/*
 ShieldX Networks Inc. CONFIDENTIAL
 ----------------------------------
 *
 Copyright (c) 2016 ShieldX Networks Inc.
 All Rights Reserved.
 *
 NOTICE: All information contained herein is, and remains
 the property of ShieldX Networks Incorporated and its suppliers,
 if any. The intellectual and technical concepts contained
 herein are proprietary to ShieldX Networks Incorporated
 and its suppliers and may be covered by U.S. and Foreign Patents,
 patents in process, and are protected by trade secret or copyright law.
 Dissemination of this information or reproduction of this material
 is strictly forbidden unless prior written permission is obtained
 from ShieldX Networks Incorporated.
 */

(function() {
    function threatDetectionCtrl(
        $scope,
        $state,
        $translate,
        $sessionStorage,
        policyService,
        $timeout,
        $q,
        $mdDialog,
        deploymentSpecificationService,
        infrastructureConnectorService,
        commonDataManagement
    ) {
        commonDataManagement.clearData();
        var deferred = $q.defer();
        $scope.promise = deferred.promise;
        $scope.promiseCompleted = true;
        $scope.disableSavePolicy = true;
        var initializing = true;
        $scope.policyselected = [];
        $scope.malwareAddForm = [];
        $scope.isSearchBarOpen = false;
        $scope.selected = [];
        //$scope.threatList = [];
        $scope.saveupdatepolicyAdd = true;
        $scope.addNewPolicyArray = [];
        $scope.policyname = "";
        //var paramId = parseInt($state.params.policyId);
        var newPolicyId = parseInt($state.params.newPolicy);
        var DuplicatedPolicy = $state.params.duplicated; 
        //$scope.dataUpdated = false;
        
        var policyDeleteFailed = {
            'heading': 'Policy Delete failed',
            'subHeading': '&nbsp;',
            'type': 'fail',
            'timeout': 5000
            
        };
        var policyDeleteSuccess = {
            'heading': 'Policy Deleted Successfully',
            'subHeading': '&nbsp;',
            'type': 'success',
            'timeout': 5000,
            
        };
        var policyDeleteProgress = {
            'heading': 'Policy Deleted Inprogress',
            'subHeading': '&nbsp;',
            'type': 'progress',
            'timeout': 5000
            
        };
         var policyCreateProgress = {
            'heading': 'Policy Create Inprogress',
            'subHeading': '&nbsp;',
            'type': 'progress',
            'timeout': 5000
            
        };
        var policyCreateFailed = {
            'heading': 'Policy Creation failed',
            'subHeading': '&nbsp;',
            'type': 'fail',
            'timeout': 5000
            
        };
        var policyCreateSuccess = {
            'heading': 'Policy Created Successfully',
            'subHeading': '&nbsp;',
            'type': 'success',
            'timeout': 5000
            
        };

         policyService.getTotalTenats().then(function(data){
            $scope.tenantsList = data;
            $scope.tenantsListCompleted = true;
            renderData();
        },function(err){
            console.log("unable to fetch tenants");
            $scope.tenantsListCompleted = true;
            renderData();
        });
        $scope.openGroups = function(event,policyName){
            $scope.assignmentPolicyName = policyName;
            $mdDialog.show({
                skipHide: true,
                controller: assignmentCountCtrl,
                bindToController: true,
                preserveScope: true,
                templateUrl: 'core/components/administration/policy/res-group-list.html',
                parent: angular.element(document.body),
                targetEvent: event,
                fullscreen: true,
                scope: $scope,
                openFrom: { top: 1100, height: 0 },
                closeTo: { left: 1500 }
            }).then(function() {

            });

        };
        function assignmentCountCtrl(){
            $scope.isAGSearchBarOpen = false;
             $scope.cancelassignmentControlDialogue = function() {
                    $mdDialog.cancel();
                    //$state.reload();
             };
             $scope.toggleSearchBarAsignment = function(event) {
                $scope.isAGSearchBarOpen = $scope.isAGSearchBarOpen === false ? true : false;
                if ($scope.isAGSearchBarOpen)
                    angular.element(event.currentTarget.firstElementChild).css('color', '#4a90e2');
                else
                    angular.element(event.currentTarget.firstElementChild).css('color', '#6d6e71');
            };
        }
        $scope.duplicateThreat = function(singleThreat){
            var newThreatObj = angular.copy(singleThreat);
            newThreatObj.id = 0;
            _.each(newThreatObj.rules,function(rule){
                rule.id = 0;
            });
            newThreatObj.name = singleThreat.name + " copy";
            showToast(policyCreateProgress);
            policyService.updateMalwarePolicyData("policy/threatpreventionpolicy",newThreatObj).then(function(returnData){
                console.log(returnData);
                $scope.newthreatCreated = returnData;
                showToast(policyCreateSuccess);
                commonDataManagement.clearData();
            },function(error){
                showToast(policyCreateFailed);
                console.log(error);
            }).finally(function(){
                $state.go('home.policy.policylist.threatdetection', { 'newPolicy': $scope.newthreatCreated,'duplicated':'d' });
            });

        };
        function renderData(){
            policyService.getListOfPoliciesDetails("threatpreventionpolicy","policy").then(function(threatdata) {
                    $scope.threatList = [];
                    $scope.intialThreatData = [];
                    _.each(threatdata,function(singleThreat){
                        singleThreat.tenantData = _.find($scope.tenantsList, {"id": parseInt(singleThreat.tenantId)});
                        if (singleThreat.id === newPolicyId) {
                               if(DuplicatedPolicy !== ''){
                                    singleThreat.duplicatedPolicy = true;
                                }else{
                                    singleThreat.newPolicy = true;    
                                }
                                $scope.intialThreatData.unshift(singleThreat);
                            } else {
                                $scope.intialThreatData.push(singleThreat);
                            }
                        
                        $scope.threatList.push(singleThreat);
                    });
                    //$scope.threatList = tempList;
                    $scope.promiseCompleted = false;
                    //$scope.threatList = threatdata;
                    console.log($scope.threatList);
                    //$scope.threatList = threatdata;
                    deferred.resolve();
                }, function(err) {
                    console.log("threat prevention policy error data");
                    deferred.reject();
                    $scope.promiseCompleted = false;
                });
            }
        //}
        $scope.$emit('listenHeaderText', { headerText: "Policy" });
        //$scope.malwarePolicyBasedId = policyService.getDataBasedOnId(paramId, "malwarepolicy");
        /*.then(function (data) {
            $scope.malwarepolicystoredData = data;
        });*/
        //$scope.malwarepolicystoredData = $sessionStorage.infrastructureObj[0].malwarepolicy;
        function confirmDeletePolicyCtr($scope, $mdDialog,policy){
        console.log("  confirmDeletePolicyCtr ",policy);
        $scope.policy = policy;
        $scope.hide = function (policy) {
            $mdDialog.hide(policy);
        };
        $scope.closeDialog = function () {
            $mdDialog.cancel();
        };
        $scope.closeDialogWithAnswer = function () {
            $scope.hide(policy);
        };
    }
       /* $scope.deleteThreat = function(policy,event){
            $mdDialog.show({
                    controller: confirmDeletePolicyCtr,
                    templateUrl: 'core/components/administration/policy/delete-threat-dialog.html',
                    parent: angular.element(document.body),
                    targetEvent: event,
                    clickOutsideToClose: true,
                    locals:{
                        policy:policy
                    },
                    skipHide: true,
                    preserveScope: true,
                   
                }).then(function (answerVal) {
                    $scope.deletePolicy(answerVal);
                }, function () {
                    
                });
            };*/

            $scope.deletePolicy = function(policy){
               showToast(policyDeleteProgress);
            policyService.deletePolicyBasedOnID("policy/threatpreventionpolicy",policy.id).then(function(responseData){
                showToast(policyDeleteSuccess);
            },function(error){
                showToast(policyDeleteFailed);
                console.log("Error while deleting data");
            }).finally(function(){
                $state.reload();
            });
            };

        
        $scope.toggleSearchBar = function(event) {
            $scope.isSearchBarOpen = $scope.isSearchBarOpen === false ? true : false;
            if ($scope.isSearchBarOpen)
                angular.element(event.currentTarget.firstElementChild).css('color', '#4a90e2');
            else
                angular.element(event.currentTarget.firstElementChild).css('color', '#6d6e71');
        };

    }

    angular.module('shieldxApp').controller('threatDetectionCtr', threatDetectionCtrl);
})();

/*
 ShieldX Networks Inc. CONFIDENTIAL
 ----------------------------------
 *
 Copyright (c) 2016 ShieldX Networks Inc.
 All Rights Reserved.
 *
 NOTICE: All information contained herein is, and remains
 the property of ShieldX Networks Incorporated and its suppliers,
 if any. The intellectual and technical concepts contained
 herein are proprietary to ShieldX Networks Incorporated
 and its suppliers and may be covered by U.S. and Foreign Patents,
 patents in process, and are protected by trade secret or copyright law.
 Dissemination of this information or reproduction of this material
 is strictly forbidden unless prior written permission is obtained
 from ShieldX Networks Incorporated.
 */

(function() {
    function threatDetectionDetailCtrl(
        $scope,
        $state,
        $translate,
        $sessionStorage,
        policyService,
        $timeout,
        $q,
        $mdDialog,
        deploymentSpecificationService,
        infrastructureConnectorService,
        commonDataManagement,
        userSessionMenagment
    ) {
        var deferred = $q.defer();
        $scope.promise = deferred.promise;
        $scope.promiseCompleted = true;
        $scope.disableSavePolicy = true;
        var initializing = true;
        $scope.policyselected = [];
        $scope.malwareAddForm = [];
        $scope.isSearchBarOpen = false;
        $scope.selected = [];
        $scope.policyDetails = {};
        $scope.saveupdatepolicyAdd = true;
        $scope.addNewPolicyArray = [];
        $scope.policyname = "";
        $scope.editpolicyname = false;
        $scope.edittenant = false;
        $scope.allRuleThreats = [];
        $scope.tenantSelected = false;
        var policyObject = $state.params.policyobject;
        var existingrules = $state.params.existingrules;
        $scope.policyId = $state.params.policyId;
        if(typeof $scope.policyId === 'undefined')
            $state.go('home.policy.policylist.threatdetection');

        var policyId = $state.params.policyId ? parseInt($state.params.policyId) : parseInt($state.params.policyobject.policyId);

        $scope.selectedTenantObj = $state.params.tenantData;
        var policyUpdateFailed = {
            'heading': 'Policy Updation Failed',
            'subHeading': '&nbsp;',
            'type': 'fail',
            'timeout': 5000,
            'callback': function () {
                $state.reload();
            }
        };
        var policyUpdateSuccess = {
            'heading': 'Policy Updated Successfully',
            'subHeading': '&nbsp;',
            'type': 'success',
            'timeout': 5000,
            'callback': function () {
                $state.go('home.policy.policylist.threatdetection');
            }
        };
        var policyUpdateProgress = {
            'heading': 'Policy Updation Progress',
            'subHeading': '&nbsp;',
            'type': 'success',
            'timeout': 5000,
            'callback': function () {
                $state.reload();
            }
        };
        
        $scope.editRule = function(singleRule){
            singleRule.action = "edit";
            $state.go('home.policy.addthreatdetectionrule',{'policyobject':{'threatName':$scope.policyDetails.name,'tenantdetails':$scope.selectedTenantObj,'policyId' : policyId,'allthreatCounter':$scope.policyDetails.allthreatCounter,'lastModified':$scope.policyDetails.lastModified},'ruleobject':singleRule,'existingrules':$scope.policyDetails.rules});
        };
        $scope.addthreatRule = function(){
            var  singleRule = {action:"add",id:0};
            $state.go('home.policy.addthreatdetectionrule',{'policyobject':{'threatName':$scope.policyDetails.name,'tenantdetails':$scope.selectedTenantObj ,'policyId' : policyId,'allthreatCounter':$scope.policyDetails.allthreatCounter,'lastModified':$scope.policyDetails.lastModified},'ruleobject':singleRule,'existingrules':$scope.policyDetails.rules});
        };
       /* $scope.getTenantDataForCloud = function(cloudObj) {
            $scope.tenantsList = [];
            deploymentSpecificationService.getTenants(cloudObj.id).then(function(tenants) {
                _.each(tenants, function(tenant) {
                    tenant.cloudName = cloudObj.name;
                    $scope.tenantsList.push(tenant);
                });
            });
        };
        $scope.getTenants = function() {
            infrastructureConnectorService.getListOfInfrastructures().then(function(clouds) {
                _.each(clouds, function(cloud) {
                    $scope.getTenantDataForCloud(cloud);
                });
            });
        };

        $scope.getTenants();*/
        policyService.getTotalTenats().then(function(data){
            $scope.tenantsList = data;
            $scope.tenantsListCompleted = true;
            renderData();
        },function(err){
            console.log("unable to fetch tenants");
            $scope.tenantsListCompleted = true;
            renderData();
        });
        $scope.showAllThreats = function(){
            $state.go('home.policy.viewallthreat',{'policyId':policyId});
        };
        
         $scope.$on('$viewContentLoaded', function(event){ 
                console.log(event);
                fixContainerHeight(1);
        });
    
        var update_id = authorities("policy_update");
        $scope.is_update_policy = userSessionMenagment.isUserAllowd(update_id);
         
        $scope.getStringData = function(appArray,protocolArray){
            var returnString = "";
            if(appArray && appArray.length)
                returnString = appArray.join();
            if(returnString && protocolArray && protocolArray.length)
                returnString += ","+protocolArray.join();
            else if(protocolArray && protocolArray.length)
                returnString = protocolArray.join();
            return returnString;
        };
        $scope.showMoreItemPopUp = function(event,data,name){
                $scope.showmorePopUpData = data;
                $scope.showMoreDataName = name;
                $mdDialog.show({
                    skipHide: true,
                    preserveScope: true,
                    controller: showMoreDataCtrl,
                    bindToController: true,
                    templateUrl: 'core/components/administration/policy/more-data.html',
                    parent: angular.element(document.body),
                    targetEvent: event,
                    fullscreen: false,
                    scope: $scope,
                    openFrom: { top: 1100, height: 0 },
                    closeTo: { left: 1500 }
                }).then(function() {

                });
            };
            function showMoreDataCtrl($mdDialog,$scope){
                $scope.cancelShowMoreDataPopup = function(){
                    $mdDialog.cancel();
                };
            }
        if(policyObject && existingrules){
                $scope.policyDetails.name = policyObject.threatName;
                $scope.selectedTenantObj = policyObject.tenantdetails;
                $scope.policyDetails.id = policyId;
                $scope.policyDetails.rules = existingrules;
                $scope.policyDetails.allthreatCounter = policyObject.allthreatCounter;
                $scope.policyDetails.lastModified = policyObject.lastModified;
                $scope.promiseCompleted = false;
                deferred.resolve();
            } else {
                policyService.getPolicyDetail("threatpreventionpolicy","policy",policyId).then(function(threatdata) {
                    $scope.threatDataFromApi = threatdata;
                    $scope.fromPolicyData = true;
                    renderData();
                    /*$scope.policyDetails = threatdata;
                    console.log($scope.policyDetails);
                    $scope.selectedTenantObj = _.find($scope.tenantsList,{"id":$scope.policyDetails.tenantId});
                    $scope.selectedTenantsValue = JSON.stringify($scope.selectedTenantObj); 
                    $scope.tenantSelected = true;
                    policyService.getListOfPoliciesDetails("threats",policyId).then(function(allthreatdata) {
                        console.log("This is all threat data here");
                        console.log(allthreatdata);
                        $scope.allRuleThreats = allthreatdata;
                        $scope.policyDetails.allthreatCounter = $scope.allRuleThreats.length;
                        $scope.promiseCompleted = false;
                        deferred.resolve();
                    }, function(err) {
                        console.log("threat prevention policy error data");
                        deferred.reject();
                        $scope.promiseCompleted = false;
                    });*/
                }, function(err) {
                    console.log("threat prevention policy error data");
                    deferred.reject();
                    $scope.fromPolicyData = true;
                    renderData();
                });
        }
        function renderData(){
            if($scope.fromPolicyData && $scope.tenantsListCompleted) {
                $scope.promiseCompleted = false;
                $scope.policyDetails = $scope.threatDataFromApi;
                console.log($scope.policyDetails);
                $scope.selectedTenantObj = _.find($scope.tenantsList,{"id":$scope.policyDetails.tenantId});
                $scope.selectedTenantsValue = JSON.stringify($scope.selectedTenantObj); 
                $scope.tenantSelected = true;
                policyService.getListOfPoliciesDetails("threats",policyId).then(function(allthreatdata) {
                    console.log("This is all threat data here");
                    console.log(allthreatdata);
                    $scope.allRuleThreats = allthreatdata;
                    $scope.policyDetails.allthreatCounter = $scope.allRuleThreats.length;
                    $scope.promiseCompleted = false;
                    deferred.resolve();
                }, function(err) {
                    console.log("threat prevention policy error data");
                    deferred.reject();
                    $scope.promiseCompleted = false;
                });
            }
        }
        /*$scope.allRuleThreats = dummyData;*/
        function tenantListCtr($scope, $mdDialog, policyService) {
                    $scope.canceltenantDialogue = function() {
                        //tenantSelection();
                        $mdDialog.hide();
                    };
                    //$scope.tenantSelected = false;
                    $scope.tenants = $scope.tenantsList;

                   $scope.onSelectTenantChanged = function() {
                        console.log(" onSelectionChanged >> ");
                        $scope.tenantSelected = true;
                    };
                     $scope.tenantdone = function(value) {
                        $scope.tenantselected = true;
                        $scope.selectedTenantObj = JSON.parse(value);
                        $scope.policyDetailForm.$dirty = true;
                        $mdDialog.hide();
                    };
                }
        $scope.callpopupTenats = function(event) {
                    $scope.edittenant = true;
                    $mdDialog.show({
                        skipHide: true,
                        preserveScope: true,
                        controller: tenantListCtr,
                        bindToController: true,
                        templateUrl: 'core/components/administration/policy/tenants.html',
                        parent: angular.element(document.body),
                        targetEvent: event,
                        fullscreen: false,
                        scope: $scope,
                        openFrom: { top: 1100, height: 0 },
                        closeTo: { left: 1500 }
                    }).then(function() {
                        $scope.edittenant = false;
                    });
                };

        $scope.toggleSearchBar = function(event) {
            $scope.isSearchBarOpen = $scope.isSearchBarOpen === false ? true : false;
            if ($scope.isSearchBarOpen)
                angular.element(event.currentTarget.firstElementChild).css('color', '#4a90e2');
            else
                angular.element(event.currentTarget.firstElementChild).css('color', '#6d6e71');
        };
        
        $scope.deleteRule =function(rule,event){
            $mdDialog.show({
                    controller: confirmDeleteRuleCtr,
                    templateUrl: 'core/components/administration/policy/delete-rule-dialog.html',
                    parent: angular.element(document.body),
                    targetEvent: event,
                    clickOutsideToClose: true,
                    locals:{
                        rule:rule
                    },
                    skipHide: true,
                    preserveScope: true,
                   
                }).then(function (answerVal) {
                    $scope.deleteRuleFromPolicy(answerVal);
                }, function () {
                    
                });
        };

        function confirmDeleteRuleCtr($scope, $mdDialog,rule){
            $scope.rule = rule;
            $scope.hide = function (rule) {
                $mdDialog.hide(rule);
            };
            $scope.closeDialog = function () {
                $mdDialog.cancel();
            };
            $scope.closeDialogWithAnswer = function () {
                $scope.hide(rule);
            };
        }

            $scope.deleteRuleFromPolicy = function(rule){
               var idx = _.findIndex($scope.policyDetails.rules,rule);
               $scope.policyDetails.rules.splice(idx, 1);
            };
        $scope.updateThreat = function(){
            showToast(policyUpdateProgress);
            console.log($scope.policyDetails);
            var threatMainObj = $scope.policyDetails;
            threatMainObj.isEditable = true;
            threatMainObj.tenantId = $scope.selectedTenantObj.id;
            threatMainObj.lastModified = Math.round(new Date().getTime()/1000);
            policyService.updatePolicyData("policy/threatpreventionpolicy",threatMainObj).then(function(returnData){
                console.log(returnData);
                commonDataManagement.clearData();
                showToast(policyUpdateSuccess);
            },function(error){
                showToast(policyUpdateFailed);
                console.log(error);
            });
        };
        $scope.cancelNewThreat = function(){
            $state.go('home.policy.policylist.threatdetection');
        };
        $scope.openSpecificThreatPopup = function(event,specificThreats){
            $mdDialog.show({
                controller: rulespecificthreatCtr,
                templateUrl: 'core/components/administration/policy/rulespecificthreat.html',                
                parent: angular.element(document.body),
                event: event,
                scope: $scope,
                preserveScope: true,
                fullscreen: true,
                locals:{'policyId':$scope.policyId,'specificThreats':specificThreats}
            }).then(function() {

            });
        };
        function rulespecificthreatCtr($rootScope, $scope, $mdDialog,policyId,specificThreats,filterFilter,$filter,$q) {
            (function() {
                var deferred = $q.defer();
                $scope.promise = deferred.promise;
                $scope.specificThreats = specificThreats;
                $scope.promiseCompleted = true;
                $scope.threatResponse = [];
                $scope.enabledThreats = 0;
                $scope.policyData = {};
                $scope.responseSet = {
                                    "enabled":false,
                                    "enabledNot":false,
                                    "logPacket":false,
                                    "logPacketNot":false,
                                    "alert":false,
                                    "alertNot":false,
                                    "block":false,
                                    "blockNot":false,
                                    "notifySMTP":false,
                                    "notifySMTPNot":false,
                                    "notifySysLog":false,
                                    "notifySysLogNot":false
                                };
                /*$scope.disableSavePolicy = true;*/
                $scope.policyselected = [];
                $scope.selected = [];
                $scope.isSearchBarOpen = false;
                $scope.saveupdatepolicyAdd = true;
                $scope.addNewPolicyArray = [];
                $scope.policyname = "";
                $scope.selectAll = false;
                $scope.policyId = policyId;
                $scope.query = {
                    order: 'name',
                    limit: 8,
                    page: 1
                };
                $scope.closeDialog = function(){
                    $mdDialog.hide();
                };
                function resetData(){
                    $scope.responseSet = {
                                    "enabled":false,
                                    "enabledNot":false,
                                    "logPacket":false,
                                    "logPacketNot":false,
                                    "alert":false,
                                    "alertNot":false,
                                    "block":false,
                                    "blockNot":false,
                                    "notifySMTP":false,
                                    "notifySMTPNot":false,
                                    "notifySysLog":false,
                                    "notifySysLogNot":false
                                };
                    $scope.threatResponse = [];
                    $scope.policyselected =[];
                }
                $scope.openThreatPopup = function(event,policyName,threatReferenceData){
                    $mdDialog.show({
                        skipHide: true,
                        controller: threatRefenceController,
                        templateUrl: 'core/components/administration/policy/threatReferenceList.html',
                        parent: angular.element(document.body),
                        event: event,
                        scope: $scope,
                        preserveScope: true,
                        locals:{'policyName':policyName,'threatReferenceData':threatReferenceData}
                    }).then(function() {

                    });
                };
                function threatRefenceController($rootScope, $scope, $mdDialog,threatReferenceData,policyName) {
                    (function() {
                        $scope.items = threatReferenceData;
                        $scope.threatName = policyName;
                        $scope.cancelDialogue = function() {
                            $mdDialog.hide();
                        };
                    })();
                }
                $scope.onReorder = function(order){
                    $scope.policythreatData =  $filter('orderBy')($scope.policythreatData,order);
                };
                $scope.filterset = {};
                
                policyService.getPolicyDetail("threatpreventionpolicy","policy","severity").then(function(severityData) {
                    $scope.severitylevels = severityData;
                }, function(err) {
                    console.log("new threat rule error");
                });
                $scope.malwarePolicy = true;
                $scope.malwareselected = [];
                $scope.updateResponse = function(event,responseType,value){
                    _.each($scope.policyselected,function(singleThreat){
                        singleThreat.threatResponseData.policyId = $scope.policyId;
                        var alreadyPresent = _.find($scope.threatResponse,{"protocolId":singleThreat.protocolID,"threatId":singleThreat.threatID});
                        if(typeof alreadyPresent !== 'undefined'){
                            alreadyPresent[responseType] = value;
                        } else {
                            $scope.threatResponse.push(singleThreat.threatResponseData);
                            $scope.threatResponse[$scope.threatResponse.length - 1][responseType] = value;
                        }
                    });
                    $scope.responseSet[responseType+"Not"] = !value; 
                    $scope.responseSet[responseType] = value;
                };
                $scope.clearEdits = function(){
                    resetData();
                    $scope.onReorder("name");
                    $scope.filterset = {"_status":["Enabled","Disabled"],"severity":["Medium","High","Critical","Low","Fixme"],"protectionType":["SERVER","CLIENT"],"response":["Block-true","Alert-true","Log-true","Block-false","Alert-false","Log-false"],"action":["notifySMTP-true","notifySysLog-true","notifySMTP-false","notifySysLog-false"]};
                    $scope.policythreatData = angular.copy($scope.policythreatDataCopy);
                };
                $scope.getSelectedText = function(receivedData,totalength){
                    if(typeof receivedData === 'undefined' || receivedData.length == totalength)
                        return "ALL";
                    return receivedData.length + " Selected";
                };
                $scope.updateEdits = function(){
                    var dataTosend = {"id":$scope.policyId,"responses":$scope.threatResponse};
                    toastparam = {
                            'heading': 'Update of Threats in progress',
                            'subHeading': 'Update of Threats initiated.',
                            'type': 'progress',
                            'timeout': 5000
                        };
                    showToast(toastparam);
                    policyService.updateExistingPolicyData("policy/threatresponses",dataTosend).then(function(responseData){
                        resetData();
                        $scope.policythreatDataCopy = angular.copy($scope.policythreatData);
                        toastparam = {
                            'heading': 'Update of Threats Completed',
                            'subHeading': 'Threats Updated.',
                            'type': 'success',
                            'timeout': 5000
                        };
                        showToast(toastparam);
                    },function(error){
                        toastparam = {
                            'heading': 'Update of Threats Failed.',
                            'subHeading': 'Threats failed to update.',
                            'type': 'fail',
                            'timeout': 5000
                        };
                        showToast(toastparam);
                        console.log(error);
                    });
                };
                $scope.getCount = function(){
                    if(typeof $scope.policythreatData !== "undefined")
                        return filterFilter( $scope.policythreatData, $scope.filterset).length;
                    else
                        return 0;
                };
                policyService.getPolicyDetail("threatpreventionpolicy","policy",$scope.policyId).then(function(threatdata) {
                    $scope.policyData = threatdata;
                });
                policyService.getPolicyDetail( $scope.policyId,"policy","threats").then(function(data) {
                    $scope.promiseCompleted = false;
                        policyService.getPolicyDetail($scope.policyId,"policy","threatresponses").then(function(responseData){
                        console.log(responseData);
                        var filteredResponse = [];
                        _.each(specificThreats,function(singleSpecific){
                            var currentData = _.find(data,{"protocolID":singleSpecific.protocolID.toString(),"threatID":singleSpecific.threatID.toString()});
                            if(typeof currentData !== 'undefined' ){
                                filteredResponse.push(currentData);
                            }
                        });
                        policyService.getDataBasedOnId("policy","protocol").then(function(protocolData) {
                            filteredResponse.map(function(currentObj){
                                currentObj.threatResponseData =  _.find(responseData,{"protocolId":currentObj.protocolID,"threatId":currentObj.threatID});
                                currentObj._numthreatID = parseInt(currentObj.threatID);
                                currentObj._numprotocolID = parseInt(currentObj.protocolID);
                                var matchedProtocol = _.find(protocolData,{"protocolID" : currentObj.protocolID});
                                
                                if(matchedProtocol)
                                    currentObj.protocolName = matchedProtocol.protocolName;
                                else
                                    currentObj.protocolName = "";
                                
                                if(typeof currentObj.threatResponseData !== 'undefined')
                                    if(currentObj.threatResponseData.enabled){
                                        currentObj._status =  "Enabled";
                                        $scope.enabledThreats++;
                                    } else {
                                        currentObj._status = "Disabled";
                                    }
                                else
                                   currentObj._status = "Disabled";
                                /*currentObj._response = parseInt(currentObj.protocolID);*/
                            });
                            $scope.policythreatData = filteredResponse;
                            $scope.policythreatDataCopy = angular.copy(filteredResponse);
                            console.log("threat data is this ",$scope.policythreatData);
                            $scope.getCount();
                            deferred.resolve();
                        });
                    });
                    
                }, function(err) {
                    console.log("policy error data");
                    deferred.reject();
                    $scope.promiseCompleted = false;
                });
                


                $scope.toggleSearchBar = function(event) {
                    $scope.isSearchBarOpen = $scope.isSearchBarOpen === false ? true : false;
                    if ($scope.isSearchBarOpen)
                        angular.element(event.currentTarget.firstElementChild).css('color', '#4a90e2');
                    else
                        angular.element(event.currentTarget.firstElementChild).css('color', '#6d6e71');
                };


            })();
        }
    }

    angular.module('shieldxApp').controller('threatDetectionDetailCtr', threatDetectionDetailCtrl);
})();

(function () {
    function reportsCtr(
            $scope,
            $state,
            $translate,
            $sessionStorage,
            $q,
            reportGenerationService,
            infrastructureConnectorService,
            deploymentSpecificationService,
            $mdDialog
            ) {



        clearAllSession($sessionStorage);
        var reportSummaryData = [];

        var deferred = $q.defer();
        $scope.promise = deferred.promise; 
        $scope.promiseCompleted = true;
        var promiseCtr = 0;
        var totalClouds = 0;
        $scope.inboundKeysAvailable = false;
        $scope.editMiscState = false;

        $scope.isAdornmentPanelOpen = false;
        $scope.isSearchBarOpen = false;

        var resignKeysCtr = 0;
        $scope.inboundKeys = [];
        $scope.tenantId = 1;
        
        //$scope.$emit('listenHeaderText', {headerText: $translate.instant('admin.toolbar.heading')});
        $scope.$emit('listenHeaderText', {headerText: $translate.instant('admin.shieldx.reports.heading')});

        /* **** for tables [start] **** */
        $scope.selected = [];
        $scope.query = {
            order: 'name',
            limit: 10,
            page: 1
        };

        $scope.isAdornmentPanelOpen = false;
        $scope.isSearchBarOpen = false;

        $scope.active_help_id = "admin_reports_help";
        $scope.helpButtonClicked = function(id){
            $scope.active_help_id = id;
            console.log("  helpButtonClicked ");
            $scope.bordcastEventHelpButtonClicked($scope.active_help_id);
        }; 
        $scope.bordcastEventHelpButtonClicked = function(helpId){
            $scope.$broadcast('onHelpButtonClicked', {
               helpIDString: helpId 
            });
         }; 
        $scope.updateAdornmentPanel = function (event, rowData) {
            $scope.toggleAdornmentPanel();
            $scope.adornmentData = rowData;
            console.log($scope.adornmentData);
        };

        $scope.toggleAdornmentPanel = function () {
            $scope.isAdornmentPanelOpen = $scope.isAdornmentPanelOpen === false ? true : false;
        };

        $scope.toggleSearchBar = function (event) {
            $scope.isSearchBarOpen = $scope.isSearchBarOpen === false ? true : false;
            if ($scope.isSearchBarOpen)
                angular.element(event.currentTarget.firstElementChild).css('color', '#4a90e2');
            else
                angular.element(event.currentTarget.firstElementChild).css('color', '#6d6e71');
        };            
        /* **** for tables [end] **** */

        var reportGenerationStarted = {
            'heading': 'Initiating ShiledX System Summary Report',
            'subHeading': 'Initiating ShiledX System Summary Report',
            'type': 'progress',
            'timeout': $scope.toastTimeout
        };

        var reportGenerationCompleted = {
            'heading': 'ShiledX Executive Summary Report',
            'subHeading': 'ShiledX executive summary report generation completed, downloading the report...',
            'type': 'success',
            'timeout': $scope.toastTimeout,
            'callback': function () {
                $state.reload();
            }
        };

        var reportDownloadCompleted = {
            'heading': 'Download Report',
            'subHeading': 'Report download completed.',
            'type': 'success',
            'timeout': $scope.toastTimeout,
            'callback': function () {
                $state.reload();
            }
        };

        var reportGenerationFailed = {
            'heading': 'ShiledX executive summary report generation failed',
            'subHeading': '&nbsp;',
            'type': 'fail',
            'timeout': $scope.toastTimeout,
            'callback': function () {
                $state.reload();
            }
        };

        $scope.report = {};

        $scope.report.format='2';
        $scope.formatTypes = [
                {'name': 'PDF', 'value': '1'},
                {'name': 'HTML', 'value': '2'}
            ];

        $scope.tenants = [];

        $scope.getTenantDataForCloud = function (cloudObj) {
            deploymentSpecificationService.getTenants(cloudObj.id).then(function (tenants) {
                _.each(tenants, function (tenant) {
                    tenant.cloudName = cloudObj.name;
                    $scope.tenants.push(tenant);
                });
            });
        };

        $scope.getTenants = function () {
            infrastructureConnectorService.getListOfInfrastructures().then(function (clouds) {
                _.each(clouds, function (cloud) {
                    $scope.getTenantDataForCloud(cloud);
                });
            });
        };

        $scope.fileChanged = function (elem) {
            $scope.files = elem.files;
            $scope.$appply();
        };

        $scope.generateReport = function () {

            var tenantId = $scope.tenantId;
            var topn = $scope.report.top_n;
            var nDays = $scope.report.no_of_days;
            var reportConfig = $scope.report;
            console.log(" Top N = "+topn+" No of Days = "+nDays);
            tenantId = 1;

            showToast(reportGenerationStarted);

            reportGenerationService.generateReport(reportConfig).then(function (data) {

                console.log("Report generated successfully.");
                showToast(reportGenerationCompleted);

                console.log("Download report.");
                reportGenerationService.downloadReport().then(function (data) {

                    console.log("Download completed.");
                    showToast(reportDownloadCompleted);
                    var linkElement = document.createElement('a');
                    try {
                        var blob = new Blob([data], { type: 'application/pdf' });
                        var url = window.URL.createObjectURL(blob);

                        linkElement.setAttribute('href', url);
                        linkElement.setAttribute("download", 'ExecutiveSummaryReport.pdf');

                        var clickEvent = new MouseEvent("click", {
                            "view": window,
                            "bubbles": true,
                            "cancelable": false
                        });
                        linkElement.dispatchEvent(clickEvent);
                    } catch (ex) {
                        console.log(" Failed to download pdf report "+ex.getMessage());
                        console.log(ex);
                    }
                });

            }, function error(err) {
                reportGenerationFailed.subHeading = "Error: " + err.data.message;
                showToast(reportGenerationFailed);
            });
            $mdDialog.hide();

        };


        $scope.getTenants();

        fixContainerHeight(0);

        $scope.fileInputText = "No File Chosen";

        //Configure Resigning Keys 
        $scope.import = function(ev){
            console.log("Launch inbound keys import dialog.");                             
            $mdDialog.show({
                controller: sslkeysCtr,
                skipHide: true,
                templateUrl: 'core/components/administration/sslkeys/importinboundkeys.html',
                parent: angular.element(document.body),
                targetEvent: ev,
                fullscreen: true,
                openFrom: {top: 1100, height: 0},
                closeTo: {left: 1500}
                //locals: {'cloudData': cloudData}
            }).then(function () {

            });
        };

        $scope.hide = function () {
            $mdDialog.hide();
        };

        $scope.cancel = function () {
            $mdDialog.cancel();
        };

        $scope.cancelDialog = function() {
            $mdDialog.cancel();
        };        
    }

    angular.module('shieldxApp').controller('reportsCtr', reportsCtr);
})();

/*
 ShieldX Networks Inc. CONFIDENTIAL
 ----------------------------------
 *
 Copyright (c) 2016 ShieldX Networks Inc.
 All Rights Reserved.
 *
 NOTICE: All information contained herein is, and remains
 the property of ShieldX Networks Incorporated and its suppliers,
 if any. The intellectual and technical concepts contained
 herein are proprietary to ShieldX Networks Incorporated
 and its suppliers and may be covered by U.S. and Foreign Patents,
 patents in process, and are protected by trade secret or copyright law.
 Dissemination of this information or reproduction of this material
 is strictly forbidden unless prior written permission is obtained
 from ShieldX Networks Incorporated.
 */

(function () {
    function resourceGroupsCtr(
            $stateParams,
            $scope,
            $state,
            infrastructureConnectorService,
            ipPoolServices,
            resourceGroupService,
            deploymentSpecificationService,
            $translate,
            $q,
            $sessionStorage,
            $mdDialog,
            userSessionMenagment) {

        "ngInject";

        clearAllSession($sessionStorage);
        var deferred = $q.defer();
        $scope.promise = deferred.promise;
        $scope.promiseCompleted = true;
        var promiseCtr = 0;
        var totalClouds = 0;
        var groupData = [];
        var viewData = [];
        var rgIdSet = ($stateParams && $stateParams.rgId) ? parseInt($stateParams.rgId) : null;
        /* **** for tables [start] **** */
        $scope.$emit('listenHeaderText', {headerText: $translate.instant('admin.toolbar.heading')});
        $scope.$emit('quickSetupEnded', {});

        $scope.selected = [];
        $scope.query = {
            order: 'name',
            limit: 10,
            page: 1
        };
        $scope.isAdornmentPanelOpen = false;
        $scope.isSearchBarOpen = false;

        $scope.updateAdornmentPanel = function (event, rowData) {
            $scope.toggleAdornmentPanel();
            $scope.adornmentData = angular.copy(rowData);
        };

        $scope.toggleAdornmentPanel = function () {
            $scope.isAdornmentPanelOpen = $scope.isAdornmentPanelOpen === false ? true : false;
            //toggleGridCols($scope.isAdornmentPanelOpen);
            //$scope.editDetails = false;
            $scope.editGroup = false;
        };
        $scope.toggleSearchBar = function (event) {
            $scope.isSearchBarOpen = $scope.isSearchBarOpen === false ? true : false;
            if ($scope.isSearchBarOpen)
                angular.element(event.currentTarget.firstElementChild).css('color', '#4a90e2');
            else
                angular.element(event.currentTarget.firstElementChild).css('color', '#6d6e71');
        };

         
        var create_id = authorities("resourceGroups_create");
        var delete_id = authorities("resourceGroups_delete");
        var update_id = authorities("resourceGroups_update");
        $scope.is_create_rsgroup = userSessionMenagment.isUserAllowd(create_id);
        $scope.is_update_rsgroup = userSessionMenagment.isUserAllowd(update_id);
        $scope.is_delete_rsgroup = userSessionMenagment.isUserAllowd(delete_id);

        /* **** for tables [end] **** */

        //if(!$sessionStorage.groupViewData) {
        $sessionStorage.groupAllData = [];
        //GET LIST OF ALL INFRASTRUCTURE
        infrastructureConnectorService.getListOfInfrastructures().then(function (data) {
            totalClouds = data.length;
            if (totalClouds === 0) {
                $scope.errorMessage = "No Infrastructures!!!";
                //NO DATA FOR VIEW
                deferred.resolve();
                $scope.promiseCompleted = false;
            } else {
                for (i = 0; i < data.length; i++) {
                    groupData[i] = {};
                    groupData[i].cloud_data = {};
                    groupData[i].group_data = [];
                    groupData[i].tenants = [];
                    groupData[i].network_data = [];
                    groupData[i].unused_networks = [];
                    groupData[i].tenantsNetwork = [];

                    //ADDING CLOUD DATA IN DEPLOYMENT SPEC
                    groupData[i].cloud_data = data[i];
                    groupData[i].cloudId = data[i].id;
                    //GET network, Groups
                    getNetworksAndResourceGroups(data[i], groupData[i]);

                    $sessionStorage.groupAllData.push(groupData[i]);

                }
            }
        });
        /*} else {
         //console.log($sessionStorage.viewData);
         viewData = $sessionStorage.groupViewData;
         //$scope.groupData = viewData;
         $scope.groupData = moveRecordToStart(viewData, "id", rgIdSet);
         deferred.resolve();
         $scope.promiseCompleted = false;
         }*/


        getNetworksAndResourceGroups = function (cloudData, obj) {
            //CALL ITS AVAILABLE NETWORKS
            ipPoolServices.getNetworkListByCloudId(cloudData.id).then(function (networkData) {
                obj.network_data = angular.copy(networkData);
                obj.unused_networks = angular.copy(networkData);
                //console.log("Available Networks for " + cloudData.id);
                //console.log(networkData);
                //CALL ITS AVAILABLE TENANTS
                deploymentSpecificationService.getTenants(cloudData.id).then(function (data) {
                    obj.tenants = data;
                    if (cloudData.type === 'OPENSTACK') {
                        for (k = 0; k < obj.tenants.length; k++) {
                           // obj.tenantsNetwork[obj.tenants[k].id] = getTenantNetworks(obj.tenants[k].name, obj.network_data);
                            //console.log(obj.tenantsNetwork[obj.tenants[k].id]);
                            obj.tenantsNetwork[obj.tenants[k].id] = obj.network_data;
                        }
                    }
                    //CALL ITS AVAILABLE RESOURCE GROUP
                    resourceGroupService.getGroupList(cloudData.id).then(function (groupData) {

                        for (c = 0; c < groupData.length; c++) { //c for counter

                            groupData[c].cloudName = obj.cloud_data.name;
                            groupData[c].cloudType = obj.cloud_data.type;

                            if (obj.cloud_data.type === 'OPENSTACK') {
                                groupData[c].networks = obj.tenantsNetwork[groupData[c].tenantId];
                                groupData[c].unused_networks = getOpenStacksUnusedNetwork(obj, groupData[c].memberList, groupData[c].tenantId);
                                groupData[c].availableNetworks = groupData[c].unused_networks;
                            }

                            //Assign names to ids of tenants and networks
                            groupData[c].networksWithName =
                                    getnetworkDataWithName(groupData[c].memberList,
                                            obj.network_data);

                            //Call function to update unused Networks.
                            obj.unused_networks = updateUnusedNetworks(obj, groupData[c].memberList);
                            //groupData[c].availableNetworks = groupData[c].networksWithName.concat(obj.unused_networks);
                            //getAvailableNetworksForGroupObject(obj.unused_networks, groupData[c].networksWithName);
                            if (obj.cloud_data.type !== 'OPENSTACK') {
                                groupData[c].availableNetworks = obj.unused_networks;
                            }
                            //console.log("Unused Networks === for " +  cloudData.id);
                            //console.log(obj.unused_networks);
                            groupData[c].tenantName =
                                    getNameOfGivenParam(groupData[c].tenantId,
                                            angular.copy(obj.tenants));

                            groupData[c].availableTenants = angular.copy(obj.tenants);
                            //Total number of networks in this group assigned
                            
                            var uniqueNetwork = [];
                            for(var i = 0; i < groupData[c].memberList.length; i++) {
                                if(!_.find(uniqueNetwork, {"networkId" : groupData[c].memberList[i].networkId})) {
                                    uniqueNetwork.push(groupData[c].memberList[i]);
                                }
                            }
                            groupData[c].countMembers = uniqueNetwork.length;

                            viewData.push(groupData[c]);

                        }
                        obj.group_data = groupData;

                        promiseCtr += 1;
                        //console.log("PROMISE COUNTER==="+promiseCtr);
                        if (promiseCtr >= totalClouds) {
                            $sessionStorage.groupViewData = viewData;
                            deferred.resolve();
                            console.log(viewData);
                            $scope.promiseCompleted = false;
                            //$scope.groupData = viewData;
                            $scope.groupData = moveRecordToStart(viewData, "id", rgIdSet);
                            console.log("$sessionStorage.groupAllData");
                            console.log($sessionStorage.groupAllData);
                            console.log("$sessionStorage.groupViewData");
                            console.log($sessionStorage.groupViewData);

                        }

                    }, function (error) {
                        console.log(error);
                        obj.group_data = [];
                        promiseCtr += 1;
                        if (promiseCtr === totalClouds) {

                            $sessionStorage.groupViewData = viewData;
                            deferred.resolve();
                            $scope.promiseCompleted = false;
                            console.log($scope.groupData);
                            console.log($sessionStorage.groupViewData);
                        }
                    });
                }, function (error) {
                    console.log(error);
                    obj.tenants = [];
                });
            }, function (error) {
                console.log(error);
                obj.network_data = [];
            });
        };

        getnetworkDataWithName = function (srcArray, FromArray) {

            var result = [];
            var i = 0;
            for (var ntw = 0; ntw < srcArray.length; ) {
                if (!_.find(result, {"id" : parseInt(srcArray[ntw].networkId)})) {
                    result[i++] = _.find(FromArray, {'id': parseInt(srcArray[ntw].networkId)});
                }
                ntw++;
            }
            return result;
        };

        //Helper function to get name of given Id from given list
        getNameOfGivenParam = function (id, list) {
            if (list.length > 0 || typeof id !== 'undefined') {
                var result = {};
                result = _.find(list, {'id': id});
                if (typeof result !== 'undefined') {
                    return result;
                } else {
                    return {};
                }
            } else {
                return {};
            }
        };


        //DELETE GROUP
        $scope.deleteGroup = function (objectData) {
            console.log(objectData);
            $scope.isAdornmentPanelOpen = false;

            var toastparam = {};
            toastparam = {
                'heading': 'Group deletion in progress',
                'subHeading': 'Group deletion initiated.',
                'type': 'progress',
                'timeout': 10000
            };
            showToast(toastparam);
            $scope.promiseCompleted = true;
            var list = $scope.groupData;

            //DELETE /shieldxapi/infras/resourcegroup/{rgId} 
            resourceGroupService.deleteGroupList(objectData.id, objectData.cloudId).then(function (data) {
                if (data.status) {
                    //update rows
                    for (i = 0; i < list.length; i++) {
                        if (list[i].id === objectData.id) {
                            list.splice(i, 1);
                        }
                    }

                    toastparam = {
                        'heading': 'Group deleted successfully',
                        'subHeading': '&nbsp;',
                        'type': 'success',
                        'timeout': 5000
                    };
                    showToast(toastparam);
                    $scope.promiseCompleted = false;
                } else {
                    console.log("Unable to delete Group (%s) due to %s", objectData.name, data.errorMessage);
                    //TODO to show message/something else;
                    toastparam = {
                        'heading': 'Group deletion failed',
                        'subHeading': "Error: " + data.errorMessage,
                        'type': 'fail',
                        'timeout': 5000
                    };
                    showToast(toastparam);
                    $scope.promiseCompleted = false;
                }
            }, function (error) {
                console.log("Unable to delete group - %s due to %s", objectData.name, error.message);
                //TODO to show message/something else;
                toastparam = {
                    'heading': 'Group deletion failed',
                    'subHeading': "Something went wrong",
                    'type': 'fail',
                    'timeout': 5000
                };
                showToast(toastparam);
                $scope.promiseCompleted = false;
            });
        }; //DELETE GROUP ENDS.

        //UPDATE GROUP
        var oldData;
        $scope.discardChanges = function () {
            $scope.editGroup = false;
            console.log(oldData);
            $scope.adornmentData = oldData; //ASSIGN OLD DATA TO OBJECT.
        };

        $scope.callupdateGroupPopup = function (ev, adornmentData) {
            $mdDialog.show({
                controller: editResourceGroupCtr,
                templateUrl: 'core/components/administration/resource-groups/edit-rule.html',
                parent: angular.element(document.body),
               targetEvent: ev,
                fullscreen: true,
                openFrom: {top: 1100, height: 0},
                closeTo: {left: 1500},
                locals: {
                    toastTimeout: $scope.toastTimeout,
                    adornmentData: angular.copy($scope.adornmentData)
                }
            }).then(function (value) {
                if(value === 'resource_Group'){
                    $state.reload();
                }
            });
        };
        $scope.updateGroup = function (dataObject) {
            //THIS FUNCTION WILL CALL WHEN USER COMING IN EDIT MODE.
            oldData = angular.copy(dataObject); //MAKE COPY OF OLD DATA.
            console.log(oldData);
            $scope.editGroup = true;
        };
        $scope.editGroupData = function (dataObject) {
            $scope.editGroup = false;
            $scope.isAdornmentPanelOpen = false;
            toastparam = {
                'heading': 'Group update in progress',
                'subHeading': 'Group update initiated.',
                'type': 'progress',
                'timeout': 10000
            };
            showToast(toastparam);
            $scope.promiseCompleted = true;
            console.log("dataObject to update data");
            console.log(dataObject);

            var paramObject = {"id": dataObject.id,
                "name": dataObject.name,
                "cloudId": dataObject.cloudId,
                "tenantId": dataObject.tenantId,
                "memberList": dataObject.memberList,
                "dynamic":dataObject.dynamic,
                "regex": dataObject.regex,
                "resourceType":dataObject.resourceType,
                "precedence":dataObject.precedence
            };
            console.log(paramObject);
            var listGroupData = $scope.groupData;
            var listAllGroupsData = $sessionStorage.groupAllData;
            console.log(listGroupData);
            resourceGroupService.updateResourceGroup(paramObject).then(function () {
                console.log('SUCCESS');
                for (i = 0; i < listGroupData.length; i++) {
                    //UPDATE its PARENT ON LEFT SIDE GRID
                    if (listGroupData[i].id === paramObject.id) {
                        listGroupData[i] = dataObject;
                    }

                    //UPDATE all PARENTs (available Network) ON LEFT SIDE GRID belonging to Same CLOUD/INFRA
                    if (listGroupData[i].cloudId === paramObject.cloudId) {
                        if (dataObject.cloudType !== 'OPENSTACK') {
                            listGroupData[i].availableNetworks = dataObject.availableNetworks;
                        } else {
                            //IF OPENSTACK THEN CHECK FOR TENANT ID FOR UPDATE
                            if (listGroupData[i].tenantId === dataObject.tenantId) {
                                listGroupData[i].availableNetworks = dataObject.availableNetworks;
                            }
                        }
                    }
                }

                //UPDATE SessionData (available Network of group_data and unused_networks) belonging to Same CLOUD/INFRA
                for (i = 0; i < listAllGroupsData.length; i++) {
                    if (listAllGroupsData[i].cloudId === paramObject.cloudId) {
                        listAllGroupsData[i].unused_networks = dataObject.availableNetworks;
                        for (j = 0; j < listAllGroupsData[i].group_data.length; j++) {
                            if (dataObject.cloudType !== 'OPENSTACK') {
                                listAllGroupsData[i].group_data[j].availableNetworks = dataObject.availableNetworks;
                            } else {
                                if (listAllGroupsData[i].group_data[j].tenantId === dataObject.tenantId) {
                                    listAllGroupsData[i].group_data[j].availableNetworks = dataObject.availableNetworks;
                                }
                            }
                        }
                    }
                }
                //console.log($sessionStorage.groupAllData);
                //console.log($scope.groupData);
                toastparam = {
                    'heading': 'Group (' + dataObject.name + ') updated successfully',
                    'subHeading': '&nbsp;',
                    'type': 'success',
                    'timeout': 5000
                };
                showToast(toastparam);
                $scope.promiseCompleted = false;
            }, function (error) {
                console.log(error);
                toastparam = {
                    'heading': 'Group update failed',
                    'subHeading': "ERROR: " + error.message,
                    'type': 'fail',
                    'timeout': 5000
                };
                showToast(toastparam);
                $scope.promiseCompleted = false;
            });
        };
        $scope.callpopuptenants = function (dataObject) {
            console.log(dataObject);
        };
       
        function editResourceGroupCtr($scope,
            $sessionStorage,
            $state,
            $mdDialog,
            toastTimeout,
            adornmentData,
            ipPoolServices) {
            console.log("This is adornmentData data");
            $scope.cloudId = adornmentData.cloudId;
          
            /////////////////////////
            
                $scope.cloudData = {};
                $scope.cloudData.vChassis = {};   
                $scope.cloudData.vChassis.id = "";
                $scope.cloudData.vChassis.name = "";

                $scope.cloudData.cloudId = $scope.cloudId;

              

                $scope.cloudData.ipPool = {};
                $scope.cloudData.ipPool.serverData = {};
                $scope.cloudData.ipPool.serverData.backPlaneNetworkId = -1;
                $scope.cloudData.ipPool.serverData.mgmtNetworkId = -1;

                var existingGroups =[];
               
                $scope.cloudData.vChassis.existingGroups = existingGroups;
                
                ipPoolServices.getNetworkListByCloudId($scope.cloudData.cloudId).then(function (networkList) {
                    $scope.cloudData.ipPool.networks = angular.copy(networkList);
                    $sessionStorage.cloudData = angular.copy($scope.cloudData);
                    $scope.showNetworks = true;
                });    
           
            

            /////////////////////////////////

            
            $scope.resourceGroupArray = [];
            console.log($scope.cloudId);
            console.log(adornmentData);
            var resourceGroup = adornmentData;
            $scope.OSRuleConfig = new OSRuleConfig(false, false, OSRuleConfig.modes.EDIT_RC);
            $scope.cancel = function () {
                $mdDialog.cancel();
                $state.reload();
            };

            $scope.$on(SOEvents.ruleAllCommitedEvent, function (event, args) {
               $scope.cancel();
            });

                var sr = new SORule();
                sr.mergeExistingGroup(resourceGroup);
                console.log("resourceGroup  ");
                console.dir(resourceGroup);
                sr.aspInfo = new ASPInfo();
                console.log("SORule  ");
                console.dir(sr);
                $scope.resourceGroupArray.push(sr);
          
        }
        $scope.callpopupToAddNewGroup = function (dataObject, ev) {
            $mdDialog.show({
                controller: addNewResourceGroupPopupCtr,
                templateUrl: 'core/components/administration/resource-groups/newresource-group.html',
                parent: angular.element(document.body),
                targetEvent: ev,
                fullscreen: true,
                openFrom: {top: 1100, height: 0},
                closeTo: {left: 1500},
                locals: {'dataObject': dataObject}
            }).then(function (value) {
                console.log(value);
            });
        };

       


      function addNewResourceGroupPopupCtr($scope, $mdDialog,dataObject,$sessionStorage, $state, ipPoolServices){
             
             $scope.OSRuleConfig = new OSRuleConfig(false, false, OSRuleConfig.modes.ADD_RC);

            $scope.cancel = function () {
                 $mdDialog.cancel();
                 $state.go("home.resourceGroups");
            };



           // $scope.cloudId = $sessionStorage.groupAllData[0].cloudId;
            $scope.resourceGroupArray =[];
            $scope.infrastructureId = -1;
            $scope.showHelp = true;
            $state.go("addrulecontainer.infra");
           $scope.onGoToNewRulePageClicked = function($event, infrastructureId){
                $scope.infrastructureId = infrastructureId;
                $scope.showHelp = false;
                $scope.cloudData = {};
                $scope.cloudData.vChassis = {};   
                $scope.cloudData.vChassis.id = "";
                $scope.cloudData.vChassis.name = "";

                $scope.cloudData.cloudId = infrastructureId;

              

                $scope.cloudData.ipPool = {};
                $scope.cloudData.ipPool.serverData = {};
                $scope.cloudData.ipPool.serverData.backPlaneNetworkId = -1;
                $scope.cloudData.ipPool.serverData.mgmtNetworkId = -1;

                var existingGroups =[];
               
                $scope.cloudData.vChassis.existingGroups = existingGroups;



                ipPoolServices.getNetworkListByCloudId($scope.cloudData.cloudId).then(function (networkList) {
                    $scope.cloudData.ipPool.networks = angular.copy(networkList);
                    $sessionStorage.cloudData = angular.copy($scope.cloudData);
                    $scope.showNetworks = true;
                    $state.go("addrulecontainer.rule");
                });    

                console.log(" onGoToNewRulePageClicked  >>>>>>>>>>>>  "+infrastructureId);
                 
          };

          
            
        }
        $scope.callpopupNetworks = function (dataObject, ev) {
            console.log(dataObject);
            $mdDialog.show({
                controller: groupNetworkPopupController,
                skipHide: true,
                templateUrl: 'core/components/administration/resource-groups/networks.tmpl.html',
                parent: angular.element(document.body),
                targetEvent: ev,
                locals: {'dataObject': dataObject}
            });
        };

        
        function groupNetworkPopupController($scope, $mdDialog, dataObject) {

            (function () {
                var networks = angular.copy(dataObject.networksWithName.concat(dataObject.availableNetworks));
                console.log(networks);
                //var selectedHostsList = [];
                $scope.items = networks;
                $scope.no_of_hosts = networks.length;

                var selectedNetworks = dataObject.networksWithName;
                $scope.selected = (selectedNetworks) ? angular.copy(selectedNetworks) : [];
                if ($scope.selected) {
                    $scope.no_of_selected_networks = $scope.selected.length;
                } else {
                    $scope.no_of_selected_networks = 0;
                }
                console.log($scope.selected);
                $scope.cancelDialogue = function () {
                    $mdDialog.cancel();
                };
                $scope.done = function () {
                    console.log($scope.selected);
                    dataObject.networksWithName = $scope.selected;
                    var result = [];
                    var memberList = [];
                    var ctr = 0;
                    dataObject.availableNetworks = networks;
                    for (ntw = 0; ntw < $scope.selected.length; ntw++) {
                        var objMember = {'id': 0, 'networkId': $scope.selected[ntw].id};
                        memberList.push(objMember);
                        var res = _.find(dataObject.availableNetworks, {'id': parseInt($scope.selected[ntw].id)});
                        if (res) {
                            result[ctr] = res;
                            ctr++;
                        }
                    }
                    for (ntwk = 0; ntwk < result.length; ntwk++) {
                        if (result[ntwk]) {
                            _.remove(dataObject.availableNetworks, result[ntwk]);
                        }
                    }
                    dataObject.memberList = memberList;
                    dataObject.countMembers = dataObject.memberList.length;
                    $mdDialog.hide();
                };
                $scope.toggle = function (item, list) {
                    var isDeleted = false;
                    for (i = 0; i < list.length; i++) {
                        if (list[i].id === item.id) {
                            list.splice(i, 1);
                            isDeleted = true;
                        }
                    }
                    if (!isDeleted) {
                        list.push(item);
                    }
                    console.log($scope.selected);
                    $scope.no_of_selected_networks = $scope.selected.length;
                };
                $scope.exists = function (item, list) {
                    for (i = 0; i < list.length; i++) {
                        if (list[i].id === item.id) {
                            return true;
                        }
                    }
                    return false;
                };
                $scope.isIndeterminate = function () {
                    return ($scope.selected.length !== 0 &&
                            $scope.selected.length !== $scope.items.length);
                };
                $scope.isChecked = function () {
                    return $scope.selected.length === $scope.items.length;
                };
                $scope.toggleAll = function () {
                    if ($scope.selected.length === $scope.items.length) { //uncheck all
                        $scope.selected = [];
                    } else if ($scope.selected.length === 0 || $scope.selected.length > 0) {
                        $scope.selected = $scope.items.slice(0); //check all
                    }
                    console.log($scope.selected);
                    $scope.no_of_selected_networks = $scope.selected.length;
                };
                //}
            })();
        }
        //Cleare session stored data.
        $scope.callCacheBurst = function () {
            console.log('Bursting cache data and reloading from server');
            clearMasterSession($sessionStorage, $state);
            /*$sessionStorage.groupViewData = false;
             $state.reload();*/
        };

        $scope.$on('$viewContentLoaded', function (event) {
            console.log(event);
            fixContainerHeight(1);
        });

    }

    angular.module('shieldxApp').controller('resourceGroupsCtr', resourceGroupsCtr);

    function NewRuleInfraCtr(
            infrastructureConnectorService,
            $scope,
            $state,
            $mdDialog) {

        console.log(" NewRuleInfraCtr ");
        $scope.goToRulePageDisabled = true;
       
       
        $scope.clouds = [];
        $scope.active_help_id = "infra_type_help_wizard";
        $scope.helpButtonClicked = function(id){
                $scope.active_help_id = id;
                console.log("  helpButtonClicked ");
                $scope.bordcastEventHelpButtonClicked($scope.active_help_id);
        }; 
        infrastructureConnectorService.getListOfInfrastructures().then(function (data) {

            $scope.infraAvailable = (data.length > 0) ? true : false;

            $scope.clouds = data;

        });

        $scope.showInfraOptionSelected = function(){
             $scope.goToRulePageDisabled = false;

          };
         
    }
    angular.module('shieldxApp').controller('NewRuleInfraCtr', NewRuleInfraCtr);

    function NewRuleCtr(
            infrastructureConnectorService,
            $scope,
            $state,
            $mdDialog) {

        $scope.cancel = function () {
            $mdDialog.cancel();
            $state.go("home.resourceGroups");
        };

        $scope.$on(SOEvents.ruleAllCommitedEvent, function (event, args) {
            $scope.cancel();
        });

    }
    angular.module('shieldxApp').controller('NewRuleCtr', NewRuleCtr);
    
})();
(function () {
    function emailServerSettingsCtr(
        $scope,
        $state,
        $translate,
        emailService,
        $q,
        $sessionStorage,
        $mdDialog) {

            "ngInject";
            
            clearAllSession($sessionStorage);
            $scope.emailConfigAvailable = false;
            $scope.editMiscState = false;

            $scope.emailConfigDetails ={}; 

            $scope.isAdornmentPanelOpen = false;
                                    
            $scope.$emit('listenHeaderText', {headerText: $translate.instant('admin.setup.heading')});            

            var started = {
                'heading': 'Save Initiating',
                'subHeading': 'Save Initiating..',
                'type': 'progress',
                'timeout': $scope.toastTimeout
            };

            var completed = {
                'heading': 'Email Server Settings Saved',
                'subHeading': 'Email Server Settings Saved',
                'type': 'success',
                'timeout': $scope.toastTimeout,
                'callback': function () {
                    $state.reload();
                }
            };

            var failed = {
                'heading': 'Save Failed',
                'subHeading': '&nbsp;',
                'type': 'fail',
                'timeout': $scope.toastTimeout,
                'callback': function () {
                    $state.reload();
                }
            };


            $scope.emailserver = {};

            $scope.emailserver_ipaddress_fqdn = $translate.instant("wizardinfrastucture.placeholder.ip_address_fqdn");
            $scope.emailserver_login = "User Name";
            $scope.emailserver_password = "Password";
            $scope.emailserver_port = "Port";
            $scope.emailserver_auth_reqd = "Server authentication required?";
            $scope.emailserver_use_ssl = "Use SSL/TLS";

            $scope.emailserver.port = 25;

            //Save email server configuration
            $scope.saveEmailServerSettings = function () {

                var emailServerConfigDetails = $scope.emailserver;
                var tenantId = 1;
                emailServerConfigDetails.tenantId = tenantId;

                var startAddSmtpServerMessage = {
                    'heading': 'Add SMTP Server',
                    'subHeading': 'This should take only a few minutes max.',
                    'type': 'progress',
                    'timeout': 3000
                };
                var successfulSmtpServerMessage = {
                    'heading': 'SMTP Server Created',
                    'subHeading': 'SMTP Server created successfully.',
                    'type': 'success',
                    'timeout':3000
                };

                //showToast(backupStarted);
                console.log("emailServerSettingsCtr : save configuration settings"+emailServerConfigDetails);
                showToast(startAddSmtpServerMessage);

                emailService.saveEmailServerSettings(tenantId,emailServerConfigDetails).then(function () {
                    showToast(successfulSmtpServerMessage);
                    console.log("Email server settings saved.");
                }, function (error) {
                    console.log(error);
                    failed.subHeading = "Error: " + error.data.message;
                    showToast(failed);
                });                
                //$mdDialog.hide();
            };


            emailService.getEmailServerSettings(1).then(function (data) {

                console.log("Get SMTP server config details for tenant id 1 ");

                if (!data) {
                    $scope.emailConfigAvailable = false;
                } else {
                    $scope.emailConfigAvailable = true;
                    $scope.emailserver = data;
                    console.log(" Sender = "+data.senderaddress+" Server IP = "+data.ip+"  use auth = "+data.usessl);
                    console.log($scope.emailserver);
                }
            }, function (error) {
                $scope.errorMessage = "ERROR occured while getting SMTP server details!!!";
                $scope.emailConfigAvailable = false;
                console.log(error);
            });


            //Test email server connection
            $scope.testConnection = function () {
                var ip = $scope.emailserver.ip;
                var emailServerConfigDetails = {
                    'senderAddress' : $scope.emailserver.sender,
                    'serverIp': $scope.emailserver.ip,
                    'userName': $scope.emailserver.username,
                    'password': $scope.emailserver.password,
                    'useAuth': ($scope.emailserver.useauth == 1)?true:false
                };

                var startTestConnection = {
                    'heading': 'Test connection',
                    'subHeading': 'Test connection initiating..',
                    'type': 'progress',
                    'timeout': $scope.toastTimeout
                };

                var testConnectionDone = {
                    'heading': 'Test connection successful',
                    'subHeading': 'Test connection to email server was successful',
                    'type': 'success',
                    'timeout': $scope.toastTimeout
                    //'callback': function () {
                    //    $state.reload();
                    //}
                };

                //showToast(backupStarted);
                console.log("emailServerSettingsCtr : test connection settings for email server ip = "+ip);
                
                showToast(startTestConnection); 

                emailService.testConnection(emailServerConfigDetails).then(function () {
                    showToast(testConnectionDone);
                    console.log("test connection to email server is successful!!!");

                }, function (error) {
                    console.log(error);
                    var testConnectionFailed = {
                        'heading': 'Email server test connection failed',
                        'subHeading': "Error: Test connection failed!",
                        'type': 'fail',
                        'timeout': 10000
                    };                    
                    showToast(testConnectionFailed);
                });                
                //$mdDialog.hide();
            };

            $scope.pwdType = 'password';
            $scope.togglePasswordType = function () {
                $scope.pwdType = $scope.pwdType === 'password' ? 'text' : 'password';
            };

            $scope.showStatus = function (status, test) {
                return status === test;
            };

            $scope.hide = function () {
                $mdDialog.hide();
            };

            $scope.cancel = function () {
                $mdDialog.cancel();
            };

            $scope.$on('$viewContentLoaded', function (event) {
                console.log(event);
                fixContainerHeight(1);
            });
    }
    angular.module('shieldxApp').controller('emailServerSettingsCtr', emailServerSettingsCtr);

})();
(function () {
    function ldapServerSettingsCtr(
        $scope,
        $state,
        $translate,
        ldapService,
        $q,
        $sessionStorage,
        $mdDialog) {

            "ngInject";
            
            clearAllSession($sessionStorage);
            var ldapConfigData;
            $scope.ldapConfigAvailable = false;
            $scope.editMiscState = false;

            $scope.isAdornmentPanelOpen = false;
                                    
            $scope.$emit('listenHeaderText', {headerText: $translate.instant('admin.setup.heading')});            

            var started = {
                'heading': 'Save Initiating',
                'subHeading': 'Save Initiating..',
                'type': 'progress',
                'timeout': $scope.toastTimeout
            };

            var completed = {
                'heading': 'LDAP Server Settings Saved',
                'subHeading': 'LDAP Server Settings Saved',
                'type': 'success',
                'timeout': $scope.toastTimeout,
                'callback': function () {
                    $state.reload();
                }
            };

            var failed = {
                'heading': 'Save Failed',
                'subHeading': '&nbsp;',
                'type': 'fail',
                'timeout': $scope.toastTimeout,
                'callback': function () {
                    $state.reload();
                }
            };

            var startedTest = {
                'heading': 'Test Connection Initiating',
                'subHeading': 'Test Connection Initiating..',
                'type': 'progress',
                'timeout': $scope.toastTimeout
            };

            var completedTest = {
                'heading': 'Test Passed',
                'subHeading': 'Test Passed',
                'type': 'success',
                'timeout': $scope.toastTimeout,
                'callback': function () {
                    $state.reload();
                }
            };

            var failedTest = {
                'heading': 'Test Failed',
                'subHeading': '&nbsp;',
                'type': 'fail',
                'timeout': $scope.toastTimeout,
                'callback': function () {
                    $state.reload();
                }
            };


            $scope.ldapserver = {};

            $scope.smbserver_ipaddress_fqdn = $translate.instant("wizardinfrastucture.placeholder.ip_address_fqdn");
            $scope.smbserver_login = "User Name";
            $scope.smbserver_password = "Password";

            ldapService.getSettings().then(function (data) {
               $scope.ldapserver=data;

            }, function (error) {
                console.log(error);
                $scope.errorMessage = "ERROR occured while getting User List!!!";
            });


            //Save SMB Configuration
            $scope.saveSettings = function () {
                var name = $scope.ldapserver.name;
                var ip = $scope.ldapserver.ip;
                var userName = $scope.ldapserver.username;
                var password = $scope.ldapserver.password;
                var port = $scope.ldapserver.port;

                var ldapServerConfigDetails = {
                    'name' : name,
                    'ip': ip,
                    'username': userName,
                    'password': password,
                    'port': port,
                    "tenantID" : 1
                };

                //showToast(backupStarted);
                console.log("ldapServerSettingsCtr : save configuration settings. server ip = "+ip+" user name  = "+userName);
                
                showToast(started); 

                ldapService.saveSettings(ldapServerConfigDetails).then(function () {
                    console.log("Save LDAP Server configuration !!!");
                    showToast(completed);

                }, function (error) {
                    console.log(error);
                    failed.subHeading = "Error: " + error.data.message;
                    showToast(failed);
                });                
                //$mdDialog.hide();
            }; 

            //Save SMB Configuration
            $scope.testConnection = function () {
                var name = $scope.ldapserver.name;
                var ip = $scope.ldapserver.ip;
                var userName = $scope.ldapserver.username;
                var password = $scope.ldapserver.password;
                var port = $scope.ldapserver.port;

                var ldapServerConfigDetails = {
                    'name' : name,
                    'ip': ip,
                    'username': userName,
                    'password': password,
                    'port': port,
                    "tenantID" : 1
                };

                //showToast(backupStarted);
                console.log("ldapServerSettingsCtr : test connection. server name = "+name+" user name  = "+userName);
                
                showToast(startedTest); 

                ldapService.testConnection(ldapServerConfigDetails).then(function () {
                    console.log("test LDAP server connection !!!");
                    showToast(completedTest);

                }, function (error) {
                    console.log(error);
                    failed.subHeading = "Error: " + error.data.message;
                    showToast(failedTest);
                });                
                //$mdDialog.hide();
            };


            $scope.pwdType = 'password';
            $scope.togglePasswordType = function () {
                $scope.pwdType = $scope.pwdType === 'password' ? 'text' : 'password';
            };

            $scope.showStatus = function (status, test) {
                return status === test;
            };

            $scope.hide = function () {
                $mdDialog.hide();
            };

            $scope.cancel = function () {
                $mdDialog.cancel();
            };

            $scope.$on('$viewContentLoaded', function (event) {
                console.log(event);
                fixContainerHeight(1);
            });
    }
    angular.module('shieldxApp').controller('ldapServerSettingsCtr', ldapServerSettingsCtr);

})();
(function () {
    function settingsCtr(
        $scope,
        $state,
        backupRestoreService,
        $q
    ) {

        $scope.$emit('listenHeaderText', { headerText: "Setup" });
        var url = $state.current.url;
        console.log(" Settings Controller : url -->> "+url);
        if(url.indexOf("smbserver") >0 ) {
            $state.go('home.setup.settings.smbserver');
        } else if(url.indexOf("syslog") >0 ) {
            $state.go('home.setup.settings.syslog');    
        } else if(url.indexOf("emailserver") >0 ) {
            $state.go('home.setup.settings.emailserver');    
        } else if(url.indexOf("ldapserver") >0 ) {
            $state.go('home.setup.settings.ldapserver');    
        } else {
            $state.go('home.setup.settings.smbserver');    
        }
        $scope.$on('$stateChangeSuccess', function(event, toState, toParams, fromState, fromParams) {
            if (toState.data) {
                $scope.currentTab = toState.data.selectedTab;
            }

        });
        $scope.active_help_id = "admin_system_setup_configs_help";
        $scope.helpButtonClicked = function(id){
            $scope.active_help_id = id;
            console.log("  helpButtonClicked ");
            $scope.bordcastEventHelpButtonClicked($scope.active_help_id);
        }; 
        $scope.bordcastEventHelpButtonClicked = function(helpId){
            $scope.$broadcast('onHelpButtonClicked', {
               helpIDString: helpId 
            });
        };
        $scope.$on('$viewContentLoaded', function (event) {
            fixContainerHeight(1);
        });
        $scope.$on('$viewContentLoaded', function (event) {
            fixContainerHeight(1);
        });

    }
    angular.module('shieldxApp').controller('settingsCtr', settingsCtr);
})();
(function() {
    function setupCtr(
        $scope
        
    ) {

        $scope.$emit('listenHeaderText', { headerText: "Setup" });    

    }

    angular.module('shieldxApp').controller('setupCtr', setupCtr);
})();

(function () {
    function smbServerSettingsCtr(
        $scope,
        $state,
        $translate,
        smbService,
        $q,
        $sessionStorage,
        $mdDialog,
        userSessionMenagment) {

            "ngInject";
            
            clearAllSession($sessionStorage);
            var smbConfigData;
            $scope.smbConfigAvailable = false;
            $scope.editMiscState = false;

            $scope.isAdornmentPanelOpen = false;

            $scope.smbServerConfigDetails ={};

            $scope.$emit('listenHeaderText', {headerText: $translate.instant('admin.setup.heading')});

            var started = {
                'heading': 'Save Initiating',
                'subHeading': 'Save Initiating..',
                'type': 'progress',
                'timeout': $scope.toastTimeout
            };

            var completed = {
                'heading': 'SMB Server Settings Saved',
                'subHeading': 'SMB Server Settings Saved',
                'type': 'success',
                'timeout': $scope.toastTimeout,
                'callback': function () {
                    $state.reload();
                }
            };

            var failed = {
                'heading': 'Save Failed',
                'subHeading': '&nbsp;',
                'type': 'fail',
                'timeout': $scope.toastTimeout,
                'callback': function () {
                    $state.reload();
                }
            };


            $scope.smbserver = {};

            $scope.smbserver_ipaddress_fqdn = $translate.instant("wizardinfrastucture.placeholder.ip_address_fqdn");
            $scope.smbserver_login = "User Name";
            $scope.smbserver_password = "Password";
            $scope.smbserver_sharename = "Share Name";

            //var read_id = authorities("setup_read");
            var update_id = authorities("setup_update");
           //$scope.is_read_smb = userSessionMenagment.isUserAllowd(read_id);
            $scope.is_update_smb = userSessionMenagment.isUserAllowd(update_id);


            smbService.getSmbServerSettings().then(function (data) {

                console.log("Get SMB server config details for tenant id 1");

                if (!data) {
                    $scope.smbConfigAvailable = false;
                } else {
                    $scope.smbConfigAvailable = true;
                    //$scope.smbserver = data;
                    console.log(" Server IP = "+data.serverIp+" Share Name = "+data.shareName+"  Last Modified Time = "+data.lastModifiedTime);
                    $scope.smbserver.ip = data.serverIp;
                    $scope.smbserver.username = data.userName;
                    $scope.smbserver.password = data.password;
                    $scope.smbserver.sharename = data.shareName;
                    console.log($scope.smbserver);
                }

            }, function (error) {
                console.log(error);
                $scope.errorMessage = "ERROR occured while getting smb server config details!!!";
                $scope.smbConfigAvailable = false;
            });


            //Save SMB Configuration
            $scope.smbserverSettings = function () {
                var serverName = $scope.smbserver.name;
                var ip = $scope.smbserver.ip;
                var userName = $scope.smbserver.username;
                var password = $scope.smbserver.password;
                var shareName = $scope.smbserver.sharename;

                var smbServerConfigDetails = {
                    'servername' : serverName,
                    'serverIp': ip,
                    'userName': userName,
                    'password': password,
                    'shareName': shareName
                };

                //showToast(backupStarted);
                console.log("smbServerSettingsCtr : save configuration settings. server ip = "+ip+" user name  = "+userName);
                
                showToast(started); 

                smbService.saveSmbServerSettings(smbServerConfigDetails).then(function () {
                    showToast(completed);
                    console.log("SMB server settings saved.");
                }, function (error) {
                    console.log(error);
                    failed.subHeading = "Error: " + error.data.message;
                    showToast(failed);
                });                
                //$mdDialog.hide();
            };


            //Test SMB server connection
            $scope.testConnection = function () {
                var ip = $scope.smbserver.ip;
                var smbServerConfigDetails = {
                    'servername' : $scope.smbserver.name,
                    'serverIp': $scope.smbserver.ip,
                    'userName': $scope.smbserver.username,
                    'password': $scope.smbserver.password,
                    'shareName': $scope.smbserver.sharename
                };

                var startTestConnection = {
                    'heading': 'Test connection',
                    'subHeading': 'Test connection initiating..',
                    'type': 'progress',
                    'timeout': $scope.toastTimeout
                };

                var testConnectionDone = {
                    'heading': 'Test connection successful',
                    'subHeading': 'Test connection to SMB was successful',
                    'type': 'success',
                    'timeout': $scope.toastTimeout
                    //'callback': function () {
                    //    $state.reload();
                    //}
                };

                //showToast(backupStarted);
                console.log("smbServerSettingsCtr : test connection settings for smb server ip = "+ip);
                
                showToast(startTestConnection); 

                smbService.testConnection(smbServerConfigDetails).then(function () {
                    showToast(testConnectionDone);
                    console.log("test SMB server connection successful!!!");

                }, function (error) {
                    console.log(error);
                    var testConnectionFailed = {
                        'heading': 'Smb server test connection failed',
                        'subHeading': "Error: Test connection failed!",
                        'type': 'fail',
                        'timeout': 10000
                    };                    
                    showToast(testConnectionFailed);
                });                
                //$mdDialog.hide();
            };

            $scope.pwdType = 'password';
            $scope.togglePasswordType = function () {
                $scope.pwdType = $scope.pwdType === 'password' ? 'text' : 'password';
            };

            $scope.showStatus = function (status, test) {
                return status === test;
            };

            $scope.hide = function () {
                $mdDialog.hide();
            };

            $scope.cancel = function () {
                $mdDialog.cancel();
            };

            $scope.$on('$viewContentLoaded', function (event) {
                console.log(event);
                fixContainerHeight(1);
            });
    }
    angular.module('shieldxApp').controller('smbServerSettingsCtr', smbServerSettingsCtr);

})();
(function() {
    function syslogServerSettingsCtr(
        $scope,
        $state,
        $http,
        $q,
        $translate,
        $sessionStorage,
        deploymentSpecificationService,
        infrastructureConnectorService,
        syslogForwardingService,
        $mdDialog
    ) {
        "ngInject";

        clearAllSession($sessionStorage);
        var serverProfiles = [];
        var deferred = $q.defer();
        $scope.promise = deferred.promise;
        $scope.promiseCompleted = true;
        var promiseCtr = 0;
        var totalClouds = 0;
        $scope.serverProfilesAvailable = false;
        $scope.editMiscState = false;

        $scope.isAdornmentPanelOpen = false;
        $scope.isSearchBarOpen = false;

        var serverProfilesCtr = 0;
        $scope.profiles = [];

        $scope.serverProfileSelected = false;

        /* **** for tables [start] **** */
        $scope.selected = [];
        $scope.query = {
            order: 'name',
            limit: 10,
            page: 1
        };

        $scope.isAdornmentPanelOpen = false;
        $scope.isSearchBarOpen = false;

        $scope.updateAdornmentPanel = function (event, rowData) {
            $scope.toggleAdornmentPanel();
            $scope.adornmentData = rowData;
            console.log($scope.adornmentData);
            console.log("Server Profile Name : "+$scope.adornmentData.serverProfileName);
            console.log("Server Profile Id : "+$scope.adornmentData.serverProfileId);
        };

        $scope.toggleAdornmentPanel = function () {
            $scope.isAdornmentPanelOpen = $scope.isAdornmentPanelOpen === false ? true : false;
        };

        $scope.toggleSearchBar = function (event) {
            $scope.isSearchBarOpen = $scope.isSearchBarOpen === false ? true : false;
            if ($scope.isSearchBarOpen)
                angular.element(event.currentTarget.firstElementChild).css('color', '#4a90e2');
            else
                angular.element(event.currentTarget.firstElementChild).css('color', '#6d6e71');
        };
        /* **** for tables [end] **** */


        $scope.serverprofile = {};

        $scope.serverprofile.protocol='2';
        $scope.protocoltypes = {
            'protocols': [
                {'name': 'TCP', 'value': '1'},
                {'name': 'UDP', 'value': '2'}
            ]
        };

        $scope.serverprofile.serverProfileName = "";
        $scope.serverprofile.serverFqdnOrIp = "";
        $scope.serverprofile.port = 514;
        $scope.serverprofile.usessl = "";
        $scope.serverprofile.certFile = "";

        $scope.serverprofile.targetServerProfile='serverProfilesListCtr';

        $scope.serverprofile.tenantId = 1;

        $scope.fileInputText = "No File Chosen";

        $scope.tenants = [];

        $scope.getTenantDataForCloud = function (cloudObj) {
            deploymentSpecificationService.getTenants(cloudObj.id).then(function (tenants) {
                _.each(tenants, function (tenant) {
                    tenant.cloudName = cloudObj.name;
                    $scope.tenants.push(tenant);
                });
            });
        };

        $scope.getTenants = function () {
            infrastructureConnectorService.getListOfInfrastructures().then(function (clouds) {
                _.each(clouds, function (cloud) {
                    $scope.getTenantDataForCloud(cloud);
                });
            });
        };

        $scope.getTenants();

        /*
        $scope.fileChanged = function (elem) {
            $scope.files = elem.files;
            $scope.$appply();
        };
        */

        //Configure Resigning Keys
        $scope.addProfile = function(ev){
            console.log("Open add syslog server profile dialog.");
            $mdDialog.show({
                controller: syslogServerSettingsCtr,
                skipHide: true,
                templateUrl: 'core/components/administration/setup/syslogserver-settings.html',
                parent: angular.element(document.body),
                targetEvent: ev,
                fullscreen: true,
                openFrom: {top: 1100, height: 0},
                closeTo: {left: 1500}
                //locals: {'cloudData': cloudData}
            }).then(function () {

            });
        };


        // Get Server Profiles if exist any
        var tenantId = $scope.serverprofile.tenantId;
        console.log("Get Server Profiles for Tenant Id : "+tenantId);
        syslogForwardingService.getSyslogServerProfiles(tenantId).then(function (data) {
            console.log("Server Profiles = "+data);
            //$scope.serverprofile = angular.fromJson(data);
            //console.log("Server Profile Name = "+$scope.serverprofile.serverProfileName);
            totalprofiles = data.length;
            console.log("Total certs = "+totalprofiles);
            if (totalprofiles === 0) {
                deferred.resolve();
                $scope.promiseCompleted = false;
                $scope.serverProfilesAvailable = false;

            } else {
                console.log("Server profiles available = "+data);
                $scope.serverProfilesAvailable = true;

                for (var i = 0; i < data.length; i++) {
                    console.log(" data -> "+data[i]);
                    serverProfiles[i] = {};
                    serverProfiles[i] = data[i];
                }

                deferred.resolve();
                $scope.promiseCompleted = false;
                $scope.profiles = serverProfiles;

                console.log(serverProfiles);
            }
        }, function (error) {
            console.log("Failed to get syslog server profiles");
            $scope.errorMessage = "ERROR occured while getting syslog server profiles.";
            serverProfiles = [];
            $scope.profiles = [];
            deferred.resolve();
            $scope.promiseCompleted = false;
            $scope.serverProfilesAvailable = false;
            console.log(error);
        });


        $scope.addSyslogServerProfile = function () {

            console.log(" Add Syslog Server Profile -->> "+$scope.serverprofile);

            var syslogServerProfile = $scope.serverprofile;

            var tenantId = 1;
            syslogServerProfile.tenantId = tenantId;

            var startAddSyslogServerMessage = {
                'heading': 'Create Syslog Server Profile',
                'subHeading': 'This should take only a few minutes max.',
                'type': 'progress',
                'timeout': 3000
            };
            var successfulSyslogServerMessage = {
                'heading': 'Syslog Server Created',
                'subHeading': 'Syslog Server created successfully.',
                'type': 'success',
                'timeout': 2000
            };
            showToast(startAddSyslogServerMessage);
            syslogForwardingService.createSyslogServerProfile(tenantId, syslogServerProfile).then(function (data) {
                console.log(" Add Syslog Server profile.");
                if (data) {
                    var newData = syslogServerProfile;
                    console.log(syslogServersData);
                    showToast(successfulSyslogServerMessage);

                    syslogServersData.unshift(newData);
                    console.log(syslogServersData);
                    $sessionStorage.syslogServersList = syslogServersData;
                    $scope.syslogServerProfiles=syslogServersData;
                    //$rootScope.$broadcast('newSyslogServerCreated', {});
                }
            }, function (error) {
                var failureSyslogServerCreation = {
                    'heading': 'Syslog Server creation failed',
                    'subHeading': "Error: " + error.data.message,
                    'type': 'fail',
                    'timeout': 3000
                };
                showToast(failureSyslogServerCreation);
            });
            $mdDialog.hide();
        };

        $scope.deleteSyslogServerProfile = function (event, rowData) {

            $scope.adornmentData = rowData;
            console.log(" Delete syslog server profile for server profile id : "+$scope.adornmentData.serverProfileId);
            var startDeleteSyslogServerProfile = {
                'heading': 'Delete Syslog Server Profile',
                'subHeading': '',
                'type': 'progress',
                'timeout': 3000
            };
            var successfulDeletedSyslogServerProfile = {
                'heading': 'Syslog server deleted',
                'subHeading': 'Syslog server deleted successfully.',
                'type': 'success',
                'timeout': 2000,
                'callback': function () {
                    $state.reload();
                }
            };
            showToast(startDeleteSyslogServerProfile);
            syslogForwardingService.deleteSyslogServerProfile($scope.adornmentData.serverProfileId).then(function (data) {
                console.log(" Syslog server profile deleted for profile id "+$scope.adornmentData.serverProfileId);
                if (data) {
                    showToast(successfulDeletedSyslogServerProfile);
                }
            }, function (error) {
                var failureSyslogServerProfileDeletion = {
                    'heading': 'Syslog server deletion failed',
                    'subHeading': "Error: " + error.data.message,
                    'type': 'fail',
                    'timeout': 3000
                };
                showToast(failureSyslogServerProfileDeletion);
            });
        };


        $scope.fileNameChanged =  function(element){
            $scope.fileInputText = element.files[0].name;
        };

        $scope.$on('$viewContentLoaded', function (event) {
            console.log(event);
            fixContainerHeight(1);
        });

        $scope.clearServerProfilesFromSession = function () {
            clearMasterSession($sessionStorage, $state);
            //$sessionStorage.profileList = false;
            $state.reload();
        };

        $scope.hide = function () {
            $mdDialog.hide();
        };

        $scope.cancel = function () {
            $mdDialog.cancel();
        };

        $scope.cancelDialog = function() {
            $mdDialog.cancel();
        };
    }
    angular.module('shieldxApp').controller('syslogServerSettingsCtr', syslogServerSettingsCtr);
})();
/*
 ShieldX Networks Inc. CONFIDENTIAL
 ----------------------------------
 *
 Copyright (c) 2016 ShieldX Networks Inc.
 All Rights Reserved.
 *
 NOTICE: All information contained herein is, and remains
 the property of ShieldX Networks Incorporated and its suppliers,
 if any. The intellectual and technical concepts contained
 herein are proprietary to ShieldX Networks Incorporated
 and its suppliers and may be covered by U.S. and Foreign Patents,
 patents in process, and are protected by trade secret or copyright law.
 Dissemination of this information or reproduction of this material
 is strictly forbidden unless prior written permission is obtained
 from ShieldX Networks Incorporated.
 */

(function () {
    function shieldxUpdatesCtr(
            $scope,
            $state,
            $translate,
            managementService,
            infrastructureConnectorService,
            deploymentSpecificationService,
            userSessionMenagment,
            $mdDialog) {

        $scope.$emit('listenHeaderText', {headerText: $translate.instant('admin.toolbar.heading')});

        var softwareUpgradeStarted = {
            'heading': 'Software Upgrade Initiating',
            'subHeading': '&nbsp;',
            'type': 'progress',
            'timeout': $scope.toastTimeout
        };
        var softwareUpgraded = {
            'heading': 'Software Upgrade Initiated',
            'subHeading': '&nbsp;',
            'type': 'success',
            'timeout': $scope.toastTimeout,
            'callback': function () {
                $state.reload();
            }
        };

        var softwareUpgradeFailed = {
            'heading': 'Software Upgrade Failed',
            'type': 'fail',
            'timeout': $scope.toastTimeout
        };

        var contentUpgradeStarted = {
            'heading': 'Content Update Initiating',
            'subHeading': '&nbsp;',
            'type': 'progress',
            'timeout': $scope.toastTimeout
        };
        var contentUpgraded = {
            'heading': 'Content Update Initiated',
            'subHeading': '&nbsp;',
            'type': 'success',
            'timeout': $scope.toastTimeout,
            'callback': function () {
                $state.reload();
            }
        };

        var contentUpgradeFailed = {
            'heading': 'Content Update Failed',
            'subHeading': '&nbsp;',
            'type': 'fail',
            'timeout': $scope.toastTimeout
        };

        var shieldx_upgrade = authorities("shieldxUpdates_update");
        var content_update = authorities("shieldxUpdates_content_update");

        $scope.is_shieldx_upgrade = userSessionMenagment.isUserAllowd(shieldx_upgrade);
        $scope.is_content_update = userSessionMenagment.isUserAllowd(content_update);

        $scope.disableUpgradeSoftware = (parseInt($scope.currentTime) - $scope.callout.upgradeSoftware < $scope.disableTimeout);
        $scope.disableDeployPatch = (parseInt($scope.currentTime) - $scope.callout.deployHotfixBuild < $scope.disableTimeout);
        $scope.disableUpgradeContent = (parseInt($scope.currentTime) - $scope.callout.upgradeContent < $scope.disableTimeout);

        $scope.swVersionsAvailable = false;
        $scope.swversions = [];
        $scope.latetsswversions = [];
        var swVersionData = [];
        var latestswVersionData = [];
        $scope.swupgrade = {};
        $scope.swupgrade.deployhotfix ='';
        $scope.swupgrade.hotfix = '';

        $scope.active_help_id = "admin_system_sx_updates_help";
        $scope.helpButtonClicked = function(id){
            $scope.active_help_id = id;
            console.log("  helpButtonClicked ");
            $scope.bordcastEventHelpButtonClicked($scope.active_help_id);
        }; 

        $scope.bordcastEventHelpButtonClicked = function(helpId){
            $scope.$broadcast('onHelpButtonClicked', {
                helpIDString: helpId 
            });
        };
        //Get Software Versions
        //$sessionStorage.swVersionList = [];

        var getswversionsstarted = {
            'heading': 'Get deployed software versions from registry sync..',
            'subHeading': '&nbsp;',
            'type': 'progress',
            'timeout': 3000
        };
        var getswversionscompleted = {
            'heading': 'Received deloyed software versions from registry sync',
            'subHeading': '&nbsp;',
            'type': 'success',
            'timeout': 2000,
        };
        var failedtogetswversions = {
            'heading': 'Failed to get software versions from registry sync',
            'subHeading': '&nbsp;',
            'type': 'fail',
            'timeout': 3000
        };

        showToast(getswversionsstarted);
        managementService.listDeployedSoftwarePackage().then(function (data) {

            console.log("SW versions length = "+data.length);

            if (data === 0) {

                $scope.swVersionsAvailable = false;

            } else {
                //showToast(getswversionscompleted);
                console.log("SW Versions available = "+data);
                $scope.swVersionsAvailable = true;

                for (var i = 0; i < data.length; i++) {
                    console.log(" data -> "+data[i]);
                    swVersionData[i] = {};
                    console.log("MicroService : "+data[i].microservice+" version : "+data[i].swversion);
                    swVersionData[i] = data[i];
                }
                console.log(swVersionData);
                $scope.swversions = swVersionData;
            }
        }, function (error) {
            console.log(error);
            $scope.errorMessage = "ERROR occured while getting SW version list!!!";
            $scope.swversions = [];
            failedtogetswversions.subHeading = "Error: " + error.data.message;
            showToast(failedtogetswversions);

        });

        managementService.checkForSoftwareUpdates().then(function (data) {

            console.log("Latest sw updates length = "+data.length);

            if (data.length === 0) {
                console.log("No latest available software versions");
                $scope.swVersionsAvailable = false;
                $scope.latetsswversions = [];

            } else {
                //showToast(getswversionscompleted);
                console.log("Latets SW Versions available = "+data);
                $scope.swVersionsAvailable = true;

                for (var i = 0; i < data.length; i++) {
                    console.log(" data -> "+data[i]);
                    latestswVersionData[i] = {};
                    console.log("MicroService : "+data[i].microservice+" version : "+data[i].swversion);
                    latestswVersionData[i] = data[i];
                }
                console.log(latestswVersionData);
                $scope.latetsswversions = latestswVersionData;
            }
        }, function (error) {
            console.log(error);
            $scope.errorMessage = "ERROR occured while checking for latest SW updates !!!";
            $scope.latetsswversions = [];
            failedtogetswversions.subHeading = "Error: " + error.data.message;
            showToast(failedtogetswversions);
        });


        $scope.deployHotfixBuild = function () {

            //$scope.disableCallout('upgradeSoftware');
            showToast(softwareUpgradeStarted);

            var hfbuild = $scope.swupgrade.hotfix;

            console.log("Deploy hot fix build : "+hfbuild);

            managementService.upgradeSoftwarePatch(hfbuild).then(function (data) {

                showToast(softwareUpgraded);

            }, function (error) {
                console.log(error.data.message);
                $scope.disableDeployPatch=false;
                var hotfixdeploymentfailed = {
                    'heading': 'Software Upgrade Failed',
                    'subHeading': '&nbsp;',
                    'type': 'fail',
                    'timeout': 3000,
                    'callback': function () {
                        $state.reload();
                    }
                };

                hotfixdeploymentfailed.subHeading = "Error: " + error.data.message;
                showToast(hotfixdeploymentfailed);
            });
        };


        $scope.callUpgradeSoftware = function () {

            //$scope.disableCallout('upgradeSoftware');
            console.log("Upgrade Software to latest version.");
            showToast(softwareUpgradeStarted);

            managementService.upgradeSoftware().then(function (data) {
                console.log("Software has been upgrade to latest");
                showToast(softwareUpgraded);

            }, function (error) {
                console.log(error);
                softwareUpgradeFailed.subHeading = "Error: " + error.data.message;
                showToast(softwareUpgradeFailed);

            });
        };

        /*
        $scope.callUpgradeSoftware = function () {

            $scope.disableCallout('upgradeSoftware');

            showToast(softwareUpgradeStarted);

            managementService.callUpgradeSoftware().then(function () {

                showToast(softwareUpgraded);

            }, function (error) {
                console.log(error);
                softwareUpgradeFailed.subHeading = "Error: " + error.data.message;
                showToast(softwareUpgradeFailed);

            });
        };
        */

        $scope.callUpgradeContent = function () {

            console.log("Content update started..");

            //$scope.disableCallout('upgradeContent'); //Call out is not working as expected. Commnted for beta - QTAD-2570

            showToast(contentUpgradeStarted);

            managementService.callUpgradeContent().then(function () {

                showToast(contentUpgraded);

            }, function (error) {
                console.log(error);
                contentUpgradeFailed.subHeading = "Error: " + error.data.message;
                showToast(contentUpgradeFailed);
            });
        };
      
        fixContainerHeight(1);

        $scope.callpopupToUploadUrlFilteringContent = function(ev){
            console.log("Launch upload url filtering content upload dialog.");             
            $mdDialog.show({
                controller: urlFilteringCtr,
                templateUrl: 'core/components/administration/shieldx-updates/urlfiltering-content.html',                
                parent: angular.element(document.body),
                targetEvent: ev,
                fullscreen: true,
                openFrom: {top: 1100, height: 0},
                closeTo: {left: 1500}
                //locals: {'cloudData': cloudData}
            }).then(function () {

            });
        };

        //Export URL Filtering Data
        $scope.exportUrlContent = function () {
            console.log("Export URL Content");

            var exportUrlContentCompleted = {
                'heading': 'Export Url filtering content completed',
                'subHeading': 'URL filtering content has been exported successfully.',
                'type': 'success',
                'timeout': 5000
            };

            managementService.exportUrlFilteringData(1).then(function (data) {

                console.log("url filtering content exported.");
                console.log(data);
                showToast(exportUrlContentCompleted);

                var linkElement = document.createElement('a');
                try {
                    var blob = new Blob([data], { type: 'application/octet-stream' });
                    var url = window.URL.createObjectURL(blob);

                    linkElement.setAttribute('href', url);
                    linkElement.setAttribute("download", 'emit-url-data.csv');

                    var clickEvent = new MouseEvent("click", {
                        "view": window,
                        "bubbles": true,
                        "cancelable": false
                    });
                    linkElement.dispatchEvent(clickEvent);
                } catch (ex) {
                    console.log(" Failed to export url filtering content key "+ex.getMessage());
                    console.log(ex);
                }

            }, function error(err) {
                console.log(err);
                var exportUrlDataFailed = {
                    'heading': 'Export url filtering content request failed.',
                    'subHeading': '&nbsp;',
                    'type': 'fail',
                    'timeout': 10000,
                };
                exportUrlDataFailed.subHeading = "Error: " + err.data.message;

                showToast(exportUrlDataFailed);
            });
        };

        // control Plane Setting controller

        $scope.clouds = [];

        infrastructureConnectorService.getListOfInfrastructures().then(function (data) {

            $scope.infraAvailable = (data.length > 0) ? true : false;

            $scope.clouds = data;

        });

        $scope.deploymentSpecDataNotAvailable = true;

        $scope.showDeploymentSpecOptions = function (infraId) {
            $scope.enableNext = false;
            $scope.deploymentSpecList = [];
            $scope.selectedDspec= parseInt(infraId);
            deploymentSpecificationService.getDeploymentSpecList(parseInt(infraId)).then(
                    function (delpoymentSpecList) {
                        $scope.deploymentSpecList = delpoymentSpecList;
                        if (delpoymentSpecList.length !== 0) {
                            $scope.deploymentSpecDataNotAvailable = false;
                        }
                    }
            );
        };

        function urlFilteringCtr($rootScope, $scope, $sessionStorage){
            
            //FUNCTIONALITY TO ADD INFRA
            $scope.active_help_id = "infra_type_help_wizard";
            $scope.helpButtonClicked = function(id){
                $scope.active_help_id = id;
                console.log("  helpButtonClicked ");
                $scope.bordcastEventHelpButtonClicked($scope.active_help_id);
            }; 

            $scope.bordcastEventHelpButtonClicked = function(helpId){
                $scope.$broadcast('onHelpButtonClicked', {
                    helpIDString: helpId 
                });
            };     

            $scope.urlfiltering = {};

            $scope.urlfiltering.tenantId = 1;
            
            $scope.urlfiltering.tenants = [];

            $scope.hide = function () {
                $mdDialog.hide();
            };
            $scope.cancel = function () {
                $mdDialog.cancel();
            };

            
            $scope.hideRightPanel = false;

            $scope.toggleHelpPanel = function () {
                $scope.hideRightPanel = !($scope.hideRightPanel);
            };
            

            $scope.getTenantDataForCloud = function (cloudObj) {
                deploymentSpecificationService.getTenants(cloudObj.id).then(function (tenants) {
                    _.each(tenants, function (tenant) {
                        tenant.cloudName = cloudObj.name;
                        $scope.urlfiltering.tenants.push(tenant);
                    });
                });
            };

            $scope.getTenants = function () {
                infrastructureConnectorService.getListOfInfrastructures().then(function (clouds) {
                    _.each(clouds, function (cloud) {
                        $scope.getTenantDataForCloud(cloud);
                    });
                });
            };

            $scope.uploadUrlfilteringContent = function () {
                                
                var tenantId = $scope.urlfiltering.tenantId;
                console.log("Upload CSV File for tenantId "+tenantId);
                var csvfile = $scope.urlfilteringcsvfile;
                
                var startcsvFileUploadMessage = {
                    'heading': 'URL Filtering CSV File Upload',
                    'subHeading': 'URL filtering csv file upload started..',
                    'type': 'progress',
                    'timeout': 2000
                };
                var csvFileUploadedMessage = {
                    'heading': 'URL Filtering CSV File Upload',
                    'subHeading': 'URL filtering csv file uploaded successfully.',
                    'type': 'success',
                    'timeout': 2000
                };

                var csvFileUploadFailedMessage = {
                    'heading': 'URL Filtering CSV File Upload',
                    'subHeading': 'URL Filtering csv file upload failed',
                    'type': 'fail',
                    'timeout': 3000
                };

                showToast(startcsvFileUploadMessage);

                managementService.uploadFile(tenantId, csvfile).then(function (data) {
                    showToast(csvFileUploadedMessage);
                    console.log("URL Filtering CSV file has been imported successfully.");
                    if (data) {
                        console.log(data);
                    }
                }, function error(err) {
                    console.log("URL Filtering CSV file upload failed.");
                    csvFileUploadFailedMessage.subHeading = "Error: " + err.data.message;
                    showToast(csvFileUploadFailedMessage);
                });

                $mdDialog.hide();
            };

            $scope.getTenants();

            $scope.fileInputText = "No File Chosen";

            $scope.fileNameChanged =  function(element){
                $scope.fileInputText = element.files[0].name;
            };

        }
        $scope.$on('$viewContentLoaded', function (event) {
            console.log(event);
            fixContainerHeight(1);
        });

    }

    angular.module('shieldxApp').controller('shieldxUpdatesCtr', shieldxUpdatesCtr);
})();

/*
 ShieldX Networks Inc. CONFIDENTIAL
 ----------------------------------
 *
 Copyright (c) 2016 ShieldX Networks Inc.
 All Rights Reserved.
 *
 NOTICE: All information contained herein is, and remains
 the property of ShieldX Networks Incorporated and its suppliers,
 if any. The intellectual and technical concepts contained
 herein are proprietary to ShieldX Networks Incorporated
 and its suppliers and may be covered by U.S. and Foreign Patents,
 patents in process, and are protected by trade secret or copyright law.
 Dissemination of this information or reproduction of this material
 is strictly forbidden unless prior written permission is obtained
 from ShieldX Networks Incorporated.
 */

(function () {
    function usersCtr($scope,
        $translate,
        usersService,
        $q,
        $sessionStorage,
        $state,
        $mdDialog,
        userSessionMenagment) {
            "ngInject";
            
            clearAllSession($sessionStorage);
            var UserListData = [];
            var deferred = $q.defer();
            $scope.promise = deferred.promise; 
            $scope.promiseCompleted = true;
            var promiseCtr = 0;
            var totalUsers = 0;
            $scope.usersAvailable = false;
            $scope.editMiscState = false;
            /*$scope.freshData = (!$sessionStorage.hasOwnProperty('InfraList') || 
                    typeof $sessionStorage.InfraList === "undefined" || 
                    $sessionStorage.InfraList === false || 
                    $sessionStorage.InfraList.length === 0);*/
            
            var userCtr = 0;
            $scope.users = [];

            
            //for tables [start]
                    
            $scope.$emit('listenHeaderText', { headerText: $translate.instant('admin.toolbar.heading') });
            $scope.$emit('quickSetupEnded',{});

            /* **** for tables [start] **** */
            $scope.selected = [];
            $scope.query = {
                order: 'name',
                limit: 10,  //updated the limit from 5 to 10 for bug id QTAD-2042
                page: 1
            };


        $scope.isAdornmentPanelOpen = false;
        $scope.isSearchBarOpen = false;

        var create_id = authorities("users_create");
        var delete_id = authorities("users_delete");
        var update_id = authorities("users_update");
        $scope.is_create_user = userSessionMenagment.isUserAllowd(create_id);
        $scope.is_update_user = userSessionMenagment.isUserAllowd(update_id);
        $scope.is_delete_user = userSessionMenagment.isUserAllowd(delete_id);


        $scope.updateAdornmentPanel = function (event, rowData) {
            $scope.toggleAdornmentPanel();
            $scope.adornmentData = rowData;
            console.log($scope.adornmentData);
        };

        $scope.toggleAdornmentPanel = function () {
            $scope.isAdornmentPanelOpen = $scope.isAdornmentPanelOpen === false ? true : false;
        };

        $scope.toggleSearchBar = function (event) {
            $scope.isSearchBarOpen = $scope.isSearchBarOpen === false ? true : false;
            if ($scope.isSearchBarOpen)
                angular.element(event.currentTarget.firstElementChild).css('color', '#4a90e2');
            else
                angular.element(event.currentTarget.firstElementChild).css('color', '#6d6e71');
        };
        /* **** for tables [end] **** */

        $scope.showStatus = function (status, test) {
            return status === test;
        };

        //if ($scope.freshData) {
        $sessionStorage.UserList = [];

        usersService.getListOfUsers().then(function (data) {
            totalUsers = data.length;
            if (totalUsers === 0) {
                deferred.resolve();
                $scope.promiseCompleted = false;
                $scope.infrasAvailable = false;
            } else {
                $scope.usersAvailable = true;
                $scope.promiseCompleted = false;
                deferred.resolve();
                var login = "";
                for (var i = 0; i < data.length; i++) {

                    login = data[i].login;

                    UserListData[i] = data[i];

                }
                $scope.users = UserListData;
                console.log(UserListData);
            }

        }, function (error) {
            console.log(error);
            $scope.errorMessage = "ERROR occured while getting User List!!!";
            UserListData = [];
            $scope.users = [];
            deferred.resolve();
            $scope.promiseCompleted = false;
            $scope.usersAvailable = false;
        });



        $scope.deleteUser = function (userObj) {
            toastparam = {
                'heading': 'User deletion in progress',
                'subHeading': 'User deletion deletion initiated.',
                'type': 'progress',
                'timeout': 15000
            };
            showToast(toastparam);
            console.log(userObj);
            var toastparam = {};
            usersService.deleteUser(userObj.login).then(function (data) {
                if (data.status) {
                    //update rows
                    for (i = 0; i < UserListData.length; i++) {
                        if (UserListData[i].login === userObj.login) {
                            UserListData.splice(i, 1);
                        }
                    }
                    $sessionStorage.UserList = UserListData;
                    toastparam = {
                        'heading': 'User deleted successfully',
                        'subHeading': '',
                        'type': 'success',
                        'timeout': 5000
                    };
                    showToast(toastparam);

                } else {
                    //TODO to show message/something else;
                    toastparam = {
                        'heading': 'User deletion failed',
                        'subHeading': "Error: " + data.errorMessage,
                        'type': 'fail',
                        'timeout': 5000
                    };
                    showToast(toastparam);
                }
            }, function (error) {
                console.log(error);
                toastparam = {
                    'heading': 'User deletion failed',
                    'subHeading': "Error: " + error.data.errorMessage,
                    'type': 'fail'
                };
                showToast(toastparam);
            });
        };

        $scope.callpopupToAddUser = function (ev) {
            $mdDialog.show({
                controller: addUserPopupCtr,
                templateUrl: 'core/components/administration/users/addUser.tmpl.html',
                parent: angular.element(document.body),
                targetEvent: ev,
                fullscreen: true,
                openFrom: {top: 1100, height: 0},
                closeTo: {left: 1500}
            }).then(function () {

            });
        };

        $scope.clearUserListFromSession = function () {
            clearMasterSession($sessionStorage, $state);
            /*$sessionStorage.InfraList = false;
             $state.reload();*/
        };

        $scope.editMiscUserData = function () {
            if(typeof $scope.adornmentData.password !== "undefined") {
                $scope.adornmentData.password = null;
            }
            $scope.tempUserData = angular.copy($scope.adornmentData);
            $scope.userFormValid = false;
            $scope.editMiscState = true;
        };

        $scope.discardMiscChanges = function(){
            if (typeof $scope.adornmentData.password !== "undefined") {
                $scope.adornmentData.password = null;
            }
            $scope.editMiscState = false;
        };
        
        var updateUserStarted = {
            'heading': 'User update started',
            'subHeading': '&nbsp;',
            'type': 'progress',
            'timeout': 5000
        };

        var userUpdated = {
            'heading': 'User updated successfully',
            'subHeading': '&nbsp;',
            'type': 'success',
            'timeout': 5000,
            'callback': function () {
                $state.reload();
            }
        };

        var userUpdateFailed = {
            'heading': 'User Update failed',
            'subHeading': '&nbsp;',
            'type': 'fail',
            'timeout': 5000,
            'callback': function () {
                $state.reload();
            }
        };
        
        $scope.updateUserData = function () {
            if ($scope.editMiscState && $scope.tempUserData.password) {
                $scope.editMiscState = false;
                var userObject = {
                    "login": $scope.tempUserData.login,
                    "name": $scope.tempUserData.name,
                    "authType": $scope.tempUserData.authType,
                    "userDN": $scope.tempUserData.userDN,
                    "password": $scope.tempUserData.password,
                    "role": $scope.tempUserData.role
                };
                console.log(userObject);
                showToast(updateUserStarted);
                usersService.updateUser(userObject).then(function (response) {
                    showToast(userUpdated);
                }, function (error) {
                    userUpdateFailed.subHeading = error.data.message;
                    showToast(userUpdateFailed);
                });
            }
        };
        
        $scope.pwdType = 'password';

        $scope.role = {
                'types': [
                    {'name': 'SuperUser', 'value': 'SuperUser'},
                    {'name': 'SecurityAdministrator', 'value': 'SecurityAdministrator'},
                    {'name': 'SecurityAnalyst', 'value': 'SecurityAnalyst'},
                    {'name': 'VirtualInfraAnalyst', 'value': 'VirtualInfraAnalyst'}
                ]
            };
        
        $scope.togglePasswordType = function () {
            $scope.pwdType = $scope.pwdType === 'password' ? 'text' : 'password';
        };

        $scope.userFormValid = false;
        
        $scope.validateUserForm =  function () {
            var userData = $scope.tempUserData;
            if (
                    userData.login &&
                    userData.name &&
                    userData.authType &&
                    userData.userDN &&
                    userData.password &&
                    userData.role) {
                $scope.userFormValid = true;
            } else {
                $scope.userFormValid = false;
            }
        };

        function addUserPopupCtr($rootScope, $scope, $sessionStorage){
            
            //FUNCTIONALITY TO ADD INFRA
            $scope.active_help_id = "admin_users_manageUsers_help";
            $scope.helpButtonClicked = function(id){
                $scope.active_help_id = id;
                console.log("  helpButtonClicked ");
                $scope.bordcastEventHelpButtonClicked($scope.active_help_id);
            }; 
             $scope.bordcastEventHelpButtonClicked = function(helpId){
                $scope.$broadcast('onHelpButtonClicked', {
                 helpIDString: helpId 
                });
            };     

            $scope.pwdType = 'password';
            $scope.togglePasswordType = function () {
                $scope.pwdType = $scope.pwdType === 'password' ? 'text' : 'password';
            };

            $scope.auth_type = $translate.instant('wizarduser.label.auth_type');
            $scope.user_name = $translate.instant("wizarduser.placeholder.name");
            $scope.user_fqdn = $translate.instant("wizarduser.placeholder.fqdn");
            $scope.user_login = $translate.instant("wizarduser.placeholder.login");
            $scope.user_password = $translate.instant("wizarduser.placeholder.password");
            $scope.user_role = $translate.instant("wizarduser.placeholder.role");
            $scope.create_user = $translate.instant("wizarduser.button.create_user");


            $scope.authentication = {
                'types': [
                    {'name': 'Local', 'value': 'LOCAL'},
                    {'name': 'LDAP', 'value': 'LDAP'}
                ]
            };

            $scope.role = {
                'types': [
                    {'name': 'SuperUser', 'value': 'SuperUser'},
                    {'name': 'SecurityAdministrator', 'value': 'SecurityAdministrator'},
                    {'name': 'SecurityAnalyst', 'value': 'SecurityAnalyst'},
                    {'name': 'VirtualInfraAnalyst', 'value': 'VirtualInfraAnalyst'}
                ]
            };
            $scope.user = {};

            $scope.user.authType = 'SuperUser';

            $scope.hide = function () {
                $mdDialog.hide();
            };
            $scope.cancel = function () {
                $mdDialog.cancel();
            };

            
            $scope.hideRightPanel = false;

            $scope.toggleHelpPanel = function () {
                $scope.hideRightPanel = !($scope.hideRightPanel);
            };


            $scope.addUser = function () {
                console.log($scope.user);
                var userObject = $scope.user;
                var startUserCreationMessage = {
                    'heading': 'Create User',
                    'subHeading': 'This should take only a few minutes max.',
                    'type': 'progress',
                    'timeout': 5000
                };
                var successfulUserCreationMessage = {
                    'heading': 'users Created',
                    'subHeading': 'user created successfully.',
                    'type': 'success',
                    'timeout': 5000
                };
                showToast(startUserCreationMessage);
                usersService.createUser(userObject).then(function (data) {
                    if (data) {
                        var newData = userObject;

                        console.log(UserListData);
                        showToast(successfulUserCreationMessage);

                    
                        UserListData.unshift(newData);
                        console.log(UserListData);
                        $sessionStorage.UserList = UserListData;
                        $scope.users=UserListData;
                        $rootScope.$broadcast('newUsercreated', {});
                    }
                }, function (error) {
                    var failureUserCreation = {
                        'heading': 'User creation failed',
                        'subHeading': "Error: " + error.data.message,
                        'type': 'fail',
                        'timeout': 10000
                    };
                    showToast(failureUserCreation);
                });
                $mdDialog.hide();
            };


            $scope.isFormValid = function () {
                    //validate form data
                    console.log($scope.user);
                    if ($scope.user.login && $scope.user.name && $scope.user.authType &&  $scope.user.role && $scope.user.password) {
                        return true;
                    } else {
                        return false;
                    }

            
            };
        }
        $scope.$on('newUsercreated', function (event) {
            console.log($scope.query);
            $scope.query.page = 1;
        });
        $scope.$on('$viewContentLoaded', function (event) {
            console.log(event);
            fixContainerHeight(1);
        });
    }

    angular.module('shieldxApp').controller('usersCtr', usersCtr);
})();

(function () {
    function resigningkeysCtr(
        $scope,
        $state,
        $translate,
        $sessionStorage,
        $q,
        $http,
        sslDecryptionService,
        infrastructureConnectorService,
        deploymentSpecificationService,
        $mdDialog) {

            "ngInject";

            clearAllSession($sessionStorage);
            var resigningCertData = [];
            var deferred = $q.defer();
            $scope.promise = deferred.promise; 
            $scope.promiseCompleted = true;
            var promiseCtr = 0;
            var totalClouds = 0;
            $scope.resigningKeysAvailable = false;
            $scope.editMiscState = false;

            $scope.isAdornmentPanelOpen = false;
            $scope.isSearchBarOpen = false;

            var resignKeysCtr = 0;
            $scope.resigningKeys = [];

            $scope.$emit('listenHeaderText', {headerText: $translate.instant('admin.ssldecryption.heading')});

            /* **** for tables [start] **** */
            $scope.selected = [];
            $scope.query = {
                order: 'name',
                limit: 5,
                page: 1
            };

            $scope.isAdornmentPanelOpen = false;
            $scope.isSearchBarOpen = false;

            $scope.updateAdornmentPanel = function (event, rowData) {
                $scope.toggleAdornmentPanel();
                $scope.adornmentData = rowData;
                console.log($scope.adornmentData);
            };

            $scope.toggleAdornmentPanel = function () {
                $scope.isAdornmentPanelOpen = $scope.isAdornmentPanelOpen === false ? true : false;
            };

            $scope.toggleSearchBar = function (event) {
                $scope.isSearchBarOpen = $scope.isSearchBarOpen === false ? true : false;
                if ($scope.isSearchBarOpen)
                    angular.element(event.currentTarget.firstElementChild).css('color', '#4a90e2');
                else
                    angular.element(event.currentTarget.firstElementChild).css('color', '#6d6e71');
            };            
            /* **** for tables [end] **** */


            $scope.connectionType = {
                'connections': [
                    {'name': 'Trusted', 'value': '1'},
                    {'name': 'Untrusted', 'value': '2'}                
                ]
            };
            
            $scope.resingingkeys = {};

            $scope.resingingkeys.tenantId = 1;   // <<<<<<<<<<<<<<<<< Added for Testing. Should be removed

            $scope.resingingkeys.connectionType='Trusted';

            $scope.tenants = [];


            $scope.getTenantDataForCloud = function (cloudObj) {
                deploymentSpecificationService.getTenants(cloudObj.id).then(function (tenants) {
                    _.each(tenants, function (tenant) {
                        tenant.cloudName = cloudObj.name;
                        $scope.tenants.push(tenant);
                    });
                });
            };

            $scope.getTenants = function () {
                infrastructureConnectorService.getListOfInfrastructures().then(function (clouds) {
                    _.each(clouds, function (cloud) {
                        $scope.getTenantDataForCloud(cloud);
                    });
                });
            };

            $scope.fileChanged = function (elem) {
                $scope.files = elem.files;
                $scope.$appply();
            };


            $scope.importResigningKeys = function () {
                console.log("import resigning keys");
                var file = $scope.resigningCertFile;
                var tenantId = $scope.resingingkeys.tenantId;
                var importStarted = {
                    'heading': 'Import Re-Signing Keys Initiating',
                    'subHeading': 'Import of Re-Sigining Keys for Tenant Initiating',
                    'type': 'progress',
                    'timeout': 5000
                };

                var importCompleted = {
                    'heading': 'Import Re-Signing Keys Completed',
                    'subHeading': 'Import of Re-Signing Keys for Tenant Completed',
                    'type': 'success',
                    'timeout': 5000,
                    'callback': function () {
                        $state.reload();
                    }
                };

                showToast(importStarted);                
                console.log("resigningKeysCtr : import resigning key "+file);

                sslDecryptionService.importResigningKeys(tenantId, file).then(function (data) {
                    console.log("Import Completed.");
                    var status = data;
                    console.log(" Import status ---->>> "+status);
                    showToast(importCompleted);
                    sslDecryptionService.useImportedCert(tenantId, true).then(function (data) {
                        
                        console.log("Use imported cert flag has been sent to keyserver.");   

                    }, function error(err) {
                        console.log("Failed to set use imported cert flag to key server.");
                        console.log(err.data.message);    
                    });

                    $rootScope.$broadcast('newCertImported', {});
                }, function error(err) {
                    console.log(err.data.message);
                    var importFailed = {
                        'heading': 'Import of Re-Signing Keys Failed',
                        //'subHeading': '&nbsp;',
                        'subHeading': "Error: " + err.data.message,
                        'type': 'fail',
                        'timeout': 10000,
                        'callback': function () {
                            $state.reload();
                        }
                    };                    
                    //importFailed.subHeading = "Error: " + err.data.message;
                    showToast(importFailed);
                });
                $mdDialog.hide();
            };


            $scope.restoreDefaultKey = function () {

                var tenantId = $scope.resingingkeys.tenantId;

                var restoreCompleted = {
                    'heading': 'Restore default certificate',
                    'subHeading': 'Restore default certificate completed',
                    'type': 'success',
                    'timeout': 5000,
                    'callback': function () {
                        $state.reload();
                    }
                };

                console.log("Restore default re-signing keys.");

                sslDecryptionService.useImportedCert(tenantId, false).then(function (data) {

                    console.log("Restored default certificate.");   
                    showToast(restoreCompleted);

                }, function error(err) {
                        console.log("Failed to restore default re-signing keys.");
                        console.log(err.data.message);    
                });
            };


            $scope.generateDefaultResigningKey = function () {
                console.log("Generate default resigning key");
               
                var startGenDefaultCert = {
                    'heading': 'Generation of default Re-Signing Keys initiating',
                    'subHeading': 'Generation of default Re-Sigining keys for Tenant initiating',
                    'type': 'progress',
                    'timeout': 5000
                };

                var genDefaultCertCompleted = {
                    'heading': 'Generation of default Re-Signing Keys completed',
                    'subHeading': 'Generation of default Re-Signing Keys for Tenant completed',
                    'type': 'success',
                    'timeout': 5000,
                    'callback': function () {
                        $state.reload();
                    }
                };

                sslDecryptionService.generateDefaultResigningKey(1).then(function (data) {
                    console.log("Default certificate generated.");  
                    showToast(genDefaultCertCompleted);
                    $mdDialog.hide();
                }, function error(err) {
                    console.log(err.data.message);
                    var genDefaultCertFailed = {
                        'heading': 'Generation of default Re-Signing Keys failed',
                        'subHeading': '&nbsp;',
                        'type': 'fail',
                        'timeout': 10000,
                        'callback': function () {
                            $state.reload();
                        }
                    }; 
                    genDefaultCertFailed.subHeading = "Error: " + err.data.message;

                    showToast(genDefaultCertFailed);
                    $mdDialog.hide();
                });                
            };            
            

            $scope.export = function (tenantId) {
                $http({
                    method: 'GET',
                    url: 'shieldxapi/tls/exportkey',
                    //url: 'api/values/download',
                    //params: { name: name },
                    responseType: 'arraybuffer'
                }).success(function (data, status, headers) {
                    headers = headers();
             
                    //var filename = headers['x-filename'];
                    var contentType = headers['content-type'];
                    console.log("Content Type = "+contentType);
             
                    var linkElement = document.createElement('a');
                    try {
                        var blob = new Blob([data], { type: 'application/octet-stream' });
                        var url = window.URL.createObjectURL(blob);
             
                        linkElement.setAttribute('href', url);
                        linkElement.setAttribute("download", 'ShieldX-Cert.pem');
             
                        var clickEvent = new MouseEvent("click", {
                            "view": window,
                            "bubbles": true,
                            "cancelable": false
                        });
                        linkElement.dispatchEvent(clickEvent);
                    } catch (ex) {
                        console.log(ex);
                    }
                }).error(function (data) {
                    console.log("Failed to export key");
                    console.log(data);
                });
            };


            $scope.exportPublicKey = function () {
                console.log("Export public key");
                              
                var exportKeyCompleted = {
                    'heading': 'Export public key completed',
                    'subHeading': 'Public key has been exported successfully.',
                    'type': 'success',
                    'timeout': 5000
                };

                sslDecryptionService.exportPublicKey(1).then(function (data) {
                    
                    console.log("public key exported.");
                    console.log(data);
                    showToast(exportKeyCompleted);

                    var linkElement = document.createElement('a');
                    try {
                        var blob = new Blob([data], { type: 'application/octet-stream' });
                        var url = window.URL.createObjectURL(blob);
             
                        linkElement.setAttribute('href', url);
                        linkElement.setAttribute("download", 'ShieldX-cert.pem');
             
                        var clickEvent = new MouseEvent("click", {
                            "view": window,
                            "bubbles": true,
                            "cancelable": false
                        });
                        linkElement.dispatchEvent(clickEvent);
                    } catch (ex) {
                        console.log(" Failed to export public key "+ex.getMessage());
                        console.log(ex);
                    }

                }, function error(err) {
                    console.log(err);
                    var exportKeyFailed = {
                        'heading': 'Export public key request failed.',
                        'subHeading': '&nbsp;',
                        'type': 'fail',
                        'timeout': 10000,
                    }; 
                    exportKeyFailed.subHeading = "Error: " + err.data.message;

                    showToast(exportKeyFailed);
                });                
            };            


            //Get resigning keys
            $sessionStorage.certificatesList = [];            
            sslDecryptionService.getResigningKeys($scope.resingingkeys.tenantId).then(function (data) {
                console.log("Get resigning keys for given tenant id "+data);
                totalCerts = data.length;
                console.log("Total certs = "+totalCerts);
                if (totalCerts === 0) {

                    deferred.resolve();
                    $scope.promiseCompleted = false;
                    $scope.resigningKeysAvailable = false;

                } else {
                    console.log("Resigning Cert available = "+data);
                    $scope.resigningKeysAvailable = true;
                    
                    for (var i = 0; i < data.length; i++) {
                        console.log(" data -> "+data[i]);
                        resigningCertData[i] = {};
                        resigningCertData[i] = data[i];
                        $sessionStorage.certificatesList.push(resigningCertData[i]);
                    }
                    
                    deferred.resolve();                    
                    $scope.promiseCompleted = false;                                        
                    $scope.resigningKeys = resigningCertData;

                    console.log(resigningCertData);
                }

            }, function (error) {
                console.log(error);
                $scope.errorMessage = "ERROR occured while getting backup config list!!!";
                backupConfigData = [];
                $scope.resigningKeys = [];
                deferred.resolve();
                $scope.promiseCompleted = false;
                $scope.resigningKeysAvailable = false;
            });

            $scope.getTenants();

            fixContainerHeight(0);

            //Configure Resigning Keys 
            $scope.import = function(ev){
                console.log("Launch resigning keys import dialog.");                             
                $mdDialog.show({
                    controller: resigningkeysCtr,
                    skipHide: true,
                    templateUrl: 'core/components/administration/sslkeys/importresigningkey.html',
                    parent: angular.element(document.body),
                    targetEvent: ev,
                    fullscreen: true,
                    openFrom: {top: 1100, height: 0},
                    closeTo: {left: 1500}
                    //locals: {'cloudData': cloudData}
                }).then(function () {

                });
            };

            $scope.hide = function () {
                $mdDialog.hide();
            };

            $scope.cancel = function () {
                $mdDialog.cancel();
            };

            $scope.cancelDialog = function() {
                $mdDialog.cancel();
            };
              
            $scope.callCacheBurst = function () {
                console.log('Bursting cache data and reloading from server');
                //$sessionStorage.viewData = false;
                clearMasterSession($sessionStorage, $state);
                
            };

            $scope.fileInputText = "No File Chosen";

            $scope.$on('newCertImported', function (event) {
                console.log($scope.query);
                $scope.query.page = 1;
            });

            $scope.fileNameChanged =  function(element){
                $scope.fileInputText = element.files[0].name;
            };
        }
    angular.module('shieldxApp').controller('resigningkeysCtr', resigningkeysCtr);
})();

(function() {
    function setupTlsCtr(
        $scope
        
    ) {

        $scope.$emit('listenHeaderText', { headerText: "TLS Inspection" });    

    }

    angular.module('shieldxApp').controller('setupTlsCtr', setupTlsCtr);
})();

(function () {
    function sslkeysCtr(
            $scope,
            $state,
            $translate,
            $sessionStorage,
            $q,
            sslDecryptionService,
            infrastructureConnectorService,
            deploymentSpecificationService,
            $mdDialog
            ) {



        clearAllSession($sessionStorage);
        var inboundCertData = [];
        var deferred = $q.defer();
        $scope.promise = deferred.promise; 
        $scope.promiseCompleted = true;
        var promiseCtr = 0;
        var totalClouds = 0;
        $scope.inboundKeysAvailable = false;
        $scope.editMiscState = false;

        $scope.isAdornmentPanelOpen = false;
        $scope.isSearchBarOpen = false;

        var resignKeysCtr = 0;
        $scope.inboundKeys = [];
        $scope.tenantId = 1;
        
        //$scope.$emit('listenHeaderText', {headerText: $translate.instant('admin.toolbar.heading')});
        $scope.$emit('listenHeaderText', {headerText: $translate.instant('admin.ssldecryption.heading')});

        /* **** for tables [start] **** */
        $scope.selected = [];
        $scope.query = {
            order: 'name',
            limit: 10,
            page: 1
        };

        $scope.isAdornmentPanelOpen = false;
        $scope.isSearchBarOpen = false;

        $scope.updateAdornmentPanel = function (event, rowData) {
            $scope.toggleAdornmentPanel();
            $scope.adornmentData = rowData;
            console.log($scope.adornmentData);
        };

        $scope.toggleAdornmentPanel = function () {
            $scope.isAdornmentPanelOpen = $scope.isAdornmentPanelOpen === false ? true : false;
        };

        $scope.toggleSearchBar = function (event) {
            $scope.isSearchBarOpen = $scope.isSearchBarOpen === false ? true : false;
            if ($scope.isSearchBarOpen)
                angular.element(event.currentTarget.firstElementChild).css('color', '#4a90e2');
            else
                angular.element(event.currentTarget.firstElementChild).css('color', '#6d6e71');
        };            
        /* **** for tables [end] **** */

        var tenantUpdateStarted = {
            'heading': 'Upload SSL Key Initiating',
            'subHeading': 'Upload SSL Key for Tenant Initiating',
            'type': 'progress',
            'timeout': $scope.toastTimeout
        };
        var tenantUpdated = {
            'heading': 'Upload SSL Key Completed',
            'subHeading': 'Upload SSL Key for Tenant Completed',
            'type': 'success',
            'timeout': $scope.toastTimeout,
            'callback': function () {
                $state.reload();
            }
        };

        var tenantUpdateFailed = {
            'heading': 'Upload SSL Key Failed',
            'subHeading': '&nbsp;',
            'type': 'fail',
            'timeout': $scope.toastTimeout,
            'callback': function () {
                $state.reload();
            }
        };

        $scope.inboundkeys = {};
        $scope.tenants = [];

        $scope.getTenantDataForCloud = function (cloudObj) {
            deploymentSpecificationService.getTenants(cloudObj.id).then(function (tenants) {
                _.each(tenants, function (tenant) {
                    tenant.cloudName = cloudObj.name;
                    $scope.tenants.push(tenant);
                });
            });
        };

        $scope.getTenants = function () {
            infrastructureConnectorService.getListOfInfrastructures().then(function (clouds) {
                _.each(clouds, function (cloud) {
                    $scope.getTenantDataForCloud(cloud);
                });
            });
        };

        $scope.fileChanged = function (elem) {
            $scope.files = elem.files;
            $scope.$appply();
        };

        $scope.uploadSSLKeys = function () {
            var file = $scope.sslKeyFile;
            var tenantId = $scope.tenantId;
            tenantId = 1;
            showToast(tenantUpdateStarted);

            infrastructureConnectorService.uploadSslKeys(tenantId, file).then(function (data) {
                    showToast(tenantUpdated);
            }, function error(err) {
                tenantUpdateFailed.subHeading = "Error: " + err.data.message;
                showToast(tenantUpdateFailed);
            });
            $mdDialog.hide();

        };


        //Get resigning keys
        $sessionStorage.certificatesList = [];            
        sslDecryptionService.getInboundKeys($scope.tenantId).then(function (data) {
            console.log("Get inbound keys for given tenant id "+data);
            totalCerts = data.length;
            console.log("Total certs = "+totalCerts);
            if (totalCerts === 0) {

                deferred.resolve();
                $scope.promiseCompleted = false;
                $scope.inboundKeysAvailable = false;

            } else {
                console.log("Inbound Cert available = "+data);
                $scope.inboundKeysAvailable = true;
                
                for (var i = 0; i < data.length; i++) {
                    console.log(" data -> "+data[i]);
                    inboundCertData[i] = {};
                    inboundCertData[i] = data[i];
                }
                
                deferred.resolve();                    
                $scope.promiseCompleted = false;                                        
                $scope.inboundKeys = inboundCertData;

                console.log(inboundCertData);
            }

        }, function (error) {
            console.log(error);
            $scope.errorMessage = "ERROR occured while getting inbound web server certificates";
            inboundCertData = [];
            $scope.inboundKeys = [];
            deferred.resolve();
            $scope.promiseCompleted = false;
            $scope.inboundKeysAvailable = false;
        });

        $scope.getTenants();

        fixContainerHeight(0);

        $scope.fileInputText = "No File Chosen";

        //Configure Resigning Keys 
        $scope.import = function(ev){
            console.log("Launch inbound keys import dialog.");                             
            $mdDialog.show({
                controller: sslkeysCtr,
                skipHide: true,
                templateUrl: 'core/components/administration/sslkeys/importinboundkeys.html',
                parent: angular.element(document.body),
                targetEvent: ev,
                fullscreen: true,
                openFrom: {top: 1100, height: 0},
                closeTo: {left: 1500}
                //locals: {'cloudData': cloudData}
            }).then(function () {

            });
        };


        $scope.pwdType = 'password';
        $scope.togglePasswordType = function () {
            $scope.pwdType = $scope.pwdType === 'password' ? 'text' : 'password';
        };

        $scope.fileNameChanged =  function(element){
            $scope.fileInputText = element.files[0].name;
        };

        $scope.hide = function () {
            $mdDialog.hide();
        };

        $scope.cancel = function () {
            $mdDialog.cancel();
        };

        $scope.cancelDialog = function() {
            $mdDialog.cancel();
        };        
    }

    angular.module('shieldxApp').controller('sslkeysCtr', sslkeysCtr);
})();

(function () {
    function tlsDecryptionCtr(
        $scope,
        $state,
        $translate,
        backupRestoreService,
        $q
    ) {

        //$scope.$emit('listenHeaderText', { headerText: "SSL Decryption" });
        
        $scope.$emit('listenHeaderText', {headerText: $translate.instant('admin.ssldecryption.heading')});

        var url = $state.current.url;
        console.log("tlsDecryptionCtr : URL -->> "+url);
        if(url.indexOf("inboundkeys") > 0 ) {
            $state.go('home.setuptls.tlsdecryption.inboundkeys');
        } else if(url.indexOf("outboundkeys") > 0 ) {
            $state.go('home.setuptls.tlsdecryption.outboundkeys');    
        } else if(url.indexOf("rootcas") > 0 ) {
            $state.go('home.setuptls.tlsdecryption.rootcas');    
        } else {
            $state.go('home.setuptls.tlsdecryption.inboundkeys');    
        }
        $scope.$on('$stateChangeSuccess', function(event, toState, toParams, fromState, fromParams) {
            if (toState.data) {
                $scope.currentTab = toState.data.selectedTab;
            }

        });
        
        $scope.$on('$viewContentLoaded', function (event) {
            fixContainerHeight(1);
        });

    }
    angular.module('shieldxApp').controller('tlsDecryptionCtr', tlsDecryptionCtr);
})();
/*
 ShieldX Networks Inc. CONFIDENTIAL
 ----------------------------------
 *
 Copyright (c) 2016 ShieldX Networks Inc.
 All Rights Reserved.
 *
 NOTICE: All information contained herein is, and remains
 the property of ShieldX Networks Incorporated and its suppliers,
 if any. The intellectual and technical concepts contained
 herein are proprietary to ShieldX Networks Incorporated
 and its suppliers and may be covered by U.S. and Foreign Patents,
 patents in process, and are protected by trade secret or copyright law.
 Dissemination of this information or reproduction of this material
 is strictly forbidden unless prior written permission is obtained
 from ShieldX Networks Incorporated.
 */

(function () {
    function virtualChasisAddResourceCtr($scope) {
        
    }


    angular.module('shieldxApp').controller('virtualChasisAddResourceCtr', virtualChasisAddResourceCtr);
    


    function virtualChasisAddCtr($scope) {


    }


    angular.module('shieldxApp').controller('virtualChasisAddCtr', virtualChasisAddCtr);
})();
/*
 ShieldX Networks Inc. CONFIDENTIAL
 ----------------------------------
 *
 Copyright (c) 2016 ShieldX Networks Inc.
 All Rights Reserved.
 *
 NOTICE: All information contained herein is, and remains
 the property of ShieldX Networks Incorporated and its suppliers,
 if any. The intellectual and technical concepts contained
 herein are proprietary to ShieldX Networks Incorporated
 and its suppliers and may be covered by U.S. and Foreign Patents,
 patents in process, and are protected by trade secret or copyright law.
 Dissemination of this information or reproduction of this material
 is strictly forbidden unless prior written permission is obtained
 from ShieldX Networks Incorporated.
 */

(function () {
    function listVirtualChassisCtr($scope,
            $state,
            virtualChassisService,
            infrastructureConnectorService,
            deploymentSpecificationService,
            ipPoolServices,
            resourceGroupService,
            $translate,
            $mdDialog,
            $q,
            $sessionStorage,
            userSessionMenagment) {
        "ngInject";
//        var InfraListData = [];
//        var virtualChassisCtr = 0;
//        var totalvirtualChassis = 0;
        clearAllSession($sessionStorage);
        $scope.clouds = [];
        var deferred = $q.defer();
        $scope.promise = deferred.promise;

//        $scope.virtualChassisList = [];
        $scope.vChassisDataFetched = false;
        $scope.editMiscState = false;
        $scope.infraAvailable = false;

        console.log("listVirtualChassisCtr >> ");

        var vchassisDeploymentStarted = {
            'heading': 'Data Plane deployment started',
            'subHeading': 'Data Plane deployment has been started',
            'type': 'progress',
            'timeout': $scope.toastTimeout
        };
        var vchassisDeployed = {
            'heading': 'Data Plane deployed',
            'subHeading': 'Data Plane deployed successfully',
            'type': 'success',
            'timeout': $scope.toastTimeout
        };

        var vchassisReDeploymentStarted = {
            'heading': 'Data Plane Redeployment started',
            'subHeading': '&nbsp;',
            'type': 'progress',
            'timeout': $scope.toastTimeout
        };
        var vchassisReDeployed = {
            'heading': 'Data Plane Redeployed',
            'subHeading': 'Data Plane Redeployed successfully',
            'type': 'success',
            'timeout': $scope.toastTimeout
        };

        var vChassisUpdateStarted = {
            'heading': 'Data Plane Update Started',
            'type': 'progress',
            'timeout': $scope.toastTimeout
        };

        var vChassisUpdateSuccess = {
            'heading': 'Data Plane Updated successfully',
            'subHeading': 'Data Plane Updated successfully',
            'type': 'success',
            'timeout': $scope.toastTimeout,
            'callback': function () {
                $state.reload();
            }
        };

        var vChassisUpdateFailed = {
            'heading': 'Data Plane Update failed',
            'type': 'fail',
            'timeout': $scope.toastTimeout
        };

        //for tables [start]
        var create_id = authorities("virtualChassis_create");
        var delete_id = authorities("virtualChassis_delete");
        var update_id = authorities("virtualChassis_update");
        var check_id = authorities("virtualChassis_check");
        var deploy_id = authorities("virtualChassis_deploy");
        $scope.is_create_vchassis = userSessionMenagment.isUserAllowd(create_id);
        $scope.is_update_vchassis = userSessionMenagment.isUserAllowd(update_id);
        $scope.is_delete_vchassis = userSessionMenagment.isUserAllowd(delete_id);
        $scope.is_check_vchassis = userSessionMenagment.isUserAllowd(check_id);
        $scope.is_deploy_vchassis = userSessionMenagment.isUserAllowd(deploy_id);

        
        $scope.$emit('listenHeaderText', {headerText: $translate.instant('admin.toolbar.heading')});
        $scope.$emit('quickSetupEnded', {});

        /* **** for tables [start] **** */
        $scope.selected = [];
        $scope.query = {
            order: 'name',
            limit: 10,
            page: 1
        };
        $scope.isAdornmentPanelOpen = false;
        $scope.isSearchBarOpen = false;

        $scope.clearVChassisListFromSession = function () {
            clearMasterSession($sessionStorage, $state);
        };

        $scope.updateAdornmentPanel = function (event, rowData) {
            $scope.toggleAdornmentPanel();
            $scope.adornmentData = rowData;
            $scope.editMiscState = false;
            $scope.editNetworkData = false;
            $scope.deploymentSpecs = _.find($scope.vChassisObj, {"id": rowData.id}).deploySpec;
//            $scope.adornmentData.deploymentSpecId = $scope.deploymentSpecs.id;

            $scope.infraAccordionData = [{
                    id: 'infraName',
                    header: rowData.infra.name,
                    content: '',
                    isExpanded: false,
                    subData: [{
                            id: 'infraType',
                            header: rowData.infra.type,
                            content: '',
                            headerAddOn: 'Type'
                        }, {
                            id: 'infraAddr',
                            header: rowData.infra.ip,
                            content: '',
                            headerAddOn: 'Address'
                        }, {
                            id: 'infralogin',
                            header: rowData.infra.username,
                            content: '',
                            headerAddOn: 'Login'
                        }]
                }];
        };

        $scope.toggleAdornmentPanel = function () {
            $scope.isAdornmentPanelOpen = $scope.isAdornmentPanelOpen === false ? true : false;
        };
        $scope.toggleSearchBar = function (event) {
            $scope.isSearchBarOpen = $scope.isSearchBarOpen === false ? true : false;
            if ($scope.isSearchBarOpen)
                angular.element(event.currentTarget.firstElementChild).css('color', '#4a90e2');
            else
                angular.element(event.currentTarget.firstElementChild).css('color', '#6d6e71');
        };

        /* **** for tables [end] **** */

        $scope.showStatus = function (status, test) {
            return status === test;
        };
        //static data for table

        $scope.expandCallback = function (index, id) {
            var getDownChevron = document.querySelector('#' + id + ' md-icon.arrow-down');
            angular.element(getDownChevron).css("display", "none");
            var getUpChevron = document.querySelector('#' + id + ' md-icon.arrow-up');
            angular.element(getUpChevron).css("display", "block");
        };

        $scope.collapseCallback = function (index, id) {
            var getUpChevron = document.querySelector('#' + id + ' md-icon.arrow-up');
            angular.element(getUpChevron).css("display", "none");
            var getDownChevron = document.querySelector('#' + id + ' md-icon.arrow-down');
            angular.element(getDownChevron).css("display", "block");
        };



        $scope.infraObj = [];

       
        infrastructureConnectorService.getListOfInfrastructures().then(function (data) {
            $scope.infraAvailable = (data.length > 0) ? true : false;

            virtualChassisService.getListOfVirtualChassis().then(function (virtualChassisListData) {
                $scope.infraObj = angular.copy(data);
                  $scope.infraObj.chassis = virtualChassisListData;
                mapInfraVChassisData($scope.infraObj);
            });
        });


        mapInfraVChassisData = function (cloudObj) {
            $scope.vChassisObj = [];

            _.each(cloudObj, function (infraObj) {

                deploymentSpecificationService.getDeploymentSpecList(infraObj.id).then(function (deploymentSpecList) {
                   
                    if(!infraObj.chassis) {
                        infraObj.chassis = [];
                         _.each($scope.infraObj.chassis, function (chassis) {
                            var chassisSet = false;
                            _.each(deploymentSpecList, function (deploySpec) {
                                if (!chassisSet && deploySpec.id === chassis.datapathDeploySpecId) {
                                    infraObj.chassis.push(chassis);
                                    
                                    chassisSet = true;
                                }
                            });
                        });
                    }

                    resourceGroupService.getGroupList(infraObj.id).then(function (groupData) {

                        if (typeof infraObj.chassis !== "undefined") {

                            _.each(infraObj.chassis, function (vChassis) {

                                var tempChassisObj = {};
                                tempChassisObj = vChassis;
                                tempChassisObj.name = vChassis.name;
//                                tempChassisObj.infra = angular.copy(infraObj);
                                tempChassisObj.infra = {};
                                tempChassisObj.infra.id = angular.copy(infraObj.id);
                                tempChassisObj.infra.name = angular.copy(infraObj.name);
                                tempChassisObj.infra.type = angular.copy(infraObj.type);
                                tempChassisObj.infra.ip = angular.copy(infraObj.ip);
                                tempChassisObj.infra.username = angular.copy(infraObj.username);
                                var intId = parseInt(vChassis.datapathDeploySpecId);
                                tempChassisObj.deploySpec = _.find(deploymentSpecList, {"id": intId});
                                tempChassisObj.deploySpecList = deploymentSpecList;
                                tempChassisObj.resourceGroup = [];

                                _.each(vChassis.subscriptionList, function (subscription) {

                                    tempChassisObj.resourceGroup.push(
                                            _.find(groupData, {"id": subscription.resourceGroupId})
                                            );
                                });
                                $scope.vChassisObj.push(tempChassisObj);

                            });
                            console.log(" mapInfraVChassisData final data  ");
                            console.dir($scope.vChassisObj);
                            deferred.resolve();
                            $scope.vChassisDataFetched = true;
                        }
                    });
                });
            });
        };

        //var canDeleteVirtualChassis = false;
        $scope.deployVirtualChassis = function (vChassisObj) {
            var vChassisId = vChassisObj.id;
            showToast(vchassisDeploymentStarted);
            virtualChassisService.deployVirtualChassis(vChassisId).then(function (data) {
                if (data.status === false) {
                    console.log(data.errorMessage);
                } else {
                    showToast(vchassisDeployed);
                }
            }, function (error) {
                console.log(error);
                //showError
            });
        };

        $scope.reDeployVirtualChassis = function (vChassisObj) {
            var vChassisId = vChassisObj.id;
            showToast(vchassisReDeploymentStarted);
            virtualChassisService.reDeployVirtualChassis(vChassisId).then(function (data) {
                if (data.status === false) {
                    console.log(data.errorMessage);
                } else {
                    showToast(vchassisReDeployed);
                }
            }, function (error) {
                console.log(error);
                //showError
            });
        };
        
        deleteResourceGroup = function (rGroupId, infraId) {
            virtualChassisService.deleteResourceGroup(rGroupId, infraId).then(function (data) {
                if (data.status === false) {
                    console.log(data.errorMessage);
                }
            }, function (error) {
                console.log(error);
                //canDeleteVirtualChassis = false;
            });
        };

        $scope.deleteVirtualChassis = function (vChassisObj) {
            //canDeleteVirtualChassis = true;
            toastparam = {
                'heading': 'Data Plane deletion started',
                'subHeading': 'Data Plane deletion initiated',
                'type': 'progress',
                'timeout': $scope.toastTimeout
            };
            showToast(toastparam);
            var vChassisId = vChassisObj.id;
            var subscriptionList = vChassisObj.subscriptionList;
            var toastparam = {};
            virtualChassisService.deleteVirtualChassis(vChassisId, vChassisObj.infra.id).then(function (data) {
                if (data.status === true) {

                    for (var i = 0; i < $scope.vChassisObj.length; i++) {
                        if ($scope.vChassisObj[i].id === vChassisId) {
                            $scope.vChassisObj.splice(i, 1);
                        }
                    }
                    toastparam = {
                        'heading': 'Data Plane deleted successfully',
                        'subHeading': '',
                        'type': 'success',
                        'timeout': $scope.toastTimeout
                    };
                    showToast(toastparam);

                    for (var rgList = 0; rgList < subscriptionList.length; rgList++) {
                        var rGroupId = vChassisObj.subscriptionList[rgList].resourceGroupId;
                        deleteResourceGroup(rGroupId, vChassisObj.infra.id); //CALL TO DELETE RESOURCEGROUP
                    }
                } else {
                    console.log(data.errorMessage);
                    toastparam = {
                        'heading': 'Resourcegroup of Data Plane deletion failed',
                        'subHeading': data.errorMessage,
                        'type': 'fail',
                        'timeout': $scope.toastTimeout
                    };
                    showToast(toastparam);
                }
                $sessionStorage.vChassisList = $scope.virtualChassisList;
            }, function (error) {
                console.log(error);
                toastparam = {
                    'heading': 'Data Plane deletion failed',
                    'subHeading': "Error: " + error.data.message,
                    'type': 'fail',
                    'timeout': $scope.toastTimeout
                };
                showToast(toastparam);
                //showError
            });
        };

        $scope.callpopupToVirtualChassis = function (ev) {
            $mdDialog.show({
                controller: addVirtualChassisPopupCtr,
                templateUrl: 'core/components/administration/virtual-chassis/add-virtual-chassis.html',
                parent: angular.element(document.body),
                targetEvent: ev,
                fullscreen: true,
                openFrom: {top: 1100, height: 0},
                closeTo: {left: 1500},
                locals: {
                    toastTimeout: $scope.toastTimeout
                }
            }).then(function () {

            });
        };


        $scope.callpopupToEditResourceGroup = function (ev, adornmentData) {
            $mdDialog.show({
                controller: editChassisResourceGroupCtr,
                templateUrl: 'core/components/administration/virtual-chassis/edit-virtual-chassis.html',
                parent: angular.element(document.body),
                targetEvent: ev,
                fullscreen: true,
                openFrom: {top: 1100, height: 0},
                closeTo: {left: 1500},
                locals: {
                    toastTimeout: $scope.toastTimeout,
                    adornmentData: angular.copy($scope.adornmentData)
                }
            }).then(function () {

            });
        };


        $scope.editMiscInfraData = function () {
            $scope.editMiscState = true;
        };

        $scope.discardMiscChanges = function () {
            $scope.editMiscState = false;
        };


        $scope.editNetworks = function () {
            $scope.editNetworkData = true;
        };

        $scope.discardNetworkChanges = function () {
            $scope.editNetworkData = false;
        };

        $scope.submitMiscInfraData = function (vChassisObject) {

            $scope.editMiscState = false;

            $scope.toggleAdornmentPanel();

            showToast(vChassisUpdateStarted);

            var index = _.findIndex($scope.vChassisObj, {"id": vChassisObject.id});
            var deploymentSpecList = $scope.vChassisObj[index].deploySpecList;

            if (vChassisObject.deploySpec.id !== $scope.adornmentData.deploymentSpecId) {
                var paramObject = {
                    "cloudId": $scope.adornmentData.cloudId,
                    "datapathDeploySpecId": $scope.adornmentData.deploymentSpecId,
                    "descr": $scope.adornmentData.descr,
                    "id": $scope.adornmentData.id,
                    "name": $scope.adornmentData.name,
                    "subscriptionList": $scope.adornmentData.subscriptionList
                };

                virtualChassisService.updateVirtualChassis(paramObject, paramObject.cloudId).then(function (response) {

                    $scope.vChassisObj[index].deploymentSpec =
                            _.find(deploymentSpecList, {'id': parseInt($scope.adornmentData.deploymentSpecId)});

                    showToast(vChassisUpdateSuccess);

                }, function (error) {
                    console.log(error);
                    vChassisUpdateFailed.subHeading = "Error: " + error.data.message;
                    showToast(vChassisUpdateFailed);
                });
            }
        };

        $scope.$on('$viewContentLoaded', function (event) {
            console.log(event);
            fixContainerHeight(1);
        });

    }

    function editChassisResourceGroupCtr($scope,
            $sessionStorage,
            $state,
            $mdDialog,
            infrastructureConnectorService,
            deploymentSpecificationService,
            ipPoolServices,
            virtualChassisService,
            toastTimeout,
            adornmentData,
            coreservices) {
       //FUNCTIONALITY TO ADD DEPLOY SPEC
        $scope.virtualChassis = [];
        $scope.cloudid = (adornmentData.cloudId) ? parseInt(adornmentData.cloudId) : adornmentData.infra.id;
        $scope.virtualChassisData = adornmentData;
        $scope.virtualChassis.infrastructure = [];
        $scope.virtualChassis.deploymentSpec = "";
        $scope.virtualChassis.deploymentSpecObj = "";
        $scope.virtualChassis.networks = [];
        $scope.resourceGroupArray = [];
        $scope.deploymentSpecDataNotAvailable = true;
        $scope.items = [];
        $scope.noNetworkData = true;
        $scope.enableNextNetworkButton = false;
        $scope.showNetworks = false;
        $scope.disableDone = false;
        var selectedInfra = {};
        var allresourceGroupsForInfra = [];
        $scope.OSRuleConfig = null;
        $scope.chassisId = adornmentData.id;
        $scope.workloads = [];

//        if(adornmentData.resourceGroup){
//
//        }

        var vChassisCreated = {
            'heading': 'Data Plane created',
            'subHeading': 'Data Plane created successfully',
            'type': 'success',
            'timeout': toastTimeout
        };

        var vChassisCreationFailed = {
            'heading': 'Data Plane creation failed',
            'type': 'fail',
            'timeout': toastTimeout
        };

        var infraStructureRetrivalFailed = {
            'heading': 'infraStructure Retrival Failed',
            'type': 'fail',
            'timeout': toastTimeout
        };

        $scope.hideHelp = true;
        $scope.active_help_id = "virtual_chassis_title_help_wizard";

        $scope.helpButtonClicked = function(id){
            $scope.active_help_id = id;
            console.log("  helpButtonClicked ");
            $scope.bordcastEventHelpButtonClicked($scope.active_help_id);
        }; 
        $scope.bordcastEventHelpButtonClicked = function(helpId){
            $scope.$broadcast('onHelpButtonClicked', {
               helpIDString: helpId 
            });
         };

         console.log("editChassisResourceGroupCtr adornmentData "); 
         console.dir(adornmentData);
         console.log(JSON.stringify(adornmentData));
        $scope.vChassisObj = [];
        $scope.clouds = [];
        $scope.deploySpecList = []; 
        $scope.cloudData = {};
        $scope.cloudData.vChassis = {};
        $scope.deploymentSpecReady = false;
        $scope.enableNext = false;
        $scope.disableAdd = true;
        $scope.policySet = [];
        $scope.subscriptionList = [];

        coreservices.getSecurityPolicySet().then(function(data){
           $scope.policySet = data;
           setVchassisInitData();
        });

        $scope.formType = "Edit";
        $scope.cloudData.vChassis.id = adornmentData.id;
        $scope.cloudData.vChassis.name = adornmentData.name;

        $scope.cloudData.cloudId = (adornmentData.cloudId) ? parseInt(adornmentData.cloudId) : adornmentData.infra.id;

        $scope.cloudData.infrastructure = adornmentData.infra;
        $scope.deploySpecList = adornmentData.deploySpecList;
        $scope.subscriptionList = adornmentData.subscriptionList;

        console.log(" setVchassisInitData  >>>>>>>>>>>>>>>>>");
        console.dir($scope.subscriptionList);

        $scope.cloudData.ipPool = {};
        $scope.cloudData.ipPool.serverData = {};
        $scope.cloudData.comingFrom = 'ADMINEDIT';

        $scope.virtualChassis.deploymentSpec = parseInt(adornmentData.datapathDeploySpecId);

        $scope.selectedDeploymentSpec = adornmentData.deploySpec;
        


        setVchassisInitData = function () {

            $scope.cloudData.ipPool.serverData.backPlaneNetworkId = parseInt($scope.selectedDeploymentSpec.backPlaneNetworkId);
            $scope.cloudData.ipPool.serverData.mgmtNetworkId = parseInt($scope.selectedDeploymentSpec.mgmtNetworkId);

            var existingGroups = adornmentData.resourceGroup;
             
        
            var inlineMode =  deploymentSpecificationService.isinlineModeAvailable(
                $scope.cloudData.cloudId,
                $scope.virtualChassis.deploymentSpec);
              $scope.OSRuleConfig = new OSRuleConfig(inlineMode, true, OSRuleConfig.modes.EDIT_VC);
            console.log(" setVchassisInitData >>>>>>>>>>>> ");
            $scope.resourceGroupArray = [];
            _.each(existingGroups, function (resourceGroup, resourceGroupIndex) {
                var sr = new SORule();
                sr.mergeExistingGroup(resourceGroup);
                sr.resourceType = resourceGroup.resourceType;
                console.log("resourceGroup  ");
                console.dir(resourceGroup);
                sr.aspInfo = new ASPInfo();
                _.each(adornmentData.subscriptionList, function (subscription) {
                    console.log(" subscription >> ");
                    console.dir(subscription);
                    console.dir($scope.policySet);
                    if (resourceGroup.id === subscription.resourceGroupId) {
                        sr.aspInfo.id = subscription.spsId;
                        var policySetRef = _.find($scope.policySet, function(item){
                           return  item.id == subscription.spsId;
                        });
                        sr.aspInfo.name = policySetRef.name;
                        sr.inline = subscription.inline;
                        sr.trunkMode = subscription.trunk;
                    }
                });
                console.log("SORule  ");
                console.dir(sr);
                sr.precedence = (existingGroups.length+1) - sr.precedence;
                $scope.resourceGroupArray.push(sr);
            });



            $scope.existinggroups = existingGroups;

            $scope.cloudData.cloudId = $scope.cloudData.infrastructure.id;
            
           
//            console.log("$scope.networkChassisMapping");
//            console.log($scope.networkChassisMapping);
            /*virtualChassisService.getVchassisNetworkMappingData($scope.cloudData.cloudId).then(function (networkChassisMapping) {
                console.log("6");
                $scope.networkChassisMapping = networkChassisMapping;
                ipPoolServices.getNetworkListByCloudId($scope.cloudData.cloudId).then(function (networkList) {
                    var tempNetworkList = angular.copy(networkList);
                    _.each($scope.networkChassisMapping, function (networkChassisMappingObj) {
//                        var tempNetworkList = angular.copy(networkList);
                        _.each(networkChassisMappingObj.networks, function (mappingNetwork) {
//                            _.remove(tempNetworkList, function (network) {
                                if (networkChassisMappingObj.chassisId !== $scope.cloudData.vChassis.id) {
                                    var obj = _.find(networkList, {"id" : mappingNetwork});
                                    _.pull(tempNetworkList, obj);
                                }
//                            });
                        });
//                       finalTempList =  _.union(finalTempList, tempNetworkList);
                    });
                        $scope.cloudData.ipPool.networks = angular.copy(tempNetworkList);
                        $sessionStorage.cloudData = angular.copy($scope.cloudData);
                        $scope.networksavailable = angular.copy(tempNetworkList);
                        $scope.showNetworks = true;

                });
            });*/
                        $scope.showNetworks = true;
        };


        

        $scope.hide = function () {
            $mdDialog.hide();

            $state.go("home.virtualChassis", {}, { reload: true });
        };
        
        $scope.cancel = function () {
            $scope.$broadcast("unsavedExistInIt");
            $mdDialog.cancel();
            $state.go("home.virtualChassis");
        };

        $scope.$watch('showNetworks', function () {
            if ($scope.showNetworks) {
                $state.go("addvirtualChassis.newrc");
            }
        });

//        $scope.setDeploymentSpecData = function () {
//            $scope.deploymentSpecDataNotAvailable = true;
//            $scope.noNetworkData = true;
//            $scope.deploymentSpecs = [];
//            $scope.enableNextNetworkButton = false;
//            
//            selectedInfra = _.find($scope.cloudData, {"id" : parseInt($scope.virtualChassis.infrastructureId)});
//
//            if ( selectedInfra === {}) {
//
//                deploymentSpecificationService.getDeploymentSpecList($scope.virtualChassis.infrastructureId).then(function (deploymentSpecData) {
//                    $scope.deploymentSpecs = deploymentSpecData;
//                    $scope.deploymentSpecDataNotAvailable = false;
//                    virtualChassisService.getListOfResourceGroups($scope.virtualChassis.infrastructureId).then(function (resourceGroups) {
//                        allresourceGroupsForInfra = resourceGroups;
//                    });
//                });
//            } else {
//                $scope.deploymentSpecs = selectedInfra.deploymentSpecs;
//                $scope.deploymentSpecDataNotAvailable = (typeof selectedInfra.deploymentSpecs !== 'undefined' && selectedInfra.deploymentSpecs.length !== 0) ? false : true;
//                allresourceGroupsForInfra = selectedInfra.resourceGroups;
//            }
//        };

        $scope.showAll = function () {
            $scope.viewall = 'active-link';
            $scope.viewselected = false;
            $scope.items = $scope.networks;
        };
        $scope.showSelected = function () {
            $scope.viewall = false;
            $scope.viewselected = 'active-link';
            $scope.items = $scope.selected;
        };
        $scope.toggle = function (item, list) {
            var idx = list.indexOf(item);
            if (idx > -1) {
                list.splice(idx, 1);
            } else {
                list.push(item);
            }
            if (list.length > 0 && $scope.virtualChassis.name && $scope.virtualChassis.name !== '') {
                $scope.formInProgress = false;
            } else {
                $scope.formInProgress = true;
            }
        };
        $scope.exists = function (item, list) {
            return list.indexOf(item) > -1;
        };
        $scope.isIndeterminate = function () {
            return (typeof $scope.selected !== 'undefined' && $scope.selected.length !== 0 &&
                    $scope.selected.length !== $scope.items.length);
        };
        $scope.isChecked = function () {
            return (typeof $scope.selected !== 'undefined') ? $scope.selected.length === $scope.items.length : false;

        };
        $scope.toggleAll = function () {
            if ($scope.selected.length === $scope.items.length) { //uncheck all
                $scope.selected = [];
            } else if (typeof $scope.selected === 'undefined' || $scope.selected.length === 0 || $scope.selected.length > 0) {
                $scope.selected = $scope.items.slice(0); //check all
            }
            if ($scope.selected.length > 0 && $scope.virtualChassis.name && $scope.virtualChassis.name !== '') {
                $scope.formInProgress = false;
            } else {
                $scope.formInProgress = true;
            }
        };

        $scope.getNetworkData = function () {

            $scope.virtualChassis.deploymentSpecObj = _.find($scope.deploymentSpecs, {'id': parseInt($scope.virtualChassis.deploymentSpec)});

            $scope.noNetworkData = true;
//            getNetworks(true);
            if (selectedInfra === {}) {
                ipPoolServices.getNetworkListByCloudId($scope.virtualChassis.infrastructureId).then(function (networkData) {
                    if (networkData.length !== 0) {
                        $scope.noNetworkData = false;
                        $scope.networks = virtualChassisService.getAdditionalNetworkInfo(
                                angular.copy(networkData),
                                $scope.virtualChassis.deploymentSpecObj.backPlaneNetworkId,
                                $scope.virtualChassis.deploymentSpecObj.mgmtNetworkId
                                );

                        $scope.networks = virtualChassisService.getAdditionalNetworkResourceGroupInfo(
                                $scope.networks,
                                selectedInfra.resourceGroups,
                                true);

                        $scope.items = $scope.networks;
                        _.remove($scope.items, function (item) {
                            return item.hide === true;
                        });
//                        $scope.networks = networkData;
//                        $scope.items = networkData;

                        $scope.selected = [];
                        $scope.viewall = 'active-link';
                        $scope.viewselected = false;
                    } else {
                        $scope.noNetworkData = true;
                    }
                    $scope.networkFetched = true;
                }, function (error) {
                    console.log(error);
                });
            } else {
                var networkData = selectedInfra.networks;
                if (networkData.length !== 0) {
                    $scope.noNetworkData = false;
                    $scope.networks = virtualChassisService.getAdditionalNetworkInfo(
                            networkData,
                            $scope.virtualChassis.deploymentSpecObj.backPlaneNetworkId,
                            $scope.virtualChassis.deploymentSpecObj.mgmtNetworkId
                            );
                    $scope.networks = virtualChassisService.getAdditionalNetworkResourceGroupInfo(
                            $scope.networks,
                            selectedInfra.resourceGroups,
                            true);

                    $scope.items = $scope.networks;
//                        $scope.networkFetched = true;
                    _.remove($scope.items, function (item) {
                        return item.hide === true;
                    });

                    $scope.selected = [];
                    $scope.viewall = 'active-link';
                    $scope.viewselected = false;
                } else {
                    $scope.noNetworkData = true;
                }
            }
            if ($scope.virtualChassis.name && $scope.virtualChassis.name !== '') {
                $scope.enableNextNetworkButton = true;
            }

        };



        $scope.addVirtualChassis = function () {

            $scope.$broadcast('nextClicked', {});
            $mdDialog.hide();
        };

        getNetworks = function (omitNetworksUsed) {

            $scope.networks = virtualChassisService.getAdditionalNetworkResourceGroupInfo(
                    selectedInfra.networks,
                    selectedInfra.resourceGroups,
                    omitNetworksUsed);

            $scope.items = $scope.networks;
//            $scope.networkFetched = true;
            _.remove($scope.items, function (item) {
                return item.hide === true;
            });
        };
        $state.go("addvirtualChassis.newvc");
        $scope.toggleNetwork = function (networkval) {
            console.log(" toggleNetwork ");
            if ($scope.selected) {
                var idx = $scope.selected.indexOf(networkval);
                if (idx > -1) {
                    $scope.selected.splice(idx, 1);
                } else {
                    $scope.selected.push(networkval);
                }


                $scope.$broadcast('onNetworkSelectionChanged', {selectedNetworks: $scope.selected});
            }
        };

        $scope.enableNextButton = function () {
            $scope.disableAdd = false;
        };

        $scope.disableNextButton = function () {
            $scope.disableAdd = true;
        };

        $scope.setFocusOnElem = function (elemId) {
            setTimeout(function () {
                document.querySelector(elemId).focus();
            }, 0);
        };

        $scope.hideRightPanel = false;

        $scope.toggleHelpPanel = function () {
            $scope.hideRightPanel = !($scope.hideRightPanel);
        };

         $scope.$on(SOEvents.ruleAllCommitedEvent, function (event, args) {
            console.log("resourceGroupCreated  >>>> 1 ",$scope.resourceGroupArray);
            $scope.enableNextButton();
//            console.log("resourceGroupCreated  >>>> 2 ");
        });
        
        $scope.$on("newrulecreated", function (event, args) {
            console.log("disableNextButton new rule added");
            $scope.disableNextButton();
        });
        
        $scope.$on("existingruleupdated", function (event, args) {
            console.log("disableNextButton rule updated");
            $scope.disableNextButton();
        });

        $scope.updateVirtualChassis = function(){
            console.log(" updateVirtualChassis ");
            console.dir($scope.resourceGroupArray);
            console.dir($scope.subscriptionList);

            toastparam = {
                'heading': 'Data Plane update in progress',
                'subHeading': "Data Plane update initiated. This should take only a few minutes max.",
                'type': 'progress',
                'timeout': 5000
            };
            showToast(toastparam);

            var  exitSubscriptionList = $scope.subscriptionList;
            var vChassisParamObject = SORuleUtil.getExistingVitrialChassisJSON($scope.cloudData.vChassis.id, $scope.cloudData.vChassis.name, $scope.virtualChassis.deploymentSpec, $scope.resourceGroupArray, exitSubscriptionList);
            vChassisParamObject.cloudId =  $scope.cloudData.cloudId;
           /*var vChassisParamObject = {
                "cloudId": cloudId,
                "datapathDeploySpecId": vChassisSelectedDeploymentSpec,
                "descr": vChassisDesc,
                "id": $scope.cloudData.vChassis.id,
                "name": vChassisName,
                "subscriptionList": virtualChassisService.createSubscriptionList($scope.existingGroups)
            };
            */
            //console.log(" createChassis "+$scope.resourceGroupIndex);
            console.dir(vChassisParamObject);
            //$scope.hide();
            virtualChassisService.updateVirtualChassis(vChassisParamObject).then(function (vchassisData) {
                ///created vchassis move user to another location
                 toastparam = {
                    'heading': 'Data Plane updated successfully',
                    'subHeading': "",
                    'type': 'success',
                    'timeout': 2000,
                    'callback': function () {
                        $state.go('home.virtualChassis');
                    }
                };
                showToast(toastparam);
                $scope.hide();

            }, function (error) {
                //ERROR HANDLING WILL COME HERE
                console.log(error);
                toastparam = {
                    'heading': 'Data Plane update failed',
                    'subHeading': "Error: " + error.data.message,
                    'type': 'fail',
                    'timeout': 5000,
                    'callback': function () {
                        $state.go('home.virtualChassis');
                    }
                };
                showToast(toastparam);
                //saveCurrentState();
                $scope.hide();

            });
             
        };

    }

    function addVirtualChassisPopupCtr($scope,
            $sessionStorage,
            $state,
            $mdDialog,
            infrastructureConnectorService,
            deploymentSpecificationService,
            ipPoolServices,
            virtualChassisService,
            toastTimeout) {
        //FUNCTIONALITY TO ADD DEPLOY SPEC
        $scope.formInProgress = true;
        $scope.virtualChassis = [];
        $scope.virtualChassis.infrastructure = [];
        $scope.virtualChassis.deploymentSpec = "";
        $scope.virtualChassis.deploymentSpecObj = "";
        $scope.virtualChassis.networks = [];
        $scope.deploymentSpecDataNotAvailable = true;
        $scope.items = [];
        $scope.workloads = [];
        $scope.noNetworkData = true;
        $scope.enableNextNetworkButton = false;
        $scope.showNetworks = false;
        $scope.disableDone = false;
        var selectedInfra = {};
        var allresourceGroupsForInfra = [];
        $scope.hideHelp = false;
        $scope.active_help_id = "virtual_chassis_title_help_wizard";
        $scope.OSRuleConfig = null;

        $scope.helpButtonClicked = function(id){
            $scope.active_help_id = id;
            console.log("  helpButtonClicked ");
            $scope.bordcastEventHelpButtonClicked($scope.active_help_id);
        }; 
        $scope.bordcastEventHelpButtonClicked = function(helpId){
            $scope.$broadcast('onHelpButtonClicked', {
               helpIDString: helpId 
            });
         };  

         $scope.resourceGroupArray = [];
          console.log(" addVirtualChassisPopupCtr  >> "+$scope.cloudId);

        var vChassisCreated = {
            'heading': 'Data Plane created',
            'subHeading': 'Data Plane created successfully',
            'type': 'success',
            'timeout': toastTimeout
        };

        var vChassisCreationFailed = {
            'heading': 'Data Plane creation failed',
            'type': 'fail',
            'timeout': toastTimeout
        };

        var infraStructureRetrivalFailed = {
            'heading': 'infraStructure Retrival Failed',
            'type': 'fail',
            'timeout': toastTimeout
        };

        $scope.vChassisObj = [];
        $scope.clouds = [];

        infrastructureConnectorService.getListOfInfrastructures().then(function (data) {

            $scope.infraAvailable = (data.length > 0) ? true : false;

            $scope.clouds = data;
            $scope.infraLoaded = true;

        });

        $scope.showDeploymentSpecOptions = function () {
            $scope.deploymentSpecDataNotAvailable = true;
            $scope.noNetworkData = true;
            $scope.enableNext = false;

            $scope.selectedInfra = angular.copy(_.find($scope.clouds, {
                "id": parseInt($scope.virtualChassis.infrastructureId)
            }));

            $scope.deploymentSpecs = $scope.selectedInfra.deployspec;

            $scope.deploymentSpecDataNotAvailable = (typeof $scope.deploymentSpecs !== 'undefined' &&
                    $scope.deploymentSpecs.length !== 0) ? false : true;
        };

        $scope.cloudData = {};
        $scope.cloudData.vChassis = {};
        $scope.deploymentSpecReady = false;
        $scope.enableNext = false;
        $scope.disableAdd = true;
        
        $scope.formType = "Add";
        $scope.cloudData.vChassis.name = $scope.virtualChassis.name;


        $scope.cloudData.ipPool = {};
        $scope.cloudData.ipPool.serverData = {};


        $scope.setVchassisInitData = function () {

            
            $scope.cloudData.cloudId = parseInt($scope.virtualChassis.infrastructureId);

            $scope.cloudData.infrastructure = $scope.selectedInfra;
            
            $scope.cloudData.vChassis.selectedDeploymentSpec = parseInt($scope.virtualChassis.deploymentSpec);

            $scope.selectedDeploymentSpec = _.find($scope.deploymentSpecs,
                    {"id": parseInt($scope.virtualChassis.deploymentSpec)});

            $scope.backplanenetworkid = parseInt($scope.selectedDeploymentSpec.backPlaneNetworkId);
            $scope.managmentnetworkid = parseInt($scope.selectedDeploymentSpec.mgmtNetworkId);
            $scope.tenantid = parseInt($scope.selectedDeploymentSpec.tenantId);
            
              var inlineMode =  deploymentSpecificationService.isinlineModeAvailable(
                $scope.cloudData.cloudId,
                parseInt($scope.virtualChassis.deploymentSpec));
              $scope.OSRuleConfig = new OSRuleConfig(inlineMode, true, OSRuleConfig.modes.ADD_VC);

            $scope.deploymentSpecReady = true;
            checkEnableNext();

        };

        $scope.$watch('virtualChassis.name', function () {
            checkEnableNext();
        });

        $scope.$watch('deploymentSpecReady', function () {
            checkEnableNext();
        });

        checkEnableNext = function () {
            if ($scope.virtualChassis.name && $scope.deploymentSpecReady) {
                $scope.enableNext = true;
            } else {
                $scope.enableNext = false;
            }
        };

        $scope.addSerurityGroups = function () {
            var inlineMode =  deploymentSpecificationService.isinlineModeAvailable(
            $scope.cloudData.cloudId,
            parseInt($scope.virtualChassis.deploymentSpec));
            $scope.OSRuleConfig = new OSRuleConfig(inlineMode, true, OSRuleConfig.modes.ADD_VC);
            $sessionStorage.cloudData = $scope.cloudData;
            $sessionStorage.cloudData.comingFrom = 'ADMINADD';
            $scope.showNetworks = true;
            $scope.hideHelp = true;
            console.log($scope.selectedDeploymentSpec);
            $state.go("addvirtualChassis.newrc");
            /*ipPoolServices.getNetworkListByCloudId($scope.cloudData.cloudId).then(function (networkList) {
                $scope.networksavailable = angular.copy(networkList);
            });*/
        };

        $scope.hide = function () {
            $mdDialog.hide();

            $state.go("home.virtualChassis");
        };
        $scope.cancel = function () {
            $scope.$broadcast("unsavedExistInIt");
            $mdDialog.cancel();
            $state.go("home.virtualChassis");
        };

        $scope.onNexClicked = function () {
            $state.go("addvirtualChassis.newrc");
        };

        $scope.showAll = function () {
            $scope.viewall = 'active-link';
            $scope.viewselected = false;
            $scope.items = $scope.networks;
        };
        $scope.showSelected = function () {
            $scope.viewall = false;
            $scope.viewselected = 'active-link';
            $scope.items = $scope.selected;
        };
        $scope.toggle = function (item, list) {
            var idx = list.indexOf(item);
            if (idx > -1) {
                list.splice(idx, 1);
            } else {
                list.push(item);
            }
            if (list.length > 0 && $scope.virtualChassis.name && $scope.virtualChassis.name !== '') {
                $scope.formInProgress = false;
            } else {
                $scope.formInProgress = true;
            }
        };
        $scope.exists = function (item, list) {
            return list.indexOf(item) > -1;
        };
        $scope.isIndeterminate = function () {
            return (typeof $scope.selected !== 'undefined' && $scope.selected.length !== 0 &&
                    $scope.selected.length !== $scope.items.length);
        };
        $scope.isChecked = function () {
            return (typeof $scope.selected !== 'undefined') ? $scope.selected.length === $scope.items.length : false;

        };
        $scope.toggleAll = function () {
            if ($scope.selected.length === $scope.items.length) { //uncheck all
                $scope.selected = [];
            } else if (typeof $scope.selected === 'undefined' || $scope.selected.length === 0 || $scope.selected.length > 0) {
                $scope.selected = $scope.items.slice(0); //check all
            }
            if ($scope.selected.length > 0 && $scope.virtualChassis.name && $scope.virtualChassis.name !== '') {
                $scope.formInProgress = false;
            } else {
                $scope.formInProgress = true;
            }
        };

        $scope.getNetworkData = function () {

            $scope.virtualChassis.deploymentSpecObj = _.find($scope.deploymentSpecs, {'id': parseInt($scope.virtualChassis.deploymentSpec)});

            $scope.noNetworkData = true;
//            getNetworks(true);
            if (selectedInfra === {}) {
                ipPoolServices.getNetworkListByCloudId($scope.virtualChassis.infrastructureId).then(function (networkData) {
                    if (networkData.length !== 0) {
                        $scope.noNetworkData = false;
                        $scope.networks = virtualChassisService.getAdditionalNetworkInfo(
                                angular.copy(networkData),
                                $scope.virtualChassis.deploymentSpecObj.backPlaneNetworkId,
                                $scope.virtualChassis.deploymentSpecObj.mgmtNetworkId
                                );

                        $scope.networks = virtualChassisService.getAdditionalNetworkResourceGroupInfo(
                                $scope.networks,
                                selectedInfra.resourceGroups,
                                true);

                        $scope.items = $scope.networks;
                        $scope.networkFetched = true;
                        _.remove($scope.items, function (item) {
                            return item.hide === true;
                        });
//                        $scope.networks = networkData;
//                        $scope.items = networkData;

                        $scope.selected = [];
                        $scope.viewall = 'active-link';
                        $scope.viewselected = false;
                    } else {
                        $scope.noNetworkData = true;
                    }
                }, function (error) {
                    console.log(error);
                });
            } else {
                var networkData = selectedInfra.networks;
                if (networkData.length !== 0) {
                    $scope.noNetworkData = false;
                    $scope.networks = virtualChassisService.getAdditionalNetworkInfo(
                            networkData,
                            $scope.virtualChassis.deploymentSpecObj.backPlaneNetworkId,
                            $scope.virtualChassis.deploymentSpecObj.mgmtNetworkId
                            );
                    $scope.networks = virtualChassisService.getAdditionalNetworkResourceGroupInfo(
                            $scope.networks,
                            selectedInfra.resourceGroups,
                            true);

                    $scope.items = $scope.networks;
//                        $scope.networkFetched = true;
                    _.remove($scope.items, function (item) {
                        return item.hide === true;
                    });

                    $scope.selected = [];
                    $scope.viewall = 'active-link';
                    $scope.viewselected = false;
                } else {
                    $scope.noNetworkData = true;
                }
            }
            if ($scope.virtualChassis.name && $scope.virtualChassis.name !== '') {
                $scope.enableNextNetworkButton = true;
            }

        };


        $scope.creationInProgress = false;

        $scope.addVirtualChassis = function () {
            var toastparam = {
                'heading': ' Data Plane  Creation Started...',
                'subHeading': "Calling Server API For Data Plane Creation",
                'type': 'progress',
                'timeout': 5000
            };
            showToast(toastparam);

            $scope.creationInProgress = true;
            $scope.disableAdd = true;
            $scope.createChassis();
        };
        $scope.gotoChassisListing = function(){
             $scope.hide() ;
             //$state.reload();
        };
 

         $scope.createChassis = function () {
//                toastparam = {
//                    'heading': 'Data Plane creation in progress',
//                    'subHeading': "Data Plane creation initiated. This should take only a few minutes max.",
//                    'type': 'progress',
//                    'timeout': 5000
//                };
//                showToast(toastparam);
            var vChassisParamObject = SORuleUtil.getNewVitrialChassisJSON($scope.virtualChassis.name , $scope.virtualChassis.deploymentSpec, $scope.resourceGroupArray);
            //console.log(" createChassis "+$scope.resourceGroupIndex);
//            console.dir(vChassisParamObject);
            vChassisParamObject.cloudId =  $scope.cloudData.cloudId;
            /*$scope.hide();*/
            virtualChassisService.createVirtualChassis(vChassisParamObject).then(function (vchassisData) {
                console.log("createVirtualChassis  virtual chasis created successfully");
                ///created vchassis move user to another location
                $scope.$emit('quickSetupEnded', {});
                var toastparam = {
                    'heading': 'Data Plane created successfully',
                    'subHeading': "",
                    'type': 'success',
                    'timeout': 5000,
                    'callback': $scope.gotoChassisListing()
                };
                showToast(toastparam);

            }, function (error) {
                //ERROR HANDLING WILL COME HERE
//                console.log(error);
                var toastparam = {
                    'heading': 'Data Plane creation failed',
                    'subHeading': "Error: " + error.data.message,
                    'type': 'fail',
                    'timeout': 5000,
                    'callback': $scope.gotoChassisListing()
                };
                showToast(toastparam);
                //saveCurrentState();
            });
        };

        getNetworks = function (omitNetworksUsed) {

            $scope.networks = virtualChassisService.getAdditionalNetworkResourceGroupInfo(
                    selectedInfra.networks,
                    selectedInfra.resourceGroups,
                    omitNetworksUsed);

            $scope.items = $scope.networks;
//            $scope.networkFetched = true;
            _.remove($scope.items, function (item) {
                return item.hide === true;
            });
        };
        $state.go("addvirtualChassis.newvc");
        $scope.toggleNetwork = function (networkval) {
            console.log(" toggleNetwork ");
            if ($scope.selected) {
                var idx = $scope.selected.indexOf(networkval);
                if (idx > -1) {
                    $scope.selected.splice(idx, 1);
                } else {
                    $scope.selected.push(networkval);
                }


                $scope.$broadcast('onNetworkSelectionChanged', {selectedNetworks: $scope.selected});
            }
        };

       $scope.$on(SOEvents.ruleAllCommitedEvent, function (event, args) {
            console.log("resourceGroupCreated  >>>> 1 " , $scope.resourceGroupArray);
            $scope.enableAddButton();
            console.log("resourceGroupCreated  >>>> 2 ");
        });


        $scope.enableAddButton = function () {
            $scope.disableAdd = false;
        };

        $scope.disableNextButton = function () {
            $scope.disableAdd = true;
        };

        $scope.setFocusOnElem = function (elemId) {
            setTimeout(function () {
                document.querySelector(elemId).focus();
            }, 0);
        };

        $scope.hideRightPanel = false;

        $scope.toggleHelpPanel = function () {
            $scope.hideRightPanel = !($scope.hideRightPanel);
        };
    }

    angular.module('shieldxApp').controller('listVirtualChassisCtr', listVirtualChassisCtr);
})();
(function () {
    function vlanPoolsCtr(
        $scope, 
        $state, 
        $stateParams, 
        infrastructureConnectorService, 
        vlanService, 
        deploymentSpecificationService,
        $translate, 
        $q, 
        $mdDialog, 
        $sessionStorage,
        userSessionMenagment) {

        "ngInject";

        clearAllSession($sessionStorage);
        var deferred = $q.defer();
        $scope.promise = deferred.promise;
        $scope.promiseCompleted = true;
        var promiseCtr = 0;
        var totalClouds = 0;
        var vlanData = [];
        var viewData = [];

        var vlanId = ($stateParams && $stateParams.vlanId) ? parseInt($stateParams.vlanId) : null;

        /* **** for tables [start] **** */
        $scope.$emit('listenHeaderText', {headerText: $translate.instant('admin.toolbar.heading')});
        $scope.$emit('quickSetupEnded', {});

        $scope.selected = [];
        $scope.query = {
            order: 'name',
            limit: 10,
            page: 1
        };
        $scope.isAdornmentPanelOpen = false;
        $scope.isSearchBarOpen = false;
        $scope.updateAdornmentPanel = function (event, rowData) {
            $scope.toggleAdornmentPanel();
            $scope.adornmentData = angular.copy(rowData);
        };

        $scope.toggleAdornmentPanel = function () {
            $scope.isAdornmentPanelOpen = $scope.isAdornmentPanelOpen === false ? true : false;
            //toggleGridCols($scope.isAdornmentPanelOpen);
        };
        $scope.toggleSearchBar = function (event) {
            $scope.isSearchBarOpen = $scope.isSearchBarOpen === false ? true : false;
            if ($scope.isSearchBarOpen)
                angular.element(event.currentTarget.firstElementChild).css('color', '#4a90e2');
            else
                angular.element(event.currentTarget.firstElementChild).css('color', '#6d6e71');
        };
        /* **** for tables [end] **** */

        
           var create_id = authorities("vlanPools_create");
           var delete_id = authorities("vlanPools_delete");
           var update_id = authorities("vlanPools_update");
           $scope.is_create_vlanPool = userSessionMenagment.isUserAllowd(create_id);
           $scope.is_update_vlanPool = userSessionMenagment.isUserAllowd(update_id);
           $scope.is_delete_vlanPool = userSessionMenagment.isUserAllowd(delete_id);

        //GET LIST OF ALL INFRASTRUCTURE
        infrastructureConnectorService.getListOfInfrastructures().then(function (data) {
            totalClouds = data.length;
            
            if (totalClouds === 0) {
                $scope.errorMessage = "No Infrastructures!!!";
                //NO DATA FOR VIEW
                deferred.resolve();
                $scope.promiseCompleted = false;
            } else {
                $scope.infrastructres = [];
                for (i = 0; i < data.length; i++) {
                    if (data[i].type === 'VMWARE') {
                        console.log(data[i]);
                        vlanData[i] = {};
                        $scope.infrastructres.push(data[i]);
                        vlanData[i].cloud_data = data[i];
                        vlanData[i].cloudId = data[i].id;
                        vlanData[i].vlan_data = [];
                        vlanData[i].deploySpec_data = [];
                        getVlanData(data[i], vlanData[i]);
                        //$sessionStorage.vlanPoolAllData.push(vlanData[i]);
                    } else {
                        totalClouds --;
                    }
                }
            }
        });
        
        function findDeploySpecforVLAN(obj, vlanPoolDataId){
            return _.filter(obj.deploySpec_data, { 'vlanPoolId': parseInt(vlanPoolDataId) });
        }
        
        getVlanData = function(cloudData, obj) {
            
            deploymentSpecificationService.getDeploymentSpecList(cloudData.id).then(function(deployData){
            //getvlanList
            obj.deploySpec_data = deployData;
                vlanService.getvlanList(cloudData.id).then(function(vlanPoolData){

                    for(c=0; c< vlanPoolData.length; c++) { //c for counter
                        var arrRanges = [];
                        vlanPoolData[c].cloudName = obj.cloud_data.name;
                        arrRanges = vlanPoolData[c].ranges.split(",");
                        vlanPoolData[c].rangeList = [];
                        for(i=0; i < arrRanges.length; i++) {                       
                           vlanPoolData[c].rangeList[i] = {};
                           var eachRange = arrRanges[i].split("-");
                           vlanPoolData[c].rangeList[i].start = parseInt(eachRange[0]);
                           vlanPoolData[c].rangeList[i].end = parseInt(eachRange[1]);
                        }
                        vlanPoolData[c].deploy_spec_data = findDeploySpecforVLAN(obj, vlanPoolData[c].id);
                        
                        viewData.push(vlanPoolData[c]);
                    }
                    obj.vlan_data = vlanPoolData;

                    promiseCtr += 1;
                    //console.log("PROMISE COUNTER==="+promiseCtr);
                    if(promiseCtr >= totalClouds) {
                        deferred.resolve();
                        console.log(viewData);
                        $scope.promiseCompleted = false;
                        $scope.vlanPoolData = moveRecordToStart(viewData, "id", vlanId);
                        console.log($scope.vlanPoolData);
                    }
                }, function(error){
                    console.log(error);
                    obj.vlan_data = [];
                    promiseCtr += 1;
                    if(promiseCtr === totalClouds) {

                        //$sessionStorage.groupViewData = viewData;
                        deferred.resolve();
                        $scope.promiseCompleted = false;
                    }
                });

                });
            
        };
        
        $scope.createRangeStartMessage = function (poolForm, index){
              return   poolForm["startrange"+index].$error;
        };

        $scope.createRangeEndMessage = function (poolForm, index){
              return   poolForm["endrange"+index].$error;
        };
        
        $scope.$on('UpdateRowData', function(event, arg){
            viewData.unshift(arg);
            $scope.vlanPoolData = viewData;
        });
        //ADD VLAN POOL
        $scope.addVlanPool = function(cloudData, ev){
            $mdDialog.show({
                controller: addVlanPoolController,
                skipHide: true,
                templateUrl: 'core/components/administration/vlan-pools/addvlan.tmpl.html',
                parent: angular.element(document.body),
                targetEvent: ev,
                locals: {'cloudData': cloudData}
            });
        };
        
        function addVlanPoolController($rootScope, $scope, cloudData){
            $scope.createRangeStartMessage = function (poolForm, index){
              return   poolForm["startrange"+index].$error;
            };

            $scope.createRangeEndMessage = function (poolForm, index){
                  return   poolForm["endrange"+index].$error;
            };
            
            $scope.addnewranges = function(objectData){
                objectData.rangeList.push({"start" : '', "end": ''});
            };

            $scope.deleterange = function(range, adornmentData){
               var index = _.findIndex(adornmentData.rangeList, range);
               adornmentData.rangeList.splice(index, 1); 
            };
            
            $scope.vlanPoolObject = {};
            //$scope.vlanPoolObject.cloudId = cloudId;
            $scope.vlanPoolObject.id = 0;
            $scope.vlanPoolObject.name = "";
            $scope.vlanPoolObject.ranges = "";
            $scope.vlanPoolObject.rangeList = [{"start": '', "end": ''}];
            $scope.clouds = cloudData;
            $scope.active_help_id = "admin_deploy_components_add_vlan_pool_help";
            $scope.helpButtonClicked = function(id){
                $scope.active_help_id = id;
                console.log("  helpButtonClicked ");
                $scope.bordcastEventHelpButtonClicked($scope.active_help_id);
            }; 
            $scope.bordcastEventHelpButtonClicked = function(helpId){
                $scope.$broadcast('onHelpButtonClicked', {
                   helpIDString: helpId 
                });
             };  

            $scope.cancelDialogue = function() {
                $mdDialog.cancel();
            };
            
            
            $scope.done = function(){
                $scope.vlanPoolObject.cloudid = JSON.parse($scope.vlanPoolObject.cloud).id;
                $scope.vlanPoolObject.cloudName  = JSON.parse($scope.vlanPoolObject.cloud).name;
                
                var objectData = $scope.vlanPoolObject;
                
                var arrRangeList = [];
                for (i = 0, ctr = 0; i < objectData.rangeList.length; i++){
                    if(objectData.rangeList[i].start !== '') {
                        arrRangeList[ctr++] = objectData.rangeList[i].start + '-' + objectData.rangeList[i].end;
                    } else {
                        objectData.rangeList.splice(i, 1);
                        i--;
                    }
                }
                console.log(arrRangeList.toString());
                objectData.ranges = arrRangeList.toString();
                
                var toastparam = {};
                toastparam = {
                    'heading': 'VLAN Pool creation in progress',
                    'subHeading': 'Pool creation initiated.',
                    'type': 'progress',
                    'timeout': 15000
                };
                showToast(toastparam);
                $scope.promiseCompleted = true;
                console.log(objectData);
                $mdDialog.hide();
                vlanService.createVlanPool(objectData).then(function(data){

                    //update rows
                    $rootScope.$broadcast('UpdateRowData', objectData);
                    
                    
                    ////////////////////////
                    //$mdDialog.cancel();
                    toastparam = {
                        'heading': 'VLAN Pool (' + objectData.name + ') created successfully',
                        'subHeading': '&nbsp;',
                        'type': 'success',
                        'timeout': 5000
                    };
                    showToast(toastparam);
                    $scope.promiseCompleted = false;

                }, function(error){
                    console.log("Unable to create VLAN Pool - %s due to %s", objectData.name, error.data.message);
                    //TODO to show message/something else;
                    toastparam = {
                        'heading': 'VLAN Pool create failed',
                        'subHeading': "ERROR: "+error.data.message,
                        'type': 'fail',
                        'timeout': 5000
                    };
                    showToast(toastparam);
                    $scope.promiseCompleted = false;
                });
            };
        }
        //ADD VLAN POOL ENDS
        
        //EDIT VLAN POOL
        $scope.addnewranges = function(objectData){
            objectData.rangeList.push({"start" : '', "end": ''});
        };
        
        $scope.deleterange = function(range, adornmentData){
           var index = _.findIndex(adornmentData.rangeList, range);
           adornmentData.rangeList.splice(index, 1); 
        };
        
        $scope.editPoolData = function(objectData){
            console.log(objectData);
            var arrRangeList = [];
            for (i = 0, ctr = 0; i < objectData.rangeList.length; i++){
                if(objectData.rangeList[i].start !== '') {
                    arrRangeList[ctr++] = objectData.rangeList[i].start + '-' + objectData.rangeList[i].end;
                } else {
                    objectData.rangeList.splice(i, 1);
                    i--;
                }
            }
            console.log(arrRangeList.toString());
            objectData.ranges = arrRangeList.toString();
            console.log(objectData);
            $scope.isAdornmentPanelOpen = false;
            
            var toastparam = {};
            toastparam = {
                'heading': 'VLAN Pool update in progress',
                'subHeading': 'Pool update initiated.',
                'type': 'progress',
                'timeout': 15000
            };
            $scope.editPool = false;
            showToast(toastparam);
            $scope.promiseCompleted = true;
            var list = $scope.vlanPoolData;
            
            
            vlanService.updateVlanPool(objectData, objectData.cloudid).then(function(){
                
                //update rows
                for(i=0; i<list.length ; i++) {
                    if (list[i].id === objectData.id) {
                        //list.splice(i, 1);
                        list[i] = objectData;
                    }
                }

                toastparam = {
                    'heading': 'VLAN Pool (' + objectData.name + ') updated successfully',
                    'subHeading': '&nbsp;',
                    'type': 'success',
                    'timeout': 5000
                };
                showToast(toastparam);
                $scope.promiseCompleted = false;
                
            }, function(error){
                console.log("Unable to update VLAN Pool - %s due to %s", objectData.name, error.data.message);
                //TODO to show message/something else;
                toastparam = {
                    'heading': 'VLAN Pool update failed',
                    'subHeading': "ERROR: "+error.data.message,
                    'type': 'fail',
                    'timeout': 5000
                };
                showToast(toastparam);
                $scope.promiseCompleted = false;
            });
        };
        
        //EDIT VLAN POOL ENDS
        
        $scope.deleteVlanPool = function(objectData){
            console.log(objectData);
            $scope.isAdornmentPanelOpen = false;
            
            var toastparam = {};
            toastparam = {
                'heading': 'VLAN Pool deletion in progress',
                'subHeading': 'Pool deletion initiated.',
                'type': 'progress',
                'timeout': 10000
            };
            showToast(toastparam);
            $scope.promiseCompleted = true;
            var list = $scope.vlanPoolData;
            
            //DELETE /shieldxapi/infras/resourcegroup/{rgId} 
            vlanService.deleteVlanPool(objectData.id, objectData.cloudid).then(function(data){
                if(data.status) {
                //update rows
                    for(i=0; i<list.length ; i++) {
                        if (list[i].id === objectData.id) {
                            list.splice(i, 1);
                        }
                    }

                    toastparam = {
                        'heading': 'VLAN Pool deleted successfully',
                        'subHeading': '&nbsp;',
                        'type': 'success',
                        'timeout': 5000
                    };
                    showToast(toastparam);
                    $scope.promiseCompleted = false;
                } else {
                    console.log("Unable to delete VLAN Pool (%s) due to %s", objectData.name, data.errorMessage);
                    //TODO to show message/something else;
                    toastparam = {
                        'heading': 'VLAN Pool deletion failed',
                        'subHeading': "Error: "+data.errorMessage,
                        'type': 'fail',
                        'timeout': 5000
                    };
                    showToast(toastparam);
                    $scope.promiseCompleted = false;
                }
            }, function(error){
                console.log("Unable to delete VLAN Pool - %s due to %s", objectData.name, error.message);
                //TODO to show message/something else;
                toastparam = {
                    'heading': 'VLAN Pool deletion failed',
                    'subHeading': "Something went wrong",
                    'type': 'fail',
                    'timeout': 5000
                };
                showToast(toastparam);
                $scope.promiseCompleted = false;
            });
        }; //DELETE POOL ENDS.
        
        //EDIT
        var oldData;
        $scope.discardChanges = function(){
            $scope.editPool = false;
            console.log(oldData);
            $scope.adornmentData = oldData; //ASSIGN OLD DATA TO OBJECT.
        };
        $scope.updatePool = function(dataObject){
            //THIS FUNCTION WILL CALL WHEN USER COMING IN EDIT MODE.
            oldData = angular.copy(dataObject); //MAKE COPY OF OLD DATA.
            console.log(oldData);
            $scope.editPool = true;
            $scope.rangeheightsetup();
        };
        
        //EDIT ENDS
        
        
        //Cleare session stored data.
        $scope.callCacheBurst = function () {
            console.log('Bursting cache data and reloading from server');
            clearMasterSession($sessionStorage, $state);
            /*$sessionStorage.groupViewData = false;
            $state.reload();*/
        };
        
        $scope.$on('$viewContentLoaded', function(event){ 
            console.log(event);
            fixContainerHeight(1);
        });
        $scope.rangeheightsetup = function(){
            console.log((window.innerHeight - 355) + 'px');
            $scope.rangeheight = (window.innerHeight - 355) + 'px';
        };
    }

    angular.module('shieldxApp').controller('vlanPoolsCtr', vlanPoolsCtr);
})();

(function () {
    function deleteconfromalert($scope, $mdDialog, groupName ) {
        
       
        $scope.groupName = groupName;
        
        $scope.hide = function () {
            $mdDialog.hide();
        };
        $scope.closeDialog = function () {
            $mdDialog.cancel();
        };
        $scope.answer = function (answer) {
           
            $mdDialog.hide(answer);
        };
    }
    angular.module('shieldxApp').controller('deleteconfromalert', deleteconfromalert);

})();
/*
 ShieldX Networks Inc. CONFIDENTIAL
 ----------------------------------
 *
 Copyright (c) 2016 ShieldX Networks Inc.
 All Rights Reserved.
 *
 NOTICE: All information contained herein is, and remains
 the property of ShieldX Networks Incorporated and its suppliers,
 if any. The intellectual and technical concepts contained
 herein are proprietary to ShieldX Networks Incorporated
 and its suppliers and may be covered by U.S. and Foreign Patents,
 patents in process, and are protected by trade secret or copyright law.
 Dissemination of this information or reproduction of this material
 is strictly forbidden unless prior written permission is obtained
 from ShieldX Networks Incorporated.
 */

(function () {
    function monitorNetworksRightPanelCtr($scope,
            $state,
            $translate,
            $mdDialog,
            deploymentSpecificationService,
            $sessionStorage) {

        $scope.viewStates = {
            INITIAL_SCREEN_NO_RESOURCE_GROUP: 0,
            ADD_NEW_RESOURCE_GROUP: 1,
            LIST_ALL_RESOURCE_GROUP: 2,
            ADD_OPTION_EXISTING_RESOURCE_GROUP: 3
        };

        $scope.panelCurrentState = -1;
        $scope.selectedSecurityControl = "";
        $scope.editableMode = false;
        $scope.selectedNetworks = [];
        $scope.infrastructureTenants = {};

        $scope.editResourceGroup = function () {
            $scope.editableMode = true;
        };



        $scope.showAddNewGroupScreen = function () {
            $scope.setCurrentState($scope.viewStates.ADD_NEW_RESOURCE_GROUP);
        };

        $scope.showAllResourceGroups = function () {
            //console.log(" <<<<<  showAllResourceGroups >>>>> ");
            $scope.setCurrentState($scope.viewStates.LIST_ALL_RESOURCE_GROUP);
        };

        $scope.applyResourceGroupChanges = function () {
            $scope.editableMode = false;
            setTimeout(function () {
                $scope.showUnGrouped(); //setting view to ungrouped 
            }, 0);
        };

        $scope.setCurrentState = function (currentState) {
            var states = {
                oldState: $scope.panelCurrentState,
                newState: currentState
            };
            $scope.panelCurrentState = currentState;
            $scope.$emit('currentStateChanged', states);
            $scope.$broadcast('currentStateChanged', states);
        };

        $scope.isViewStateInitialScreenNoResourceGroup = function () {
            //console.log(" isActiveStateIsNOSecurityGroup called");
            return $scope.panelCurrentState == $scope.viewStates.INITIAL_SCREEN_NO_RESOURCE_GROUP;
        };

        $scope.isViewStateAddNewResourceGroup = function () {
            //console.log(" isActiveStateIsNewSecurityGroup called");
            return $scope.panelCurrentState == $scope.viewStates.ADD_NEW_RESOURCE_GROUP;
        };

        $scope.isViewStateListAllResourceGroup = function () {
            //console.log(" isActiveStateIAssignSecurityControl called");
            return $scope.panelCurrentState == $scope.viewStates.LIST_ALL_RESOURCE_GROUP;
        };

        $scope.isViewStateAddOptionExistingResourceGroup = function () {
            var ret = $scope.panelCurrentState == $scope.viewStates.ADD_OPTION_EXISTING_RESOURCE_GROUP;
            //console.log(" isViewStateAddOptionExistingResourceGroup  called >> "+ret);
            return ret;
        };

        $scope.addNetworksToGroup = function (event, group) {
            //console.log(" addNetworksToGroup >>> ");
            if (group && $scope.selectedNetworks.length > 0) {
                $scope.addNetworkToResourceGroup(group, $scope.selectedNetworks);
                $scope.selectedNetworks = [];
                $scope.$emit('existingGroupModified', {exRG: group});
                $scope.showAllResourceGroups();
            }
        };

        $scope.showResourceGroup = function (group) {
            $scope.$emit('resourceGroupSelected', {selRG: group});
        };

        $scope.isGroupExits = function(){
            return $scope.existingGroups && $scope.existingGroups.length > 0;
        };
         
        $scope.initializeRescourceGroupScreen = function () {
            if ($scope.existingGroups.length === 0) {
                $scope.setCurrentState($scope.viewStates.INITIAL_SCREEN_NO_RESOURCE_GROUP);
            } else {
                $scope.setCurrentState($scope.viewStates.LIST_ALL_RESOURCE_GROUP);
            }
        };

        $scope.cancleRescourceGroupScreen = function () {
            if ($scope.existingGroups.length === 0) {
                $scope.setCurrentState($scope.viewStates.INITIAL_SCREEN_NO_RESOURCE_GROUP);
            } else {
                $scope.setCurrentState($scope.viewStates.LIST_ALL_RESOURCE_GROUP);
            }
        };

        $scope.showUserEditOptions = function () {

            if ($scope.existingGroups.length === 0)
            {
                $scope.setCurrentState($scope.viewStates.ADD_NEW_RESOURCE_GROUP);
            } else {
                $scope.setCurrentState($scope.viewStates.ADD_OPTION_EXISTING_RESOURCE_GROUP);
            }
        };

        $scope.commitNewResourceGroup = function (newResourceGroup) {
            //console.log(" commitNewResourceGroup "+newResourceGroup);
            //console.dir(newResourceGroup);	
            _.each($scope.existingGroups, function (obj) {
                obj.new = false;
            });
            $scope.existingGroups.push(newResourceGroup);
            $scope.$emit('newGroupCreated', {newRG: newResourceGroup});
            $scope.selectedNetworks = [];
            $scope.showAllResourceGroups();
        };

        $scope.$on('tenantChanged', function (event, args) {
            console.log("tenantChanged  >>>> " + args.tenant);
            $scope.initializeRescourceGroupScreen();
        });

        $scope.$on('onNetworkSelectionChanged', function (event, args) {
            console.log("onNetworkSelectionChanged  >>>> " + args.selectedNetworks);
            console.dir(args.selectedNetworks);
            $scope.selectedNetworks = [];
            $scope.editableMode = false;
            for (var i = 0; i < args.selectedNetworks.length; i++) {
                console.dir(args.selectedNetworks[i]);
                var network = new Network();
                network.name = args.selectedNetworks[i].name;
                network.networkId = args.selectedNetworks[i].id;
                network.resourceGroupName = args.selectedNetworks[i].resourceGroupName;
                network.resourceGroupId = args.selectedNetworks[i].resourceGroupId;
                $scope.selectedNetworks.push(network);
            }

            if ($scope.selectedNetworks.length === 0) {
                $scope.cancleRescourceGroupScreen();
            } else {
                $scope.showUserEditOptions();
            }
            $scope.setFocusOnElem('#groupNameInput');

        });

        $scope.deleteResourcegroupOnConform = function(group){
               var index = -1;
                index =  _.findIndex($scope.existingGroups, function(rg){
                  return rg.name === group.name; 
                });
                       // console.log(" index "+index);  
                if(index !== -1){
                  var dgr = $scope.existingGroups.splice(index,1);
                   $scope.$emit('groupDeleted',{delRG:group});
                  if($scope.existingGroups.length === 0){
                              $scope.cancleRescourceGroupScreen();
                  }
                }
                setTimeout(function () {
                    $scope.showUnGrouped(); //setting view to ungrouped
                });
        };
         $scope.deleteResourceGroup = function(event,group){
            $scope.showConfromAlertOnDelete(group,event, $scope.deleteResourcegroupOnConform); 
             
         };

      $scope.showConfromAlertOnDelete = function(gp,event, callback){
            $mdDialog.show({
                        controller: 'deleteconfromalert', templateUrl: 'core/components/screenComponents/networkView/delete-conform-alert.html', parent: angular.element(document.body),  skipHide: true, targetEvent: event, clickOutsideToClose: true,
                        locals : {
                            groupName : gp.name,
                        }
                    }).then(function (answerVal) {
                        console.log("showConfromAlertOnDelete answare");
                         callback(gp);
                    }, function () {
                        $scope.status = 'You cancelled the dialog.';
                    });  
        };

        $scope.addNetworkToResourceGroup = function (group, networks) {
            console.log(" addNetworkToResourceGroup ");
            console.dir(networks);
            for (var i = 0; i < networks.length; i++) {
                var tempNet = networks[i];
                if (tempNet.resourceGroupName !== "") {
                    if (group.name !== tempNet.resourceGroupName) {
                        console.log(" resource group found  ");
                        /* jshint ignore:start */
                        var findRG = _.find($scope.existingGroups, function (groupIt) {
                            return groupIt.name == tempNet.resourceGroupName;
                        });
                        console.dir(findRG);
                        /* jshint ignore:end */
                        if (findRG && findRG.memberList) {
                            var findNtIndex = -1;
                            console.log(" resource group network to delete  tempNet.resourceGroupName " + tempNet.resourceGroupName);
                            console.log(" resource group network to delete  groupIt.name " + tempNet.name);
                            /* jshint ignore:start */
                            findNtIndex = _.findIndex(findRG.memberList, function (networkInd) {
                                return networkInd.networkId == tempNet.networkId;
                            });
                            console.log(" resource group network to delete  " + findNtIndex);
                            /* jshint ignore:end */
                            if (findNtIndex !== -1) {
                                console.log("  network  deleted " + findRG.memberList[findNtIndex].name + "resource group" + findRG.name);
                                findRG.memberList.splice(findNtIndex, 1);
                            }
                        }
                    } else {
                        networks.splice(i, 1);
                    }

                }
            }
            console.log(" addNetworkToResourceGroup result  begin");
            console.dir($scope.existingGroups);
            console.dir(networks);
            console.log(" addNetworkToResourceGroup result  end");
            group.addNetworks(networks);
        };
        $scope.initializeRescourceGroupScreen();

        var cloudId = (!$sessionStorage.cloudData.comingFrom) ? 
                $sessionStorage.cloudData.cloudId : 
                $sessionStorage.cloudData.infrastructure.id;
         var vChassisSelectedDeploymentSpec = ($sessionStorage.cloudData.vChassis.selectedDeploymentSpec) ? $sessionStorage.cloudData.vChassis.selectedDeploymentSpec : $state.go('home.quickSetup.virtual-chassis');
        $scope.inlineModeAvailable = false;
        $scope.inlineModeAvailable = deploymentSpecificationService.isinlineModeAvailable(
                cloudId,
                vChassisSelectedDeploymentSpec);
        // this.getCachedListOfTenants();
        //console.l
        //og(" state 1"+$scope.isActiveStateIsNOSecurityGroup());
        //console.log(" state 2"+$scope.isActiveStateIsNewSecurityGroup());
        //console.log(" state 3"+$scope.isActiveStateIAssignSecurityControl());
        //console.log(" state 4"+$scope.isActiveStateIsExistingSecurityGroup());
    }
    angular.module('shieldxApp').controller('monitorNetworksRightPanelCtr', monitorNetworksRightPanelCtr);

    function newResourcegroupCtr($scope) {
        $scope.newResourceGroups = new ResourceGroups();
        $scope.disableCreateGroup = true;
        $scope.newResourceGroups.tenant = $scope.activeTenant.id;
        $scope.createNewResourceGroup = function () {
            console.dir($scope.newResourceGroups);
            if ($scope.selectedNetworks.length > 0) {
                $scope.newResourceGroups.tenant = $scope.activeTenant.id;
                var crg = $scope.newResourceGroups.copy();
                crg.new = true;
                $scope.addNetworkToResourceGroup(crg, $scope.selectedNetworks);
                // console.log(" $scope.newResourceGroups  " +$scope.newResourceGroups.copy);
                $scope.commitNewResourceGroup(crg);
                $scope.newResourceGroups = new ResourceGroups();
                $scope.disableCreateGroup = true;
            }
        };


        $scope.$watch('newResourceGroups.name', function () {
            $scope.checkResourceGroup();
        });
        $scope.$watch('newResourceGroups.tenant', function () {
            $scope.checkResourceGroup();
        });
        $scope.$watch('newResourceGroups.controlPolicy', function () {
            $scope.checkResourceGroup();
        });

        $scope.checkResourceGroup = function () {
            console.log("$scope.newResourceGroups ");
            console.dir($scope.newResourceGroups);
            $scope.disableCreateGroup = !(($scope.newResourceGroups.name && $scope.newResourceGroups.name !== "") && ($scope.newResourceGroups.controlPolicy && $scope.newResourceGroups.controlPolicy !== null));
        };

        $scope.cancelNewResourceGroup = function () {

            $scope.cancleRescourceGroupScreen();
        };

        $scope.checkResourceGroup();

        console.log(" $scope.disableCreateGroup " + $scope.disableCreateGroup);
    }
    angular.module('shieldxApp').controller('newResourcegroupCtr', newResourcegroupCtr);

    function listResourceGroupCtr($scope) {
        console.log(" listResourceGroupCtr ");
        /* jshint ignore:start */



        $scope.$on('currentStateChanged', function (event, args) {
            var oldState = args.oldState;
            var newState = args.newState;
            $scope.setFocusOnElem('#groupNameInput');
            console.log("set focus");
            console.log(" current state listResourceGroupCtr " + newState);
            console.dir(newState);
            if (newState === $scope.viewStates.ADD_OPTION_EXISTING_RESOURCE_GROUP) {
                console.log(" disable resource groups depending upon collection   ");
                console.dir($scope.selectedNetworks);
                console.dir($scope.existingGroups);

                var rs = $scope.existingGroups;
                var sn = $scope.selectedNetworks;
                for (var j = 0; j < rs.length; j++) {
                    if (rs[j].tenant === $scope.activeTenant.id) {
                        rs[j].setViewData("disableAdd", false);
                    } else {
                        rs[j].setViewData("disableAdd", true);
                    }
                }

                for (var i = 0; i < sn.length; i++) {
                    var srg = _.find($scope.existingGroups, function (indexArg) {
                        return indexArg.name === sn[i].resourceGroupName;
                    });
                    if (srg) {
                        srg.setViewData("disableAdd", true);
                    }
                }


            } else if (newState === $scope.viewStates.LIST_ALL_RESOURCE_GROUP) {
                var rsEye = $scope.existingGroups;
                for (var k = 0; k < rsEye.length; k++) {
                    if (rsEye[k].tenant === $scope.activeTenant.id) {
                        rsEye[k].setViewData("disableEye", false);
                    } else {
                        rsEye[k].setViewData("disableEye", true);
                    }
                }
            }

        });



        /* jshint ignore:end */
    }


    angular.module('shieldxApp').controller('listResourceGroupCtr', listResourceGroupCtr);
})();
/*
 ShieldX Networks Inc. CONFIDENTIAL
 ----------------------------------
 *
 Copyright (c) 2016 ShieldX Networks Inc.
 All Rights Reserved.
 *
 NOTICE: All information contained herein is, and remains
 the property of ShieldX Networks Incorporated and its suppliers,
 if any. The intellectual and technical concepts contained
 herein are proprietary to ShieldX Networks Incorporated
 and its suppliers and may be covered by U.S. and Foreign Patents,
 patents in process, and are protected by trade secret or copyright law.
 Dissemination of this information or reproduction of this material
 is strictly forbidden unless prior written permission is obtained
 from ShieldX Networks Incorporated.
 */

(function () {
    function networkViewCtr($scope,
            $state,
            $translate,
            $sessionStorage,
            ipPoolServices,
            virtualChassisService,
            policyService,
            deploymentSpecificationService,
            $mdDialog,
            $rootScope) {
        "ngInject";

        // console.log("monitorNetworksCtr initialised");
        $scope.comingFromAdmin = false;
        $scope.$emit('quickSetupBegun', {});
        $scope.$storage = $sessionStorage;
        $scope.init = false;
        $scope.isViewAll = false;
        $scope.isViewGrouped = false;
        $scope.isViewUnGrouped = true;
        $scope.networkFetched = false;
        $scope.name = "Active";
        $scope.activeTenant = {name: "A", id: 0};
        $scope.tenants = [{name: "A", id: 0}, {name: "B", id: 1}];
        $scope.monitor_network_heading = $translate.instant('wizardnetworkmap.header.select_network');
        $scope.wizardnetworkmap_rightpanel_header = $translate.instant("wizardnetworkmap.rightpanel.header");
        $scope.monitor_network_heading_infra_name = ($sessionStorage.cloudData.infrastructure.name) ? $sessionStorage.cloudData.infrastructure.name : 'no value set';
        $scope.monitor_network_heading_vc_name = $sessionStorage.cloudData.vChassis.name;

        $scope.active_help_id = "virtualchassis_vieweditaddisecgroup_wizard";
        
        //Write condition to check from where coming for $scope.headerValues.
        if (!$sessionStorage.cloudData.comingFrom) {
            $scope.setLastQuickSetupPage();
            $scope.headerValues = [{
                    label: 'Connector', value: $sessionStorage.cloudData.infrastructure.name
                }, {
                    label: 'Infrastructure', value: $sessionStorage.cloudData.infrastructure.ip
                }, {
                    label: 'Management Network', value: $sessionStorage.cloudData.ipPool.serverData.managmentNetworkHeaderValue
                }, {
                    label: 'Management IP Pool', value: $sessionStorage.cloudData.ipPool.serverData.managmentIPPoolHeaderValue
                }, {
                    label: 'Backplane Network', value: $sessionStorage.cloudData.ipPool.serverData.backpaneNetworkHeaderValue
                }, {
                    label: 'Backplane IP Pool', value: $sessionStorage.cloudData.ipPool.serverData.backpaneIPPoolHeaderValue
                }, {
                    label: 'Deployment Specification', value: $sessionStorage.cloudData.deploySpec.serverData.name
                }];
            //Write condition to check from where coming for $scope.headerValues. ENDS
        } else {
            if ($sessionStorage.cloudData.comingFrom === 'ADMINADD' ||
                    $sessionStorage.cloudData.comingFrom === 'ADMINEDIT') {
                $scope.comingFromAdmin = true;
            }
        }
        $scope.securityPoliciyDescriptionMapping = {
            ACL: "Access Control",
            ThreatPrevention: "Threat Prevention",
            AppID: "Application Identification",
            ThreatPreventionAndAppID: "Threat Prevention Application Identification",
            ThreatPreventionAndACL: "Access Control Threat Prevention",
            ACLAndAppId: "Access Control Application Identification",
            ACLThreatPreventionAndAppID: "Access Control Threat Prevention Application Identification",
            AllInclusive:"All Inclusive",
            Tuned:"Tuned"

        };

        $scope.getSecurityPolicyDiscriptionFromName = function (name) {
            var str = $scope.securityPoliciyDescriptionMapping[name];
            if(str){
               return str; 
            } 
            return name;
        };
        $scope.getSecurityPolicyDescriptionFormID = function (id) {
            //console.log(" getSecurityPolicyDescriptionFormID 1 "+id);
            // console.dir($scope.securityPolicySet); 
            if ($scope.securityPolicySet) {
                //console.log(" getSecurityPolicyDescriptionFormID 2 ");
                var sp = _.find($scope.securityPolicySet, function (arg) {
                    return arg.id == id;
                });
                //console.log(" getSecurityPolicyDescriptionFormID 3 "+sp);
                if (sp) {
                    var val = $scope.getSecurityPolicyDiscriptionFromName(sp.name);
                    //console.log(" getSecurityPolicyDescriptionFormID "+val); 
                    return val;
                }
            }
        };

        $scope.getTenantNameFromID = function (id) {

            var retVal = _.find($scope.tenants, function (tenantInd) {
                return tenantInd.id === id;
            });

            return retVal;
        };
        $scope.showTentantPopup = function (ev) {
            console.dir($scope.tenants);
            $mdDialog.show({
                controller: 'tenantDialogBoxCtr', templateUrl: 'core/components/screenComponents/networkView/tenantDialogBox.html', parent: angular.element(document.body), skipHide: true, targetEvent: ev, clickOutsideToClose: true,
                locals: {
                    tenants: $scope.tenants,
                    selectedTenatnID: $scope.activeTenant.id,
                }
            }).then(function (answerVal) {
                $scope.networkFetched = false;
                var tenantSelected = $scope.getTenantNameFromID(parseInt(answerVal.selectedVal));
                $scope.activeTenant = tenantSelected;
                $scope.selected = [];
                $scope.$broadcast('tenantChanged', {tenant: $scope.activeTenant});
                $scope.masterList = angular.copy($scope.activeTenant.networks);
                $scope.updateMasterList();
                
                setTimeout(function () {
                    $scope.showUnGrouped(); //setting view to ungrouped 
                    $scope.networkFetched = true;
                }, 0);
                console.log(" tenant selected ");
                console.dir($scope.activeTenant);
                
            }, function () {
                $scope.status = 'You cancelled the dialog.';
            });
        };

        $scope.onNetworkSelected = function () {

            $scope.$broadcast('onNetworkSelectionChanged', {message: "newtwork selcetion changed"});
        };
        $scope.items = [];
        $scope.resourceGroupIndex = -1;
        if (!$sessionStorage.cloudData.vChassis.existingGroups) {
            $scope.existingGroups = [
            ];
            $sessionStorage.cloudData.vChassis.existingGroups = $scope.existingGroups;
        } else {
            //console.log(" group alrady exit ");
            console.dir($sessionStorage.cloudData.vChassis.existingGroups);
            var rt = $sessionStorage.cloudData.vChassis.existingGroups;
            $scope.existingGroups = [];
            for (var i = 0; i < rt.length; i++) {
                var tm = new ResourceGroups();
                tm.init(rt[i]);
                $scope.existingGroups.push(tm);
            }

            $sessionStorage.cloudData.vChassis.existingGroups = $scope.existingGroups;

        }
        //console.log($sessionStorage.cloudData);
        if (!$sessionStorage.cloudData) {
            $sessionStorage.cloudData = {};
            //console.log('cloudData not set');
            $state.go('home.quickSetup.quickSetup-begin');
        }
        //Write condition to check from where coming for $scope.headerValues.

        if (!$sessionStorage.cloudData.comingFrom) {
            if (!$sessionStorage.cloudData.cloudId) {
                //console.log('cloud Id not set');
                $state.go('home.quickSetup.infrastructure-connector');
                //$sessionStorage.cloudData.cloudId =  1; //THIS NEEDS TO BE REMOVED ONCE WE STORE IT FROM INFRASTRUCTURE
            }
            if (!$sessionStorage.cloudData.ipPool || !($sessionStorage.cloudData.ipPool.serverData)) {
                //console.log('data not set in ipPool');
                $state.go('home.quickSetup.ip-pools-management');
            }
            if (!$sessionStorage.cloudData.vChassis) {
                $state.go('home.quickSetup.virtual-chassis');
            }
        }
        //Write condition to check from where coming for $scope.headerValues.
        var cloudId = (!$sessionStorage.cloudData.comingFrom) ? 
                $sessionStorage.cloudData.cloudId : 
                $sessionStorage.cloudData.infrastructure.id;
        var vChassisName = ($sessionStorage.cloudData.vChassis.name) ? $sessionStorage.cloudData.vChassis.name : $state.go('home.quickSetup.virtual-chassis');
        var vChassisDesc = $sessionStorage.cloudData.vChassis.desc;
        var vChassisSelectedDeploymentSpec = ($sessionStorage.cloudData.vChassis.selectedDeploymentSpec) ? $sessionStorage.cloudData.vChassis.selectedDeploymentSpec : $state.go('home.quickSetup.virtual-chassis');
        $scope.inlineModeAvailable = deploymentSpecificationService.isinlineModeAvailable(
                cloudId,
                vChassisSelectedDeploymentSpec);

        deploymentSpecificationService.getTenants(cloudId).then(function (data) {
            $scope.tenants = data;
            if ($scope.tenants && $scope.tenants.length > 0) {
                $scope.activeTenant = $scope.tenants[0];
            }
            getNetworks(true);

        });


        getNetworks = function (omitNetworksUsed) {
            virtualChassisService.getAllNetworksMappedToResource({success: function (data) {
                    //console.log(" virtualChassisService.getAllNetworkInformations  success >> "+data);
                    //console.dir(data);
                    $scope.networks = virtualChassisService.getAdditionalNetworkInfo(
                            data,
                            $sessionStorage.cloudData.ipPool.serverData.backPlaneNetworkId,
                            $sessionStorage.cloudData.ipPool.serverData.mgmtNetworkId
                            );
                    $sessionStorage.cloudData.networks = $scope.networks;
                    $scope.items = $scope.networks;
                    _.remove($scope.items, function (item) {
                        return item.hide === true;
                    });
                    setTimeout(function () {
                        $scope.showUnGrouped(); //setting view to ungrouped 
                    }, 0);
                    //console.log(" $scope.items  >>> "+$scope.items.length);

                }, fail: function (error) {
                    console.log(" virtualChassisService.getAllNetworkInformations error " + error);
                }},
                    $sessionStorage.cloudData.cloudId,
                    angular.copy($sessionStorage.cloudData.ipPool.networks),
                    $sessionStorage.cloudData.vChassis.resourceGroup,
                    omitNetworksUsed,
                    angular.copy($sessionStorage.cloudData.vChassis.existingGroups));
        };


        $sessionStorage.cloudData.networks = [];
        $scope.securityPolicySet = [];
        $scope.selected = [];
        $scope.viewall = 'active-link';
        $scope.viewselected = false;

        $scope.showAll = function () {
            var tempList = angular.copy($scope.masterList);
            $scope.viewall = 'active-link';
            $scope.viewselected = false;
            $scope.selectAllDisabled = true;
            $scope.items = angular.copy(tempList);
            manageActiveViews('all');

        };

        $scope.showGrouped = function () {
            var tempList = angular.copy($scope.masterList);
            $scope.items = [];
            $scope.selectAllDisabled = false;
            _.forEach(tempList, function (obj) {
                if (obj.resourceGroupName || obj.resourceGroupId) {
                    $scope.items.push(obj);
                }
            });
            if ($scope.items.length === 0) {
                $scope.selectAllDisabled = true;
            }
            manageActiveViews('grouped');
        };
        $scope.showUnGrouped = function () {
            var tempList = angular.copy($scope.masterList);
            $scope.selected = [];
            $scope.items = [];
            $scope.selectAllDisabled = false;
            _.forEach(tempList, function (obj) {
                if (obj.resourceGroupName === null && obj.resourceGroupId === null) {
                    $scope.items.push(obj);
                }
            });
            if ($scope.items.length === 0) {
                $scope.selectAllDisabled = true;
            }
            $scope.networkFetched = true;

            manageActiveViews('un');
        };

        function manageActiveViews(type) {
            if (type.match(/all/ig)) {
                angular.element(document.querySelector('.view-grouped')).removeClass('active-link');
                angular.element(document.querySelector('.view-ungrouped')).removeClass('active-link');
                angular.element(document.querySelector('.view-all')).addClass('active-link');
                $scope.isViewAll = true;
                $scope.isViewGrouped = false;
                $scope.isViewUnGrouped = false;
                $scope.disableAllSelection(true);
            } else if (type.match(/grouped/ig)) {
                angular.element(document.querySelector('.view-all')).removeClass('active-link');
                angular.element(document.querySelector('.view-ungrouped')).removeClass('active-link');
                angular.element(document.querySelector('.view-grouped')).addClass('active-link');
                $scope.isViewAll = false;
                $scope.isViewGrouped = true;
                $scope.isViewUnGrouped = false;
                $scope.disableAllSelection(false);
            } else if (type.match(/un/ig)) {
                angular.element(document.querySelector('.view-all')).removeClass('active-link');
                angular.element(document.querySelector('.view-grouped')).removeClass('active-link');
                angular.element(document.querySelector('.view-ungrouped')).addClass('active-link');
                $scope.isViewAll = false;
                $scope.isViewGrouped = false;
                $scope.isViewUnGrouped = true;
                $scope.disableAllSelection(false);
            }
        }

        $scope.disableAllSelection = function (flag) {
            _.each($scope.items, function (obj) {
                obj.disabled = flag;
            });
        };

        $scope.$on('newGroupCreated', function (event, data) {
            //console.log(" newGrupCreated >>> "+data.newRG);
            //console.dir(data.newRG);
            if (typeof $sessionStorage.cloudData.vChassis.resourceGroup === "undefined") {
                $sessionStorage.cloudData.vChassis.resourceGroup = [];
            }
            $sessionStorage.cloudData.vChassis.resourceGroup.push(data.newRG);
            $scope.checkCommit();
            $scope.selected = [];
            reCalcNetworks();
            setTimeout(function () {
                $scope.showUnGrouped(); //setting view to ungrouped 
            }, 0);


        });

        $scope.$on('groupDeleted', function (event, data) {
            //console.log(" newGrupCreated >>> "+data.delRG);
            //console.dir(data.delRG);
            // $sessionStorage.cloudData.vChassis.resourceGroup.push(data.newRG);
            _.remove($sessionStorage.cloudData.vChassis.resourceGroup,
                    function (resourceGrp) {
                        return resourceGrp.name === data.delRG.name;
                    });
            $scope.checkCommit();
            reCalcNetworks();
        });

        $scope.$on('existingGroupModified', function (event, data) {
            //console.log(" existingGrupModified >>> "+data.exRG);
            //console.dir(data.exRG);
            var rtRG = _.find($sessionStorage.cloudData.vChassis.existingGroups,
                    function (resourceGrp) {
                        return resourceGrp.name === data.exRG.name;
                    });
            rtRG.memberList = data.exRG.memberList;
            $scope.selected = [];
            reCalcNetworks();
            setTimeout(function () {
                $scope.showGrouped(); //setting view to ungrouped 
            }, 0);
        });

        reCalcNetworks = function () {
            $scope.items = virtualChassisService.getAdditionalNetworkResourceGroupInfo(
                    $scope.networks,
                    $sessionStorage.cloudData.vChassis.existingGroups
                    );
            _.remove($scope.items, function (item) {
                return item.hide === true;
            });
            $scope.items = virtualChassisService.getAdditionalNetworkResourceGroupInfo(
                    $scope.activeTenant.networks,
                    $sessionStorage.cloudData.vChassis.existingGroups
                    );
            $scope.$emit('listChanged', {});
        };
        $scope.showSelected = function () {
            $scope.viewall = false;
            $scope.viewselected = 'active-link';
            $scope.items = $scope.selected;
        };
        $scope.toggleNetwork = function (networkval) {
            // console.log(" toggleNetwork ");
            if ($scope.selected) {
                var idx = $scope.selected.indexOf(networkval);
                if (idx > -1) {
                    $scope.selected.splice(idx, 1);
                } else {
                    $scope.selected.push(networkval);
                }


                $scope.$broadcast('onNetworkSelectionChanged', {selectedNetworks: $scope.selected});
            }
        };


        $scope.$on('resourceGroupSelected', function (event, data) {

            //console.dir(data.selRG);
            for (var i = 0; i < $scope.items.length; i++) {
                if ($scope.items[i].resourceGroupName === data.selRG.name)
                    $scope.items[i].faded = false;
                else
                    $scope.items[i].faded = true;
            }

        });


        $scope.isIndeterminate = function () {
            return ($scope.selected.length !== 0 &&
                    $scope.selected.length !== $scope.items.length);
        };
        $scope.isChecked = function () {
            return $scope.selected.length === $scope.items.length;
        };
        $scope.toggleAll = function () {
            if ($scope.selected.length === $scope.items.length) { //uncheck all
                $scope.selected = [];
            } else if ($scope.selected.length === 0 || $scope.selected.length > 0) {
                $scope.selected = $scope.items.slice(0); //check all
            }
            $scope.checkCommit();
            $scope.$broadcast('onNetworkSelectionChanged', {selectedNetworks: $scope.selected});
        };



        if (!($sessionStorage.cloudData.securityPolicySet)) {
            $sessionStorage.cloudData.securityPolicySet = [];
        }
        //CALL TO GET POLICY SET
        if ($sessionStorage.cloudData.securityPolicySet.length === 0) {
            //CALL TO GET SECURITY POLICY SET FROM SERVER
            policyService.getSecurityPolicySet().then(function (policyData) {
                //var data = _.sortBy(policyData, ["id"]);
                _.each(policyData, function (obj, key) {
                    obj.viewId = key;
                });
                $scope.securityPolicySet = policyData; //data;
                $sessionStorage.cloudData.securityPolicySet = policyData; //data;
            }, function (error) {
                console.log(error);
                $scope.securityPolicySet = [
                    {
                        "id": 4,
                        "name": "ACL"
                    },
                    {
                        "id": 2,
                        "name": "ThreatPrevention"
                    },
                    {
                        "id": 3,
                        "name": "AppID"
                    },
                    {
                        "id": 1,
                        "name": "ThreatPreventionAndAppID"
                    },
                    {
                        "id": 5,
                        "name": "ThreatPreventionAndACL"
                    },
                    {
                        "id": 6,
                        "name": "ACLAndAppId"
                    },
                    {
                        "id": 7,
                        "name": "ACLThreatPreventionAndAppID"
                    }
                ];
            });
        } else {
            $scope.securityPolicySet = $sessionStorage.cloudData.securityPolicySet;
        }

        $scope.checkCommit = function () {
            if ($scope.existingGroups.length > 0) {
                $scope.enableNextButton();
            } else {
                $scope.disableNextButton();
            }
        };

        $scope.$on('nextClicked', function (event, data) {
            // console.log('cmg here');
            data.stopNextClick = true;
            $scope.startCreatingChassis();
        });
        $scope.startCreatingChassis = function () {
            $scope.resourceGroupIndex = 0;
            $scope.createResourceGroup();
        };

        $scope.createResourceGroup = function () {
            if ($scope.resourceGroupIndex < $scope.existingGroups.length) {
                var rs = $scope.existingGroups[$scope.resourceGroupIndex];
                if (!rs.id) {
                    var createResouceParams = {
                        "cloudId": cloudId,
                        "id": 0,
                        "memberList": rs.getNetworkServerFormat(),
                        "name": rs.name,
                        "tenantId": rs.tenant
                    };
                    // console.log(" createResourceGroup "+$scope.resourceGroupIndex);
                    console.dir(createResouceParams);
                    virtualChassisService.createResourceGroup(createResouceParams).then(
                            function (resData) {
                                rs.id = resData;
                                if ($scope.resourceGroupIndex < $scope.existingGroups.length) {
                                    $scope.resourceGroupIndex++;
                                    $scope.createResourceGroup();
                                } else
                                {
                                    // $scope.createChassis(); 
                                }

                            }, function (error) {

                    });
                } else {
                    var newnetworksPresent = _.find(rs.memberList, function (singleNetwork) {
                        return (singleNetwork.resourceGroupId === null);
                    });
                    if(newnetworksPresent){
                        var updateResourceGroupParam = {"id": rs.id,
                                                        "name": rs.name,
                                                        "cloudId": cloudId,
                                                        "tenantId": rs.tenant,
                                                        "memberList": rs.memberList
                                                        };
                        virtualChassisService.updateResourceGroup(updateResourceGroupParam).then(
                            function (resData) {
                                $scope.resourceGroupIndex++;
                                $scope.createResourceGroup();
                            },function (error){
                                console.log("Error in update");
                            });
                    }
                }
            } else {
                if (!$sessionStorage.cloudData.vChassis.id) {
                    $scope.createChassis();
                } else {
                    $scope.updateChassis();
                }
            }
        };

        $scope.createChassis = function () {
//                toastparam = {
//                    'heading': 'Data Plane creation in progress',
//                    'subHeading': "Data Plane creation initiated. This should take only a few minutes max.",
//                    'type': 'progress',
//                    'timeout': 5000
//                };
//                showToast(toastparam);
            var vChassisParamObject = {
                "cloudId": cloudId,
                "datapathDeploySpecId": vChassisSelectedDeploymentSpec,
                "descr": vChassisDesc,
                "id": 0,
                "name": vChassisName,
                "subscriptionList": virtualChassisService.createSubscriptionList($scope.existingGroups)
            };
            //console.log(" createChassis "+$scope.resourceGroupIndex);
            console.dir(vChassisParamObject);
            virtualChassisService.createVirtualChassis(vChassisParamObject).then(function (vchassisData) {
                ///created vchassis move user to another location
                delete $scope.$storage.cloudData;
                $scope.$emit('quickSetupEnded', {});
                var toastparam = {
                    'heading': 'Data Plane created successfully',
                    'subHeading': "",
                    'type': 'success',
                    'timeout': 5000,
                    'callback': gotoChassisListing()
                };
                showToast(toastparam);

            }, function (error) {
                //ERROR HANDLING WILL COME HERE
                console.log(error);
                var toastparam = {
                    'heading': 'Data Plane creation failed',
                    'subHeading': "Error: " + error.data.message,
                    'type': 'fail',
                    'timeout': 5000,
                    'callback': gotoChassisListing()
                };
                showToast(toastparam);
                saveCurrentState();
            });
        };

        saveCurrentState = function () {
            if (!$sessionStorage.cloudData.comingFrom) {
                $sessionStorage.cloudData.savedState = $state.current.name;
            }
        };

        gotoChassisListing = function () {
            if ($scope.comingFromAdmin) {
                $scope.hide();
            }
            $state.go('home.virtualChassis');
        };

        $scope.updateChassis = function () {
            toastparam = {
                'heading': 'Data Plane update in progress',
                'subHeading': "Data Plane update initiated. This should take only a few minutes max.",
                'type': 'progress',
                'timeout': 5000
            };
            showToast(toastparam);
            var vChassisParamObject = {
                "cloudId": cloudId,
                "datapathDeploySpecId": vChassisSelectedDeploymentSpec,
                "descr": vChassisDesc,
                "id": $scope.cloudData.vChassis.id,
                "name": vChassisName,
                "subscriptionList": virtualChassisService.createSubscriptionList($scope.existingGroups)
            };
            //console.log(" createChassis "+$scope.resourceGroupIndex);
            console.dir(vChassisParamObject);
            virtualChassisService.updateVirtualChassis(vChassisParamObject).then(function (vchassisData) {
                ///created vchassis move user to another location
                delete $scope.$storage.cloudData;
                $scope.$emit('quickSetupEnded', {});
                toastparam = {
                    'heading': 'Data Plane updated successfully',
                    'subHeading': "",
                    'type': 'success',
                    'timeout': 2000,
                    'callback': function () {
                        $state.go('home.virtualChassis');
                    }
                };
                showToast(toastparam);
                $mdDialog.hide();
                $state.go("home.virtualChassis");

            }, function (error) {
                //ERROR HANDLING WILL COME HERE
                console.log(error);
                toastparam = {
                    'heading': 'Data Plane update failed',
                    'subHeading': "Error: " + error.data.message,
                    'type': 'fail',
                    'timeout': 5000,
                    'callback': function () {
                        $state.go('home.virtualChassis');
                    }
                };
                showToast(toastparam);
                saveCurrentState();
                $state.go("home.virtualChassis");

            });
        };

        $scope.updateMasterList = function () {
            //console.log($scope.items, $scope.masterList);
            $scope.groupedElemsCount = 0;
            $scope.unGroupedElemsCount = 0;
            for (var i = 0; i < $scope.items.length; i++) {
                for (var j = 0; j < $scope.masterList.length; j++) {
                    if ($scope.masterList[j].id === $scope.items[i].id) {
                        $scope.masterList[j].resourceGroupId = angular.copy($scope.items[i].resourceGroupId);
                        $scope.masterList[j].resourceGroupName = angular.copy($scope.items[i].resourceGroupName);
                    }
                }
            }
            //update variables
            for (var k = 0; k < $scope.masterList.length; k++) {
                if ($scope.masterList[k].resourceGroupName)
                    ++$scope.groupedElemsCount;
                else
                    ++$scope.unGroupedElemsCount;
            }

        };
        $scope.$on('listChanged', function () { // updates masterList
            // console.log("Items list changes >>> "+$scope.items);
            $scope.updateMasterList();
        });
        $scope.$watch('items', function (newVal) {
            console.log("Initial Items list", newVal);
            if (!$scope.init && newVal.length > 0) {
                $scope.originalNetworkList = angular.copy(newVal);
                //$scope.masterList = angular.copy($scope.originalNetworkList); //creating deliberate redundancy
                //$scope.updateMasterList();

                for (i = 0; i < $scope.tenants.length; i++) {
                    /*if ($sessionStorage.cloudData.infrastructure.type === 'OPENSTACK') {
                        $scope.tenants[i].networks = getTenantNetworks($scope.tenants[i].name, $sessionStorage.cloudData.networks);
                    } else {  */
                        $scope.tenants[i].networks = $sessionStorage.cloudData.networks;
                   /* } */
                }

                $scope.masterList = angular.copy($scope.activeTenant.networks);
                $scope.updateMasterList();
                console.log("tenants after adding networks");
                console.log($scope.tenants);
                console.log($scope.activeTenant);
                //$scope.items = $scope.activeTenant.networks;


                $scope.init = true;
                for (var i = 0; i < $scope.items.length; i++) {
                    newVal[i].faded = false;
                }
            }
        });


        $scope.checkCommit();
        //$scope.showUnGrouped(); //setting view to ungrouped 
        //fixContainerHeight(4);$scope
        fixManageNetworkHeight();

        saveCurrentState();

    }



    angular.module('shieldxApp').controller('networkViewCtr', networkViewCtr);

})();

/*
ShieldX Networks Inc. CONFIDENTIAL
----------------------------------
*
Copyright (c) 2016 ShieldX Networks Inc.
All Rights Reserved.
*
NOTICE: All information contained herein is, and remains
the property of ShieldX Networks Incorporated and its suppliers,
if any. The intellectual and technical concepts contained
herein are proprietary to ShieldX Networks Incorporated
and its suppliers and may be covered by U.S. and Foreign Patents,
patents in process, and are protected by trade secret or copyright law.
Dissemination of this information or reproduction of this material
is strictly forbidden unless prior written permission is obtained
from ShieldX Networks Incorporated.
*/

(function () {
    function tenantDialogBoxCtr($scope, $mdDialog, selectedTenatnID, tenants) {


        $scope.selectedTenatnID = selectedTenatnID;
        $scope.title = "Select Tenant";
        $scope.tenantFetched = false;
        $scope.tenants = tenants;
        $scope.numberOfTenant = $scope.tenants.length;
        $scope.selectEnableState = false;
        /*ipPoolServices.getNetworksFromCache({success:function(data){ 
         console.log("data recived &&&& ");
         console.dir(data);
         $scope.networkFetched = true; 
         $scope.newtworks = [];                                        
         for(var i in data){
         $scope.newtworks.push({id:data[i].id ,label:data[i].name,data:""}); 
         } 
         // console.dir($scope.managmentNetworks); 
         $scope.numberOfNetwork = $scope.newtworks.length;                                               
         }
         });*/

        $scope.onSelectionChanged = function () {
            console.log(" onSelectionChanged >> ");
            $scope.selectEnableState = true;
        };

        $scope.hide = function () {
            $mdDialog.hide();
        };
        $scope.closeDialog = function () {
            $mdDialog.cancel();
        };
        $scope.closeDialogWithAnswer = function (answer) {
            console.log(" answer " + answer);
            var returnVal = {selectedVal: answer, tenants: $scope.tenants};
            $mdDialog.hide(returnVal);
        };
    }
    angular.module('shieldxApp').controller('tenantDialogBoxCtr', tenantDialogBoxCtr);

})();

function OSRuleConfig(inlineMode,showSps,mode){

	if(typeof(inlineMode) != "undefined" ){
		this.inlineMode = inlineMode; 
	}else
	{
		this.inlineMode = false;
	}

	if(typeof(showSps) != "undefined"){
		this.showSps = showSps; 
	}else
	{
		this.showSps = true;
	}

	if(typeof(mode) != "undefined"){
      this.mode = mode;
	}else {
	  this.mode = OSRuleConfig.modes.WIZARD_MODE;
	}
}

OSRuleConfig.modes = {
	ADD_VC:"add_vc",
	EDIT_VC:"edit_vc",
	ADD_RC:"add_rc",
	EDIT_RC:"edit_rc",
	WIZARD_MODE:"wizardMode"
}; 
function GroupInfo(){
 this.id = "";
 this.name = "";
}

GroupInfo.prototype.init = function( arg){
	this.id = arg.id;
    this.name = arg.name;
};

GroupInfo.prototype.clone = function(){
   var groupInfo = new GroupInfo();
   groupInfo.id = this.id;
   groupInfo.name = this.name;
   return groupInfo;
 };

GroupInfo.prototype.equal = function(arg){
  return ((this.id === arg.id) && (this.name === arg.name));
};


function ASPInfo(){
 this.id = "";
 this.name = "";
}

ASPInfo.prototype.init = function( arg){
	this.id = arg.id;
    this.name = arg.name;
};

ASPInfo.prototype.equal = function( arg ){
  return (this.id === arg.id && this.name === arg.name);
};

ASPInfo.prototype.clone = function(){
   var aspInfo = new ASPInfo();
   aspInfo.id = this.id;
   aspInfo.name = this.name;
   return aspInfo;
 };

function NetworkInfo() {
	this.id = "";
    this.name = "";
}

NetworkInfo.prototype.init = function(arg){
    this.id = arg.id;
    this.name = arg.name;
};

 NetworkInfo.prototype.clone = function(){
   var netInfo = new NetworkInfo();
   netInfo.id = this.id;
   netInfo.name = this.name;
   return netInfo;
 };

 NetworkInfo.prototype.equal = function(arg){
  return ((this.id === arg.id) && (this.name === arg.name));
 };

function SORuleDesc(){
  this.ruleAttribute = "";
  this.matchingCritaria = "";
  this.networkSpec = "";
  this.networkCount = "";
  this.networks = [];
  this.deleted = false;
  this.belongToAGroup = false;
 }
 SORuleDesc.prototype.init = function( arg){
  this.ruleAttribute = arg.ruleAttribute;
  this.matchingCritaria = arg.matchingCritaria;
  this.networkSpec = arg.networkSpec;
  //Use n/w for everything except CIDR which has value 1
  if(arg.ruleAttribute != "1"){
    this.networkCount = arg.networkCount;
    this.networks = [];
      for(var i = 0; i < arg.networks.length; i++ ){
      	var network = new NetworkInfo();
      	 network.init(arg.networks[i]);
      	 this.networks.push(network);
    }
  }
  this.deleted = arg.deleted;
 };



  SORuleDesc.prototype.getJSONDataForPOST = function(){
    var memberList = [];
    switch(this.ruleAttribute){
      case "0":
        /*for(var i=0; i < this.networks.length; i++){
          memberList.push({"id": 0, "networkId": this.networks[i].id, "networkName": this.networks[i].name});  
        }*/
        break;
      case "1":
          console.log("data to create case 1 ",this);
          memberList.push({"id": 0, "cidr": this.networkSpec});
          break;
      case "2":
//          console.log("data to create case 2 ",this);
//          memberList.push({"id": 0, "vmId": this.networkSpec});
          /*for(var j=0; i < this.networks.length; j++){
              memberList.push({"id": 0, "vmId": this.networks[j].id});  
            }*/
          break;
  }
  

  return memberList;
    
 };

 SORuleDesc.prototype.getRegExFormat = function(){
 	var regEx = "";
 	console.log(" this.matchingCritaria "+this.matchingCritaria);
 	if(this.matchingCritaria === SORule.matchingCritarias.IS.id){
 		regEx = "name=\'"+this.networkSpec+"\'";
 	}else if(this.matchingCritaria === SORule.matchingCritarias.BEGIN_WITH.id){
 		regEx = "name=\'"+this.networkSpec+".*\'";
 	}else if(this.matchingCritaria === SORule.matchingCritarias.CONTAINS.id){
 		regEx = "name='\.*"+this.networkSpec+".*\'";
 	}	

 	return regEx;
 };

 SORuleDesc.prototype.getMatchingCritaria = function(reg) {
	//var totalRegex = data.regex.split(";");
	//for(var i=0;i<totalRegex.length-1;i++){
		var conatinsRegex = new RegExp("^[^*]*(?:\\*[^*]*){2}$");
		var startsRegex = new RegExp("^[^*]*(?:\\*[^*]*){1}$");
		var conatinsRegexIs = conatinsRegex.test(reg);
		var startsRegexIs  = startsRegex.test(reg);
		if(conatinsRegexIs){
			this.matchingCritaria = SORule.matchingCritarias.CONTAINS.id;
			this.networkSpec =    reg.substring(8, reg.length-3);
		}else if(startsRegexIs){
			this.matchingCritaria = SORule.matchingCritarias.BEGIN_WITH.id;
			this.networkSpec =    reg.substring(6, reg.length-3);
		}else{
			this.matchingCritaria = SORule.matchingCritarias.IS.id;
			this.networkSpec =    reg.substring(6, reg.length-1);
		}
	//}
	
};

SORuleDesc.prototype.setMatchingCritariaAndNetworkSpec = function(matchingCritaria, networkSpec,ruleAttribute){
	this.matchingCritaria = matchingCritaria;
	this.networkSpec =    networkSpec;
  if(ruleAttribute)
  this.ruleAttribute =  ruleAttribute;
};

SORuleDesc.prototype.initializeFromExistingGroup = function(memberList, ruleAttribute){
       // this.getMatchingCritaria(regEx);
        this.networks = [];
        for(var i =0; i < memberList.length; i++){
          var mem = memberList[i];	
          var netInfo = new NetworkInfo();
          if(ruleAttribute === 0)
            netInfo.id = mem.networkId;
          else if(ruleAttribute >= 2)
            netInfo.id = mem.vmId;
          netInfo.name = mem.networkName;
          this.networks.push(netInfo);
        }
		this.networkCount = this.networks.length;
		
};

SORuleDesc.prototype.clone = function(){
  var sdc = new SORuleDesc();

  sdc.ruleAttribute = this.ruleAttribute;
  sdc.matchingCritaria = this.matchingCritaria;
  sdc.networkSpec = this.networkSpec;
  sdc.networkCount = this.networkCount;
  sdc.networks = [];
  for(var i =0; i< this.networks.length; i++){
     sdc.networks.push(this.networks[i].clone());
  }
  sdc.deleted = this.deleted;
  sdc.belongToAGroup = this.belongToAGroup;

  return sdc;
};

SORuleDesc.prototype.equal = function(arg){
  if(this.ruleAttribute !== arg.ruleAttribute)
  {
    return false;
  }

  if(this.matchingCritaria !== arg.matchingCritaria)
  {
    return false;
  }

  if(this.networkSpec !== arg.networkSpec)
  {
    return false;
  }
  
  if(this.networks.length !== arg.networks.length){
    return false;
  }
  for(var i =0; i<this.networks.length; i++){
    if(!this.networks[i].equal(arg.networks[i]))
    {
         return false;
    }
  }

  return true;
  
};

function SORule(){
	this.dirty = false;
	this.id = "";
	this.ruleDesc = [];
	this.resourceGroupProxy = new ResourceGroups();
	this.groupInfo = new GroupInfo();
	this.aspInfo = new ASPInfo();
	this.precedence = -1;
	this.tempId =  "";
  this.inline = false;
	this.trunkMode = false;
  this.deleted = false;
  this.resourceType = "";
}

SORule.prototype.setDiryFlag = function(arg){
   this.dirty = arg;
};

SORule.ruleAttribute ={
	NETWORK:{name:"Network of workload", id:"0", link:"NETWORK",icon:"share"},
        CIDR : {name:"CIDR", id:"1", link:"CIDR",icon:"language"},
        WORKLOAD:{name:"Workload Name", id:"2", link:"WORKLOAD",icon:"layers"},
        WORKLOAD_APP:{name:"Workload AppID", id:"3", link:"WORKLOAD",icon:"settings_applications"},
        WORKLOAD_OS:{name:"Workload OS", id:"4", link:"WORKLOAD",icon:"",svgpath:"images/ic_os.svg"}
};

SORule.matchingCritarias ={
	IS:{name:"Equals",id:"1", img:"images/ic_equals.svg"},
	CONTAINS:{name:"Contains",id:"2", img:"images/contains.svg"},
	BEGIN_WITH:{name:"Begins With",id:"3", img:"images/ic_begins_with.svg"}
};
SORule.ruleAttributeArray = [SORule.ruleAttribute.NETWORK, SORule.ruleAttribute.CIDR, SORule.ruleAttribute.WORKLOAD,SORule.ruleAttribute.WORKLOAD_APP,SORule.ruleAttribute.WORKLOAD_OS];
SORule.matchingCritariaArray =[SORule.matchingCritarias.IS, SORule.matchingCritarias.CONTAINS, SORule.matchingCritarias.BEGIN_WITH];

SORule.prototype.addSORuleDesc = function(arg) {
  if(this.ruleDesc.length > 0){
   var existing_group = _.find(this.ruleDesc,function(val){
        return  val.networkSpec === arg.networkSpec;
   });
   if(existing_group === undefined){
    this.ruleDesc.push(arg);
   }
  }else{
    this.ruleDesc.push(arg);
  }
 	
};


SORule.prototype.init =  function(arg) {

	this.id = arg.id;
	this.ruleDesc = [];
	for(var i = 0; i < arg.ruleDesc.length; i++ ){
	  var rd = new SORuleDesc();
	  rd.init(arg.ruleDesc[i]);	
      this.ruleDesc.push(rd);
	}
	
	this.resourceGroupProxy = new ResourceGroups();

	this.groupInfo = new GroupInfo();
	this.groupInfo.init(arg.groupInfo);

	this.aspInfo = new ASPInfo();
	this.aspInfo.init(arg.aspInfo);
  this.dirty = arg.dirty;
	this.precedence = arg.precedence;
	this.tempId =  arg.tempId;
  this.inline =  arg.inline;
	this.trunkMode =  arg.trunkMode;
  this.deleted = arg.deleted;
};

SORule.prototype.deleteSORuleDesc = function(arg) {
	
};

SORule.prototype.setResourceGroup = function( arg ) {
	this.resourceGroupProxy = new ResourceGroups();
};
SORule.prototype.equal = function(arg){
  var equalRes = true;

  if(this.ruleDesc.length !== arg.ruleDesc.length){
    return false;
  }

  for(var i =0; i<this.ruleDesc.length; i++){
    if(!this.ruleDesc[i].equal(arg.ruleDesc[i]))
    {
         return false;
    }
  }
  
  if(!(this.groupInfo.equal(arg.groupInfo))){
    return false;
  }

  /*if(!(this.aspInfo.equal(arg.aspInfo))){
    return false;
  }*/
  
  if(this.precedence !== arg.precedence){
    return false;
  }

  
  return true;
};
SORule.prototype.clone = function(){
  var rule = new SORule();
  rule.dirty = this.dirty;
  rule.id = this.id;
  rule.ruleDesc = [];
  for(var i = 0; i< this.ruleDesc.length; i++){
    var tempDesc = this.ruleDesc[i].clone();
    rule.ruleDesc.push(tempDesc);
  }
  rule.resourceGroupProxy = new ResourceGroups();
  rule.groupInfo = this.groupInfo.clone();
  rule.aspInfo = this.aspInfo.clone();
  rule.precedence = this.precedence;
  rule.tempId =  this.tempId;
  rule.inline = this.inline;
  rule.trunkMode = this.trunkMode;
  return rule;
};



SORule.prototype.getResourceGroup = function() {
	this.group = new ResourceGroups();
	return this.group;
};

SORule.prototype.setResourceGroup = function( arg ) {
	this.group = arg;
};

SORule.prototype.getJSONDataForPOST = function(cloudId, tenantId){

   console.log(" SORule getJSONData"); 

    var memberList = [];
    var regEx = "";
    //"name='.*backplane.*';"

    for(var i =0; i < this.ruleDesc.length; i++){
      var memberlistDesc = 	this.ruleDesc[i].getJSONDataForPOST();
      memberList = memberList.concat(memberlistDesc);
      //regEx = regEx + this.ruleDesc[i].getRegExFormat() + ";";
    } 

    
    var resourceType = "";
    var dynamic = true;
    /*switch(this.ruleDesc[0].ruleAttribute){
      case "0":
        resourceType = "NETWORK";
        break;
      case "1":
        resourceType = "CIDR";
        dynamic = false;
        break;
      case "2":
        resourceType = "VM";
        break;

    }*/
    // >=2 checks for VM based 3 conditions  viz. name,appid and os
    if(this.ruleDesc[0].ruleAttribute == "0"){
      resourceType = "NETWORK";
    } else if(this.ruleDesc[0].ruleAttribute == "1"){
      resourceType = "CIDR";
      dynamic = false;
    } else if(this.ruleDesc[0].ruleAttribute >= 2){
      resourceType = "VM";
 
    }
    this.resourceType = resourceType;
    regEx = this.genarateRegExFromRuleDesc(resourceType);
    console.log(" memberList >> "); 
    console.dir(memberList);
    console.log(" regEx >> "+regEx); 

    var data =	{
	  "cloudId": parseInt(cloudId),
	  "dynamic": dynamic,
	  "id": 0,
	  "memberList": memberList,
	  "name": this.groupInfo.name,
	  "precedence": this.precedence,
	  "regex": regEx,
	  "resourceType": resourceType,
	  "tenantId": parseInt(tenantId)
	};

	console.log(" data >> "); 
    console.dir(data);

	return data;
};
SORule.prototype.generateRuleDescFromObject = function(memberList){
  var newRuleDesc = null;
  for (var i = 0; i < memberList.length; i++) {
    newRuleDesc = new SORuleDesc();
    newRuleDesc.setMatchingCritariaAndNetworkSpec(SORule.matchingCritarias.IS.id,memberList[i].cidr);
    this.addNewSORuleDesc(newRuleDesc);
  }
};
function generateArrayData(conditionArray){
    var containCriteriaString = "";
    var startsCriteriaString = "";
    var equalCriteriaString = "";
    var remainingCriterias = [];
    var startsCriteriaArray = [];
    var equalCriteriaArray = [];
    var containCriteriaArray = [];
    //string matches contains criteria if length is 2 else no contains criteria is set
      if(conditionArray.length == 2){
        if(conditionArray[0].indexOf(")") === -1){ 
          //closing bracket checks presence of multiple networks
          containCriteriaString = conditionArray[0].substring(2,conditionArray[0].length);
        } else{
          containCriteriaString = conditionArray[0].substring(3,conditionArray[0].length-1);
        }
        console.log("contains criteria string is ",containCriteriaString);
        containCriteriaArray = containCriteriaString.split("|");
        console.log("contains criteria selected are ",containCriteriaArray);
            
        if(conditionArray[1].indexOf(")|(") === -1){
          //single instance of one of the rules
          if(conditionArray[1].indexOf(")|") !== -1){
            remainingCriterias = conditionArray[1].split(")|");
          } else if(conditionArray[1].indexOf("|(") !== -1) {
            remainingCriterias = conditionArray[1].split("|(");
          } else if(conditionArray[1].indexOf("|") !== -1) {
            remainingCriterias = conditionArray[1].split("|");
          } else {
            remainingCriterias = [conditionArray[1]];
          }
          console.log(conditionArray);
        } else{
            remainingCriterias = conditionArray[1].split(")|(");
            console.log("remaining criteria ",remainingCriterias);
            
        }
        if(remainingCriterias.length == 2){
            if(remainingCriterias[0].indexOf("(") !== -1){
              equalCriteriaArray = remainingCriterias[0].substring(1,remainingCriterias[0].length).split("|");
            } else {
              equalCriteriaArray = remainingCriterias[0].split("|");
            }
            console.log(equalCriteriaArray);
            if(remainingCriterias[1].indexOf(")") !== -1)
              startsCriteriaString = remainingCriterias[1].substring(0,remainingCriterias[1].length-3);
            else
              startsCriteriaString = remainingCriterias[1].substring(0,remainingCriterias[1].length-2);
            console.log("starts criteria ",startsCriteriaString);
            startsCriteriaArray = startsCriteriaString.split("|");
            console.log("start criteria array ",startsCriteriaArray);
          } else {
            //presence of ").*" indicates begins with criteria is present
            if(remainingCriterias[0].indexOf(".*") !== -1){
                startsCriteriaString = remainingCriterias[0].substring(0,remainingCriterias[0].length-2);
                console.log("starts criteria single ",startsCriteriaString);
                startsCriteriaArray = startsCriteriaString.split("|");
                console.log("start criteria array single ",startsCriteriaArray);
              } else {
                equalCriteriaString = remainingCriterias[0].substring(0,remainingCriterias[0].length);
                console.log("equal criteria single ",equalCriteriaString);
                equalCriteriaArray = equalCriteriaString.split("|");
                console.log("equal criteria array single ",equalCriteriaArray);
              }
          }
      } else {
      if(conditionArray[0].indexOf(")|(") === -1){
        //single instance of one of the rules
        if(conditionArray[0].indexOf(")|") !== -1){
          remainingCriterias = conditionArray[0].split(")|");
        } else if(conditionArray[0].indexOf("|(") !== -1) {
          remainingCriterias = conditionArray[0].split("|(");
        } else {
          remainingCriterias = conditionArray;
        }
        console.log(conditionArray);
      } else{
          remainingCriterias = conditionArray[0].split(")|(");
          console.log("remaining criteria ",remainingCriterias);
      }
      if(remainingCriterias.length == 2){
        equalCriteriaArray = remainingCriterias[0].split("|");
        console.log(equalCriteriaArray);
        startsCriteriaString = remainingCriterias[1].substring(0,remainingCriterias[1].length-3);
        console.log("starts criteria ",startsCriteriaString);
        startsCriteriaArray = startsCriteriaString.split("|");
        console.log("start criteria array ",startsCriteriaArray);
      } else {
          //presence of ").*" indicates begins with criteria is present
          if(remainingCriterias[0].indexOf(".*") !== -1 && remainingCriterias[0].indexOf(".*") === 0){
            if(remainingCriterias[0].indexOf("(") !== -1)
              containCriteriaString = remainingCriterias[0].substring(3,remainingCriterias[0].length-3);
            else
              containCriteriaString = remainingCriterias[0].substring(2,remainingCriterias[0].length-2);
              console.log("contains criteria single ",containCriteriaString);
              containCriteriaArray = containCriteriaString.split("|");
              console.log("contain criteria array single ",containCriteriaArray);
            } else if(remainingCriterias[0].indexOf(".*") !== -1){
              if(remainingCriterias[0].indexOf("(") !== -1)
                startsCriteriaString = remainingCriterias[0].substring(1,remainingCriterias[0].length-3);
              else
                startsCriteriaString = remainingCriterias[0].substring(0,remainingCriterias[0].length-2);
              console.log("starts criteria single ",startsCriteriaString);
              startsCriteriaArray = startsCriteriaString.split("|");
              console.log("start criteria array single ",startsCriteriaArray);
            }else {
              if(remainingCriterias[0].indexOf("(") !== -1)
                equalCriteriaString = remainingCriterias[0].substring(1,remainingCriterias[0].length-1);
              else
                equalCriteriaString = remainingCriterias[0];
              console.log("equal criteria single ",equalCriteriaString);
              equalCriteriaArray = equalCriteriaString.split("|");
              console.log("equal criteria array single ",equalCriteriaArray);
            }
        }
      }
        return {'equalCriteriaArray':equalCriteriaArray,'startsCriteriaArray':startsCriteriaArray,'containCriteriaArray':containCriteriaArray};
}
SORule.prototype.generateRuleDescFromRegex = function(regEx,resourceType){
  var newRuleDesc = null;
    var res = regEx.substring(6, regEx.length-2);
    var conditionArray = res.split(".*|");
    //var conditionArray = res.split(").*|(");
    console.log("condition is ",conditionArray);
    var parentDataObj = {};
    if(resourceType === "NETWORK"){
        parentDataObj = generateArrayData(conditionArray);
      for (var i = 0; i < parentDataObj.equalCriteriaArray.length; i++) {
        newRuleDesc = new SORuleDesc();
        newRuleDesc.setMatchingCritariaAndNetworkSpec(SORule.matchingCritarias.IS.id,parentDataObj.equalCriteriaArray[i]);
        this.addNewSORuleDesc(newRuleDesc);
      }
      for (i = 0; i < parentDataObj.startsCriteriaArray.length; i++) {
        newRuleDesc = new SORuleDesc();
        newRuleDesc.setMatchingCritariaAndNetworkSpec(SORule.matchingCritarias.BEGIN_WITH.id,parentDataObj.startsCriteriaArray[i]);
        this.addNewSORuleDesc(newRuleDesc);
      }
      for (i = 0; i < parentDataObj.containCriteriaArray.length; i++) {
        newRuleDesc = new SORuleDesc();
        newRuleDesc.setMatchingCritariaAndNetworkSpec(SORule.matchingCritarias.CONTAINS.id,parentDataObj.containCriteriaArray[i]);
        this.addNewSORuleDesc(newRuleDesc);
      }
    }else if(resourceType === "VM") {
      if(regEx === "name='.*';"){
        this.generateSOdec(['.*'],SORule.matchingCritarias.IS.id,SORule.ruleAttribute.WORKLOAD.id);
      } else {
        var expressionArray = regEx.split(";");
        var mappedString = "";
        var equalCriteriaArrayOS = [];
        var startsCriteriaArrayOS = [];
        var containCriteriaArrayOS = [];
        var equalCriteriaArrayApp = [];
        var startsCriteriaArrayApp = [];
        var containCriteriaArrayApp = [];
        var equalCriteriaArrayName = [];
        var startsCriteriaArrayName = [];
        var containCriteriaArrayName = [];
        var innerArray = [];
        var innerCounter = 0;
        for (var k = expressionArray.length - 1; k >= 0; k--) {
            //this will check if os/app/name is present or not
            var osStartindex = expressionArray[k].indexOf("os");
            var appStartindex = expressionArray[k].indexOf("application");
            var nameStartindex = expressionArray[k].indexOf("name");
            var presentornot = -1;
            var stringTocheck = "";
            if(osStartindex !== -1){
              //presence of ?= shows multiple os present
              if(expressionArray[k].indexOf("?=") !== -1){
                innerArray = expressionArray[k].split("(?=.*os='");
                for (innerCounter = innerArray.length - 1; innerCounter >= 0; innerCounter--) {
                    //means this is the first iteration from end i.e. the last item
                    if(innerArray[innerCounter] !== ""){
                      if(innerCounter === (innerArray.length - 1) ){
                        stringTocheck = innerArray[innerCounter].substring(0,innerArray[innerCounter].length-4);
                      } else {
                        stringTocheck = innerArray[innerCounter].substring(0,innerArray[innerCounter].length-2);
                      }
                      presentornot = stringTocheck.indexOf(".*");
                      if(presentornot === -1){
                        //it is the final string with equal to condition
                        mappedString = stringTocheck;
                        equalCriteriaArrayOS.push(mappedString);
                      } else if(presentornot === 0){ //4 matches os=' these 4 characters
                        console.log(stringTocheck+" :missed value: ");
                        mappedString = stringTocheck.substring(2,stringTocheck.length-2);
                        containCriteriaArrayOS.push(mappedString);
                      } else if(presentornot > 0){ //>4 indicates string is with something like os='a.*'
                        mappedString = stringTocheck.substring(0,stringTocheck.length-2);
                        startsCriteriaArrayOS.push(mappedString);
                      }
                    }
                }

              } else {
                //absence shows single os is present
                presentornot = expressionArray[k].indexOf(".*");
                if(presentornot === -1){
                  //it is the final string with equal to condition
                  mappedString = expressionArray[k].substring(osStartindex+4,expressionArray[k].length-1);
                  equalCriteriaArrayOS.push(mappedString);
                } else if(presentornot === 4){ //4 matches os=' these 4 characters
                  mappedString = expressionArray[k].substring(osStartindex+6,expressionArray[k].length-3);
                  containCriteriaArrayOS.push(mappedString);
                } else if(presentornot > 4){ //>4 indicates string is with something like os='a.*'
                  mappedString = expressionArray[k].substring(osStartindex+4,expressionArray[k].length-3);
                  startsCriteriaArrayOS.push(mappedString);
                }
              }
            }
            else if(appStartindex !== -1){
            //this will check if application is present or not
              if(expressionArray[k].indexOf("?=") !== -1){
                innerArray = expressionArray[k].split("(?=.*application='");
                for (innerCounter = innerArray.length - 1; innerCounter >= 0; innerCounter--) {
                    //means this is the first iteration from end i.e. the last item
                    if(innerArray[innerCounter] !== ""){
                      if(innerArray[innerCounter] !== ""){
                      if(innerCounter === (innerArray.length - 1) ){
                        stringTocheck = innerArray[innerCounter].substring(0,innerArray[innerCounter].length-4);
                      } else {
                        stringTocheck = innerArray[innerCounter].substring(0,innerArray[innerCounter].length-2);
                      }
                      presentornot = stringTocheck.indexOf(".*");
                        console.log("asdfasdf "+stringTocheck);
                      if(presentornot === -1){
                        //it is the final string with equal to condition
                        mappedString = stringTocheck;
                        equalCriteriaArrayApp.push(mappedString);
                      } else if(presentornot === 0){ //4 matches os=' these 4 characters
                        mappedString = stringTocheck.substring(2,stringTocheck.length-2);
                        containCriteriaArrayApp.push(mappedString);
                      } else if(presentornot > 0){ //>4 indicates string is with something like os='a.*'
                        mappedString = stringTocheck.substring(0,stringTocheck.length-2);
                        startsCriteriaArrayApp.push(mappedString);
                      }
                    }
                    }
                }

              } else {
                //absence shows single app is present
                presentornot = expressionArray[k].indexOf(".*");
                if(presentornot === -1){
                  //it is the final string with equal to condition
                  mappedString = expressionArray[k].substring(appStartindex+13,expressionArray[k].length-1);
                  equalCriteriaArrayApp.push(mappedString);
                } else if(presentornot === 13){ //13 matches application=' these 13 characters
                  mappedString = expressionArray[k].substring(appStartindex+15,expressionArray[k].length-3);
                  containCriteriaArrayApp.push(mappedString);
                } else if(presentornot > 13){ //>13 indicates string is with something like os='a.*'
                  mappedString = expressionArray[k].substring(appStartindex+13,expressionArray[k].length-3);
                  startsCriteriaArrayApp.push(mappedString);
                }
              }
            } else if(nameStartindex !== -1){
              /*console.log(nameStartindex+" nameStartindex");
              //absence shows single os is present
                presentornot = expressionArray[k].indexOf(".*");
              console.log("new value s "+expressionArray[k]);
                if(presentornot === -1){
                  //it is the final string with equal to condition
                  mappedString = expressionArray[k].substring(nameStartindex+6,expressionArray[k].length-1);
                  equalCriteriaArrayName.push(mappedString);
                } else if(presentornot === 6){ //13 matches name=' these 13 characters
                  mappedString = expressionArray[k].substring(nameStartindex+8,expressionArray[k].length-3);
                  containCriteriaArrayName.push(mappedString);
                } else if(presentornot > 6){ //>6 indicates string is with something like name='a.*'
                  mappedString = expressionArray[k].substring(nameStartindex+6,expressionArray[k].length-3);
                  startsCriteriaArrayName.push(mappedString);
                }*/
                var arrayData = expressionArray[k].substring(nameStartindex+6,expressionArray[k].length-1).split(".*|");
                parentDataObj = generateArrayData(arrayData);
              }
            }

        //generate sodesc now 
        this.generateSOdec(equalCriteriaArrayOS,SORule.matchingCritarias.IS.id,SORule.ruleAttribute.WORKLOAD_OS.id);
        this.generateSOdec(startsCriteriaArrayOS,SORule.matchingCritarias.BEGIN_WITH.id,SORule.ruleAttribute.WORKLOAD_OS.id);
        this.generateSOdec(containCriteriaArrayOS,SORule.matchingCritarias.CONTAINS.id,SORule.ruleAttribute.WORKLOAD_OS.id);

        this.generateSOdec(equalCriteriaArrayApp,SORule.matchingCritarias.IS.id,SORule.ruleAttribute.WORKLOAD_APP.id);
        this.generateSOdec(startsCriteriaArrayApp,SORule.matchingCritarias.BEGIN_WITH.id,SORule.ruleAttribute.WORKLOAD_APP.id);
        this.generateSOdec(containCriteriaArrayApp,SORule.matchingCritarias.CONTAINS.id,SORule.ruleAttribute.WORKLOAD_APP.id);


        this.generateSOdec(parentDataObj.equalCriteriaArray,SORule.matchingCritarias.IS.id,SORule.ruleAttribute.WORKLOAD.id);
        this.generateSOdec(parentDataObj.startsCriteriaArray,SORule.matchingCritarias.BEGIN_WITH.id,SORule.ruleAttribute.WORKLOAD.id);
        this.generateSOdec(parentDataObj.containCriteriaArray,SORule.matchingCritarias.CONTAINS.id,SORule.ruleAttribute.WORKLOAD.id);
      }


    }
    

};
SORule.prototype.generateSOdec = function(arraytoIterate,matchCriteria,ruleAttribute){
  for (var i = 0; i < arraytoIterate.length; i++) {
    newRuleDesc = new SORuleDesc();
    newRuleDesc.setMatchingCritariaAndNetworkSpec(matchCriteria,arraytoIterate[i],ruleAttribute);
    this.addNewSORuleDesc(newRuleDesc);
  }
};
      
SORule.prototype.genarateRegExFromRuleDesc = function(resourceType)
{
  //CIDR does not require any regex as it is static type of group
  if(resourceType === "CIDR")
    return ;
	/*if(this.matchingCritaria === SORule.matchingCritarias.IS.id){
 		regEx = "name=\'"+this.networkSpec+"\'";
 	}else if(this.matchingCritaria === SORule.matchingCritarias.BEGIN_WITH.id){
 		regEx = "name=\'"+this.networkSpec+".*\'";
 	}else if(this.matchingCritaria === SORule.matchingCritarias.CONTAINS.id){
 		regEx = "name='\.*"+this.networkSpec+".*\'";
 	}*/

 	var isRegexStr = "";	
  var containRegex = "";
  var beginWithRegex = "";
  var matchCtr = "";  
  var networkSpec = "";  
  if(resourceType === "NETWORK"){
       for(var i =0; i < this.ruleDesc.length; i++){
       	    matchCtr = this.ruleDesc[i].matchingCritaria;
            networkSpec =  this.ruleDesc[i].networkSpec;
            if( matchCtr === SORule.matchingCritarias.IS.id){
            	if(isRegexStr === ""){
            		isRegexStr = isRegexStr + networkSpec;
            	}else
            	{
            		isRegexStr = isRegexStr +"|"+ networkSpec;
            	}
            } else if(matchCtr === SORule.matchingCritarias.CONTAINS.id){
                if(containRegex === ""){
            		containRegex = containRegex + networkSpec;
            	}else
            	{
            		containRegex = containRegex +"|"+ networkSpec;
            	}
            }else if(matchCtr === SORule.matchingCritarias.BEGIN_WITH.id){
                if(beginWithRegex === ""){
            		beginWithRegex = beginWithRegex + networkSpec;
            	}else
            	{
            		beginWithRegex = beginWithRegex +"|"+ networkSpec;
            	}
            }
        }

        var finalRegex = "";
        if(containRegex !== ""){
          if(containRegex.indexOf("|") !== -1)
           finalRegex = ".*("+containRegex+").*";
          else
           finalRegex = ".*"+containRegex+".*";
        }

        if(isRegexStr !== ""){
          var isReg = ""; 
         
          if(isRegexStr.indexOf("|") !== -1)
           isReg = "("+isRegexStr+")";
          else
           isReg = isRegexStr;

          if(finalRegex !== ""){
          finalRegex = finalRegex+"|"+isReg;
            } else{
              finalRegex = isReg;
            }
        }

        if(beginWithRegex !== ""){
           var bgRe = "";

           if(beginWithRegex.indexOf("|") !== -1)
           bgRe = "("+beginWithRegex+").*";
          else
           bgRe = ""+beginWithRegex+".*";
         
           if(finalRegex !== ""){
             finalRegex = finalRegex+"|"+bgRe;
            } else{
              finalRegex = bgRe;
            }
        }

    //name='(database|app|web).*';
      var nameRegex = "name=\'"+finalRegex+"\';";
       return nameRegex;
     }
  else if(resourceType === "VM"){
    var nameVM = "";
    var osVM = "";
    var appVM = "";
    var osVMis ="";
    var osVMbegins ="";
    var osVMcontains ="";
    var appVMis ="";
    var appVMbegins ="";
    var appVMcontains ="";
    for(var j =0; j < this.ruleDesc.length; j++){
            matchCtr = this.ruleDesc[j].matchingCritaria;
            networkSpec =  this.ruleDesc[j].networkSpec;
            //ruleAttribute 2 is for workload name
            if(this.ruleDesc[j].ruleAttribute == "2"){
              if( matchCtr === SORule.matchingCritarias.IS.id){
                if(isRegexStr === ""){
                  isRegexStr = isRegexStr + networkSpec;
                }else
                {
                  isRegexStr = isRegexStr +"|"+ networkSpec;
                }
              } else if(matchCtr === SORule.matchingCritarias.CONTAINS.id){
                  if(containRegex === ""){
                  containRegex = containRegex + networkSpec;
                }else
                {
                  containRegex = containRegex +"|"+ networkSpec;
                }
              }else if(matchCtr === SORule.matchingCritarias.BEGIN_WITH.id){
                  if(beginWithRegex === ""){
                  beginWithRegex = beginWithRegex + networkSpec;
                }else
                {
                  beginWithRegex = beginWithRegex +"|"+ networkSpec;
                }
              }
            }else if(this.ruleDesc[j].ruleAttribute == "3"){
              
              if( matchCtr === SORule.matchingCritarias.IS.id){
                if(appVM === ""){
                  appVM = "application='"+ networkSpec + "'";
                }else
                {
                  if(appVM.indexOf("?=") === -1)
                    appVM = "(?=.*"+ appVM + ")";

                  appVM = appVM + "(?=.*application='"+networkSpec+"')";
                }
              } else if(matchCtr === SORule.matchingCritarias.CONTAINS.id){
                  if(appVM === ""){
                    appVM = "application='.*"+ networkSpec + ".*'";
                }else
                {
                  if(appVM.indexOf("?=") === -1)
                    appVM = "(?=.*"+ appVM + ")";

                  appVM = appVM + "(?=.*application='.*"+ networkSpec + ".*')";
                }
              }else if(matchCtr === SORule.matchingCritarias.BEGIN_WITH.id){
                  if(appVM === ""){
                  appVM = "application='"+ networkSpec + ".*'";
                }else
                {
                  if(appVM.indexOf("?=") === -1)
                    appVM = "(?=.*"+ appVM + ")";

                  appVM = appVM + "(?=.*application='"+ networkSpec + ".*')";
                }
              }

            }else if(this.ruleDesc[j].ruleAttribute == "4"){
              if( matchCtr === SORule.matchingCritarias.IS.id){
                if(osVM === ""){
                  osVM = "os='"+ networkSpec + "'";
                }else
                {
                  if(osVM.indexOf("?=") === -1)
                    osVM = "(?=.*"+ osVM + ")";

                  osVM = osVM + "(?=.*os='"+networkSpec+"')";
                }
              } else if(matchCtr === SORule.matchingCritarias.CONTAINS.id){
                  if(osVM === ""){
                    osVM = "os='.*"+ networkSpec + ".*'";
                }else
                {
                  if(osVM.indexOf("?=") === -1)
                    osVM = "(?=.*"+ osVM + ")";

                  osVM = osVM + "(?=.*os='.*"+ networkSpec + ".*')";
                }
              }else if(matchCtr === SORule.matchingCritarias.BEGIN_WITH.id){
                  if(osVM === ""){
                  osVM = "os='"+ networkSpec + ".*'";
                }else
                {
                  if(osVM.indexOf("?=") === -1)
                    osVM = "(?=.*"+ osVM + ")";

                  osVM = osVM + "(?=.*os='"+ networkSpec + ".*')";
                }
              }
            }
        }
      var finalRegexVMName = "";
      if(containRegex !== ""){
          if(containRegex.indexOf("|") !== -1)
           finalRegexVMName = ".*("+containRegex+").*";
          else
           finalRegexVMName = ".*"+containRegex+".*";
        }

        if(isRegexStr !== ""){
          var isRegVM = ""; 
         
          if(isRegexStr.indexOf("|") !== -1)
           isRegVM = "("+isRegexStr+")";
          else
           isRegVM = isRegexStr;

          if(finalRegexVMName !== ""){
          finalRegexVMName = finalRegexVMName+"|"+isRegVM;
            } else{
              finalRegexVMName = isRegVM;
            }
        }

        if(beginWithRegex !== ""){
           var bgReVM = "";

           if(beginWithRegex.indexOf("|") !== -1)
           bgReVM = "("+beginWithRegex+").*";
          else
           bgReVM = ""+beginWithRegex+".*";
         
           if(finalRegexVMName !== ""){
             finalRegexVMName = finalRegexVMName+"|"+bgReVM;
            } else{
              finalRegexVMName = bgReVM;
            }
        }

      if(finalRegexVMName !== "")
        nameVM = "name=\'"+finalRegexVMName+"\';";
      if(appVM !== ""){
        if(appVM.indexOf("?") === -1){
          appVM = appVM + ";";
        } else {
          appVM = appVM + ".*;";
        }
      }
      if(osVM !== ""){
        if(osVM.indexOf("?") === -1){
          osVM = osVM + ";";
        } else {
          osVM = osVM + ".*;";
        }
      }
      return nameVM+appVM+osVM;
    }     
    
};

SORule.prototype.addNewSORuleDesc =function(rds){
  var findDs = _.find(this.ruleDesc,function(desc){
      return (desc.networkSpec === rds.networkSpec) && (desc.matchingCritaria === rds.matchingCritaria);
  });

  if(!findDs){
    this.ruleDesc.push(rds);
  }
};

SORule.prototype.genarateRuleDescFromRegEx = function( regex )
{
   //regex = '.*(VM Network 21|VM Network 23).*| (VM Network 19|VM Network 9)';
   var newRuleDesc = null;
	
   var conatinsRegex = new RegExp("^[^*]*(?:\\*[^*]*){2}$");
   var containsRegEx = /(\.\*\().*(\)\.\*)/;

    if(containsRegEx.test(regex)){
    	var containsVal = containsRegEx.exec(regex);
        console.log(" genarateRuleDescFromRegEx >>>>>>>>>>>> 1");
        console.dir(containsVal);
        if(containsVal.length === 3){
        	var containReg = containsVal[0].substring(3,containsVal[0].length-3);
        	if(containReg.indexOf("|") -1){
               var containRegArray =  containReg.split("|");
                for(var i = 0; i < containRegArray.length; i++){
                    newRuleDesc = new SORuleDesc();
        		        newRuleDesc.setMatchingCritariaAndNetworkSpec(SORule.matchingCritarias.CONTAINS.id,containRegArray[i]);
                    this.addNewSORuleDesc(newRuleDesc);
                }
        	} else{
        		newRuleDesc = new SORuleDesc();
        		newRuleDesc.setMatchingCritariaAndNetworkSpec(SORule.matchingCritarias.CONTAINS.id,containReg);
            this.addNewSORuleDesc(newRuleDesc);
        	}
        }

        regex = regex.substring(containsVal[0].length);
    } 

    // Begins with 
      var beginsWithRegEx = /(\().*(\)\.\*)/;
      if(beginsWithRegEx.test(regex)){
    	var beginsWithVal = beginsWithRegEx.exec(regex);
        console.log(" genarateRuleDescFromRegEx >>>>>>>>>>>> 2");
        console.dir(beginsWithVal);
        if(beginsWithVal.length === 3){
        	var beginWithReg = beginsWithVal[0].substring(1,beginsWithVal[0].length-3);
        	if(beginWithReg.indexOf("|") -1){
               var beginWithRegArray =  beginWithReg.split("|");
                for(var k = 0; k < beginWithRegArray.length; k++){
                 newRuleDesc = new SORuleDesc();
        		 newRuleDesc.setMatchingCritariaAndNetworkSpec(SORule.matchingCritarias.BEGIN_WITH.id, beginWithRegArray[k]);
                 this.addNewSORuleDesc(newRuleDesc);
                }
        	} else{
        		newRuleDesc = new SORuleDesc();
        		newRuleDesc.setMatchingCritariaAndNetworkSpec(SORule.matchingCritarias.BEGIN_WITH.id, beginWithReg);
                this.addNewSORuleDesc(newRuleDesc);
        	}
        }

        regex = regex.substring(beginsWithVal[0].length);
    } 

    var isRegEx = /(\().*(\))/;
      if(isRegEx.test(regex)){
    	var isRegExVal = isRegEx.exec(regex);
        console.log(" genarateRuleDescFromRegEx >>>>>>>>>>>> 3");
        console.dir(isRegExVal);
        if(isRegExVal.length === 3){
        	var isReg = isRegExVal[0].substring(1,isRegExVal[0].length-1);
        	if(isReg.indexOf("|") -1){
               var isRegArray =  isReg.split("|");
                for(var l = 0; l < isRegArray.length; l++){
                  newRuleDesc = new SORuleDesc();
        		      newRuleDesc.setMatchingCritariaAndNetworkSpec(SORule.matchingCritarias.IS.id, isRegArray[l]);
                 this.addNewSORuleDesc(newRuleDesc);
                }
        	} else{
        		newRuleDesc = new SORuleDesc();
        		newRuleDesc.setMatchingCritariaAndNetworkSpec(SORule.matchingCritarias.IS.id, isReg);
            this.raddNewSORuleDesc(newRuleDesc);
        	}
        }

        regex = regex.substring(isRegExVal[0].length);
    } 
    
   console.log(" genarateRuleDescFromRegEx final >>>>>>>>>>> ");
   console.dir(this.ruleDesc);
      
   return this.ruleDesc;
};

SORule.prototype.mergeExistingGroup = function( group ) {

	// clean up if existing group info before merging
    _.remove(this.ruleDesc, function (rd) {
	  return rd.belongToAGroup;
	});
    var resourceTypeId = SORule.ruleAttribute.NETWORK.id;
	/*if(group.resourceType)
	{*/
      _.forOwn(SORule.ruleAttribute, function(value, key) {
		  console.log(key);
		}); 
	//}

	//this.genarateRuleDescFromRegEx(group.regex);
  if(typeof group.resourceType !== "undefined" && group.resourceType === "CIDR"){
    this.generateRuleDescFromObject(group.memberList);
  } else {
    this.generateRuleDescFromRegex(group.regex,group.resourceType);
  }
	/*var totalRegex = group.regex.split(";");
	for(var i=0;i<totalRegex.length-1;i++){
		var newRuleDesc = new SORuleDesc();
		newRuleDesc.belongToAGroup = true;
		newRuleDesc.initializeFromExistingGroup(totalRegex[i], group.memberList, resourceTypeId);
		newRuleDesc.ruleAttribute = 0;
		this.ruleDesc.push(newRuleDesc);
	}*/
  var ruleAttribute = 0;
  switch(group.resourceType){
    case "CIDR" :
      ruleAttribute = 1;
      break;
    case "VM" :
      ruleAttribute = 2;
      break;
  }
	for(var i=0; i < this.ruleDesc.length; i++){
		var newRuleDesc = this.ruleDesc[i];
    
    if(!newRuleDesc.networks.length)
      newRuleDesc.initializeFromExistingGroup(group.memberList,ruleAttribute);

		newRuleDesc.belongToAGroup = true;
    if(!newRuleDesc.ruleAttribute)
		  newRuleDesc.ruleAttribute = ruleAttribute;
	}

	this.groupInfo = new GroupInfo();
	this.groupInfo.id = group.id;
	this.groupInfo.name = group.name;
	this.id = group.id;
	this.precedence = group.precedence;
};

function SORuleUtil(){

}
SORuleUtil.getExistingVitrialChassisJSON = function(vcId, VcName, datapathDeploySpecId,  SORulesRef, exitSubscriptionList){

	console.log("getExistingVitrialChassisJSON exitSubscriptionList ");
	console.dir(exitSubscriptionList);

	var subscriptionList = [];

	/* jshint ignore:start */
	for(var i = 0 ; i < SORulesRef.length; i++){
         var SORuleRef = SORulesRef[i];
         var subDataId = null;
         var subFind = _.find(exitSubscriptionList, function(sl){
         	return SORuleRef.groupInfo.id === sl.resourceGroupId;
         });

         if(subFind){
             subDataId = subFind.id; 
         }
         var subData = {
		      "id": subDataId,
          "inline": SORuleRef.inline,
		      "trunk": SORuleRef.trunkMode,
		      "resourceGroupId": SORuleRef.groupInfo.id,
		      "spsId": SORuleRef.aspInfo.id
		 };

		 subscriptionList.push(subData);
	}
	/* jshint ignore:end */

	var data = {
	  "datapathDeploySpecId": datapathDeploySpecId,
	  "descr": "string",
	  "id": vcId,
	  "name": VcName,
	  "subscriptionList": subscriptionList
	};

	console.log(" SORuleUtil getExistingVitrialChassisJSON ");
	console.dir(data);	

    return data;

};
SORuleUtil.getNewVitrialChassisJSON = function(VcName, datapathDeploySpecId,  SORulesRef){
	
	var subscriptionList = [];
	for(var i = 0 ; i < SORulesRef.length; i++){
         var SORuleRef = SORulesRef[i];
         
         var subData = {
		      "id": 0,
          "inline": SORuleRef.inline,
		      "trunk": SORuleRef.trunkMode,
		      "resourceGroupId": SORuleRef.groupInfo.id,
		      "spsId": SORuleRef.aspInfo.id
		 };

		 subscriptionList.push(subData);
	}

	var data = {
	  "datapathDeploySpecId": datapathDeploySpecId,
	  "descr": "string",
	  "id": 0,
	  "name": VcName,
	  "subscriptionList": subscriptionList
	};

	console.log(" SORuleUtil getVitrialChassisJSON ");
	console.dir(data);	

    return data;
};



(function () {
    function createNewGroupDialogCtr($scope, $mdDialog, existingGroups) {
        
        $scope.groupName = "";
        $scope.errorMessage = {show:false ,text:"Group already exists"};
        
        $scope.hide = function () {
            $mdDialog.hide();
        };
        $scope.closeDialog = function () {
            $mdDialog.cancel();
        };
        $scope.answer = function (answer) {
          var foundRG = _.find(existingGroups, function(eg){
            return eg.name === $scope.groupName;
          });
          if(foundRG){
               $scope.errorMessage.show = true;
          } else{
             $mdDialog.hide($scope.groupName);
          }
         
        };
    }
    angular.module('shieldxApp').controller('createNewGroupDialogCtr', createNewGroupDialogCtr);

})();
/*
ShieldX Networks Inc. CONFIDENTIAL
----------------------------------
*
Copyright (c) 2016 ShieldX Networks Inc.
All Rights Reserved.
*
NOTICE: All information contained herein is, and remains
the property of ShieldX Networks Incorporated and its suppliers,
if any. The intellectual and technical concepts contained
herein are proprietary to ShieldX Networks Incorporated
and its suppliers and may be covered by U.S. and Foreign Patents,
patents in process, and are protected by trade secret or copyright law.
Dissemination of this information or reproduction of this material
is strictly forbidden unless prior written permission is obtained
from ShieldX Networks Incorporated.
*/

(function () {
    function orchestrationRuleDirective() {
        var directive = {};
        directive.restrict = 'E';
        directive.replace = true;
        directive.templateUrl = 'core/directive/security-orchestration/rule/orchestration-rule-template.html';
        directive.scope = {
          orcloudid :  "=" ,
          ortenantid : "=" ,
          rule : "=",
          configinfo : "=",
          broadcastevent: '&',
          editstate : "="
        };
        directive.link = function(scope, element, attrs) {
           console.log(" llink "+scope);    
           scope.$watchCollection('rule', function(newValue, oldValue) {
                if (newValue){
                    console.log(" new rule has been intor duced ");
                     scope.updateRule();
                }
            }, true);
            scope.$watch('ortenantid',function(newv,oldv){
              if(newv && newv !== -1){
                console.log("new Tenant value" + newv);
                 scope.getAllSpsPolicycies();
              }
           });
        };
        directive.controller = ['$scope','$mdDialog','policyService',function ($scope,$mdDialog,policyService) {

            
            
            var vChassisSelectedDeploymentSpec = "";
            console.log("Console from inline mode : :  "+ $scope.inlineModeAvailable);
            console.log(SORule);
            $scope.ruleAttributes = SORule.ruleAttributeArray;
            $scope.matchCritaria  = SORule.matchingCritariaArray;
            console.log(" orchestrationRuleDirective ");
            console.log(" cloudid "+$scope.orcloudid);
            console.log(" ortenantid "+$scope.ortenantid);
            console.dir($scope.configinfo );
            console.log("edit state is "+$scope.editstate);
            $scope.$on('cloudChanged', function (event, args) {
                console.log(" orchestrationRuleDirective cloudChanged event called  >>>> " + args);
            });
            $scope.updateCriteria = function(ruleChanged){
              if(ruleChanged.ruleAttribute == 1)
                ruleChanged.matchingCritaria = 1;
            };
            $scope.$watch('outerMainForm.$valid', function(validity) {
              $scope.$emit('mainformvalidityChanged',{validity:validity});
            });
            $scope.$on('checkMainForm',function(event,args){
              if(typeof $scope.outerMainForm.$valid !== "undefined")
                $scope.$emit('mainformvalidityChanged',{validity:$scope.outerMainForm.$valid});
            });
            $scope.$on('tenatChanged', function (event, args) {
                console.log(" orchestrationRuleDirective tenatChanged event called  >>>> " + args);
               // console.dir(arg);
            });
            
            $scope.ruleDesc = [new SORuleDesc()]; 
            $scope.groupInfo = null; 
            $scope.aspInfo =  null;
            $scope.skipUpdate = false;
            $scope.inline = false;
            $scope.trunkMode = false;
            $scope.existingGroups = [];

            if($scope.rule && $scope.rule.groupInfo.name !== ""){
               var newGroup = {id:$scope.rule.groupInfo.id , name:$scope.rule.groupInfo.name, existing:true};
               $scope.existingGroups.push(newGroup);
            }
//            console.log("I am writing from here : :");
//            console.log($scope.rule);
            
            $scope.$on(SOEvents.newRuleCreationCanceledEvent, function(){
              $scope.outerMainForm.$setPristine();
              $scope.outerMainForm.$setUntouched();
            });
            $scope.$on('createNewRuleClick', function(){
              $scope.outerMainForm.$setPristine();
              $scope.outerMainForm.$setUntouched();
               $scope.showDeleteTotalRuleButton = false;
            });
            $scope.$on('EditRuleClicked', function (event, args) {
               $scope.existingRulesInMemory = args.rule;
               $scope.showDeleteTotalRuleButton = true;
            });
            $scope.onDeleteTotalRule = function(event,ruleDescArray){
              $mdDialog.show({
                    controller: 'confirmDeleteGroupDialogCtr',
                    templateUrl: 'core/directive/security-orchestration/rule/delete-group-dialog.html',
                    parent: angular.element(document.body),
                    targetEvent: event,
                    clickOutsideToClose: true,
                    locals:{
                        ruleref:ruleDescArray
                    },
                    skipHide: true
                   
                }).then(function (answerVal) {
                  $scope.existingRulesInMemory.deleted = true;
                  $scope.existingRulesInMemory.dirty = true;
                  $scope.broadcastevent({event:"onTotalDeleteStateChange", args:{rule:$scope.existingRulesInMemory}});
                }, function () {
                    
                });
                
                 //console.log("Delete Total Rule ");
            };
            $scope.updateRule = function(){
                if($scope.skipUpdate)
                {
                  $scope.skipUpdate = false;
                  return;
                }
               if($scope.rule){ 
                   $scope.existingGroups = [];
                  if($scope.rule && $scope.rule.groupInfo.name !== ""){
                     var newGroup = {id:$scope.rule.groupInfo.id , name:$scope.rule.groupInfo.name, existing:true};
                     $scope.existingGroups.push(newGroup);
                  }   
                  $scope.ruleDesc = $scope.rule.ruleDesc;
                  $scope.groupInfo = $scope.rule.groupInfo;
                  if($scope.rule.aspInfo.id === '' &&  $scope.rule.aspInfo.name === '' && $scope.noneSpsPolicy){
                    $scope.aspInfo = {"id":$scope.noneSpsPolicy.id,"name":$scope.noneSpsPolicy.name};
                  }else{
                    $scope.aspInfo = $scope.rule.aspInfo;  
                  }
                  $scope.inline = $scope.rule.inline;
                  $scope.trunkMode = $scope.rule.trunkMode;
                console.log("updateRule >>>>");
                console.dir($scope.rule);
                console.dir($scope.ruleDesc);
               }
            };  

            $scope.addMoreRules = function(ruleAttribute){
                console.log(" addMoreRules "+$scope.ruleDesc.length);
                $scope.skipUpdate = true;
                var tempRuleDesc = new SORuleDesc();
                tempRuleDesc.ruleAttribute = ruleAttribute;
                $scope.ruleDesc.push(tempRuleDesc);
                console.log(" addMoreRules "+$scope.ruleDesc.length);
            };

           $scope.onDeleteDescClicked = function(key)
           {
               var ruleDesc = $scope.ruleDesc[key];
              if(ruleDesc){
                 $scope.broadcastevent({event:SOEvents.ruleDescDeletedEvent, args:{ruleDescRef:ruleDesc}});
                 console.log(" onDeleteDescClicked "); 
                 $scope.ruleDesc.splice(key,1);
              }
               

           };

           
            $scope.addMoreRulesClicked = function(event,startRule){
                  $scope.addMoreRules(startRule.ruleAttribute);
            };


            $scope.selectSPS = function(sps){
                  console.log(" selectSPS "); 
                  console.dir(sps);   
                  var aspInfo = new ASPInfo();
                  aspInfo.name = sps.name;
                  aspInfo.id = sps.id;
                  if( $scope.rule){
                    $scope.rule.aspInfo = aspInfo;  
                    $scope.broadcastevent({event:SOEvents.spsChangeEvent, args:{asp:$scope.rule.aspInfo}});
                  }
              
            };
            $scope.updateInline = function(){
              $scope.rule.inline = $scope.inline;
              if($scope.inline)
                $scope.rule.trunkMode = false;
            };
            $scope.toggleTrunk = function(){
              $scope.rule.trunkMode = $scope.trunkMode;
            };
            $scope.noneSpsPolicy  = {};
            $scope.getAllSpsPolicycies = function(){
                //policyService.getSPSByTenant($scope.ortenantid).then(function(data){
                policyService.getSecurityPolicySet().then(function(data){
                   var noneData = {};
                   noneData = _.find(data,{'isNull':true});
                   /*if(noneData === undefined){ 
                     noneData = {"accessControlPolicyId":1,
                      "id":9,
                      "lastModified":1482578470798,
                      "malwarePolicyId":3,
                      "name":"None",
                      "tenantId":1,
                      "threatPreventionPolicyId":1};
                      if(data){
                        data.push(noneData);  
                      }else{
                        data = [noneData];  
                      }
                  }*/
                    $scope.existingSPS = data;
                   console.dir($scope.existingSPS);
                   $scope.noneSpsPolicy = noneData;
                   $scope.selectSPS($scope.noneSpsPolicy);
                   $scope.broadcastevent({event:SOEvents.noneSpsPolicy, args:{asp:$scope.noneSpsPolicy}});
                   //$scope.spsFetched = true;
                }, function(error){

              });
            };
            
             $scope.helpButtonClicked = function(id){
                $scope.active_help_id = id;
                console.log("  helpButtonClicked ");
                $scope.bordcastEventHelpButtonClicked($scope.active_help_id);
            }; 
            $scope.bordcastEventHelpButtonClicked = function(helpId){
              $scope.broadcastevent({event:SOEvents.popUpMenuSelectionChangeEvent, args:{selection:"guid",guideUrl:helpId}});
             }; 
            $scope.selectGroup = function(group){
               console.log("selectNewGroup");
               console.dir(group);
               if(!group.existing){
                   if(!$scope.rule.groupInfo.name){
                      var groupinfo = new GroupInfo();
                      groupinfo.name = group.name;
                      groupinfo.id =-1;
                      $scope.rule.groupInfo = groupinfo;
                    } else {
                      $scope.rule.groupInfo.name = group.name;
                    }
                } else {
                  $scope.rule.mergeExistingGroup(group.data);
               }
               
               $scope.groupInfo = $scope.rule.groupInfo;

               console.log("group info selectNewGroup");
               console.dir($scope.rule);
               $scope.broadcastevent({event:SOEvents.groupChangeEvent, args:{group:$scope.groupInfo}});
               if($scope.rule.aspInfo.id === '' && $scope.rule.aspInfo.name === '' ){
                  $scope.selectSPS($scope.noneSpsPolicy); 
               }
               
            };


            $scope.showGropSelectionDialog = function(event) {
                console.log(" showGropSelectionDialog "+$scope.existingGroups.length);
                console.dir($scope.existingGroups);
                $mdDialog.show({
                    controller: 'showGroupSelectionDialogCtr',
                    templateUrl: 'core/directive/security-orchestration/rule/select-group-dialog.html',
                    parent: angular.element(document.body),
                    targetEvent: event,
                    clickOutsideToClose: true,
                    locals:{
                        existingGroups:$scope.existingGroups,
                        tenantid:$scope.ortenantid,
                        cloudid:$scope.orcloudid,
                        groupInfo:$scope.rule.groupInfo
                    },
                    skipHide: true
                   
                }).then(function (answerVal) {
                    $scope.selectGroup(answerVal);
                }, function () {
                    
                });
            };

            $scope.showSPSSelectionDialog = function(event,seletedSpsData) {
                   $mdDialog.show({
                    controller: 'showASPSelectionDialogCtr',
                    templateUrl: 'core/directive/security-orchestration/rule/select-asp-dialog.html',
                    parent: angular.element(document.body),
                    targetEvent: event,
                    clickOutsideToClose: true,
                    locals:{
                        existingSpsTotal:$scope.existingSPS,
                        tenantid:$scope.ortenantid,
                        cloudid:$scope.orcloudid,
                        selectedSpsData:seletedSpsData
                    },
                    skipHide: true
                   
                }).then(function (answerVal) {
                    $scope.selectSPS(answerVal);
                }, function () {
                    
                });
            };
            $scope.cancelSPSSelectionDialog = function(event){
              $scope.selectSPS($scope.noneSpsPolicy);
            };
            
            $scope.updateRule(); 
               
        }];
        return directive;
    }

    angular.module('shieldxApp').directive('orchestrationrule', orchestrationRuleDirective);

    function showGroupSelectionDialogCtr($scope,$mdDialog,resourceGroupService, existingGroups,tenantid, cloudid,groupInfo){
        
        $scope.groupsFetched = true; 
         $scope.selectedGroup = "";
         if(groupInfo){
          $scope.selectedGroup = groupInfo.name;
         }
        $scope.selectEnableState = false;
        console.log(" showGroupSelectionDialogCtr tenantid "+tenantid);
        console.log(" existingGroups "+existingGroups);
        console.dir(existingGroups);
        /* jshint ignore:start */
        resourceGroupService.getGroupList(cloudid).then(function(data){
          console.log(" resourceGroupService ");
          console.dir(data);
          $scope.existingGroups = existingGroups;
          var groups = _.filter(data, function(item){
            return item.tenantId ===  tenantid;     
          });
         
          for(var i =0 ; i < groups.length; i++){
            
            var exist = _.find($scope.existingGroups, function(f){
               return f.name === groups[i].name;
            });

            if(!exist){
              var newGroup = {id:groups[i].id , name:groups[i].name, existing:true,data:groups[i]};
              $scope.existingGroups.push(newGroup);
            }
            
          }
       
         
        },function(error){

        });

        /* jshint ignore:end */
        $scope.hide = function () {
            $mdDialog.hide();
        };
        $scope.closeDialog = function () {
            $mdDialog.cancel();
        };

        $scope.onSelectionChanged = function(){
           $scope.selectEnableState = true;
         };
        $scope.closeDialogWithAnswer = function (answer) {
           var  returnVal =  _.find($scope.existingGroups, function(item){
               return  item.name === $scope.selectedGroup;
            });
           $mdDialog.hide(returnVal);
        };
        $scope.groupNameEntered = function(grpname){
          if($scope.groupnameForm.$invalid){
            return ;
          }
          $scope.createNewGroupInput =false;
          console.log(grpname);
          var newGroup = {id:-1, name:grpname, existing:false};
          $scope.selectedGroup = newGroup.name;
          $scope.existingGroups.unshift(newGroup);
          $scope.selectEnableState = true;
        };
        $scope.clearGroup = function(){
          $scope.createNewGroupInput = false;
          $scope.groupName = "";
        };
        $scope.openEdit = function(event,group){
          $scope.createNewGroupInput = true;
          $scope.groupName = group.name;
          var matchedIndex = _.findIndex($scope.existingGroups,{id:-1, name:group.name, existing:false});
          $scope.existingGroups.splice(matchedIndex,1);
        };
        $scope.deleteGroup = function(event,group){
          var matchedIndex = _.findIndex($scope.existingGroups,{id:-1, name:group.name, existing:false});
          $scope.existingGroups.splice(matchedIndex,1);
          $scope.groupName = "";
        };
        $scope.createNewGroupClicked = function(event){
          $scope.createNewGroupInput = true;

             /* $mdDialog.show({
                    controller: 'createNewGroupDialogCtr',
                    templateUrl: 'core/directive/security-orchestration/rule/new-group-dialog.html',
                    parent: angular.element(document.body),
                    targetEvent: event,
                    clickOutsideToClose: true,
                    skipHide: true,
                    locals:{
                        existingGroups:existingGroups
                    }
                   
                }).then(function (answerVal) {
                  var newGroup = {id:-1, name:answerVal, existing:false};
                  $scope.selectedGroup = newGroup.name;
                   $scope.existingGroups.push(newGroup);
                  $scope.selectEnableState = true;
                }, function () {
                    
                });*/
        };

    }
    angular.module('shieldxApp').controller('showGroupSelectionDialogCtr', showGroupSelectionDialogCtr);

    function showASPSelectionDialogCtr($scope, $mdDialog,policyService,deploymentSpecificationService,existingSpsTotal,tenantid, cloudid,selectedSpsData){
        console.log("  showASPSelectionDialogCtr ");
        $scope.spsFetched = true; 
       // $scope.existingSPS = [];
       // $scope.selectedSPS = "";
        $scope.existingSPS = existingSpsTotal;
        $scope.selectEnableState = false;
        $scope.showAddPolicy = false;
        $scope.sopTenant = true;
         if(selectedSpsData){
          var spsdata  = _.find($scope.existingSPS, function(item){
                 return  item.id === selectedSpsData;
              });
          $scope.selectedSPS = spsdata.name;
        }else{
          $scope.selectedSPS = "";  
        }
        $scope.showAddSPSSelectionDialogCtrDialog = function(event) {
          angular.element(document.querySelectorAll(".spsQuickSetUpDialog.ip-config-dialog")).removeClass('ip-config-dialog').addClass('fullscreen-dialog');
          $scope.showAddPolicy = true;
          $scope.policy = {};

          deploymentSpecificationService.getTenants(cloudid).then(function (data) {
              $scope.tenants = data;
              $scope.selectedTenantObj = $scope.getTenantNameFromID(tenantid);
          });

          $scope.getTenantNameFromID = function (id) {

              var retVal = _.find($scope.tenants, function (tenantInd) {
                  return tenantInd.id === id;
              });

              return retVal;
          };

          $scope.redirectInSPS = function(cancel){
              $scope.showAddPolicy = false;
              angular.element(document.querySelectorAll(".spsQuickSetUpDialog.fullscreen-dialog")).removeClass('fullscreen-dialog').addClass('ip-config-dialog');

              if(!cancel){

                   $scope.selectEnableState = true;
                   //var newSPS = {id:-1, name:answerVal, existing:false};
                  $scope.selectedSPS = $scope.policy.name;
                   //$scope.existingSPS.push(newSPS);
                  var allSpsBeforeFetch = $scope.existingSPS;
                  //policyService.getSPSByTenant(tenantid).then(function(data){
                  policyService.getSecurityPolicySet().then(function(data){
                     console.log(" sps data fatched ");
                     //$scope.existingSPS = data;
                     console.dir($scope.existingSPS);
                     $scope.spsFetched = true;
                     _.each(data, function(thisSPS){
                        if(thisSPS.name == $scope.selectedSPS){
                          //$scope.selectedSPS = thisSPS.name;
                          allSpsBeforeFetch.unshift(thisSPS);
                          $scope.existingSPS = allSpsBeforeFetch;
                        }
                     });

                  }, function(error){

                  });
              }
          };

            /*  $mdDialog.show({
                controller: 'showAddSPSSelectionDialogCtr',
                templateUrl: 'core/directive/security-orchestration/rule/select-addSps-dialog.html',
                parent: angular.element(document.body),
                targetEvent: event,
                clickOutsideToClose: true,
                locals:{
                    tenantid:tenantid,
                    cloudid:cloudid
                },
                skipHide: true,
                fullscreen: true
               
            }).then(function (answerVal) {
                $scope.selectSPS(answerVal);
            }, function () {
                
            });*/

        };

        $scope.onSelectionChanged = function(){
           $scope.selectEnableState = true;
        };
        $scope.hide = function () {
            $mdDialog.hide();
        };
        $scope.closeDialog = function () {
            $mdDialog.cancel();
        };
        $scope.closeDialogWithAnswer = function (answer) {
            console.log(" answer " + answer);
            var  returnVal =  _.find($scope.existingSPS, function(item){
               return  item.name === $scope.selectedSPS;
            });
            $mdDialog.hide(returnVal);
        };
    }
    angular.module('shieldxApp').controller('showASPSelectionDialogCtr', showASPSelectionDialogCtr);
})();

/*
ShieldX Networks Inc. CONFIDENTIAL
----------------------------------
*
Copyright (c) 2016 ShieldX Networks Inc.
All Rights Reserved.
*
NOTICE: All information contained herein is, and remains
the property of ShieldX Networks Incorporated and its suppliers,
if any. The intellectual and technical concepts contained
herein are proprietary to ShieldX Networks Incorporated
and its suppliers and may be covered by U.S. and Foreign Patents,
patents in process, and are protected by trade secret or copyright law.
Dissemination of this information or reproduction of this material
is strictly forbidden unless prior written permission is obtained
from ShieldX Networks Incorporated.
*/

(function() {
    function orchestrationRuleListDirective() {
        var directive = {};
        directive.restrict = 'E';
        directive.replace = true;
        directive.templateUrl = 'core/directive/security-orchestration/rule/orchestration-rule-list-template.html';
        directive.scope = {
           rules : "=",
           broadcastevent: '&',
           configinfo : "="
        };

        directive.controller = ['$scope','dragularService','$filter','filterFilter', function($scope, dragularService,$filter,filterFilter) {
           
           $scope.sandboxMode = false;
           $scope.broadcastListSOREvents = function(nameOfEvent,arg){
               $scope.broadcastevent({event:nameOfEvent, args:arg});
           };
           $scope.$watchCollection('rules', function(newRules, oldRules) {
            if(!$scope.activeRules.length && $scope.rules.length){
              _.each($scope.rules,function(singleRule){
                    if(singleRule.id){
                      $scope.activeRules.push(angular.copy(singleRule));
                    }
                  });
            }
          });
           $scope.$on('counterChanged',function(event,args){
              _.each($scope.rules,function(singleRule){
                  if(singleRule.id){
                    var activeRule = _.find($scope.activeRules,{"id":singleRule.id});
                    activeRule.workloadsSecured = singleRule.workloadsSecured;
                    activeRule.noneSPS = singleRule.noneSPS;
                  }
                });
                $scope.broadcastevent({event:"drawSecureBar",args:$scope.activeRules});
           });
           $scope.$on(SOEvents.ruleAllCommitedEvent,function(event,args){
              console.log("caught all rules commited event");
              $scope.activeRules = angular.copy($scope.rules);
              $scope.broadcastevent({event:"drawSecureBar",args:$scope.activeRules});
           });
            $scope.$on('reorderRules',function(event,args){
              var selectedRule = _.find($scope.rules,args.rule);
              if(args.type === 1){
                var previousRule = _.find($scope.rules,{"precedence": (selectedRule.precedence-1) }); 
                if(typeof previousRule !== "undefined" && !previousRule.deleted){
                  selectedRule.precedence--;
                  previousRule.precedence++;
                  previousRule.dirty = true;
                }
              } else if(args.type === 2) {
                var nextRule = _.find($scope.rules,{"precedence": (selectedRule.precedence+1) }); 
                if(typeof nextRule !== "undefined" && !nextRule.deleted){
                  selectedRule.precedence++;
                  nextRule.precedence--;
                  nextRule.dirty = true;
                }
              }
              
            });
            

//            $scope.filterNotCommittedRules = function (rule) {
////                return (rule.id !==  "");
//                return rule;
//            };

            $scope.$on('sandboxModeToggled', function (event, sandboxMode) {
                console.log("sandboxModeToggled rulestrip call");
                $scope.sandboxMode = sandboxMode;
            });
            $scope.activeRules = [];
            /*$scope.$on('$viewContentLoaded', function (event) {
              console.log("present rules are ",$scope.rules);
                _each($scope.rules,function(singleRule){
                    if(singleRule.groupInfo.id !== -1 ){
                      $scope.activeRules.push(singleRule);
                    }
                });
            });*/
          /* $scope.activeRules = filterFilter($scope.rules, function (rule) {
              console.log("I am called here :) :) ");
               return rule.id !== '';
           });*/

            /*$scope.filteredRecords = function() {
              return $scope.rules.filter(function(rule, i) {
                  console.log("rule id : " + rule.groupInfo.id);
                  return (rule.groupInfo.id !== -1 && !rule.dirty);
              });
            };*/
            
            $scope.onCreateNewRuleClicked = function () {
                $scope.broadcastevent({event: "onCreateNewRuleClicked", args: null});
            };
            $scope.activeRules = [];
            console.log("original rules",$scope.rules);
            console.log("Active rules are ",$scope.activeRules);

        }];
        return directive;
        
    }

    angular.module('shieldxApp').directive('orchestrationrulelist', orchestrationRuleListDirective);

   
    
})();

/*
ShieldX Networks Inc. CONFIDENTIAL
----------------------------------
*
Copyright (c) 2016 ShieldX Networks Inc.
All Rights Reserved.
*
NOTICE: All information contained herein is, and remains
the property of ShieldX Networks Incorporated and its suppliers,
if any. The intellectual and technical concepts contained
herein are proprietary to ShieldX Networks Incorporated
and its suppliers and may be covered by U.S. and Foreign Patents,
patents in process, and are protected by trade secret or copyright law.
Dissemination of this information or reproduction of this material
is strictly forbidden unless prior written permission is obtained
from ShieldX Networks Incorporated.
*/

(function() {

    function orchestrationRuleStripDirective() {
        var directive = {};
        directive.restrict = 'E';
        directive.replace = true;
        directive.templateUrl = 'core/directive/security-orchestration/rule/rule-strip-template.html';
        directive.scope = {
           ruleref : "=",
           editclicked : "&",
           broadcastevent: '&',
           lastindex : "=",
           configinfo : "=",
           totalrules : "=",
        };
        directive.link = function(scope, element, attrs) {
           console.log(" orchestrationRuleStripDirective ");   
           var intialize = true; 
           scope.$watch('ruleref', function(newValue, oldValue) {
                if (newValue){
                    scope.updateRuleDesc();
                }
            }, true);
        };
        directive.controller = ['$scope','$mdDialog', function($scope,$mdDialog) {
            $scope.showDrag = false;
            $scope.networkCount = -1;
            $scope.ruleDesc = null;
                        
            $scope.updateRuleDesc  = function(){
               $scope.ruleDesc = $scope.ruleref.ruleDesc;
               $scope.networkCount = 0;   
               var uniqueNetworks = [];
                _.each($scope.ruleDesc, function (ruleDesc) {
                    if (ruleDesc.ruleAttribute === "1") {
                        ruleDesc.ruleImg = 'images/cidr.svg';
                        ruleDesc.ruleTooltip = 'CIDR';
                    } else if (ruleDesc.ruleAttribute >= "2") {
                        ruleDesc.ruleImg = "images/workloads.svg";
                        ruleDesc.ruleTooltip = 'Workloads';
                    } else {
                        ruleDesc.ruleImg = 'images/share.svg';
                        ruleDesc.ruleTooltip = 'Network';
                    }
                    if (ruleDesc.matchingCritaria === "1") {
                        ruleDesc.matchingCriteriaImg = "images/ic_equals.svg";
                        ruleDesc.matchingCriteriaTooltip = 'Equals';
                    } else if (ruleDesc.matchingCritaria === "2") {
                        ruleDesc.matchingCriteriaImg = "images/contains.svg";
                        ruleDesc.matchingCriteriaTooltip = 'Contains';
                    } else {
                        ruleDesc.matchingCriteriaImg = "images/ic_begins_with.svg";
                        ruleDesc.matchingCriteriaTooltip = 'Begins with';
                    }
                    /*if(ruleDesc.networks){
                        _.each(ruleDesc.networks, function (network) {
                            if (!_.find(uniqueNetworks, network)) {
                                uniqueNetworks.push(angular.copy(network));
                            }
                        });
                    }*/
                }); 
                //$scope.networkCount = uniqueNetworks.length;
            };
            if($scope.configinfo.mode == 'edit_rc'){
                 $scope.$emit("resourceGroupModeNetworks",$scope.ruleref);
            }
            
            $scope.editRuleClicked = function(ruleref){
               $scope.$emit("editClicked",ruleref); 
            };

            $scope.onMouseDown = function(event){
               event.target.style.cursor = "-webkit-grabbing"; 
            };

            $scope.reorder = function(ruleset,type){
                $scope.broadcastevent({event:'reorderRules', args:{rule:ruleset,type:type}});
            };

            $scope.updateRuleDesc();

            _.each($scope.show, function(show) {
                show = false;
            });

            $scope.showResourceGroup = function (event, groupRef,action) {
              console.log(" showResourceGroup >>>> ");
               $scope.broadcastevent({event:'showNetoworksBelongToRuleEvent', args:{groups:groupRef,action:action}});
            };
            $scope.containsRule = function(ruleDesc,criteria){
                for (var i = 0; i < ruleDesc.length; i++) {
                    if(ruleDesc[i].matchingCritaria == criteria)
                        return false;
                }
                return true;
            };
            $scope.showStaticPopup = function(event,filteredequal,title){
                $mdDialog.show({
                    controller: 'staticDataCtr',
                    templateUrl: 'core/components/screenComponents/static-dialog.html',
                    parent: angular.element(document.body),
                    targetEvent: event,
                    clickOutsideToClose: true,
                    locals:{
                        title:title,
                        staticData:filteredequal,
                    },
                    skipHide: true
                   
                }).then(function (answerVal) {
                    
                }, function () {
                    
                });
            };
            $scope.helpButtonClicked = function(helpId){
              $scope.broadcastevent({event:SOEvents.popUpMenuSelectionChangeEvent, args:{selection:"guid",guideUrl:helpId}});
             };
         /*   $scope.deleteRuleClicked = function(ruleref,event){
                $mdDialog.show({
                    controller: 'confirmDeleteGroupDialogCtr',
                    templateUrl: 'core/directive/security-orchestration/rule/delete-group-dialog.html',
                    parent: angular.element(document.body),
                    targetEvent: event,
                    clickOutsideToClose: true,
                    locals:{
                        ruleref:ruleref
                    },
                    skipHide: true
                   
                }).then(function (answerVal) {
                    $scope.deleteGroup(answerVal);
                }, function () {
                    
                });
            };
            $scope.deleteGroup = function(ruleref){
              ruleref.deleted = true;
            };*/

            $scope.sandboxMode = false;
            $scope.$on('sandboxModeToggled', function (event, sandboxMode) {
                console.log("sandboxModeToggled rulestrip call");
                $scope.sandboxMode = sandboxMode;
            });

            $scope.hoverIn = function(){
                this.hoverEdit = true;
            };

            $scope.hoverOut = function(){
                this.hoverEdit = false;
            };
        }];
        return directive;
    }

    angular.module('shieldxApp').directive('orchestrationrulestrip', orchestrationRuleStripDirective);
function confirmDeleteGroupDialogCtr($scope, $mdDialog,ruleref){
        console.log("  confirmDeleteGroupDialogCtr ");
        
        $scope.hide = function (ruleref) {
            $mdDialog.hide(ruleref);
        };
        $scope.closeDialog = function () {
            $mdDialog.cancel();
        };
        $scope.closeDialogWithAnswer = function () {
            $scope.hide(ruleref);
        };
    }
    angular.module('shieldxApp').controller('confirmDeleteGroupDialogCtr', confirmDeleteGroupDialogCtr);

    function staticDataCtr($scope,$mdDialog,title,staticData){
        $scope.staticData = staticData;
        $scope.title = title;
        $scope.selected = [];
        _.each($scope.staticData, function (item) {
           if(item.ruleAttribute === "1")  {
               item.ruleTooltip= 'CIDR';
               item.ruleImg= 'images/share.svg';
           } else if (item.ruleAttribute === "2")  {
               item.ruleTooltip= "Workloads";
               item.ruleImg= "images/workloads.svg";
           } else {
               item.ruleTooltip= 'Network';
               item.ruleImg= 'images/share.svg';
           }
           if(item.matchingCritaria === "1")  {
               item.matchingCriteriaTooltip= "Equals";
               item.matchingCriteriaImg= "images/ic_equals.svg";
           } else if (item.matchingCritaria === "2")  {
               item.matchingCriteriaTooltip= "Contains";
               item.matchingCriteriaImg= "images/contains.svg";
           } else {
               item.matchingCriteriaTooltip= "Begins With";
               item.matchingCriteriaImg= "images/ic_begins_with.svg";
           }
        });
        $scope.cancelDialog = function(){
            $mdDialog.hide();
        };
    }

    angular.module('shieldxApp').controller('staticDataCtr', staticDataCtr);
})();

/*
 ShieldX Networks Inc. CONFIDENTIAL
 ----------------------------------
 *
 Copyright (c) 2016 ShieldX Networks Inc.
 All Rights Reserved.
 *
 NOTICE: All information contained herein is, and remains
 the property of ShieldX Networks Incorporated and its suppliers,
 if any. The intellectual and technical concepts contained
 herein are proprietary to ShieldX Networks Incorporated
 and its suppliers and may be covered by U.S. and Foreign Patents,
 patents in process, and are protected by trade secret or copyright law.
 Dissemination of this information or reproduction of this material
 is strictly forbidden unless prior written permission is obtained
 from ShieldX Networks Incorporated.
 */

(function () {
    function deploymentSpecificationCtr($rootScope, $scope,
        $translate,
        deploymentSpecificationService,
        vlanService,
        $mdDialog, 
        $sessionStorage, 
        $state) {
        "ngInject";        
        
        console.log($sessionStorage.cloudData);
        if(!$sessionStorage.cloudData){
            $sessionStorage.cloudData = {};
            $state.go('landingpage');
        }else{
          if(!$sessionStorage.cloudData.cloudId) {
            console.log('cloud Id not set');
            $state.go('home.quickSetup.quickSetup-begin');
          }
          
          if(!$sessionStorage.cloudData.infrastructure){
              console.log('cloud Id not set');
              $state.go('home.quickSetup.quickSetup-begin');
          }
          if(!$sessionStorage.cloudData.infrastructure.id){
              console.log('cloud Id not set');
              $state.go('home.quickSetup.quickSetup-begin');
          }
          
          if(!$sessionStorage.cloudData.ipPool || !($sessionStorage.cloudData.ipPool.serverData) ){
              console.log('data not set in ipPool');
              $state.go('home.quickSetup.ip-pools-management');
          }
          if(!($sessionStorage.cloudData.ipPool.serverData.managmentNetworkHeaderValue) || !($sessionStorage.cloudData.ipPool.serverData.managmentIPPoolHeaderValue)){
              console.log('data not set in ipPool');
              $state.go('home.quickSetup.ip-pools-management');
          }
          if(!($sessionStorage.cloudData.ipPool.serverData.backpaneIPPoolHeaderValue) || !($sessionStorage.cloudData.ipPool.serverData.backpaneNetworkHeaderValue)){
              console.log('data not set in ipPool');
              $state.go('home.quickSetup.ip-pools-backplane');
          } 
        }
        
        

        $scope.$emit('quickSetupBegun',{});
        
        $scope.active_help_id = "deploy_spec_title_help_wizard";

        $scope.deployment_description = $translate.instant("wizardinfrastucture.placeholder.description");
        $scope.deployment_name = $translate.instant("wizardinfrastucture.placeholder.name");
        
        $scope.deployment_where_host = $translate.instant("wizardinfrastucture.placeholder.where_host_label");
        $scope.deployment_where_host_desc = $translate.instant("wizardinfrastucture.placeholder.where_host_desc");
        
        $scope.deployment_designate_host = $translate.instant("wizardinfrastucture.button.designate_host");
        $scope.deployment_designate_storage = $translate.instant("wizardinfrastucture.button.designate_storage");
       
        $scope.headerValues = [{
            label: 'Connector', value: $sessionStorage.cloudData.infrastructure.name
        }, {
            label: 'Infrastructure', value: $sessionStorage.cloudData.infrastructure.ip
        },{
            label: 'Management Network', value: $sessionStorage.cloudData.ipPool.serverData.managmentNetworkHeaderValue
        },{
            label: 'Management IP Pool', value:$sessionStorage.cloudData.ipPool.serverData.managmentIPPoolHeaderValue 
        },{
            label: 'Backplane Network', value: $sessionStorage.cloudData.ipPool.serverData.backpaneNetworkHeaderValue
        },{
            label: 'Backplane IP Pool', value: $sessionStorage.cloudData.ipPool.serverData.backpaneIPPoolHeaderValue
        }];
        
        var cloudId = $sessionStorage.cloudData.cloudId;
        $scope.cloudId = cloudId;
        $scope.cloudType = $sessionStorage.cloudData.infrastructure.type;
        //$scope.cloudType = 'OPENSTACK';        
        $scope.deployment = {};
        if(!$sessionStorage.cloudData.deploySpec){
            $sessionStorage.cloudData.deploySpec ={};
        }
        if(!$sessionStorage.cloudData.deploySpec.serverData){
            $sessionStorage.cloudData.deploySpec.serverData ={};
        }
        if($sessionStorage.cloudData.selectedHosts) {
            $scope.selectedHosts = $sessionStorage.cloudData.selectedHosts; 
        } else {
            $scope.selectedHosts = [];
        }
        
        if($sessionStorage.cloudData.selectedStorages) {
            $scope.selectedStorages = $sessionStorage.cloudData.selectedStorages; 
        } else {
            $sessionStorage.cloudData.selectedStorages = {
                    "cloudId": cloudId,
                    "id": 0,
                    "name": "Local"
                };
            $scope.selectedStorages = $sessionStorage.cloudData.selectedStorages; 
        }
        
        if($sessionStorage.cloudData.deploySpec.serverData.name) {
            $scope.deployment.name = $sessionStorage.cloudData.deploySpec.serverData.name;
            $scope.deployment.region = $sessionStorage.cloudData.deploySpec.serverData.region;
        } else {
            $scope.deployment.name = '';
            $scope.deployment.region = '';
        }
        
        if($sessionStorage.cloudData.deploySpec.serverData.descr) {
           $scope.deployment.description = $sessionStorage.cloudData.deploySpec.serverData.descr;
        }  else {
            $scope.deployment.description = '';
        }

        $scope.checkNext = function(){
            if($scope.cloudType !== 'OPENSTACK'){
                if(($scope.deployment.name) && ($scope.deployment.name.length > 0) && ($scope.selectedHosts.length > 0) && ($scope.selectedStorages))
                {
                    console.log("enable next ");
                    $scope.enableNextButton();
                } else {
                    $scope.disableNextButton();
                }
            } else {
                if(($scope.deployment.name) && ($scope.deployment.name.length > 0) && ($scope.selectedHosts.length > 0) && ($scope.selectedStorages) && ($scope.deployment.tenant) && ($scope.deployment.region) && ($scope.deployment.region.length <= 40))
                {
                    console.log("enable next ");
                    $scope.enableNextButton();
                } else {
                    $scope.disableNextButton();
                }
            }
        };

        /// vlane specific logic
        $scope.rangesParent = [];
        $scope.newVlan = new Vlan();
        $scope.selectedVlan = null;
        $scope.selectOption = null;

        $scope.onOptionChanged = function(value){
          $scope.selectOption = value;
          $sessionStorage.cloudData.deploySpec.vlan.selectOption =  $scope.selectOption;
           $scope.newVlan = new Vlan();
           $sessionStorage.cloudData.deploySpec.vlan.newVlan = $scope.newVlan;

          if(value === "new"){
            $scope.selectedVlan = -1;
            $sessionStorage.cloudData.deploySpec.vlan.selectedVlan = $scope.selectedVlan;
          }

          if(value === "existing" || value === "new"){
            $scope.disableNextButton();
          }else if(value ===  "novlan"){
             $scope.checkNext();
          }
          
        }; 

        $scope.onVlanSelected = function(value){
             $scope.selectedVlan = value;
             console.log(" onVlanSelected "+$scope.selectedVlan);
             $scope.selectOption = "existing";
             $sessionStorage.cloudData.deploySpec.vlan.selectOption =  $scope.selectOption;
              $sessionStorage.cloudData.deploySpec.vlan.selectedVlan = $scope.selectedVlan;
              $scope.checkNext();
        };

        $scope.$on('newRangeValueChanged', function (event, data) {
             if($scope.newVlan.isPopulated()){
                $scope.checkNext();
             }
        });
        
        if($sessionStorage.cloudData.deploySpec.vlan){

          if($sessionStorage.cloudData.deploySpec.vlan.selectOption){
            $scope.selectOption  = $sessionStorage.cloudData.deploySpec.vlan.selectOption;
            console.log("vlan selectOption "+$scope.selectOption);
            console.dir("vlan selectedVlan "+$scope.selectedVlan);
          }

          if($sessionStorage.cloudData.deploySpec.vlan.selectedVlan){   
            $scope.selectedVlan = $sessionStorage.cloudData.deploySpec.vlan.selectedVlan;
          }

          if($sessionStorage.cloudData.deploySpec.vlan.newVlan){
            if(!$sessionStorage.cloudData.deploySpec.vlan.newVlan.id){
              var nvlan = new Vlan();
              nvlan.diserialize($sessionStorage.cloudData.deploySpec.vlan.newVlan);
              $scope.selectedVlan  = $sessionStorage.cloudData.deploySpec.vlan.selectedVlan;
              $scope.newVlan = nvlan;
              $sessionStorage.cloudData.deploySpec.vlan.newVlan = $scope.newVlan;

             if($scope.newVlan.isPopulated()){
                $scope.checkNext();
              } else{
                $scope.disableNextButton();
              }
            } else
            {
              $scope.selectOption = "existing";
              $sessionStorage.cloudData.deploySpec.vlan.selectOption = $scope.selectOption; 
              $scope.selectedVlan = $sessionStorage.cloudData.deploySpec.vlan.newVlan.id;
              $sessionStorage.cloudData.deploySpec.vlan.selectedVlan = $scope.selectedVlan;
              if($scope.selectedVlan){
                $scope.checkNext();
              } else{
                $scope.disableNextButton();
              }
            }
            
          }
          
        }else {
           $sessionStorage.cloudData.deploySpec.vlan = {}; 
        }   


        //$scope.cloudType = 'OPENSTACK'; //NEED TO REMOVE AFTERWARD
        if($scope.cloudType === 'OPENSTACK'){
            //call to get all available tenant for cloudId
            if(!$sessionStorage.cloudData.tenants){
                deploymentSpecificationService.getTenants(cloudId).then(function(data){
                    $scope.tenants = data;
                    $sessionStorage.cloudData.tenants = data;
                    $scope.deployment.tenant = $scope.tenants[0].id;
                    $scope.selectedTenants = $scope.tenants[0];
                }, function(error){
                    console.log(error);
                    $scope.tenants = [];
                });
            } else {
                $scope.tenants = $sessionStorage.cloudData.tenants;
                if($sessionStorage.cloudData.deploySpec.serverData.selectedTenant){
                    $scope.deployment.tenant = $sessionStorage.cloudData.deploySpec.serverData.selectedTenant;
                    $scope.selectedTenants = _.find($scope.tenants, function(o) { return o.id === $scope.deployment.tenant; });
                } else {
                    $scope.deployment.tenant = $scope.tenants[0].id;
                    $scope.selectedTenants = $scope.tenants[0];
                }
            }
            
        }
        
        $scope.numberOfHosts = ($sessionStorage.cloudData.selectedHostsCount)?$sessionStorage.cloudData.selectedHostsCount:0;    
        $scope.$on('listenSelectedHosts', function (event, args) {
            $scope.selectedHosts = args;
            $scope.numberOfHosts = args.length;
            $scope.checkNext();
        });
        
        $scope.$on('listenSelectedStorages', function (event, args) {
            $scope.selectedStorages = args;
            $scope.checkNext();
        });
        
        $scope.$on('listenSelectedTenants', function (event, args) {
            $scope.selectedTenants = args;
            $scope.deployment.tenant = args.id;
            $scope.checkNext();
        });
        
        
        $scope.$watch('deployment.name',function(){
             $scope.checkNext();
        });
        if($scope.cloudType === 'OPENSTACK'){
            $scope.$watch('deployment.region',function(){
                 $scope.checkNext();
            });
        }

     
         
        
        
        $scope.$on('nextClicked', function(event, data){
            data.stopNextClick = true;
//            if($scope.cloudType !== 'OPENSTACK'){
//                if( $scope.deployment.name !== $sessionStorage.cloudData.deploySpec.serverData.name) {
                    $scope.startCreatingDeploymentspec();
//                } else {
//                    $sessionStorage.cloudData.savedState = $state.current.name;
//                    $state.go('home.quickSetup.virtual-chassis');
//                }
//            } else {
//                if( $scope.deployment.name !== $sessionStorage.cloudData.deploySpec.serverData.name || $scope.deployment.tenant !== $sessionStorage.cloudData.deploySpec.serverData.selectedTenant || $sessionStorage.cloudData.deploySpec.serverData.region !== $scope.deployment.region) {
                    //$scope.startCreatingDeploymentspec();
//                } else {
//                    $sessionStorage.cloudData.savedState = $state.current.name;
//                    $state.go('home.quickSetup.virtual-chassis');
//                }
//            }
        });
        $scope.startCreatingDeploymentspec = function(){
           $scope.hideNextButton();
           console.log(" startCreatingDeploymentspec "+$scope.selectOption); 
           if($scope.cloudType === 'VMWARE'){
              if($scope.selectOption){
                 switch($scope.selectOption){
                  case "new":
                   // console.dir($scope.newVlan); 
                   // console.log(" startCreatingDeploymentspec new  1"+$scope.newVlan.isPopulated());

                   if($scope.newVlan && $scope.newVlan.isPopulated())
                   {
                     var data = {
                        "cloudid": parseInt($sessionStorage.cloudData.cloudId),
                        "id": 0,
                        "name": $scope.newVlan.name,
                        "ranges": $scope.newVlan.serializeRanges()
                     };
                    if (typeof $sessionStorage.qSdeploySpecvlanData === "undefined" ||
                            !$sessionStorage.qSdeploySpecvlanDataId) {
                        $sessionStorage.qSdeploySpecvlanData = angular.copy(data);

                        // console.log(" startCreatingDeploymentspec new  2"+ $scope.newVlan.serializeRanges()); 
                        vlanService.createVlanPool(data, $sessionStorage.cloudData.cloudId).then(function(data){
                        // console.log(" startCreatingDeploymentspec new  3"+ data);
                           $scope.newVlan.id =  parseInt(data);
                           $sessionStorage.qSdeploySpecvlanDataId = parseInt(data);
                           $scope.createdeploymentspecification(parseInt(data));
                        },function(error){
                          console.log("failed to create vlan ");
                          toastparam = {
                              'heading': 'VLAN pool creation failed',
                              'subHeading': "Error: " + error.data.message,
                              'type': 'fail',
                              'timeout': 5000
                          };
                          showToast(toastparam);
                          $scope.showNextButton();
                          $scope.enableNextButton();
                        }); 
                    } else if (!_.isEqual($sessionStorage.qSdeploySpecvlanData, data)) {
                        data.id = $sessionStorage.qSdeploySpecvlanDataId;
                        vlanService.updateVlanPool(data).then(function(data){
                        // console.log(" startCreatingDeploymentspec new  3"+ data);
                           $scope.newVlan.id =  parseInt(data);
                           $sessionStorage.qSdeploySpecvlanDataId = parseInt(data);
                           $scope.createdeploymentspecification(parseInt(data));
                        },function(error){
                          console.log("failed to create vlan ");
                          toastparam = {
                              'heading': 'VLAN pool creation failed',
                              'subHeading': "Error: " + error.data.message,
                              'type': 'fail',
                              'timeout': 5000
                          };
                          showToast(toastparam);
                          $scope.showNextButton();
                          $scope.enableNextButton();  
                        }); 
                    } else if (_.isEqual($sessionStorage.qSdeploySpecvlanData, data)) {
                        $scope.createdeploymentspecification(parseInt($sessionStorage.qSdeploySpecvlanData.id));
                    }
                   }else{
                     console.log("no new vlan info found");
                   }
//               }
                  break;
                  case "existing":
                       //console.log(" $scope.selectedVlan "+$scope.selectedVlan); 
                      if($scope.selectedVlan){
                        $scope.createdeploymentspecification(parseInt($scope.selectedVlan));
                      }else{
                         $scope.createdeploymentspecification(0);
                      }
                  break; 
                  case "novlan":
                    $scope.createdeploymentspecification(0);
                  break; 

                 }
              }else{  
                $scope.createdeploymentspecification(0);
              }
           }else {
            $scope.createdeploymentspecification(0);
           } 
           
        };
        $scope.createdeploymentspecification = function(vlanId){
            $sessionStorage.cloudData.savedState = $state.current.name;
            var selected_host_ids = [];
            var selected_storage_ids = [];
            for(i=0; i < $sessionStorage.cloudData.selectedHosts.length; i++) {
                selected_host_ids[i] = $sessionStorage.cloudData.selectedHosts[i].id;
            }
            
            if ($sessionStorage.cloudData.selectedStorages.id !== 0) {
                selected_storage_ids = $sessionStorage.cloudData.selectedStorages.id;            
                $sessionStorage.cloudData.deploySpec.serverData.storageIsLocal = false;
            } else {
                selected_storage_ids = 0;            
                $sessionStorage.cloudData.deploySpec.serverData.storageIsLocal = true;
            }
            $sessionStorage.cloudData.deploySpec.serverData.name = $scope.deployment.name;
            $sessionStorage.cloudData.deploySpec.serverData.descr = $scope.deployment.description;
            /*
             {
  "backPlaneIpPoolId": 0,
  "backPlaneIsDhcp": true,
  "backPlaneNetworkId": 0,
  "cloudid": 0,
  "datastoreId": 0,
  "descr": "string",
  "hosts": [
    0
  ],
  "id": 0,
  "mgmtIpPoolId": 0,
  "mgmtIsDhcp": true,
  "mgmtNetworkId": 0,
  "name": "string",
  "region": "string",
  "storageIsLocal": true,
  "tenantId": 1
}
             */
            var paramObject = {
                "backPlaneIpPoolId": $sessionStorage.cloudData.ipPool.serverData.backPlaneIpPoolId,
                "backPlaneIsDhcp": $sessionStorage.cloudData.ipPool.serverData.backPlaneIsDhcp,
                "backPlaneNetworkId": parseInt($sessionStorage.cloudData.ipPool.serverData.backPlaneNetworkId),
                "cloudid": $sessionStorage.cloudData.cloudId,
                "datastoreId": selected_storage_ids,
                "descr": $sessionStorage.cloudData.deploySpec.serverData.descr,
                "hosts": selected_host_ids,
                "id": 0,
                "mgmtIpPoolId": parseInt($sessionStorage.cloudData.ipPool.serverData.mgmtIpPoolId),
                "mgmtIsDhcp": $sessionStorage.cloudData.ipPool.serverData.mgmtIsDhcp,
                "mgmtNetworkId": parseInt($sessionStorage.cloudData.ipPool.serverData.mgmtNetworkId),
                "name": $sessionStorage.cloudData.deploySpec.serverData.name,
               // "region": "", //Empty for VMWARE and value will come for OPENSTACK
                "storageIsLocal": $sessionStorage.cloudData.deploySpec.serverData.storageIsLocal,
                "vlanPoolId" : vlanId
               // "tenantId": 0 //Empty for VMWARE and value will come for OPENSTACK
            };
            if($scope.cloudType === 'OPENSTACK'){
                $sessionStorage.cloudData.deploySpec.serverData.region = $scope.deployment.region;
                $sessionStorage.cloudData.deploySpec.serverData.selectedTenant = $scope.deployment.tenant;
                if($sessionStorage.cloudData.deploySpec.serverData.region){
                    paramObject.region = $sessionStorage.cloudData.deploySpec.serverData.region;
                }
                paramObject.tenantId = $sessionStorage.cloudData.deploySpec.serverData.selectedTenant;
            }
            if (!$sessionStorage.qSdeploySpecvData) {
                $sessionStorage.qSdeploySpecvData = angular.copy(paramObject);
            }
            $sessionStorage.qSdeploySpecvData.id = 0;
            if (!$sessionStorage.qSdeploySpecvDataId) {
                var toastparam = {
                    'heading': 'Deployment Specification creation started',
                    'subHeading': "This should take only a few minutes max.",
                    'type': 'progress',
                    'timeout': 5000
                };            
                showToast(toastparam);

                deploymentSpecificationService.createDeploymentSpecfication(paramObject).then(function (data) {
                    if (data) {
                        toastparam = {
                            'heading': 'Deployment Specification created successfully',
                            'subHeading': "",
                            'type': 'success',
                            'timeout': 2000,
                            'callback': function () {
                                $state.go('home.quickSetup.virtual-chassis');
                                $scope.showNextButton();
                                $scope.enableNextButton();
                            }
                        };
                        showToast(toastparam);
                        $sessionStorage.qSdeploySpecvDataId = data;
                        $sessionStorage.cloudData.deploySpec.serverData.deploymentSpecId = data;
                        //$state.go('home.quickSetup.virtual-chassis');
                    }
                }, function (error) {
                    console.log(error);
                    toastparam = {
                        'heading': 'Deployment Specification creation failed',
                        'subHeading': "Error: " + error.data.message,
                        'type': 'fail',
                        'timeout': 5000
                    };
                    showToast(toastparam);
                    $scope.showNextButton();
                    $scope.enableNextButton();
                });
            } else if (!_.isEqual($sessionStorage.qSdeploySpecvData, paramObject)) {
                console.log(" update deployspec >>>>>>>>>>>>>>>>>>");
                $sessionStorage.qSdeploySpecvData.id = $sessionStorage.qSdeploySpecvDataId;
                paramObject.id = $sessionStorage.qSdeploySpecvDataId;
                $sessionStorage.qSdeploySpecvlanData = angular.copy(paramObject);
                deploymentSpecificationService.updateDeploymentSpecfication(paramObject).then(function (data) {
                    $sessionStorage.qSdeploySpecvDataIdId = data;
                    $sessionStorage.qSdeploySpecvData = angular.copy(paramObject);
                    $sessionStorage.cloudData.deploySpec.serverData.deploymentSpecId = $sessionStorage.qSdeploySpecvDataId;
                    toastparam = {
                        'heading': 'Deployment Specification updated successfully',
                        'subHeading': "",
                        'type': 'success',
                        'timeout': 2000,
                        'callback': function () {
                            $state.go('home.quickSetup.virtual-chassis');
                            $scope.showNextButton();
                            $scope.enableNextButton();
                        }
                    };
                    showToast(toastparam);
                    //$state.go('home.quickSetup.virtual-chassis');
                }, function (error) {
                    console.log(error);
                    toastparam = {
                        'heading': 'Deployment Specification update failed',
                        'subHeading': "Error: " + error.data.message,
                        'type': 'fail',
                        'timeout': 5000
                    };
                    showToast(toastparam);
                    $scope.showNextButton();
                    $scope.enableNextButton();
                });
            } else  {
                $state.go('home.quickSetup.virtual-chassis');
                $scope.showNextButton();
                $scope.enableNextButton();
            }
        };
        
        $scope.hideNextButton = function () {
            angular.element(document.querySelector('.qs-progress')).css('display', 'block');
            angular.element(document.querySelector('.qs-next')).css('display', 'none');
        };

        $scope.showNextButton = function () {
            angular.element(document.querySelector('.qs-progress')).css('display', 'none');
            angular.element(document.querySelector('.qs-next')).css('display', 'block');
        };

        $scope.callpopuphost = function(ev){
            $mdDialog.show({
            controller: hostPopupController,
            templateUrl: 'core/components/administration/quick-setup/deployment-specification/hosts.tmpl.html',
            parent: angular.element(document.body),
            targetEvent: ev
          })
          .then(function() {
             $sessionStorage.cloudData.selectedHosts = $scope.selectedHosts;
             $sessionStorage.cloudData.selectedHostsCount = $scope.selectedHosts.length;
          });
        };
        
        $scope.callpopupstorage = function(ev){
            $mdDialog.show({
            controller: storagePopupController,
            templateUrl: 'core/components/administration/quick-setup/deployment-specification/storages.tmpl.html',
            parent: angular.element(document.body),
            targetEvent: ev
          })
          .then(function() {
             console.log($scope.selectedStorages);
             $sessionStorage.cloudData.selectedStorages = $scope.selectedStorages;
             console.log($sessionStorage.cloudData.selectedStorages);
          });
        };
        
        
        /*HOST RELATED FUNCTION*/
        function hostPopupController($rootScope, $scope, $mdDialog) {
            $scope.deployment_designate_host = $translate.instant("wizardinfrastucture.button.designate_host");
            //$scope.deployment_designate_storage = $translate.instant("wizardinfrastucture.button.designate_storage");
              $scope.host_activated = true;
              $scope.selectHostBridge = new MethodBridge();
                if (!$sessionStorage.cloudData.hosts) {
                    deploymentSpecificationService.getHosts(cloudId).then(function(data){
                        $sessionStorage.cloudData.hosts = data;
                        $scope.items = $scope.hosts = data;
                        $scope.selectHostBridge.call($scope.items);
                        $scope.no_of_hosts = $scope.hosts.length;
                        commonPopupfunctions();
                        $scope.host_activated = false;
                    }, function(error) {
                        var data = [];
                        console.log(error) ;
                        $sessionStorage.cloudData.hosts = data;
                        $scope.items = $scope.hosts = data;
                        $scope.no_of_hosts = $scope.hosts.length;
                        commonPopupfunctions();
                        $scope.host_activated = false;
                    });
                } else {
                    $scope.items = $scope.hosts = $sessionStorage.cloudData.hosts;
                    $scope.no_of_hosts = $scope.hosts.length;
                    commonPopupfunctions();
                    $scope.host_activated = false;
                }
                
                function commonPopupfunctions() {
                    $scope.selected = ($sessionStorage.cloudData.selectedHosts) ? angular.copy($sessionStorage.cloudData.selectedHosts) : [];
                    if($scope.selected) {
                        $scope.no_of_selected_hosts = $scope.selected.length;
                    } else {
                       $scope.no_of_selected_hosts = 0; 
                    }
                    console.log($scope.selected);
                    $scope.cancelDialogue = function() {
                        $mdDialog.cancel();
                    };

                    $scope.done = function() {
                        $rootScope.$broadcast('listenSelectedHosts', $scope.selected);
                        $mdDialog.hide();
                    };

                    $scope.toggle = function (item, list) {
                        
                        var isDeleted = false;
                        
                        for(i=0; i<list.length ; i++) {
                            if (list[i].id === item.id) {
                                list.splice(i, 1);
                                isDeleted = true;
                            }
                        }
                        if(!isDeleted) {
                            list.push(item);
                        }
                        $scope.no_of_selected_hosts = $scope.selected.length;
                    };
                    $scope.exists = function (item, list) {
                        for(i=0; i<list.length ; i++) {
                                if (list[i].id === item.id) {
                                    return true;
                                }
                        }
                        return false;
                    };
                    $scope.isIndeterminate = function () {
                        return ($scope.selected.length !== 0 &&
                                $scope.selected.length !== $scope.items.length);
                    };
                    $scope.isChecked = function () {            
                        return $scope.selected.length === $scope.items.length;
                    };
                    $scope.toggleAll = function () {
                        if ($scope.selected.length === $scope.items.length) { //uncheck all
                            $scope.selected = [];
                        } else if ($scope.selected.length === 0 || $scope.selected.length > 0) {
                            $scope.selected = $scope.items.slice(0); //check all
                        }
                        $scope.no_of_selected_hosts = $scope.selected.length;
                    };
                }
            
        }
            
        function storagePopupController($rootScope, $scope, $mdDialog) {
            //$scope.deployment_designate_host = $translate.instant("wizardinfrastucture.button.designate_host");
            $scope.deployment_designate_storage = $translate.instant("wizardinfrastucture.button.designate_storage");
            $scope.storage_activated = true;
            $scope.selectStorageBridge = new MethodBridge();
            (function(){   
                var defaultDatastorage = [{
                        "cloudId": cloudId,
                        "id": 0,
                        "name": "Local"
                }];
                if (!$sessionStorage.cloudData.datastores) {
                    deploymentSpecificationService.getDatastore(cloudId).then(function(data){
                        $sessionStorage.cloudData.datastores = defaultDatastorage.concat(data);
                        $scope.items = $scope.dataStores = $sessionStorage.cloudData.datastores;  
                        $scope.selectStorageBridge.call($scope.items);                   
                        $sessionStorage.cloudData.selectedStorages.id = 0;
                        commonPopupfunctions();
                        $scope.storage_activated = false;
                    }, function(error) {
                        console.log(error);
                        var data = [];
                        $sessionStorage.cloudData.datastores = defaultDatastorage.concat(data);
                        $scope.items = $scope.dataStores = $sessionStorage.cloudData.datastores;
                        $sessionStorage.cloudData.selectedStorages.id = 0;
                        commonPopupfunctions();
                        $scope.storage_activated = false;
                    });
                } else {
                    $scope.items = $scope.dataStores = $sessionStorage.cloudData.datastores;
                    commonPopupfunctions();
                    $scope.storage_activated = false;
                }
                
                function commonPopupfunctions() {
                    $scope.selectedStoragesValue = $sessionStorage.cloudData.selectedStorages.id;
                    $scope.cancelDialogue = function() {
                        $mdDialog.cancel();
                    };

                    $scope.done = function() {
                        var storageItems = $scope.items;
                        for(i=0; i < storageItems.length; i++) {                            
                            if (storageItems[i].id === parseInt($scope.selectedStoragesValue)) {
                                $rootScope.$broadcast('listenSelectedStorages', storageItems[i]);
                                $mdDialog.hide();
                            }
                        }
                    };
                }
            })();
        }
        
        $scope.callpopuptenants = function(ev){
            $mdDialog.show({
            controller: tenantPopupController,
            templateUrl: 'core/components/administration/quick-setup/deployment-specification/tenants.tmpl.html',
            parent: angular.element(document.body),
            targetEvent: ev
          })
          .then(function() {
             console.log($scope.selectedTenants);
             $sessionStorage.cloudData.selectedTenants = $scope.selectedTenants;
             console.log($sessionStorage.cloudData.selectedTenants);
          });
        };
        
        function tenantPopupController($rootScope, $scope, $mdDialog) {
            //$scope.deployment_designate_host = $translate.instant("wizardinfrastucture.button.designate_host");
            //$scope.deployment_designate_storage = $translate.instant("wizardinfrastucture.button.designate_storage");
            $scope.tenant_activated = true;
            if(!$sessionStorage.cloudData.selectedTenants) {
                $sessionStorage.cloudData.selectedTenants = {};
            }
            (function(){
                if (!$sessionStorage.cloudData.tenants) {
                    deploymentSpecificationService.getTenants(cloudId).then(function(data){
                        //$sessionStorage.cloudData.datastores = defaultDatastorage.concat(data);
                        $scope.items = $scope.tenants = $sessionStorage.cloudData.tenants = data;                        
                        console.log($scope.items);
                        if(!$sessionStorage.cloudData.selectedTenants.id) {
                            $sessionStorage.cloudData.selectedTenants.id = $scope.items[0].id;
                        }
                        console.log($sessionStorage.cloudData);
                        commonPopupfunctions();
                        $scope.tenant_activated = false;
                    }, function(error) {
                        console.log(error);
                        var data = [];

                        $scope.items = $scope.tenants = $sessionStorage.cloudData.tenants;
                        $sessionStorage.cloudData.selectedTenants.id = $scope.items[0].id;
                        commonPopupfunctions();
                        $scope.tenant_activated = false;
                    });
                } else {
                    $scope.items = $scope.tenants = $sessionStorage.cloudData.tenants;
                    console.log($scope.items);
                    if(!$sessionStorage.cloudData.selectedTenants.id) {
                        $sessionStorage.cloudData.selectedTenants.id = $scope.items[0].id;
                    }
                    commonPopupfunctions();
                    $scope.tenant_activated = false;
                }
                
                function commonPopupfunctions() {
                    $scope.selectedTenantsValue = $sessionStorage.cloudData.selectedTenants.id;
                    $scope.cancelDialogue = function() {
                        $mdDialog.cancel();
                    };

                    $scope.done = function() {
                        var tenantsItems = $scope.items;
                        for(i=0; i < tenantsItems.length; i++) {                            
                            if (tenantsItems[i].id === parseInt($scope.selectedTenantsValue)) {
                                $rootScope.$broadcast('listenSelectedTenants', tenantsItems[i]);
                                $mdDialog.hide();
                            }
                        }
                    };
                }
            })();
        }
        fixContainerHeight(4);
        $scope.setFocusOnElem('#deploymentNameID');
    }
    angular.module('shieldxApp').controller('deploymentSpecificationCtr', deploymentSpecificationCtr);
})();
/*
 ShieldX Networks Inc. CONFIDENTIAL
 ----------------------------------
 *
 Copyright (c) 2016 ShieldX Networks Inc.
 All Rights Reserved.
 *
 NOTICE: All information contained herein is, and remains
 the property of ShieldX Networks Incorporated and its suppliers,
 if any. The intellectual and technical concepts contained
 herein are proprietary to ShieldX Networks Incorporated
 and its suppliers and may be covered by U.S. and Foreign Patents,
 patents in process, and are protected by trade secret or copyright law.
 Dissemination of this information or reproduction of this material
 is strictly forbidden unless prior written permission is obtained
 from ShieldX Networks Incorporated.
 */

(function () {
    function QuickSetupHeaderController($scope, $location) {
        console.log("Controller initialized");
        this.templatName = 'Quick-Setup-Header';
        $scope.maximize = false;
        
        var locationUrl = $location.path();
        var showDividerConfig = [  {
                route: "/quickSetup/infrastructure-connector" ,
                dividerSetup: []
            }, {
                route: "/quickSetup/ip-pools-management" ,
                dividerSetup: []
            }, {
                route: "/quickSetup/ip-pools-backplane" ,
                dividerSetup: [null,true]
            }, {
                route: "/quickSetup/deployment-specifications" ,
                dividerSetup: [null,true,null,true]
            }, {
                route: "/quickSetup/virtual-chassis" ,
                dividerSetup: [null,true,null,true]
            }, {
                route: "/quickSetup/monitor-networks" ,
                dividerSetup: [null,true,null,true,null,true]
            }
        ]; 
        
        $scope.dividerCntObj = _.find(showDividerConfig, {route : locationUrl});
        
        $scope.$on('fullscreen', function (event, data) {
            $scope.maximize = !$scope.maximize;
        });
        
    }
    angular.module('shieldxApp').component("quicksetupheader", {
        templateUrl: '/core/components/administration/quick-setup/header/quick-setup-header.html', controller: QuickSetupHeaderController, bindings: {
            values: '<'
        }
    });
})();
/*
 ShieldX Networks Inc. CONFIDENTIAL
 ----------------------------------
 *
 Copyright (c) 2016 ShieldX Networks Inc.
 All Rights Reserved.
 *
 NOTICE: All information contained herein is, and remains
 the property of ShieldX Networks Incorporated and its suppliers,
 if any. The intellectual and technical concepts contained
 herein are proprietary to ShieldX Networks Incorporated
 and its suppliers and may be covered by U.S. and Foreign Patents,
 patents in process, and are protected by trade secret or copyright law.
 Dissemination of this information or reproduction of this material
 is strictly forbidden unless prior written permission is obtained
 from ShieldX Networks Incorporated.
 */

(function () {
    function infrastructureConnectorCtr($scope,
            $translate,
            infrastructureConnectorService,
            $mdToast,
            $sessionStorage,
            $state) {
        "ngInject";

        $scope.$emit('quickSetupBegun', {});
        $scope.infrastructure_heading = $translate.instant('wizardinfrastucture.heading.provide_infrastructure_access');
        $scope.infrastructure_subheading = $translate.instant('wizardinfrastucture.subheading.message');

        $scope.infrastucture_type = $translate.instant('wizardinfrastucture.label.infrastructure_type');

        $scope.infrastucture_name = $translate.instant("wizardinfrastucture.placeholder.name");
        $scope.infrastucture_ipaddress_fqdn = $translate.instant("wizardinfrastucture.placeholder.ip_address_fqdn");
        $scope.infrastucture_login = $translate.instant("wizardinfrastucture.placeholder.infrastructure_login");
        $scope.infrastucture_password = $translate.instant("wizardinfrastucture.placeholder.infrastructure_password");
        $scope.create_infrastructure = $translate.instant("wizardinfrastucture.button.create_infrastructure");

        $scope.activLink = 'Infrastructure Access';

        $scope.active_help_id = "infra_header_help_wizard";

       
        $scope.infra = {
            'types': [
                {'name': 'VMWARE ESXi', 'value': 'VMWARE'},
                {'name': 'Amazon AWS', 'value': 'Amazon AWS'},
                {'name': 'OpenStack', 'value': 'OPENSTACK'},
                {'name': 'MS Azure', 'value': 'MS Azure'}
            ]
        };
        $scope.infrastructure = {};
       
        $scope.infrastructure.type = 'VMWARE';
        $scope.toastPosition = {
            'bottom': true,
            'top': false,
            'left': false,
            'right': false,
            'center': true
        };
        $scope.getToastPosition = function () {
            return Object.keys($scope.toastPosition)
                    .filter(function (pos) {
                        return $scope.toastPosition[pos];
                    })
                    .join(' ');
        };

        $scope.callCreateInfrastructure = function () {
            if (typeof ($sessionStorage.cloudData) !== 'undefined') {
                $sessionStorage.cloudData.savedState = $state.current.name;
            }
            var startInfraCreationMessage = {
                'heading': 'Create Infrastructure Connector',
                'subHeading': 'This should take only a few minutes max.',
                'type': 'progress',
                'timeout': 5000
            };
            var successfulInfraCreationMessage = {
                'heading': 'Infrastructure Connector Created',
                'subHeading': 'Click NEXT to proceed with the Quick Setup',
                'type': 'success',
                'timeout': 5000
            };
            var startInfraDiscoveryMessage = {
                'heading': 'Discovery Started',
                'subHeading': 'Discovery Started',
                'type': 'progress',
                'timeout': 5000
            };

            var completedInfraDiscoveryMessage = {
                'heading': 'Discovery Completed',
                'subHeading': 'Discovery Completed',
                'type': 'success',
                'timeout': 5000
            };

            var failedInfraDiscoveryMessage = {
                'heading': 'Discovery Failed',
                'type': 'fail',
                'timeout': 5000
            };

            //Call toast to show meesage
            var pinTo = $scope.getToastPosition();
            /*$mdToast.show(
             $mdToast.simple()
             .textContent('Please wait while we discove the network.')
             .position(pinTo )
             );*/

            $scope.changedData = false;

            showToast(startInfraCreationMessage);
            var infrastructureObject = angular.copy($scope.infrastructure);
            //md - auto complete sets the infra name 
            infrastructureObject.name = $scope.searchText;
            $scope.hideNextButton();
            console.log(infrastructureObject);
            infrastructureConnectorService.createInfrastructure(infrastructureObject).then(function (data) {
                if (data) {

                    showToast(successfulInfraCreationMessage);

                    $sessionStorage.cloudData = {}; //Need new cloudData object and then need new data of this cloud

                    $sessionStorage.cloudData.cloudId = data;
                    infrastructureObject.id = data;
                    $sessionStorage.cloudData.infrastructure = infrastructureObject;
                    $sessionStorage.infrastructure = $sessionStorage.cloudData.infrastructure;
                    $sessionStorage.cloudData.infrastructure.id = data;

                    showToast(startInfraDiscoveryMessage);
                    discoverInfrastructure(infrastructureObject).then(function (data) {
                        showToast(completedInfraDiscoveryMessage);
                        return data;
                    }, function (error) {
                        failedInfraDiscoveryMessage.subHeading = "Error: " + error.data.message;
                        showToast(failedInfraDiscoveryMessage);
                        console.log(error);
                        //showError
                    }).finally(function(){
                        $scope.showNextButton();
                        $scope.enableNextButton();   
                    });
                    $scope.setPreExistingInfra = true;
                    

                }
            }, function (error) {
                var failureInfraCreation = {
                    'heading': 'Infrastructure creation failed',
                    'type': 'fail',
                    'timeout': 10000
                };
                failureInfraCreation.subHeading = "Error: " + error.data.message;
                showToast(failureInfraCreation);
                $scope.showNextButton();
                $sessionStorage.cloudData = {};
            });
        };

        $scope.hideNextButton = function () {
            angular.element(document.querySelector('.qs-progress')).css('display', 'block');
            angular.element(document.querySelector('.qs-next')).css('display', 'none');
        };

        $scope.showNextButton = function () {
            angular.element(document.querySelector('.qs-progress')).css('display', 'none');
            angular.element(document.querySelector('.qs-next')).css('display', 'block');
        };
        discoverInfrastructure = function (infrastructureObject) {
            var infrastructureId = infrastructureObject.id;
            var completedInfraDiscoveryMessage = {
                'heading': 'Discovery Completed',
                'subHeading': 'Discovery Completed',
                'type': 'success'
            };

            var failedInfraDiscoveryMessage = {
                'heading': 'Discovery Failed',
                'subHeading': 'Discovery Failed',
                'type': 'fail'
            };

            return infrastructureConnectorService.discoverInfrastructure(infrastructureId).then(function (data) {
                return data;
            }, function (error) {
                console.log(error);
                //showError
            });
        };

        $scope.getCloudData = function () {
            if (typeof $sessionStorage.clouds === 'undefined' || $sessionStorage.clouds.length === 0) {
                infrastructureConnectorService.getListOfInfrastructures().then(function (data) {
                    $scope.cloudData = data;
                });
            } else {
                $sessionStorage.clouds = $scope.cloudData;
            }
        };

        $scope.totalFilteredResults = 0;
        // $scope.disablefields = false;

        $scope.querySearch = function (query) {
            return $scope.getFilteredResults(query);
        };

        /**
         * Create filter function for a query string
         */
        $scope.getFilteredResults = function (query) {
            var FilteredResults = [];
            for (var k in $scope.cloudData) {
                if ($scope.cloudData[k].name.indexOf(query) > -1) {
                    FilteredResults.push($scope.cloudData[k]);
                }
            }
            $scope.totalFilteredResults = FilteredResults.length;
            return FilteredResults;
        };

        $scope.setPreExistingInfra = false;

        $scope.selectedItemChange = function (item) {

            if (item !== undefined) {
                $scope.setPreExistingInfra = true;
                $scope.infrastructure.ip = item.ip;
                $scope.infrastructure.type = item.type;
                $scope.infrastructure.username = item.username;
                $scope.infrastructure.password = "******";
                if ($scope.infrastructure.type === 'OPENSTACK') {
                    $scope.infrastructure.domain = item.domain;
                    $scope.infrastructure.https = item.https;
                }

                //reset $sessionStorage cloud data with data selected
                $sessionStorage.cloudData = {};
                $sessionStorage.cloudData.cloudId = item.id;
                $sessionStorage.cloudData.infrastructure = item;
                $scope.enableNextButton();
            } else {
                $scope.setPreExistingInfra = false;
                $scope.searchTextChange();
            }
        };

        $scope.searchTextChange = function () {
            $scope.changedData = true;
            $scope.clearForm();
            $scope.infrastructureForm.infraIpFqdn.isDisabled = $scope.setPreExistingInfra;
            $scope.infrastructureForm.infraLogin.isDisabled = $scope.setPreExistingInfra;
            $scope.infrastructureForm.infraPassword.isDisabled = $scope.setPreExistingInfra;
            $scope.disableNextButton();
        };


        $scope.clearForm = function () {
            $scope.infrastructure.ip = "";
            $scope.infrastructure.username = "";
            $scope.infrastructure.password = "";
            $scope.infrastructure.domain = "";
            $scope.infrastructure.https = false;
        };

        $scope.changedData = false;


        if ($sessionStorage.cloudData && $sessionStorage.cloudData.infrastructure) {
            $scope.infrastructure = {};
            console.log($sessionStorage.cloudData.infrastructure);
            $scope.infrastructure.name = $sessionStorage.cloudData.infrastructure.name;
            $scope.infrastructure.type = $sessionStorage.cloudData.infrastructure.type;
            $scope.infrastructure.ip = $sessionStorage.cloudData.infrastructure.ip;
            $scope.infrastructure.username = $sessionStorage.cloudData.infrastructure.username;
            $scope.infrastructure.password = "******";
            if ($scope.infrastructure.type === 'OPENSTACK') {
                $scope.infrastructure.domain = $sessionStorage.cloudData.infrastructure.domain;
                $scope.infrastructure.https = $sessionStorage.cloudData.infrastructure.https;
            }
            $scope.infrastructureForm = {};
            $scope.enableNextButton();
            $scope.infrastructureForm.$invalid = true;

        }

        $scope.pwdType = 'password';
        $scope.togglePasswordType = function () {
            $scope.pwdType = $scope.pwdType === 'password' ? 'text' : 'password';
        };

        $scope.$watch('infrastructure', function (newObj, oldObj) {
            console.log(newObj);
            if (newObj.type === 'VMWARE') {
                if (newObj.ip && ($scope.searchText || newObj.name) && newObj.password && newObj.type && newObj.username)
                    $scope.enableNextButton();
                else
                    $scope.disableNextButton();
            }
            if (newObj.type === 'OPENSTACK') {
                if (newObj.ip && ($scope.searchText || newObj.name) && newObj.password && newObj.type && newObj.username && newObj.domain)
                    $scope.enableNextButton();
                else
                    $scope.disableNextButton();
            }
        }, true);

        $scope.$on('nextClicked', function (event, data) {
            if (!$scope.setPreExistingInfra) {
                data.stopNextClick = true;
                $scope.callCreateInfrastructure();
            }
        });

        $scope.$on('$viewContentLoaded', function (event) {
            if ($scope.infrastructure.ip && $scope.infrastructure.name && $scope.infrastructure.password && $scope.infrastructure.type && $scope.infrastructure.username)
                $scope.setPreExistingInfra = true;
            else
                $scope.disableNextButton();
        });

              
        fixContainerHeight(3);
 
    }

    angular.module('shieldxApp').controller('infrastructureConnectorCtr', infrastructureConnectorCtr);
})();


/*
 ShieldX Networks Inc. CONFIDENTIAL
 ----------------------------------
 *
 Copyright (c) 2016 ShieldX Networks Inc.
 All Rights Reserved.
 *
 NOTICE: All information contained herein is, and remains
 the property of ShieldX Networks Incorporated and its suppliers,
 if any. The intellectual and technical concepts contained
 herein are proprietary to ShieldX Networks Incorporated
 and its suppliers and may be covered by U.S. and Foreign Patents,
 patents in process, and are protected by trade secret or copyright law.
 Dissemination of this information or reproduction of this material
 is strictly forbidden unless prior written permission is obtained
 from ShieldX Networks Incorporated.
 */

(function () {
    function IPPoolsBackPlaneCtr($scope, $translate, $mdDialog, ipPoolServices, $state, $sessionStorage, $location, $anchorScroll) {

        if (!$sessionStorage.cloudData) {
            console.log('cloud Id not set');
            $state.go('landingpage');
        }else {
            if (!$sessionStorage.cloudData.cloudId) {
                console.log('cloud Id not set');
                $state.go('home.quickSetup.quickSetup-begin');
            }
            if (!$sessionStorage.cloudData.infrastructure) {
                console.log('cloud Id not set');
                $state.go('home.quickSetup.quickSetup-begin');
            }
            if (!$sessionStorage.cloudData.infrastructure.id) {
                console.log('cloud Id not set');
                $state.go('home.quickSetup.quickSetup-begin');
            }
            if (!$sessionStorage.cloudData.ipPool || !($sessionStorage.cloudData.ipPool.serverData)) {
                console.log('data not set in ipPool');
                $state.go('home.quickSetup.ip-pools-management');
            }
            if (!($sessionStorage.cloudData.ipPool.serverData.managmentNetworkHeaderValue) || !($sessionStorage.cloudData.ipPool.serverData.managmentIPPoolHeaderValue)) {
                console.log('data not set in ipPool');
                $state.go('home.quickSetup.ip-pools-management');
            }    
        }
        
        $scope.$emit('quickSetupBegun', {});
        $scope.activLink = 'Specify IP Addressing';
        var cloudData = ipPoolServices.getSessionData();
        if (cloudData.infrastructure.type === 'OPENSTACK') {
            $scope.cloudType = 'OPENSTACK';
            $scope.selectedData = 'dhcp';
        }
        $scope.active_help_id = "backplane_netw_help_wizard";
        $scope.headerValues = [{
                label: 'Connector', value: cloudData.infrastructure.name
            }, {
                label: 'Infrastructure', value: cloudData.infrastructure.ip
            }, {
                label: 'Management Network', value: cloudData.ipPool.serverData.managmentNetworkHeaderValue
            }, {
                label: 'Management IP Pool', value: cloudData.ipPool.serverData.managmentIPPoolHeaderValue
            }];

        $scope.quicksetup_heading = $translate.instant('quicksetup.heading.create_detect_protect');
        $scope.quicksetup_subheading = $translate.instant('quicksetup.subheading.our_wizard_will_get_you_setup_started_as_quick_as_flash');
        $scope.setLastQuickSetupPage();


        if (ipPoolServices.checkBackPlaneIPPoolDataPopulated()) {
            $scope.enableNextButton();
        }

        $scope.gotoBottom = function () {

            setTimeout(function () {

                console.log('gotoBottom() fires');
                // set the location.hash to the id of
                // the element you wish to scroll to.
                $location.hash('bottom');

                // call $anchorScroll()
                $anchorScroll();
            }, 0);

        };

        $scope.datValueChanged = function (value) {

            if (ipPoolServices.checkBackPlaneIPPoolDataPopulated())
            {

                $scope.enableNextButton();
            } else {

            }
        };

        $scope.$on('nextClicked', function (event, data) {

            if ($scope.activeScreenName == "ip-pools-backplane") {
                data.stopNextClick = true;
                var validationResult = $scope.validateAndSendDataToServer();
                var shouldGoNext = validationResult.result;
                console.log(" nextClicked >>>>>>>>>>>> " + validationResult.result);
                console.dir(validationResult.result);
                if (shouldGoNext) {
                    $sessionStorage.cloudData.savedState = $state.current.name;
                    $scope.getNextPage();
                } else
                {
                    validationResult.promise.then($scope.onIPPollCreatedSuccessFully, $scope.onIPPollCreationFailed);
                }
            }
        });

        $scope.onIPPollCreatedSuccessFully = function (data) {
            if ($scope.ipPoolData.typeOfIPSelected == "new")
            {
                toastparam = {
                    'heading': ' New IP Pool has been created successfully ',
                    'subHeading': "New IP Pool has been created",
                    'type': 'success',
                    'timeout': 5000,
                    'callback': function () {
                        $scope.getNextPage();
                    }
                };
                showToast(toastparam);
            }
            // $scope.getNextPage();
        };

        $scope.onIPPollCreationFailed = function (error) {
            //console.debug(" onIPPollCreationFailed show tost ");
            //console.dir(error);

            toastparam = {
                'heading': 'New IP Pool creation failed',
                'subHeading': "Error: " + error.data.message,
                'type': 'fail',
                'timeout': 5000
            };
            showToast(toastparam);
        };

        $scope.validateAndSendDataToServer = function () {
            if ($scope.ipPoolData.typeOfIPSelected == "new")
            {
                toastparam = {
                    'heading': ' New IP Pool Creation Started...',
                    'subHeading': "Calling Server API For IP Pool Creation",
                    'type': 'progress',
                    'timeout': 5000
                };
                showToast(toastparam);
            }
            return  ipPoolServices.commitBacklPlaneIpPoolData();
        };

        fixContainerHeight(4);

        $scope.ipPoolData = ipPoolServices.getIPPoolData().getBackPaneIPData();

        if (typeof $scope.ipPoolData.networkSelected == "undefined") {
            $scope.ipPoolData.networkSelected = {id: -1, name: ""};
        }


        if (cloudData.infrastructure.type === 'OPENSTACK') {
            $scope.ipPoolData.typeOfIPSelected = $scope.selectedData;
        }

        $scope.getNetworkNameFromID = function (id) {
            function findItem(item) {
                return item.id == id;
            }
            return _.find($scope.backPaneNetworks, findItem);
        };

        $scope.showBackPaneNetworkDialog = function (ev) {
            console.log(" showBackPaneNetworkDialog ");

            $mdDialog.show({
                controller: 'backPaneNetworkDialogCtr', templateUrl: 'core/components/administration/quick-setup/ip-pools/network-dialog/network-dialog.html', parent: angular.element(document.body), targetEvent: ev, clickOutsideToClose: true,
                locals: {
                    selectedNetworkID: $scope.ipPoolData.networkSelected.id,
                    title: $translate.instant("wizard.ippool.select_backpane_network.lower")

                }
            }).then(function (answerVal) {
                $scope.backPaneNetworks = answerVal.newtworks;
                var networkSelected = $scope.getNetworkNameFromID(answerVal.selectedVal);
                $scope.ipPoolData.networkSelected = {id: answerVal.selectedVal, name: networkSelected.label};
            }, function () {
                $scope.status = 'You cancelled the dialog.';
            });
        };


        $scope.hide = function () {
            $mdDialog.hide();
        };
        $scope.cancel = function () {
            $mdDialog.cancel();
        };
        $scope.answer = function (answer) {
            $mdDialog.hide(answer);
        };
    }
    angular.module('shieldxApp').controller('ipPoolsBackPlaneCtr', IPPoolsBackPlaneCtr);

    function backPlaneIPAddressPanelCtr($scope, $state, ipPoolServices) {
        $scope.forceRetriveIPPool = false;
        if ($scope.cloudType !== 'OPENSTACK') {
            if (typeof $scope.ipPoolData.typeOfIPSelected == "undefined" || $scope.ipPoolData.typeOfIPSelected === "") {
                $scope.selectedData = "existing";
                $scope.ipPoolData.typeOfIPSelected = $scope.selectedData;
            } else {
                $scope.selectedData = $scope.ipPoolData.typeOfIPSelected;
            }
        }



        $scope.radioClicked = function () {
            $scope.ipPoolData.typeOfIPSelected = $scope.selectedData;

            if ($scope.selectedData == "new") {
                $scope.disableNextButton();
                newSelected = true;
            } else if ($scope.selectedData == "existing") {
                $scope.forceRetriveIPPool = true;
                $scope.disableNextButton();
                existingSelected = true;
            } else if ($scope.selectedData == "dhcp") {
                dhcpSelected = true;
            }

        };

        $scope.$watch('ipPoolData.newIPData.name', function () {
            $scope.datValueChanged($scope.ipPoolData.newIPData.name);
        });

        $scope.$watch('ipPoolData.newIPData.discription', function () {
            $scope.datValueChanged($scope.ipPoolData.newIPData.discription);
        });


        $scope.$watch('ipPoolData.newIPData.startRange', function () {
            $scope.datValueChanged($scope.ipPoolData.newIPData.startRange);
        });

        $scope.$watch('ipPoolData.newIPData.endRange', function () {
            $scope.datValueChanged($scope.ipPoolData.newIPData.endRange);
        });

        $scope.$watch('ipPoolData.newIPData.gateway', function () {
            $scope.datValueChanged($scope.ipPoolData.newIPData.gateway);
        });

        $scope.$watch('ipPoolData.newIPData.mask', function () {
            $scope.datValueChanged($scope.ipPoolData.newIPData.mask);
        });

        $scope.$watch('ipPoolData.typeOfIPSelected', function () {
            $scope.datValueChanged($scope.ipPoolData.typeOfIPSelected);
        });

        $scope.$watch('ipPoolData.existingIP', function () {
            $scope.datValueChanged($scope.ipPoolData.existingIP);
        });

        $scope.$watch('ipPoolData.networkSelected.id', function () {
            $scope.datValueChanged($scope.ipPoolData.networkSelected.id);
        });
    }

    angular.module('shieldxApp').controller('backPlaneIPAddressPanelCtr', backPlaneIPAddressPanelCtr);

    function backPlaneDhcpPageCtr() {}
    angular.module('shieldxApp').controller('backPlaneDhcpPageCtr', backPlaneDhcpPageCtr);

    function backPlaneNewPageCtr() {}
    angular.module('shieldxApp').controller('backPlaneNewPageCtr', backPlaneNewPageCtr);

    function  backPlaneExistingPageCtr($scope, ipPoolServices) {
        $scope.existingIPFetched = false;
        $scope.forceRetriveIPPool = true;
        ipPoolServices.getExistingIPPoolListFromCache($scope.forceRetriveIPPool, {success: function (data) {
                $scope.ipPools = [];
                $scope.existingIPFetched = true;
                $scope.forceRetriveIPPool = false;
                for (var i in data) {
                    $scope.ipPools.push({id: data[i].id, name: data[i].name, description: data[i].descr, extdata: {raw: data}});
                }
                console.log("  getIpPoolList >>>>  " + $scope.ipPools);
            }});
    }
    angular.module('shieldxApp').controller('backPlaneExistingPageCtr', backPlaneExistingPageCtr);

    function backPlaneIPRangeCtr($scope, ipPoolServices) {

        var newIPData = ipPoolServices.getIPPoolData().getBackPaneIPData().newIPData;
        $scope.ipRangeRows = newIPData.getIPRangeRows();

        console.log(" managmentIPRangeCtr ");
        console.dir($scope.ipRangeRows);

        $scope.createRangeStartMessage = function (projectForm, index) {
            return   projectForm["rangeStart" + index].$error;
        };

        $scope.createRangeEndtMessage = function (projectForm, index) {
            return   projectForm["rangeEnd" + index].$error;
        };

        $scope.createCIDRMessage = function (projectForm, index) {
            return   projectForm["cidr" + index].$error;
        };

        $scope.addNewIPRangeRow = function (event) {
            console.log(" addNewIPRangeRow clicked");
            $scope.gotoBottom();
            newIPData.addNewIPRangeRow();

        };

        $scope.startIpRangeKeyDown = function ($event, ipRangeRowData) {
            console.log(" startIpRangeKeyDown ");
            console.dir(ipRangeRowData);
            if (ipRangeRowData.rangeStartValue || ipRangeRowData.rangeEndtValue) {
                ipRangeRowData.cidrValue = "";
                ipRangeRowData.rangeCIDREnableState = false;
            } else
            {
                ipRangeRowData.rangeCIDREnableState = true;
            }
            $scope.datValueChanged($scope.ipPoolData.newIPData.ranges);
        };

        $scope.endIPRangeKeyDown = function ($event, ipRangeRowData) {
            console.log(" endIPRangeKeyDown ");
            console.dir(ipRangeRowData);
            if (ipRangeRowData.rangeStartValue || ipRangeRowData.rangeEndtValue) {
                ipRangeRowData.cidrValue = "";
                ipRangeRowData.rangeCIDREnableState = false;
            } else
            {
                ipRangeRowData.rangeCIDREnableState = true;
            }
            $scope.datValueChanged($scope.ipPoolData.newIPData.ranges);
        };

        $scope.cidrIPRangeKeyDown = function ($event, ipRangeRowData) {
            console.log(" cidrIPRangeKeyDown ");
            console.dir(ipRangeRowData);
            if (ipRangeRowData.cidrValue) {
                ipRangeRowData.rangeStartValue = "";
                ipRangeRowData.rangeEndtValue = "";
                ipRangeRowData.rangeStartEnableState = false;
                ipRangeRowData.rangeEndEnableState = false;
            } else {
                ipRangeRowData.rangeStartEnableState = true;
                ipRangeRowData.rangeEndEnableState = true;
            }
            $scope.datValueChanged($scope.ipPoolData.newIPData.ranges);
        };

        $scope.deleteIPPool = function (event, ipRangeRowData, key) {
            newIPData.deleteIPRangeRow(key);
        };
    }
    angular.module('shieldxApp').controller('backPlaneIPRangeCtr', backPlaneIPRangeCtr);

})();
/*
 ShieldX Networks Inc. CONFIDENTIAL
 ----------------------------------
 *
 Copyright (c) 2016 ShieldX Networks Inc.
 All Rights Reserved.
 *
 NOTICE: All information contained herein is, and remains
 the property of ShieldX Networks Incorporated and its suppliers,
 if any. The intellectual and technical concepts contained
 herein are proprietary to ShieldX Networks Incorporated
 and its suppliers and may be covered by U.S. and Foreign Patents,
 patents in process, and are protected by trade secret or copyright law.
 Dissemination of this information or reproduction of this material
 is strictly forbidden unless prior written permission is obtained
 from ShieldX Networks Incorporated.
 */

(function () {
function IPPoolsManagementCtr($scope, $translate, $mdDialog, ipPoolServices, $state, $sessionStorage, $location, $anchorScroll, userSessionMenagment,screenMenagment) {
       
       
        screenMenagment.setCurrentScreen(screenMenagment.screens.WIZARD_SCREEN);
        userSessionMenagment.validateUserSession();
        if(!$sessionStorage.cloudData) {
            console.log('cloud Id not set');
            $state.go('landingpage');
        }else{
            if (!$sessionStorage.cloudData.cloudId) {
            console.log('cloud Id not set');
            $state.go('home.quickSetup.quickSetup-begin');
            }
            if (!$sessionStorage.cloudData.infrastructure) {
                console.log('cloud Id not set');
                $state.go('home.quickSetup.quickSetup-begin');
            }
            if (!$sessionStorage.cloudData.infrastructure.id) {
                console.log('cloud Id not set');
                $state.go('home.quickSetup.quickSetup-begin');
            }    
        }
        
        $scope.$emit('quickSetupBegun', {});
        $scope.activLink = 'Specify IP Addressing';
        $scope.active_help_id = "management_netw_help_wizard";
        var cloudData = ipPoolServices.getSessionData();
        console.log(cloudData);
        if (cloudData.infrastructure.type === 'OPENSTACK') {
            $scope.cloudType = 'OPENSTACK';
            $scope.selectedData = 'dhcp';

        }
        $scope.headerValues = [{
                label: 'Connector', value: cloudData.infrastructure.name
            }, {
                label: 'Infrastructure', value: cloudData.infrastructure.ip
            }];

        $scope.quicksetup_heading = $translate.instant('quicksetup.heading.create_detect_protect');
        $scope.quicksetup_subheading = $translate.instant('quicksetup.subheading.our_wizard_will_get_you_setup_started_as_quick_as_flash');
        $scope.setLastQuickSetupPage();
        $scope.invalidMask = false;
        console.log(" invalidMask " + $scope.invalidMask);

        if (ipPoolServices.checkManageMentIPPoolDataPopulated()) {
            $scope.enableNextButton();
        }
        $scope.datValueChanged = function (value) {
            console.log(" datValueChanged ");
            if (ipPoolServices.checkManageMentIPPoolDataPopulated())
            {
                $scope.enableNextButton();
            }
        };

        $scope.gotoBottom = function () {

            setTimeout(function () {

                console.log('gotoBottom() fires');
                // set the location.hash to the id of
                // the element you wish to scroll to.
                $location.hash('bottom');

                // call $anchorScroll()
                $anchorScroll();
            }, 0);

        };

        $scope.$on('nextClicked', function (event, data) {
            console.debug(" click next notified " + $scope.activeScreenName);
            if ($scope.activeScreenName == "ip-pools-management") {
                data.stopNextClick = true;
                var validationResult = $scope.validateAndSendDataToServer();
                var shouldGoNext = validationResult.result;
                console.debug(" nextClicked after validation value of shouldGoNext : " + shouldGoNext);
                if (shouldGoNext) {
                    $sessionStorage.cloudData.savedState = $state.current.name;
                    $scope.getNextPage();
                } else
                {
                    validationResult.promise.then($scope.onIPPollCreatedSuccessFully, $scope.onIPPollCreationFailed);
                }
            }
        });

        $scope.onIPPollCreatedSuccessFully = function (data) {
            console.debug(" onIPPollCreatedSuccessFully go to next page : ");
            if ($scope.ipPoolData.typeOfIPSelected == "new")
            {
                toastparam = {
                    'heading': ' New IP Pool  has been created successfully ',
                    'subHeading': "New IP Pool creation process is complete",
                    'type': 'success',
                    'timeout': 5000,
                    'callback': function () {
                        $scope.getNextPage();
                    }
                };
                showToast(toastparam);
            }

        };

        $scope.onIPPollCreationFailed = function (error) {
            //console.debug(" onIPPollCreationFailed show tost ");
            // console.dir(error);

            toastparam = {
                'heading': 'New IP Pool creation failed',
                'subHeading': "Error: " + error.data.message,
                'type': 'fail',
                'timeout': 5000
            };
            showToast(toastparam);
        };

        $scope.validateAndSendDataToServer = function () {

            if (parseInt($scope.ipPoolData.newIPData.mask) > 32) {
                $scope.invalidMask = true;
                var validationResult = {result: false};
                return validationResult;
            } else {
                $scope.invalidMask = false;
            }

            if ($scope.ipPoolData.typeOfIPSelected == "new")
            {
                toastparam = {
                    'heading': ' New IP Pool Creation Started...',
                    'subHeading': "Calling Server API For IP Pool Creation",
                    'type': 'progress',
                    'timeout': 7000
                };
                showToast(toastparam);
            }
            return ipPoolServices.commitManagmentIPPoolData();
        };

        fixContainerHeight(4);
        $scope.ipPoolData = ipPoolServices.getIPPoolData().getManagmentIPData();

        if (typeof $scope.ipPoolData.networkSelected == "undefined") {
            $scope.ipPoolData.networkSelected = {id: -1, name: ""};
        }




        if (cloudData.infrastructure.type === 'OPENSTACK') {
            $scope.ipPoolData.typeOfIPSelected = $scope.selectedData;
        }


        //console.log(" network selected "+$scope.ipPoolData.networkSelected.name);
        $scope.managmentNetworks = null;
        $scope.getNetworkNameFromID = function (id) {
            function findItem(item) {
                return item.id == id;
            }
            console.log("latest code base");
            return _.find($scope.managmentNetworks, findItem);
        };



        $scope.showManagmentNetworkDialog = function (ev) {
            $mdDialog.show({
                controller: 'managmentNetworkDialogCtr', templateUrl: 'core/components/administration/quick-setup/ip-pools/network-dialog/network-dialog.html', parent: angular.element(document.body), targetEvent: ev, clickOutsideToClose: true,
                locals: {
                    selectedNetworkID: $scope.ipPoolData.networkSelected.id,
                    title: $translate.instant("wizard.ippool.select_management_network.lower")
                }
            }).then(function (answerVal) {
                console.log(" answerVal >>> ");
                console.dir(answerVal);
                $scope.managmentNetworks = answerVal.newtworks;
                var networkSelected = $scope.getNetworkNameFromID(answerVal.selectedVal);
                $scope.ipPoolData.networkSelected = {id: answerVal.selectedVal, name: networkSelected.label};
            }, function () {
                $scope.status = 'You cancelled the dialog.';
            });
        };
    }

    angular.module('shieldxApp').controller('ipPoolsManagementCtr', IPPoolsManagementCtr);

    function managmentDhcpPageCtr() {}
    angular.module('shieldxApp').controller('managmentDhcpPageCtr', managmentDhcpPageCtr);

    function managmentNewPageCtr() {}
    angular.module('shieldxApp').controller('managmentNewPageCtr', managmentNewPageCtr);

    function managmentExistingPageCtr($scope, ipPoolServices) {
        $scope.existingIPFetched = false;
        $scope.forceRetriveIPPool = true;
        ipPoolServices.getExistingIPPoolListFromCache($scope.forceRetriveIPPool, {success: function (data) {
                $scope.forceRetriveIPPool = false;
                $scope.existingIPFetched = true;
                $scope.ipPools = [];
                for (var i in data) {
                    $scope.ipPools.push({id: data[i].id, name: data[i].name, description: data[i].descr, extdata: {raw: data}});
                }
                console.log(" managmentExistingPageCtr getIpPoolList >>>>  " + $scope.ipPools);
            }}).then(function () {
            console.log("get ip pool data >>>>>>>>>>>>>>>>>> ");
        });
    }
    angular.module('shieldxApp').controller('managmentExistingPageCtr', managmentExistingPageCtr);

    function managmentIPAddressPanelCtr($scope, $state, ipPoolServices) {
        $scope.forceRetriveIPPool = false;
        $scope.ipPanelManagmentData = {name: "managment", states: {"new": "home.quickSetup.ip-pools.managment-tab.new-ip-page", "existing": "home.quickSetup.ip-pools.managment-tab.existing-ip-page", "dhcp": "home.quickSetup.ip-pools.managment-tab.dhcp-page"}};
        console.log(" $scope.ipPoolData.typeOfIPSelected " + $scope.ipPoolData.typeOfIPSelected);
        if ($scope.cloudType !== 'OPENSTACK') {
            if (typeof $scope.ipPoolData.typeOfIPSelected == "undefined" || $scope.ipPoolData.typeOfIPSelected === "") {
                $scope.selectedData = "existing";
                $scope.ipPoolData.typeOfIPSelected = $scope.selectedData;
            } else {
                $scope.selectedData = $scope.ipPoolData.typeOfIPSelected;
            }
        }


        // console.log("$scope.ipPoolData.typeOfIPSelected  backPaneIPAddressPanelCtr "+$scope.ipPoolData.typeOfIPSelected );
        $scope.radioClicked = function () {
            //console.log($scope.selectedData + " radio button clicked " + $scope.ipPanelManagmentData.states["new"]);

            $scope.ipPoolData.typeOfIPSelected = $scope.selectedData;
            //console.log("$scope.ipPoolData.typeOfIPSelected  backPaneIPAddressPanelCtr "+$scope.ipPoolData.typeOfIPSelected );
            if ($scope.selectedData == "new") {
                $scope.disableNextButton();
                newSelected = true;
            } else if ($scope.selectedData == "existing") {
                $scope.forceRetriveIPPool = true;
                $scope.disableNextButton();
                existingSelected = true;
            } else if ($scope.selectedData == "dhcp") {
                dhcpSelected = true;
            }

            //$state.go($scope.ipPanelManagmentData.states[$scope.selectedData]);
        };

        $scope.$watch('ipPoolData.newIPData.name', function () {
            $scope.datValueChanged($scope.ipPoolData.newIPData.name);
        });

        $scope.$watch('ipPoolData.newIPData.discription', function () {
            $scope.datValueChanged($scope.ipPoolData.newIPData.discription);
        });

        $scope.$watch('ipPoolData.newIPData.gateway', function () {

            $scope.datValueChanged($scope.ipPoolData.newIPData.gateway);
        });

        $scope.$watch('ipPoolData.newIPData.mask', function () {
            console.log(" ipPoolData.newIPData.mask ");
            $scope.datValueChanged($scope.ipPoolData.newIPData.mask);
        });

        $scope.$watch('ipPoolData.typeOfIPSelected', function () {
            $scope.datValueChanged($scope.ipPoolData.typeOfIPSelected);
        });

        $scope.$watch('ipPoolData.networkSelected.id', function () {
            $scope.datValueChanged($scope.ipPoolData.networkSelected.id);
        });
        $scope.$watch('ipPoolData.existingIP', function () {
            $scope.datValueChanged($scope.ipPoolData.existingIP);
        });

    }
    angular.module('shieldxApp').controller('managmentIPAddressPanelCtr', managmentIPAddressPanelCtr);

    function managmentIPRangeCtr($scope, ipPoolServices) {

        var newIPData = ipPoolServices.getIPPoolData().getManagmentIPData().newIPData;
        $scope.ipRangeRows = newIPData.getIPRangeRows();

        console.log(" managmentIPRangeCtr ");
        console.dir($scope.ipRangeRows);

        $scope.addNewIPRangeRow = function (event) {
            console.log(" addNewIPRangeRow clicked");
            $scope.gotoBottom();
            newIPData.addNewIPRangeRow();

        };

        $scope.createRangeStartMessage = function (projectForm, index) {
            return   projectForm["rangeStart" + index].$error;
        };

        $scope.createRangeEndtMessage = function (projectForm, index) {
            return   projectForm["rangeEnd" + index].$error;
        };

        $scope.createCIDRMessage = function (projectForm, index) {
            return   projectForm["cidr" + index].$error;
        };

        $scope.startIpRangeKeyDown = function ($event, ipRangeRowData) {
            console.log(" startIpRangeKeyDown ");
            console.dir(ipRangeRowData);

            if (ipRangeRowData.rangeStartValue || ipRangeRowData.rangeEndtValue) {
                ipRangeRowData.cidrValue = "";
                ipRangeRowData.rangeCIDREnableState = false;
            } else
            {
                ipRangeRowData.rangeCIDREnableState = true;
            }


            $scope.datValueChanged($scope.ipPoolData.newIPData.ranges);
        };

        $scope.endIPRangeKeyDown = function ($event, ipRangeRowData) {
            console.log(" endIPRangeKeyDown ");
            console.dir(ipRangeRowData);

            if (ipRangeRowData.rangeStartValue || ipRangeRowData.rangeEndtValue) {
                ipRangeRowData.cidrValue = "";
                ipRangeRowData.rangeCIDREnableState = false;
            } else
            {
                ipRangeRowData.rangeCIDREnableState = true;
            }


            $scope.datValueChanged($scope.ipPoolData.newIPData.ranges);
        };

        $scope.cidrIPRangeKeyDown = function ($event, ipRangeRowData) {
            console.log(" cidrIPRangeKeyDown ");
            console.dir(ipRangeRowData);

            if (ipRangeRowData.cidrValue) {
                ipRangeRowData.rangeStartValue = "";
                ipRangeRowData.rangeEndtValue = "";
                ipRangeRowData.rangeStartEnableState = false;
                ipRangeRowData.rangeEndEnableState = false;
            } else {
                ipRangeRowData.rangeStartEnableState = true;
                ipRangeRowData.rangeEndEnableState = true;
            }

            $scope.datValueChanged($scope.ipPoolData.newIPData.ranges);
        };

        $scope.deleteIPPool = function (event, ipRangeRowData, key) {
            newIPData.deleteIPRangeRow(key);
        };
    }
    angular.module('shieldxApp').controller('managmentIPRangeCtr', managmentIPRangeCtr);

    function validateInteger() {

        var REGEX = /^\-?\d+$/;

        return {
            require: 'ngModel',
            link: function (scope, element, attrs, ctrl) {
                console.log(" ctrl ");
                console.dir(ctrl);

                ctrl.$validators.integer = function (modelValue, viewValue) {

                    if (REGEX.test(viewValue)) {
                        return true;
                    }
                    return false;
                };
            }
        };
    }
    angular.module('shieldxApp').directive('validateInteger', validateInteger);

})();
/*
 ShieldX Networks Inc. CONFIDENTIAL
 ----------------------------------
 *
 Copyright (c) 2016 ShieldX Networks Inc.
 All Rights Reserved.
 *
 NOTICE: All information contained herein is, and remains
 the property of ShieldX Networks Incorporated and its suppliers,
 if any. The intellectual and technical concepts contained
 herein are proprietary to ShieldX Networks Incorporated
 and its suppliers and may be covered by U.S. and Foreign Patents,
 patents in process, and are protected by trade secret or copyright law.
 Dissemination of this information or reproduction of this material
 is strictly forbidden unless prior written permission is obtained
 from ShieldX Networks Incorporated.
 */

(function () {
    function monitorNetworksCtr($sessionStorage, $scope, $state,
            virtualChassisService,
            $translate,
            deploymentSpecificationService,
            ipPoolServices
            ) {
        "ngInject";
        $scope.comingFromAdmin = false;
        $scope.$emit('quickSetupBegun', {});
        $scope.$storage = $sessionStorage;
        $scope.init = false;
        $scope.isViewAll = false;
        $scope.isViewGrouped = false;
        $scope.isViewUnGrouped = true;
        $scope.name = "Active";
        $scope.monitor_network_heading = $translate.instant('wizardnetworkmap.header.select_network');
        $scope.wizardnetworkmap_rightpanel_header = $translate.instant("wizardnetworkmap.rightpanel.header");
        $scope.monitor_network_heading_infra_name = ($sessionStorage.cloudData.infrastructure.name) ? $sessionStorage.cloudData.infrastructure.name : 'no value set';
        $scope.monitor_network_heading_vc_name = $sessionStorage.cloudData.vChassis.name;

        $scope.active_help_id = "virtualchassis_vieweditaddisecgroup_wizard";
       
        if (!$sessionStorage.cloudData) {
            $sessionStorage.cloudData = {};
//            console.log('cloudData not set');
            $state.go('home.quickSetup.quickSetup-begin');
        }else{
            if (!$sessionStorage.cloudData.cloudId) {
//            console.log('cloud Id not set');
            $state.go('home.quickSetup.infrastructure-connector');
            //$sessionStorage.cloudData.cloudId =  1; //THIS NEEDS TO BE REMOVED ONCE WE STORE IT FROM INFRASTRUCTURE
            }

            if (!$sessionStorage.cloudData.infrastructure) {
    //            console.log('cloud Id not set');
                $state.go('home.quickSetup.infrastructure-connector');
            }

            if (!$sessionStorage.cloudData.infrastructure.id) {
    //            console.log('cloud Id not set');
                $state.go('home.quickSetup.infrastructure-connector');
            }
            if (!$sessionStorage.cloudData.ipPool || !($sessionStorage.cloudData.ipPool.serverData)) {
    //            console.log('data not set in ipPool');
                $state.go('home.quickSetup.ip-pools-management');
            }
            if (!($sessionStorage.cloudData.ipPool.serverData.managmentNetworkHeaderValue) || !($sessionStorage.cloudData.ipPool.serverData.managmentIPPoolHeaderValue)) {
    //            console.log('data not set in ipPool');
                $state.go('home.quickSetup.ip-pools-management');
            }
            if (!($sessionStorage.cloudData.ipPool.serverData.backpaneIPPoolHeaderValue) || !($sessionStorage.cloudData.ipPool.serverData.backpaneNetworkHeaderValue)) {
    //            console.log('data not set in ipPool');
                $state.go('home.quickSetup.ip-pools-backplane');
            }

            if (!$sessionStorage.cloudData.deploySpec) {
    //            console.log('data not set in deployment spec');
                $state.go('home.quickSetup.deployment-specifications');
            }
            if (!$sessionStorage.cloudData.deploySpec.serverData) {
    //            console.log('data not set in deployment spec');
                $state.go('home.quickSetup.deployment-specifications');
            }
            if (!$sessionStorage.cloudData.deploySpec.serverData.deploymentSpecId) {
    //            console.log('data not set in deployment spec');
                $state.go('home.quickSetup.deployment-specifications');
            }
            if (!$sessionStorage.cloudData.vChassis.name || !($sessionStorage.cloudData.vChassis.selectedDeploymentSpec)) {
    //            console.log('data not set in Virtual Chassis screen');
                $state.go('home.quickSetup.virtual-chassis');
            }
        }
        

        //Write condition to check from where coming for $scope.headerValues.
        $scope.setLastQuickSetupPage();
        $scope.headerValues = [{
                label: 'Connector', value: $sessionStorage.cloudData.infrastructure.name
            }, {
                label: 'Infrastructure', value: $sessionStorage.cloudData.infrastructure.ip
            }, {
                label: 'Management Network', value: $sessionStorage.cloudData.ipPool.serverData.managmentNetworkHeaderValue
            }, {
                label: 'Management IP Pool', value: $sessionStorage.cloudData.ipPool.serverData.managmentIPPoolHeaderValue
            }, {
                label: 'Backplane Network', value: $sessionStorage.cloudData.ipPool.serverData.backpaneNetworkHeaderValue
            }, {
                label: 'Backplane IP Pool', value: $sessionStorage.cloudData.ipPool.serverData.backpaneIPPoolHeaderValue
            }, {
                label: 'Deployment Specification', value: $sessionStorage.cloudData.deploySpec.serverData.name
            }];
        //Write condition to check from where coming for $scope.headerValues. ENDS

        $scope.getTenantNameFromID = function (id) {

            var retVal = _.find($scope.tenants, function (tenantInd) {
                return tenantInd.id === id;
            });

            return retVal;
        };

        $scope.onNetworkSelected = function () {

            $scope.$broadcast('onNetworkSelectionChanged', {message: "newtwork selcetion changed"});
        };
        $scope.resourceGroupIndex = -1;
        if (!$sessionStorage.cloudData.vChassis.existingGroups) {
            $scope.existingGroups = [
            ];
            $sessionStorage.cloudData.vChassis.existingGroups = $scope.existingGroups;
        } else {

            var rt = $sessionStorage.cloudData.vChassis.existingGroups;
            $scope.existingGroups = [];
            for (var i = 0; i < rt.length; i++) {
                var tm = new ResourceGroups();
                tm.init(rt[i]);
                $scope.existingGroups.push(tm);
            }

            $sessionStorage.cloudData.vChassis.existingGroups = $scope.existingGroups;

        }

        console.log("monitorNetworksCtr initialize rule data >>>");
        console.dir($sessionStorage.cloudData.vChassis.resourceGroupArray);

         if(!$sessionStorage.cloudData.vChassis.resourceGroupArray){
            $scope.resourceGroupArray = []; 
            $sessionStorage.cloudData.vChassis.resourceGroupArray = $scope.resourceGroupArray;
        } else {

            var rga = $sessionStorage.cloudData.vChassis.resourceGroupArray;
            $scope.resourceGroupArray = [];
            for (var j = 0; j < rga.length; j++) {
                var rule = new SORule();
                rule.init(rga[j]);
                $scope.resourceGroupArray.push(rule);
            }

            console.log("monitorNetworksCtr initialize from session >>>");
             console.dir($scope.resourceGroupArray);
            $sessionStorage.cloudData.vChassis.resourceGroupArray = $scope.resourceGroupArray;

        }

        $scope.$on("newrulecreated", function (event, args) {
            console.log("disableNextButton new rule added");
            $scope.disableNextButton();
        });
        $scope.$on("existingruleupdated", function (event, args) {
            console.log("disableNextButton rule updated");
            $scope.disableNextButton();
        });
        $scope.$on("newRuleCreated", function(arg){
         console.log("monitorNetworksCtr newRuleCreated >>>>>>>>>>>>> "+$scope.resourceGroupArray);
         console.log($scope.resourceGroupArray);
        });
       


        $scope.headerValues = [{
                label: 'Connector', value: $sessionStorage.cloudData.infrastructure.name
            }, {
                label: 'Infrastructure', value: $sessionStorage.cloudData.infrastructure.ip
            }, {
                label: 'Management Network', value: $sessionStorage.cloudData.ipPool.serverData.managmentNetworkHeaderValue
            }, {
                label: 'Management IP Pool', value: $sessionStorage.cloudData.ipPool.serverData.managmentIPPoolHeaderValue
            }, {
                label: 'Backplane Network', value: $sessionStorage.cloudData.ipPool.serverData.backpaneNetworkHeaderValue
            }, {
                label: 'Backplane IP Pool', value: $sessionStorage.cloudData.ipPool.serverData.backpaneIPPoolHeaderValue
            }, {
                label: 'Deployment Specification', value: $sessionStorage.cloudData.deploySpec.serverData.name
            }];

        //Write condition to check from where coming for $scope.headerValues.
        var cloudId = $sessionStorage.cloudData.cloudId;
        $scope.cloudId = cloudId;
        var vChassisName = ($sessionStorage.cloudData.vChassis.name) ? $sessionStorage.cloudData.vChassis.name : $state.go('home.quickSetup.virtual-chassis');
        var vChassisDesc = $sessionStorage.cloudData.vChassis.desc;
        var vChassisSelectedDeploymentSpec = ($sessionStorage.cloudData.vChassis.selectedDeploymentSpec) ? $sessionStorage.cloudData.vChassis.selectedDeploymentSpec : $state.go('home.quickSetup.virtual-chassis');
        $scope.inlineModeAvailable = deploymentSpecificationService.isinlineModeAvailable(
                cloudId,
                vChassisSelectedDeploymentSpec);

         $scope.OSRuleConfig = new OSRuleConfig($scope.inlineModeAvailable, true, OSRuleConfig.modes.WIZARD_MODE);

        $scope.$on(SOEvents.ruleAllCommitedEvent, function (event, args) {
//            console.log("resourceGroupCreated  >>>> 1 " + $scope.resourceGroupArray);
            $scope.checkCommit();
//            console.log("resourceGroupCreated  >>>> 2 ");
        });

        $sessionStorage.cloudData.networks = [];
        $scope.securityPolicySet = [];
        $scope.viewall = 'active-link';
        $scope.viewselected = false;

        
        $scope.checkCommit = function () {
//            console.log(" checkCommit " + $scope.resourceGroupArray.length);
            if ($scope.resourceGroupArray.length > 0) {
                $scope.enableNextButton();
            } else {
                $scope.disableNextButton();
            }
        };

        $scope.$on('nextClicked', function (event, data) {
            // console.log('cmg here');
            data.stopNextClick = true;
            $scope.startCreatingChassis();
        });
        $scope.startCreatingChassis = function () {
            $scope.createChassis();
        };

        $scope.createResourceGroup = function () {
            if ($scope.resourceGroupIndex < $scope.existingGroups.length) {
                var rs = $scope.existingGroups[$scope.resourceGroupIndex];
                if (!rs.id) {
                    var createResouceParams = {
                        "cloudId": cloudId,
                        "id": 0,
                        "memberList": rs.getNetworkServerFormat(),
                        "name": rs.name,
                        "tenantId": rs.tenant
                    };
                    virtualChassisService.createResourceGroup(createResouceParams).then(
                            function (resData) {
                                rs.id = resData;
                                if ($scope.resourceGroupIndex < $scope.existingGroups.length) {
                                    $scope.resourceGroupIndex++;
                                    $scope.createResourceGroup();
                                } else
                                {
                                    // $scope.createChassis(); 
                                }

                            }, function (error) {

                    });
                } else {
                    $scope.resourceGroupIndex++;
                    $scope.createResourceGroup();
                }
            } else {
                if (!$sessionStorage.cloudData.vChassis.id) {
                    $scope.createChassis();
                } else {
                    $scope.updateChassis();
                }
            }
        };

        $scope.createChassis = function () {
            var vChassisParamObject = SORuleUtil.getNewVitrialChassisJSON(vChassisName, vChassisSelectedDeploymentSpec, $scope.resourceGroupArray);
            virtualChassisService.createVirtualChassis(vChassisParamObject).then(function (vchassisData) {
//                console.log("createVirtualChassis  virtual chasis created successfully");
                ///created vchassis move user to another location
                delete $scope.$storage.cloudData;
                $scope.$emit('quickSetupEnded', {});
                var toastparam = {
                    'heading': 'Data Plane created successfully',
                    'subHeading': "",
                    'type': 'success',
                    'timeout': 5000,
                    'callback': gotoChassisListing()
                };
                showToast(toastparam);

            }, function (error) {
                var toastparam = {
                    'heading': 'Data Plane creation failed',
                    'subHeading': "Error: " + error.data.message,
                    'type': 'fail',
                    'timeout': 5000,
                    'callback': gotoChassisListing()
                };
                showToast(toastparam);
                saveCurrentState();
            });
        };

        saveCurrentState = function () {
            if (!$sessionStorage.cloudData.comingFrom) {
                $sessionStorage.cloudData.savedState = $state.current.name;
            }
        };

        gotoChassisListing = function () {
            if ($scope.comingFromAdmin) {
                $scope.hide();
            }
            $state.go('home.virtualChassis');
        };

        $scope.updateChassis = function () {
            toastparam = {
                'heading': 'Date Plane update in progress',
                'subHeading': "Data Plane update initiated. This should take only a few minutes max.",
                'type': 'progress',
                'timeout': 5000
            };
            showToast(toastparam);
            var vChassisParamObject = {
                "cloudId": cloudId,
                "datapathDeploySpecId": vChassisSelectedDeploymentSpec,
                "descr": vChassisDesc,
                "id": $scope.cloudData.vChassis.id,
                "name": vChassisName,
                "subscriptionList": virtualChassisService.createSubscriptionList($scope.existingGroups)
            };

            virtualChassisService.updateVirtualChassis(vChassisParamObject).then(function (vchassisData) {
                ///created vchassis move user to another location
                delete $scope.$storage.cloudData;
                $scope.$emit('quickSetupEnded', {});
                toastparam = {
                    'heading': 'Data Plane updated successfully',
                    'subHeading': "",
                    'type': 'success',
                    'timeout': 2000,
                    'callback': function () {
                        $state.go('home.virtualChassis');
                    }
                };
                showToast(toastparam);
                $mdDialog.hide();
                $state.go("home.virtualChassis");

            }, function (error) {
                //ERROR HANDLING WILL COME HERE
//                console.log(error);
                toastparam = {
                    'heading': 'Data Plane update failed',
                    'subHeading': "Error: " + error.data.message,
                    'type': 'fail',
                    'timeout': 5000,
                    'callback': function () {
                        $state.go('home.virtualChassis');
                    }
                };
                showToast(toastparam);
                saveCurrentState();
                $state.go("home.virtualChassis");

            });
        };

        $scope.checkCommit();
        fixManageNetworkHeight();
        saveCurrentState();
        
        $scope.networksavailable = $sessionStorage.cloudData.ipPool.networks;
        $scope.resourcegroups = $sessionStorage.cloudData.vChassis.resourceGroup;
        $scope.backplanenetworkid = $sessionStorage.cloudData.ipPool.serverData.backPlaneNetworkId;
        $scope.managmentnetworkid = $sessionStorage.cloudData.ipPool.serverData.mgmtNetworkId;
        $scope.existinggroups = $sessionStorage.cloudData.vChassis.existingGroups;
    }

    angular.module('shieldxApp').controller('monitorNetworksCtr', monitorNetworksCtr);

})();

/*
 ShieldX Networks Inc. CONFIDENTIAL
 ----------------------------------
 *
 Copyright (c) 2016 ShieldX Networks Inc.
 All Rights Reserved.
 *
 NOTICE: All information contained herein is, and remains
 the property of ShieldX Networks Incorporated and its suppliers,
 if any. The intellectual and technical concepts contained
 herein are proprietary to ShieldX Networks Incorporated
 and its suppliers and may be covered by U.S. and Foreign Patents,
 patents in process, and are protected by trade secret or copyright law.
 Dissemination of this information or reproduction of this material
 is strictly forbidden unless prior written permission is obtained
 from ShieldX Networks Incorporated.
 */

(function () {
    function virtualChassisCtr($scope,
            $state,
            $translate,
            deploymentSpecificationService,
            virtualChassisService,
            $sessionStorage
            ) {
        "ngInject";

        console.log("virtualChasisCtr initialised");

        $scope.$emit('quickSetupBegun', {});

        $scope.virtual_chassis_heading = $translate.instant('wizardinfrastucture.virtual_chassis.heading');
        $scope.virtual_chassis_subheading = $translate.instant('wizardinfrastucture.virtual_chassis.subheading.message');
        $scope.virtual_chassis_name = $translate.instant("wizardinfrastucture.virtual_chassis.placeholder.name");
        $scope.virtual_chassis_description = $translate.instant("wizardinfrastucture.virtual_chassis.placeholder.description");

        $scope.active_help_id = "virtual_chassis_title_help_wizard";
        
        console.log($sessionStorage.cloudData);
        if (!$sessionStorage.cloudData) {
            $sessionStorage.cloudData = {};
            console.log('cloudData not set');
            $state.go('landingpage');
        }else{
            if (!$sessionStorage.cloudData.cloudId) {
            console.log('cloud Id not set');
            $state.go('home.quickSetup.quickSetup-begin');
            //$sessionStorage.cloudData.cloudId =  1; //THIS NEEDS TO BE REMOVED ONCE WE STORE IT FROM INFRASTRUCTURE
            }

            if (!$sessionStorage.cloudData.infrastructure) {
                console.log('cloud Id not set');
                $state.go('home.quickSetup.quickSetup-begin');
            }
            if (!$sessionStorage.cloudData.infrastructure.id) {
                console.log('cloud Id not set');
                $state.go('home.quickSetup.quickSetup-begin');
            }
            if (!$sessionStorage.cloudData.ipPool || !($sessionStorage.cloudData.ipPool.serverData)) {
                console.log('data not set in ipPool');
                $state.go('home.quickSetup.ip-pools-management');
            }
            if (!($sessionStorage.cloudData.ipPool.serverData.managmentNetworkHeaderValue) || !($sessionStorage.cloudData.ipPool.serverData.managmentIPPoolHeaderValue)) {
                console.log('data not set in ipPool');
                $state.go('home.quickSetup.ip-pools-management');
            }
            if (!($sessionStorage.cloudData.ipPool.serverData.backpaneIPPoolHeaderValue) || !($sessionStorage.cloudData.ipPool.serverData.backpaneNetworkHeaderValue)) {
                console.log('data not set in ipPool');
                $state.go('home.quickSetup.ip-pools-backplane');
            }

            if (!$sessionStorage.cloudData.deploySpec) {
                console.log('data not set in deployment spec');
                $state.go('home.quickSetup.deployment-specifications');
            }
            if (!$sessionStorage.cloudData.deploySpec.serverData) {
                console.log('data not set in deployment spec');
                $state.go('home.quickSetup.deployment-specifications');
            }
            if (!$sessionStorage.cloudData.deploySpec.serverData.deploymentSpecId) {
                console.log('data not set in deployment spec');
                $state.go('home.quickSetup.deployment-specifications');
            }    
        }
        
        if (!$sessionStorage.cloudData.vChassis) {
            $sessionStorage.cloudData.vChassis = {};
        }

        $scope.headerValues = [{
                label: 'Connector', value: $sessionStorage.cloudData.infrastructure.name
            }, {
                label: 'Infrastructure', value: $sessionStorage.cloudData.infrastructure.ip
            }, {
                label: 'Management Network', value: $sessionStorage.cloudData.ipPool.serverData.managmentNetworkHeaderValue
            }, {
                label: 'Management IP Pool', value: $sessionStorage.cloudData.ipPool.serverData.managmentIPPoolHeaderValue
            }, {
                label: 'Backplane Network', value: $sessionStorage.cloudData.ipPool.serverData.backpaneNetworkHeaderValue
            }, {
                label: 'Backplane IP Pool', value: $sessionStorage.cloudData.ipPool.serverData.backpaneIPPoolHeaderValue
            }
        ];


        deploymentSpecificationService.getDeploymentSpecList($sessionStorage.cloudData.cloudId).then(function (data) {
            $scope.virtualChassisList = data;

            if ($sessionStorage.cloudData.deploySpec.serverData.deploymentSpecId) {
                $scope.vChassis.virtualChassisSelected = $sessionStorage.cloudData.deploySpec.serverData.deploymentSpecId;
                //$scope.vChassis.virtualChassisSelected = $sessionStorage.cloudData.vChassis.selectedDeploymentSpec;
            } else {
                //$scope.vChassis.virtualChassisSelected = $scope.virtualChassisList[0].id;
                $state.go('home.quickSetup.deployment-specifications');
            }
        }, function (error) {
            console.log(error);
            $scope.virtualChassisList = [];
            if ($sessionStorage.cloudData.deploySpec.serverData.deploymentSpecId) {
                $scope.vChassis.virtualChassisSelected = $sessionStorage.cloudData.deploySpec.serverData.deploymentSpecId;
                //$scope.vChassis.virtualChassisSelected = $sessionStorage.cloudData.vChassis.selectedDeploymentSpec;
            } else {
                //$scope.vChassis.virtualChassisSelected = 100;
                $state.go('home.quickSetup.deployment-specifications');
            }
        });

        $scope.vChassis = {};
        if ($sessionStorage.cloudData.vChassis.name) {
            $scope.vChassis.name = $sessionStorage.cloudData.vChassis.name;
        } else {
            $scope.vChassis.name = '';
        }
        if ($sessionStorage.cloudData.vChassis.desc) {
            $scope.vChassis.desc = $sessionStorage.cloudData.vChassis.desc;
        } else {
            $scope.vChassis.desc = '';
        }

        $scope.$watch('vChassis.name', function () {
            $scope.checkNext();
        });

        $scope.$watch('vChassis.virtualChassisSelected', function () {
            $scope.checkNext();
        });

        $scope.checkNext = function () {
            if ($scope.vChassis.name && $scope.vChassis.virtualChassisSelected) {
                if (($scope.vChassis.name.length > 0) && ($scope.vChassis.virtualChassisSelected > 0))
                {
                    //console.log("enable next ");
                    $scope.enableNextButton();
                }
            } else {
                $scope.disableNextButton();
            }
        };

        $scope.$on('nextClicked', function (event, data) {
            data.stopNextClick = true;
            //$scope.createdeploymentspecification();
            $sessionStorage.cloudData.vChassis.name = $scope.vChassis.name;
            $sessionStorage.cloudData.vChassis.desc = $scope.vChassis.desc;
            $sessionStorage.cloudData.vChassis.selectedDeploymentSpec = $scope.vChassis.virtualChassisSelected;
            $sessionStorage.cloudData.savedState = $state.current.name;
            console.log($sessionStorage.cloudData);
            $state.go('home.quickSetup.monitor-networks');
        });
        fixContainerHeight(4);
        $scope.setFocusOnElem('#virtualChassisNameID');
    }
    angular.module('shieldxApp').controller('virtualChassisCtr', virtualChassisCtr);

})();
/*
 ShieldX Networks Inc. CONFIDENTIAL
 ----------------------------------
 *
 Copyright (c) 2016 ShieldX Networks Inc.
 All Rights Reserved.
 *
 NOTICE: All information contained herein is, and remains
 the property of ShieldX Networks Incorporated and its suppliers,
 if any. The intellectual and technical concepts contained
 herein are proprietary to ShieldX Networks Incorporated
 and its suppliers and may be covered by U.S. and Foreign Patents,
 patents in process, and are protected by trade secret or copyright law.
 Dissemination of this information or reproduction of this material
 is strictly forbidden unless prior written permission is obtained
 from ShieldX Networks Incorporated.
 */

(function () {
    function quickSetupBeginCtr($scope,
            $sessionStorage,
            $rootScope,
            $state,
            $translate,
            $mdDialog,
            userSessionMenagment) {
        "ngInject";
        clearAllSession($sessionStorage);
        $scope.quicksetup_heading = $translate.instant('quicksetup.heading.create_detect_protect');
        $scope.quicksetup_subheading = $translate.instant('quicksetup.subheading.our_wizard_will_get_you_setup_started_as_quick_as_flash');

        $scope.$storage = $sessionStorage;
        $scope.resumeWizard = false;
        $scope.$gotoState = '';
        $scope.active_help_id = "splashPage_help_wizard";
        $scope.showHelp = false;
        $scope.getWiardState = function () {
            if ($scope.$storage.hasOwnProperty('cloudData')) {
                if ($scope.$storage.cloudData.hasOwnProperty('savedState')) {
                    $scope.resumeWizard = true;
                    $scope.infraName = $scope.$storage.cloudData.infrastructure.name;
                    $scope.$gotoState = $scope.$storage.cloudData.savedState;
                }
            }
        };

        $scope.helpButtonClicked = function(id){
                $scope.active_help_id = id;
                $scope.showHelp =  !$scope.showHelp;
                console.log(" helpButtonClicked ");
                $scope.bordcastEventHelpButtonClicked($scope.active_help_id);
                
        };
        //$scope.is_quick_setup_enabled = false;
        function isQuickSetupEnabled(){
            var idToCheck  = [];
            idToCheck.push( authorities("infrastructureConnectors_discover"));
            idToCheck.push(authorities("deploymentSpecifications_create"));
            idToCheck.push(authorities("virtualChassis_create"));
            idToCheck.push(authorities("resourceGroups_create"));
            $scope.is_quick_setup_enabled = userSessionMenagment.isUserAllowd(idToCheck); 
        }
        $scope.$on("authoritiesListavalibale",function(event,data){
                isQuickSetupEnabled();
        });

        if($sessionStorage.userdata.authorities){
            isQuickSetupEnabled();
        }
           
        $scope.startNew = function () {
            delete $scope.$storage.cloudData;
            delete $sessionStorage.qSdeploySpecvlanDataId;
            delete $sessionStorage.qSdeploySpecvlanData;
            delete $sessionStorage.qSdeploySpecvData;
            delete $sessionStorage.qSdeploySpecvDataId;
            
            $state.go('home.quickSetup.infrastructure-connector');
        };
        $scope.resume = function () {
            $state.go($scope.$gotoState);
        };

        $scope.showAnimation = function(ev){
            $mdDialog.show({
                controller: 'AnimationDialogCtr', templateUrl: 'core/components/administration/quick-setup/quick-setup-begin/animation-dialog/animation-dialog-templet.html', parent: angular.element(document.body), targetEvent: ev, clickOutsideToClose: true
            }).then(function (answerVal) {
            }, function () {
                
            });
        };


        //$scope.getWiardState();

        

        /*slider*/
        $scope.slides = [
            {image: 'images/Canvas 1.png', description: 'Canvas 1'},
            {image: 'images/Canvas 2.png', description: 'Canvas 2'},
            {image: 'images/Canvas 3.png', description: 'Canvas 3'},
            {image: 'images/Canvas 4.png', description: 'Canvas 4'},
            {image: 'images/Canvas 5.png', description: 'Canvas 5'},
            {image: 'images/Canvas 6.png', description: 'Canvas 6'},
            {image: 'images/Canvas 7.png', description: 'Canvas 7'}
        ];

        $scope.direction = 'left';
        $scope.currentIndex = 0;

        $scope.setCurrentSlideIndex = function (index) {
            $scope.direction = (index > $scope.currentIndex) ? 'left' : 'right';
            $scope.currentIndex = index;
        };

        $scope.isCurrentSlideIndex = function (index) {
            return $scope.currentIndex === index;
        };

        $scope.prevSlide = function () {
            $scope.direction = 'left';
            $scope.currentIndex = ($scope.currentIndex < $scope.slides.length - 1) ? ++$scope.currentIndex : 0;
        };

        $scope.nextSlide = function () {
            $scope.direction = 'right';
            $scope.currentIndex = ($scope.currentIndex > 0) ? --$scope.currentIndex : $scope.slides.length - 1;
        };

        /*end slider*/
        $scope.$on('$stateChangeSuccess', function (event, toState, toParams, fromState, fromParams) {
            if ($state.is('home.quickSetup.quickSetup-begin')) {
                console.log("scope change from quickSetupBeginCtr");
                $scope.getWiardState();
            }
        });

        $scope.activLink = '';
        fixContainerHeight(1);
    }

    angular.module('shieldxApp').controller('quickSetupBeginCtr', quickSetupBeginCtr)
    .animation('.slide-animation', function () {
        return {
            beforeAddClass: function (element, className, done) {
                var scope = element.scope();

                if (className == 'ng-hide') {
                    var finishPoint = element[0].clientWidth;
                    if(scope.direction !== 'right') {
                        finishPoint = -finishPoint;
                    }
                    TweenMax.to(element, 0.5, {left: finishPoint, onComplete: done });
                }
                else {
                    done();
                }
            },
            removeClass: function (element, className, done) {
                var scope = element.scope();

                if (className == 'ng-hide') {
                    element.removeClass('ng-hide');

                    var startPoint = element[0].clientWidth;
                    if(scope.direction === 'right') {
                        startPoint = -startPoint;
                    }

                   TweenMax.fromTo(element, 0.5, { left: startPoint }, {left: 0, onComplete: done });
                }
                else {
                    done();
                }
            }
        };
    });
})();


/*
 ShieldX Networks Inc. CONFIDENTIAL
 ----------------------------------
 *
 Copyright (c) 2016 ShieldX Networks Inc.
 All Rights Reserved.
 *
 NOTICE: All information contained herein is, and remains
 the property of ShieldX Networks Incorporated and its suppliers,
 if any. The intellectual and technical concepts contained
 herein are proprietary to ShieldX Networks Incorporated
 and its suppliers and may be covered by U.S. and Foreign Patents,
 patents in process, and are protected by trade secret or copyright law.
 Dissemination of this information or reproduction of this material
 is strictly forbidden unless prior written permission is obtained
 from ShieldX Networks Incorporated.
 */

(function() {
        function accessPolicyCtrl(
            $scope,
            $state,
            $translate,
            $sessionStorage,
            policyService,
            $timeout,
            $q,
            $mdDialog,
            infrastructureConnectorService
        ) {
            var deferred = $q.defer();
            $scope.promise = deferred.promise;
            $scope.promiseCompleted = true;
            $scope.policyselected = [];
            $scope.query = {
                order: 'name',
                limit: 10,
                page: 1
            };
            $scope.isSearchBarOpen = false;
            $scope.saveupdatepolicyAdd = true;
            $scope.modeValue = "add_mode";
            $scope.$on("listenAclPolicyData", function(event, data) {
                $scope.aclRules = data.data;
                $scope.saveupdatepolicyAdd = false;
            });
            $scope.resGroupTotalList = [];
            var newPolicyId = parseInt($state.params.newPolicy);
            var DuplicatedPolicy = $state.params.duplicated;
            $scope.tenantsList = [];
            $scope.tenantsListCompleted = false;
            $scope.resListCompleted = false;
            $scope.aclPolicyListPromise = false;
            policyService.getTotalTenats().then(function(data){
                    $scope.tenantsList = data;
                    $scope.tenantsListCompleted = true;
                    renderData();
            },function(err) {
                $scope.tenantsListCompleted = true;
                console.log("unable to fetch tenants");
                renderData();
            });

            /* policyService.getResourceGroupData().then(function(data){
                $scope.totalResGroupTotalList = data;
                $scope.resListCompleted = true;
             },function(err){
                $scope.resListCompleted = true;
                console.log("unable to fetch Resource Groups")
             });*/
            policyService.getDataBasedOnId("policy", "accesscontrolpolicy").then(function(data) {
                   /*  _.each(data,function(item){
                        var d = new Date(item.lastModified);
                        item.modifiedDate = d.getDate() + '/' + (d.getMonth()+1) + '/' + d.getFullYear();
                    });*/
                    $scope.aclPolicyTotalData = data;
                    $scope.aclPolicyListPromise = true;
                    deferred.resolve();
                    renderData();
                },function(err) {
                    console.log("Access Control policy error data");
                    deferred.reject();
                    $scope.aclPolicyListPromise = true;
                    renderData();
                
            }); 

            function renderData(){
                if($scope.aclPolicyListPromise && $scope.tenantsListCompleted){
                    $scope.accessPolicyData = [];
                    $scope.promiseCompleted = false;
                    _.each($scope.tenantsList, function(value) {
                        for (var i = 0; i < $scope.aclPolicyTotalData.length; i++) {
                            if ($scope.aclPolicyTotalData[i].tenantId === value.id) {
                                $scope.aclPolicyTotalData[i].tenantName = value.name;
                            }
                        }
                    });
                    if (newPolicyId) {
                        _.each($scope.aclPolicyTotalData, function(value, key) {
                            if (value.id === newPolicyId) {
                                if (DuplicatedPolicy !== '') {
                                    value.duplicatedPolicy = true;
                                } else {
                                    value.newPolicy = true;
                                }
                                $scope.accessPolicyData.unshift(value);
                            } else {
                                $scope.accessPolicyData.push(value);
                            }
                        });
                    } else {
                        $scope.accessPolicyData = $scope.aclPolicyTotalData;
                    }
                }
            }


            $scope.deleteaccessPolicy = function(data) {
                        toastparam = {
                            'heading': 'Access Control Policy delete inprogress',
                            'subHeading': 'Access Control Policy delete Intiated with name ' + data.name,
                            'type': 'progress',
                            'timeout': 15000
                        };
                        showToast(toastparam);
                        policyService.deletePolicyBasedOnID("policy/accesscontrolpolicy", data.id).then(function(res) {
                            toastparam = {
                                'heading': 'Access Control Policy deleted  Successfully',
                                'subHeading': 'Access Control Policy deleted with name ' + data.name,
                                'type': 'success',
                                'timeout': 5000
                            };
                            showToast(toastparam);
                        }, function(err) {
                            toastparam = {
                                'heading': 'Access Control Policy delete  failed',
                                'subHeading': 'Access Control Policy delete failed with error ' + err.message,
                                'type': 'fail',
                                'timeout': 5000
                            };
                            showToast(toastparam);
                        }).finally(function() {
                            $state.reload();
                        });

                };
                $scope.showResourceGroupData = function(event,data){
                    $scope.assignmentPolicyName = data;
                    $mdDialog.show({
                        skipHide: true,
                        controller: resGroupListCtrl,
                        bindToController: true,
                        preserveScope: true,
                        templateUrl: 'core/components/administration/policy/res-group-list.html',
                        parent: angular.element(document.body),
                        targetEvent: event,
                        fullscreen: false,
                        scope: $scope,
                        openFrom: { top: 1100, height: 0 },
                        closeTo: { left: 1500 }
                    }).then(function() {

                    });

                };
                function resGroupListCtrl($scope,$mdDialog){
                    $scope.isAGSearchBarOpen = false;
                    $scope.cancelassignmentControlDialogue = function() {
                            $mdDialog.cancel();
                            //$state.reload();
                    };
             /*       _.each($scope.aclRulesData,function(aclrules){
                        if(aclrules.destinationResourceGroupList.length>0){
                            aclrules.resourcegroupNames = [];
                            _.each(aclrules.destinationResourceGroupList,function(value){
                                     var resgroup = _.find($scope.totalResGroupTotalList, function(resGroup) {
                                            return resGroup.id === value;
                                        });
                                        if (resgroup) {
                                            aclrules.resourcegroupNames.push(resgroup.name);
                                        }
                            });
                        }
                    });*/
                    $scope.toggleSearchBarAsignment = function(event) {
                    $scope.isAGSearchBarOpen = $scope.isAGSearchBarOpen === false ? true : false;
                    if ($scope.isAGSearchBarOpen)
                        angular.element(event.currentTarget.firstElementChild).css('color', '#4a90e2');
                    else
                        angular.element(event.currentTarget.firstElementChild).css('color', '#6d6e71');
                };

                }

                $scope.callpopupToAddNewAccess = function(eve) {
                    $scope.tenantselected = false;
                    $scope.policyname = '';
                    //$scope.selectedTenantObj = '';
                    $scope.selectedTenantsValue = '';
                    var ImplicitDenyAllData = [{"action":"DENY",
                        "description":"ImplicitDenyAll",                                    
                        "destinationApps":"Any",
                        "destinationCidrs":"Any",
                        "destinationPortRanges":"Any",
                        "destinationProtocol":null,
                        "destinationResourceGroupList":[],
                        "resourcegroupNames":[],
                        "enabled":true,
                        "enableTLSInspection":false,
                        "id":0,
                        "name":"ImplicitDenyAll",
                        "orderNum":1}];
                    $scope.aclPolicyData = ImplicitDenyAllData;
                    $mdDialog.show({
                        skipHide: true,
                        controller: policyListACLTypeCtr,
                        bindToController: true,
                        preserveScope: true,
                        templateUrl: 'core/components/administration/policy/acl/new-acl-policy.html',
                        parent: angular.element(document.body),
                        targetEvent: eve,
                        fullscreen: true,
                        scope: $scope,
                        openFrom: { top: 1100, height: 0 },
                        closeTo: { left: 1500 }
                    }).then(function() {

                    });
                };

                function policyListACLTypeCtr($rootScope, $scope, $mdDialog) {
                    (function() {
                        $scope.cancelNewPolicyDialogue = function() {
                            $mdDialog.cancel();
                            //$state.reload();
                        };
                        $scope.callUpdatePolicyData = function(data) {
                            //console.log($scope.addNewPolicyArray);
                            $mdDialog.cancel();
                            var objData = {};
                            objData.aclRules = $scope.aclRules;
                            objData.id = 0;
                            objData.name = $scope.policyname;
                            objData.tenantId = $scope.selectedTenantObj.id;
                            toastparam = {
                                'heading': 'Access Control Policy creation inprogress',
                                'subHeading': 'Access Control Policy creation Intiated with name ' + objData.name,
                                'type': 'progress',
                                'timeout': 15000
                            };
                            showToast(toastparam);
                            var path = "policy/accesscontrolpolicy";
                            policyService.updateMalwarePolicyData(path, objData).then(function(data) {
                                // console.log(data);
                                $scope.policyCreated = data;
                                toastparam = {
                                    'heading': 'Access Control Policy Created Successfully',
                                    'subHeading': 'New Access Control Policy Created with name ' + objData.name,
                                    'type': 'success',
                                    'timeout': 5000
                                };
                                showToast(toastparam);

                            }, function(err) {
                                toastparam = {
                                    'heading': 'Access Control Policy creation  failed',
                                    'subHeading': 'Access Control creation Policy failed ' + err.message,
                                    'type': 'fail',
                                    'timeout': 5000
                                };
                                showToast(toastparam);
                                //concole.log(data);
                            }).finally(function() {
                                //$state.reload();
                                $state.go('home.policy.policylist.accesscontrol', { 'newPolicy': $scope.policyCreated });
                            });
                        };
                        $scope.callpopupTenats = function(event) {
                            $mdDialog.show({
                                skipHide: true,
                                preserveScope: true,
                                controller: tenantListCtr,
                                bindToController: true,
                                templateUrl: 'core/components/administration/policy/tenants.html',
                                parent: angular.element(document.body),
                                targetEvent: event,
                                fullscreen: false,
                                scope: $scope,
                                openFrom: { top: 1100, height: 0 },
                                closeTo: { left: 1500 }
                            }).then(function() {

                            });
                        };

                        function tenantListCtr($scope, $mdDialog, policyService) {
                            //$scope.tenantselected = false;
                            // $scope.selectedTenantsValue = '';
                            $scope.canceltenantDialogue = function() {
                                //tenantSelection();
                                $mdDialog.cancel();
                            };
                            $scope.tenants = $scope.tenantsList;
                            $scope.onSelectTenantChanged = function() {
                                console.log(" onSelectionChanged >> ");
                                $scope.tenantSelected = true;
                            };
                            $scope.tenantdone = function(value) {
                                $scope.tenantselected = true;
                                $scope.selectedTenantObj = JSON.parse(value);
                                $mdDialog.hide();
                            };
                        }
                    })();
                }
                $scope.callDuplicatePolicy = function(data) {
                    var copyData = angular.copy(data);
                    copyData.id = 0;
                    copyData.name = copyData.name + ' copy';
                    _.each(copyData.aclRules, function(val) {
                        val.id = 0;
                    });
                    var date = new Date();
                    copyData.lastModified = date.getTime();
                    // POST /shieldxapi/policy/accesscontrolpolicy
                    var path = "policy/accesscontrolpolicy";
                    toastparam = {
                        'heading': 'Access Control Policy creation inprogress',
                        'subHeading': 'Access Control Policy creation Intiated with name ' + copyData.name,
                        'type': 'progress',
                        'timeout': 15000
                    };
                    showToast(toastparam);
                    policyService.updateMalwarePolicyData(path, copyData).then(function(data) {
                        $scope.policyCreated = data;
                        toastparam = {
                            'heading': 'Access Control Policy Created Successfully',
                            'subHeading': 'New Access Control Policy Created with name ' + copyData.name,
                            'type': 'success',
                            'timeout': 5000
                        };
                        showToast(toastparam);

                    }, function(err) {
                        toastparam = {
                            'heading': 'Access Control Policy create failed',
                            'subHeading': 'Access Control Policy create failed with ' + err.message,
                            'type': 'fail',
                            'timeout': 5000
                        };
                        showToast(toastparam);

                    }).finally(function() {
                        $state.go('home.policy.policylist.accesscontrol', { 'newPolicy': $scope.policyCreated, 'duplicated': 'new' });
                    });
                }; 
                $scope.toggleSearchBar = function(event) {
                    $scope.isSearchBarOpen = $scope.isSearchBarOpen === false ? true : false;
                    if ($scope.isSearchBarOpen)
                        angular.element(event.currentTarget.firstElementChild).css('color', '#4a90e2');
                    else
                        angular.element(event.currentTarget.firstElementChild).css('color', '#6d6e71');
                };
            }

            angular.module('shieldxApp').controller('accessPolicyCtr', accessPolicyCtrl);
        })();

/*
 ShieldX Networks Inc. CONFIDENTIAL
 ----------------------------------
 *
 Copyright (c) 2016 ShieldX Networks Inc.
 All Rights Reserved.
 *
 NOTICE: All information contained herein is, and remains
 the property of ShieldX Networks Incorporated and its suppliers,
 if any. The intellectual and technical concepts contained
 herein are proprietary to ShieldX Networks Incorporated
 and its suppliers and may be covered by U.S. and Foreign Patents,
 patents in process, and are protected by trade secret or copyright law.
 Dissemination of this information or reproduction of this material
 is strictly forbidden unless prior written permission is obtained
 from ShieldX Networks Incorporated.
 */

(function() {
    function aclPolicyDetailsCtrl(
        $scope,
        $state,
        $sessionStorage,
        policyService,
        $timeout,
        $q,
        $mdDialog,
        infrastructureConnectorService,
        userSessionMenagment
    ) {

        var initializing = true;
        var paramId = parseInt($state.params.policyId);
        $scope.editSavePolicy = true;
        $scope.$emit('listenHeaderText', { headerText: "Policy" });
        $scope.editcontainer = true;
        //$scope.edittenant = true;
        $scope.query = {
                order: 'name',
                limit: 10,
                page: 1
        };
        //$scope.resGroupTotalList = [];
        $scope.modeValue = "edit_mode";
        $scope.$on("listenAclPolicyData", function(event, data) {
            if(data.data !== undefined ){
                $scope.accessEditForm.$dirty = true;    
            }
        });
        var update_id = authorities("policy_update");
        $scope.is_update_policy = userSessionMenagment.isUserAllowd(update_id);
        policyService.getTotalTenats().then(function(data){
                    $scope.tenantsList = data;
                    $scope.tenantsListCompleted = true;
                    renderData();
            },function(err){
                $scope.tenantsListCompleted = true;
                $scope.tenantsList = [];
                console.log("unable to fetch tenants");
                renderData();
            });
         policyService.getResourceGroupData().then(function(data){
                $scope.totalResGroupTotalList = data;
                $scope.resListCompleted = true;
                renderData();
             },function(err){
                $scope.resListCompleted = true;
                console.log("unable to fetch Resource Groups");
                $scope.totalResGroupTotalList = [];
                renderData();
             });

        policyService.getPolicyDetail("accesscontrolpolicy", "policy", paramId).then(function(res) {
                   /*var d = new Date(res.lastModified);
                   res.modifiedDate =  d.getDate() + '/' + (d.getMonth()+1) + '/' + d.getFullYear();*/
                    $scope.apiResponseForPolicy = true;
                    $scope.aclPolicyBasedIdTotalList = res;
                    $scope.aclPolicyBasedIdTotalList.aclRules = _.sortBy( $scope.aclPolicyBasedIdTotalList.aclRules, 'orderNum');
                   /* _.each($scope.aclPolicyBasedIdTotalList.aclRules,function(item){
                        var d = new Date(item.lastModified);
                        item.modifiedDate =  d.getDate() + '/' + (d.getMonth()+1) + '/' + d.getFullYear();
                    });*/
                    renderData();
                   
        }, function(err) {
            console.log("getting policy based on Id failes with" + err);
            $scope.aclPolicyBasedIdTotalList = [];
            renderData();
        });

       function renderData(){
            if($scope.resListCompleted && $scope.tenantsListCompleted && $scope.apiResponseForPolicy){
                 $scope.aclPolicyBasedId = $scope.aclPolicyBasedIdTotalList;
                 _.each($scope.tenantsList, function(value) {
                    if (value.id === $scope.aclPolicyBasedId.tenantId) {
                        $scope.TenantFromAPI = value;
                    }
                });
                _.each($scope.aclPolicyBasedId.aclRules, function(aclRules ,key){
                    aclRules.resourcegroupNames = [];
                    /*aclRules.destinationAppsList = [];
                    if (aclRules.destinationApps) {
                        aclRules.destinationAppsList = aclRules.destinationApps.split(',');    
                    }*/
                if(aclRules.destinationResourceGroupList.length > 0){
                    _.each(aclRules.destinationResourceGroupList,function(value){
                        var resgroup =_.find($scope.totalResGroupTotalList,function(resGroup){
                            return resGroup.id === value;
                        });
                        if(resgroup){
                           aclRules.resourcegroupNames.push(resgroup.name); 
                        }
                    });
                }

            }); 
            if($scope.TenantFromAPI){
                        $scope.aclPolicyBasedId.tenantName = $scope.TenantFromAPI.name;    
                        $scope.selectedTenantsValue = JSON.stringify($scope.TenantFromAPI); 
                        $scope.tenantSelected = true;
            }
            if($scope.totalResGroupTotalList){
                $scope.aclPolicyBasedId.resourceGroupList = $scope.totalResGroupTotalList;    
            }  

            }
       }
        $scope.callUpdatePolicyData = function(data) {
            console.log("clicked on update Access Control policy");

            var date = new Date();
            data.lastModified = date.getTime();
            if($scope.selectedTenantObj){
                data.tenantId = $scope.selectedTenantObj.id;
            }
            var path = "policy/accesscontrolpolicy";
            toastparam = {
                'heading': 'Access Control Policy Update inprogress',
                'subHeading': 'Access Control Policy Update intiated with name ' + data.name,
                'type': 'progress',
                'timeout': 15000
            };
            showToast(toastparam);
            policyService.updateExistingPolicyData(path, data).then(function(res) {
                // console.log(data);
                toastparam = {
                    'heading': 'Access Control Policy updated Successfully',
                    'subHeading': 'Access Control updated with name ' + data.name,
                    'type': 'success',
                    'timeout': 5000
                };
                showToast(toastparam);

            }, function(err) {
                toastparam = {
                    'heading': 'Access Control Policy update  failed',
                    'subHeading': 'Access Control Policy ' + err.message,
                    'type': 'fail',
                    'timeout': 5000
                };
                showToast(toastparam);
                //concole.log(data);
            }).finally(function() {
                $mdDialog.cancel();
                $state.reload();
            });
        };
        $scope.editTenant = function(event) {
            $mdDialog.show({
                skipHide: true,
                preserveScope: true,
                controller: tenantListCtr,
                bindToController: true,
                templateUrl: 'core/components/administration/policy/tenants.html',
                parent: angular.element(document.body),
                targetEvent: event,
                fullscreen: false,
                scope: $scope,
                openFrom: { top: 1100, height: 0 },
                closeTo: { left: 1500 }
            }).then(function() {

            });
        };

        function tenantListCtr($scope, $mdDialog, policyService) {
            $scope.tenantselected = false;
            //$scope.selectedTenantsValue = '';
            $scope.canceltenantDialogue = function() {
                //tenantSelection();
                $mdDialog.cancel();
            };
            $scope.tenantSelected = false;
            $scope.tenants = $scope.tenantsList;
            $scope.onSelectTenantChanged = function() {
                console.log(" onSelectionChanged >> ");
                $scope.tenantSelected = true;
            };
            $scope.tenantdone = function(value) {
                $scope.tenantselected = true;
                $scope.accessEditForm.$dirty = true;
                $scope.selectedTenantObj = JSON.parse(value);
                $mdDialog.hide();
            };
        }

      /*  $scope.$watch("malwarePolicyBasedId.fileActions", function(newvalue, oldvalue) {
            if (initializing) {
                $timeout(function() { initializing = false; });
            } else {
                $scope.editSavePolicy = false;
            }

        }, true);*/
        $scope.$on('$viewContentLoaded', function(event){ 
            console.log(event);
            fixContainerHeight(1);
        });

    }

    angular.module('shieldxApp').controller('aclPolicyDetailsCtr', aclPolicyDetailsCtrl);
})();

/*
 ShieldX Networks Inc. CONFIDENTIAL
 ----------------------------------
 *
 Copyright (c) 2016 ShieldX Networks Inc.
 All Rights Reserved.
 *
 NOTICE: All information contained herein is, and remains
 the property of ShieldX Networks Incorporated and its suppliers,
 if any. The intellectual and technical concepts contained
 herein are proprietary to ShieldX Networks Incorporated
 and its suppliers and may be covered by U.S. and Foreign Patents,
 patents in process, and are protected by trade secret or copyright law.
 Dissemination of this information or reproduction of this material
 is strictly forbidden unless prior written permission is obtained
 from ShieldX Networks Incorporated.
 */

(function() {
    function globalThreatCtrl(
        $scope,
        $state,
        $translate,
        $sessionStorage,
        policyService,
        $timeout,
        $q,
        $mdDialog,
        infrastructureConnectorService,
        deploymentSpecificationService,
        filterFilter,
        $filter,
        userSessionMenagment
    ) {
        var deferred = $q.defer();
        $scope.promise = deferred.promise;
        $scope.promiseCompleted = true;
        $scope.globalResponse = [];
        $scope.enabledThreats = 0;
        $scope.responseSet = {
                            "enabled":false,
                            "enabledNot":false,
                            "logPacket":false,
                            "logPacketNot":false,
                            "alert":false,
                            "alertNot":false,
                            "block":false,
                            "blockNot":false,
                            "notifySMTP":false,
                            "notifySMTPNot":false,
                            "notifySysLog":false,
                            "notifySysLogNot":false
                        };
        /*$scope.disableSavePolicy = true;*/
        $scope.policyselected = [];
        $scope.selected = [];
        $scope.isSearchBarOpen = false;
        $scope.saveupdatepolicyAdd = true;
        $scope.addNewPolicyArray = [];
        $scope.policyname = "";
        $scope.selectAll = false;
        $scope.query = {
            order: 'name',
            limit: 8,
            page: 1
        };

        var update_id = authorities("policy_update");
        $scope.is_update_policy = userSessionMenagment.isUserAllowd(update_id);
        
        policyService.getPolicyDetail("threatpreventionpolicy","policy","severity").then(function(severityData) {
            $scope.severitylevels = severityData;
        }, function(err) {
            console.log("new threat rule error");
        });
        function resetData(){
            $scope.responseSet = {
                            "enabled":false,
                            "enabledNot":false,
                            "logPacket":false,
                            "logPacketNot":false,
                            "alert":false,
                            "alertNot":false,
                            "block":false,
                            "blockNot":false,
                            "notifySMTP":false,
                            "notifySMTPNot":false,
                            "notifySysLog":false,
                            "notifySysLogNot":false
                        };
            $scope.globalResponse = [];
            $scope.policyselected =[];
        }
        $scope.openThreatPopup = function(event,policyName,threatReferenceData){
            $mdDialog.show({
                skipHide: true,
                controller: threatRefenceController,
                templateUrl: 'core/components/administration/policy/global/threatReferenceList.html',
                parent: angular.element(document.body),
                event: event,
                scope: $scope,
                preserveScope: true,
                locals:{'policyName':policyName,'threatReferenceData':threatReferenceData}
            }).then(function() {

            });
        };
        function threatRefenceController($rootScope, $scope, $mdDialog,threatReferenceData,policyName) {
            (function() {
                $scope.items = threatReferenceData;
                $scope.threatName = policyName;
                $scope.cancelDialogue = function() {
                    $mdDialog.hide();
                };
            })();
        }
        $scope.onReorder = function(order){
            $scope.globalthreatData =  $filter('orderBy')($scope.globalthreatData,order);
            $scope.policyselected =[];
            $timeout(function(){
                angular.element(document.querySelectorAll(".md-sort.md-active md-icon")).removeClass("ng-hide");
            }, 0);
            
        };
        $scope.filterset = {};
        $scope.threatname = "";
        $scope.multipleFilters = function(threatData,index){
            if($scope.filterset)
                console.log($scope.filterset);
            return true;
        };
        $scope.malwarePolicy = true;
        $scope.malwareselected = [];
        var newPolicyId = parseInt($state.params.newPolicy);
        $scope.updateResponse = function(event,responseType,value){
            _.each($scope.policyselected,function(singleThreat){
                var alreadyPresent = _.find($scope.globalResponse,{"protocolId":singleThreat.protocolID,"threatId":singleThreat.threatID});
                if(typeof alreadyPresent !== 'undefined'){
                    alreadyPresent[responseType] = value;
                } else {
                    $scope.globalResponse.push(singleThreat.threatResponseData);
                    $scope.globalResponse[$scope.globalResponse.length - 1][responseType] = value;
                }
            });
            $scope.responseSet[responseType+"Not"] = !value; 
            $scope.responseSet[responseType] = value;
        };
        $scope.clearEdits = function(){
            resetData();
            $scope.filterset = {"_status":["Enabled","Disabled"],"severity":["Medium","High","Critical","Low","Fixme"],"protectionType":["SERVER","CLIENT"],"response":["Block-true","Alert-true","Log-true","Block-false","Alert-false","Log-false"],"action":["notifySMTP-true","notifySysLog-true","notifySMTP-false","notifySysLog-false"]};
            $scope.globalthreatData = angular.copy($scope.globalthreatDataCopy);
            $scope.onReorder("name");
            //angular.element(document.querySelectorAll(".md-sort.md-active md-icon")).addClass("ng-hide");
            //$scope.globalthreatData =  $filter('orderBy')($scope.globalthreatData,"name");
            $timeout(function(){
                angular.element(document.querySelectorAll(".md-sort.md-active md-icon")).addClass("ng-hide");
            }, 0);
        };
        $scope.updateEdits = function(){
            var dataTosend = {"id":0,"responses":$scope.globalResponse};
            toastparam = {
                    'heading': 'Update of Global Threats in progress',
                    'subHeading': 'Update of Global Threats initiated.',
                    'type': 'progress',
                    'timeout': 5000
                };
            showToast(toastparam);
            policyService.updateExistingPolicyData("policy/threatresponses",dataTosend).then(function(responseData){
                resetData();
                $scope.globalthreatDataCopy = angular.copy($scope.globalthreatData);
                toastparam = {
                    'heading': 'Update of Global Threats Completed',
                    'subHeading': 'Global Threats Updated.',
                    'type': 'success',
                    'timeout': 5000
                };
                showToast(toastparam);
            },function(error){
                toastparam = {
                    'heading': 'Update of Global Threats Failed.',
                    'subHeading': 'Global Threats failed to update.',
                    'type': 'fail',
                    'timeout': 5000
                };
                showToast(toastparam);
                console.log(error);
            });
        };
        $scope.getCount = function(){
            if(typeof $scope.globalthreatData !== "undefined")
                return filterFilter( $scope.globalthreatData, $scope.filterset).length;
            else
                return 0;
        };
        $scope.getSelectedText = function(receivedData,totalength){
            if(typeof receivedData === 'undefined' || receivedData.length >= totalength)
                return "ALL";
            return receivedData.length + " Selected";
        };
        policyService.getPolicyDetail(0 ,"policy","threats").then(function(data) {
            $scope.promiseCompleted = false;
           /* Uncomment when using dummy data
           var dummyArray = [{"alert": true,"block": true,"enabled": true,"id": 14006,"inherited": true,"logPacket": true,"notifySMTP": true,"notifySysLog": true,"policyId": 0,"protocolId": "4","threatId": "9"},{"alert": true,"block": false,"enabled": true,"id": 14007,"inherited": true,"logPacket": true,"notifySMTP": true,"notifySysLog": true,"policyId": 0,"protocolId": "4","threatId": "30"},{"alert": false,"block": true,"enabled": true,"id": 14008,"inherited": false,"logPacket": true,"notifySMTP": false,"notifySysLog": true,"policyId": 0,"protocolId": "2","threatId": "20001"}];*/
            
            //policyService.getDummyData(dummyArray,"policy","threatResponse").then(function(responseData){
                policyService.getPolicyDetail("0","policy","threatresponses").then(function(responseData){
                data.map(function(currentObj){
                    currentObj.threatResponseData =  _.find(responseData,{"protocolId":currentObj.protocolID,"threatId":currentObj.threatID});
                    currentObj._numthreatID = parseInt(currentObj.threatID);
                    currentObj._numprotocolID = parseInt(currentObj.protocolID);
                    if(typeof currentObj.threatResponseData !== 'undefined')
                        if(currentObj.threatResponseData.enabled){
                            currentObj._status =  "Enabled";
                            $scope.enabledThreats++;
                        } else {
                            currentObj._status = "Disabled";
                        }
                    else
                        currentObj._status = "Disabled";
                    /*currentObj._response = parseInt(currentObj.protocolID);*/
                });
                $scope.globalthreatData = data;
                $scope.globalthreatDataCopy = angular.copy(data);
                $scope.onReorder("name");
                $scope.getCount();
                deferred.resolve();
            });
            
        }, function(err) {
            console.log("global policy error data");
            deferred.reject();
            $scope.promiseCompleted = false;
        });
        


        $scope.toggleSearchBar = function(event) {
            $scope.isSearchBarOpen = $scope.isSearchBarOpen === false ? true : false;
            if ($scope.isSearchBarOpen)
                angular.element(event.currentTarget.firstElementChild).css('color', '#4a90e2');
            else
                angular.element(event.currentTarget.firstElementChild).css('color', '#6d6e71');
        };



    }

    angular.module('shieldxApp').controller('globalThreatCtr', globalThreatCtrl);
})();

/*
 ShieldX Networks Inc. CONFIDENTIAL
 ----------------------------------
 *
 Copyright (c) 2016 ShieldX Networks Inc.
 All Rights Reserved.
 *
 NOTICE: All information contained herein is, and remains
 the property of ShieldX Networks Incorporated and its suppliers,
 if any. The intellectual and technical concepts contained
 herein are proprietary to ShieldX Networks Incorporated
 and its suppliers and may be covered by U.S. and Foreign Patents,
 patents in process, and are protected by trade secret or copyright law.
 Dissemination of this information or reproduction of this material
 is strictly forbidden unless prior written permission is obtained
 from ShieldX Networks Incorporated.
 */

(function() {
    function malwarePolicyCtrl(
        $scope,
        $state,
        $translate,
        $sessionStorage,
        policyService,
        $timeout,
        $q,
        $mdDialog,
        infrastructureConnectorService,
        userSessionMenagment
    ) {
        var deferred = $q.defer();
        $scope.promise = deferred.promise;
        $scope.promiseCompleted = true;
        $scope.policyselected = [];
        $scope.isSearchBarOpen = false;
        $scope.addNewPolicyArray = [];
        $scope.policyname = "";
        $scope.query = {
            order: 'name',
            limit: 10,
            page: 1
        };
        var update_id = authorities("policy_update");
        $scope.is_update_policy = userSessionMenagment.isUserAllowd(update_id);
        
        $scope.policyListPromise = false;
        var newPolicyId = parseInt($state.params.newPolicy);
        var DuplicatedPolicy = $state.params.duplicated; 
        $scope.$emit('listenHeaderText', { headerText: "Policy" });
        $scope.$on('saveUpdateNewPolicy', function(event, arg) {
            //var tempfalg = true;
            if ($scope.addNewPolicyArray.length > 0) {
                var temp = _.find($scope.addNewPolicyArray, arg.data);
                if (temp === undefined) {
                    $scope.addNewPolicyArray.push(arg.data);
                }
            } else {
                $scope.addNewPolicyArray.push(arg.data);
            }
                $scope.saveupdatepolicyAdd = false;
        });
        $scope.tenantsList = [];
        policyService.getTotalTenats().then(function(data){
            $scope.tenantsList = data;
            $scope.tenantsListCompleted = true;
            renderData();
        },function(err){
            console.log("unable to fetch tenants");
            $scope.tenantsListCompleted = true;
            renderData();
        });
        policyService.getListOfPoliciesDetails("malwarepolicy", "policy", "").then(function(data) {
           /* _.each(data,function(item){
                var d = new Date(item.lastModified);
                item.modifiedDate = d.getDate() + '/' + (d.getMonth()+1) + '/' + d.getFullYear();
            });*/
            $scope.policyData = data;
            $scope.policyListPromise = true;
            renderData();
            deferred.resolve();
        }, function(err) {
            console.log("malware policy error data");
            deferred.reject();
            $scope.policyListPromise = true;
            $scope.policyData = '';
            renderData();
        });

        function renderData(){
            if($scope.tenantsListCompleted &&  $scope.policyListPromise){
                $scope.promiseCompleted = false;
                $scope.malwarePolicyData = [];
                _.each($scope.tenantsList, function(value) {
                    for (var i = 0; i < $scope.policyData.length; i++) {
                        if ($scope.policyData[i].tenantId === value.id) {
                            $scope.policyData[i].tenantName = value.name;
                        }
                    }
                });
                 if (newPolicyId) {
                        _.each($scope.policyData, function(value, key) {
                            if (value.id === newPolicyId) {
                               if(DuplicatedPolicy !== ''){
                                    value.duplicatedPolicy = true;
                                }else{
                                    value.newPolicy = true;    
                                }
                                $scope.malwarePolicyData.unshift(value);
                            } else {
                                $scope.malwarePolicyData.push(value);
                            }
                        });
                    } else {
                        $scope.malwarePolicyData = $scope.policyData;
                    }
            }
        }
        $scope.deleteMalwarePolicy = function(data) {
            toastparam = {
                'heading': 'Malware Policy delete inprogress',
                'subHeading': 'Malware Policy delete Intiated with name ' + data.name,
                'type': 'progress',
                'timeout': 15000
            };
            showToast(toastparam);
            policyService.deletePolicyBasedOnID("policy/malwarepolicy", data.id).then(function(res) {
                toastparam = {
                    'heading': 'Malware Policy deleted  Successfully',
                    'subHeading': 'Malware Policy  deleted with name ' + data.name,
                    'type': 'success',
                    'timeout': 5000
                };
                showToast(toastparam);
            }, function(err) {
                toastparam = {
                    'heading': 'Malware Policy delete  failed',
                    'subHeading': 'Malware Policy delete failed with error ' + err.message,
                    'type': 'fail',
                    'timeout': 5000
                };
                showToast(toastparam);
            }).finally(function(){
                $state.reload();    
            });
        };


        $scope.sampleFileactions = [{
            "alertingThreshold": "",
            "blackListingThreshold": "",
            "blockingThreshold": "",
            "fileType": "PDF",
            "id": 0,
            "sendToFireEyeEngine": false,
            "sendToWBList": false
        }, {
            "alertingThreshold": "",
            "blackListingThreshold": "",
            "blockingThreshold": "",
            "fileType": "EXE",
            "id": 1,
            "sendToFireEyeEngine": false,
            "sendToWBList": false
        }, {
            "alertingThreshold": "",
            "blackListingThreshold": "",
            "blockingThreshold": "",
            "fileType": "MSOFFICE",
            "id": 2,
            "sendToFireEyeEngine": false,
            "sendToWBList": false
        }, {
            "alertingThreshold": "",
            "blackListingThreshold": "",
            "blockingThreshold": "",
            "fileType": "COMPRESSED",
            "id": 3,
            "sendToFireEyeEngine": false,
            "sendToWBList": false
        }, {
            "alertingThreshold": "",
            "blackListingThreshold": "",
            "blockingThreshold": "",
            "fileType": "JAR",
            "id": 4,
            "sendToFireEyeEngine": false,
            "sendToWBList": false
        }];
        $scope.showAssignmentCountPopUp = function(event,policyName){
            $scope.assignmentPolicyName = policyName;
            $mdDialog.show({
                skipHide: true,
                controller: assignmentCountCtrl,
                bindToController: true,
                preserveScope: true,
                templateUrl: 'core/components/administration/policy/res-group-list.html',
                parent: angular.element(document.body),
                targetEvent: event,
                fullscreen: true,
                scope: $scope,
                openFrom: { top: 1100, height: 0 },
                closeTo: { left: 1500 }
            }).then(function() {

            });
        };
        function assignmentCountCtrl(){
            $scope.isAGSearchBarOpen = false;
             $scope.cancelassignmentControlDialogue = function() {
                    $mdDialog.cancel();
                    //$state.reload();
             };
             $scope.toggleSearchBarAsignment = function(event) {
                $scope.isAGSearchBarOpen = $scope.isAGSearchBarOpen === false ? true : false;
                if ($scope.isAGSearchBarOpen)
                    angular.element(event.currentTarget.firstElementChild).css('color', '#4a90e2');
                else
                    angular.element(event.currentTarget.firstElementChild).css('color', '#6d6e71');
            };
        }
        $scope.callpopupToAddNew = function(eve) {
            $scope.saveupdatepolicyAdd = true;
            $scope.tenantselected = false;
            $scope.selectedTenantsValue = '';
            $scope.tenantSelected = false;
            $scope.fileactionsData = angular.copy($scope.sampleFileactions);
            $scope.policyname = '';
            $mdDialog.show({
                skipHide: true,
                controller: policyListTypeCtr,
                bindToController: true,
                preserveScope: true,
                templateUrl: 'core/components/administration/policy/malware/new-mal-policy.html',
                parent: angular.element(document.body),
                targetEvent: eve,
                fullscreen: true,
                scope: $scope,
                openFrom: { top: 1100, height: 0 },
                closeTo: { left: 1500 }
            }).then(function() {

            });
        };

        function policyListTypeCtr($rootScope, $scope, $mdDialog) {
            (function() {
                $scope.cancelNewPolicyDialogue = function() {
                    $mdDialog.hide();
                    //$state.reload();
                };
                $scope.callUpdatePolicyData = function(data) {
                    //console.log($scope.addNewPolicyArray);
                    var objData = {};
                    objData.fileActions = $scope.addNewPolicyArray;
                    objData.id = 0;
                    objData.name = $scope.policyname;
                    objData.protocolNames = [];
                    var date = new Date();
                    objData.lastModified = date.getTime();
                    objData.tenantId = $scope.selectedTenantObj.id;
                    var path = "policy/malwarepolicy";
                    $mdDialog.cancel();
                    toastparam = {
                        'heading': 'Malware Policy update inprogress',
                        'subHeading': 'Malware Policy creation Intiated with name ' + objData.name,
                        'type': 'progress',
                        'timeout': 15000
                    };
                    showToast(toastparam);
                    policyService.updateMalwarePolicyData(path, objData).then(function(data) {
                        $scope.newMalwarePolicyCreated = data;
                        toastparam = {
                            'heading': 'Malware Policy updated Successfully',
                            'subHeading': 'New Malware Policy Created with name ' + objData.name,
                            'type': 'success',
                            'timeout': 5000
                        };
                        showToast(toastparam);

                    }, function(err) {
                        toastparam = {
                            'heading': 'Malware Policy update  failed',
                            'subHeading': 'Malware Policy ' + err.message,
                            'type': 'fail',
                            'timeout': 5000
                        };
                        showToast(toastparam);
                        //concole.log(data);
                    }).finally(function() {
                        //$mdDialog.cancel();
                        $state.go('home.policy.policylist.malware', { 'newPolicy': $scope.newMalwarePolicyCreated });
                    });
                };

                $scope.callpopupTenats = function(event) {
                    $mdDialog.show({
                        skipHide: true,
                        preserveScope: true,
                        controller: tenantListCtr,
                        bindToController: true,
                        templateUrl: 'core/components/administration/policy/tenants.html',
                        parent: angular.element(document.body),
                        targetEvent: event,
                        fullscreen: false,
                        scope: $scope,
                        openFrom: { top: 1100, height: 0 },
                        closeTo: { left: 1500 }
                    }).then(function() {

                    });
                };

                function tenantListCtr($scope, $mdDialog, policyService) {
                     //$scope.tenantselected = false;
                    $scope.canceltenantDialogue = function() {
                        //tenantSelection();
                        $mdDialog.cancel();
                    };
                    $scope.tenants = $scope.tenantsList;
                    $scope.onSelectTenantChanged = function() {
                        console.log(" onSelectionChanged >> ");
                        $scope.tenantSelected = true;
                    };
                    $scope.tenantdone = function(value) {
                        $scope.tenantselected = true;
                        $scope.selectedTenantObj = JSON.parse(value);
                        $mdDialog.hide();
                    };
                }
            })();
        }

        $scope.callpopupDuplicatePolicy = function(data) {
                var copyData = angular.copy(data);
                    copyData.id = 0;
                    copyData.name = copyData.name + ' copy';
                _.each(copyData.fileActions,function(val){
                        val.id = 0;
                    });
                var date = new Date();
                copyData.lastModified = date.getTime();
                var path = "policy/malwarepolicy";
                toastparam = {
                    'heading': 'Malware Policy creation in progress',
                    'subHeading': 'Malware Policy creation intiated with name ' + copyData.name,
                    'type': 'progress',
                    'timeout': 15000
                };
                showToast(toastparam);
                policyService.updateMalwarePolicyData(path, copyData).then(function(data) {
                    $scope.newMalwarePolicyCreated = data;
                    toastparam = {
                        'heading': 'Malware Policy created successfully',
                        'subHeading': 'New Malware Policy created with name ' + copyData.name,
                        'type': 'success',
                        'timeout': 5000
                    };
                    showToast(toastparam);

                }, function(err) {
                    toastparam = {
                        'heading': 'Malware Policy creation failed',
                        'subHeading': 'Malware Policy ' + err.message,
                        'type': 'fail',
                        'timeout': 5000
                    };
                    showToast(toastparam);

                 }).finally(function() {
                    $state.go('home.policy.policylist.malware', { 'newPolicy': $scope.newMalwarePolicyCreated,'duplicated':'d' });
                });
       };
       $scope.toggleSearchBar = function(event) {
            $scope.isSearchBarOpen = $scope.isSearchBarOpen === false ? true : false;
            if ($scope.isSearchBarOpen)
                angular.element(event.currentTarget.firstElementChild).css('color', '#4a90e2');
            else
                angular.element(event.currentTarget.firstElementChild).css('color', '#6d6e71');
        };

    }

    angular.module('shieldxApp').controller('malwarePolicyCtr', malwarePolicyCtrl);
})();

/*
 ShieldX Networks Inc. CONFIDENTIAL
 ----------------------------------
 *
 Copyright (c) 2016 ShieldX Networks Inc.
 All Rights Reserved.
 *
 NOTICE: All information contained herein is, and remains
 the property of ShieldX Networks Incorporated and its suppliers,
 if any. The intellectual and technical concepts contained
 herein are proprietary to ShieldX Networks Incorporated
 and its suppliers and may be covered by U.S. and Foreign Patents,
 patents in process, and are protected by trade secret or copyright law.
 Dissemination of this information or reproduction of this material
 is strictly forbidden unless prior written permission is obtained
 from ShieldX Networks Incorporated.
 */

(function() {
    function malwarePolicyDetailCtrl(
        $scope,
        $state,
        $sessionStorage,
        policyService,
        $timeout,
        $q,
        $mdDialog,
        infrastructureConnectorService,
        userSessionMenagment
    ) {

        var initializing = true;
        var paramId = parseInt($state.params.policyId);
        $scope.$emit('listenHeaderText', { headerText: "Policy" });
        $scope.editcontainer = true;
        $scope.tenantSelected = false;
        $scope.tenantsListCompleted = false;
        $scope.policyListPromise = false;
        $scope.selectedTenantsValue = '';
        $scope.sampleFileactions = [{
            "alertingThreshold": "",
            "blackListingThreshold": "",
            "blockingThreshold": "",
            "fileType": "PDF",
            "id": 0,
            "sendToFireEyeEngine": false,
            "sendToWBList": false
        }, {
            "alertingThreshold": "",
            "blackListingThreshold": "",
            "blockingThreshold": "",
            "fileType": "EXE",
            "id": 1,
            "sendToFireEyeEngine": false,
            "sendToWBList": false
        }, {
            "alertingThreshold": "",
            "blackListingThreshold": "",
            "blockingThreshold": "",
            "fileType": "MSOFFICE",
            "id": 2,
            "sendToFireEyeEngine": false,
            "sendToWBList": false
        }, {
            "alertingThreshold": "",
            "blackListingThreshold": "",
            "blockingThreshold": "",
            "fileType": "COMPRESSED",
            "id": 3,
            "sendToFireEyeEngine": false,
            "sendToWBList": false
        }, {
            "alertingThreshold": "",
            "blackListingThreshold": "",
            "blockingThreshold": "",
            "fileType": "JAR",
            "id": 4,
            "sendToFireEyeEngine": false,
            "sendToWBList": false
        }];

        var update_id = authorities("policy_update");
        $scope.is_update_policy = userSessionMenagment.isUserAllowd(update_id);
        $scope.tenantsList = [];
       policyService.getTotalTenats().then(function(data){
            $scope.tenantsListCompleted = true;
            $scope.tenantsList = data;
            renderData();
        },function(err){
            console.log("unable to fetch tenants");
            $scope.tenantsListCompleted = true;
            renderData();
        });
        policyService.getPolicyDetail("malwarepolicy", "policy", paramId).then(function(res) {
            _.each(res.fileActions, function(val) {
                        for (var i = 0; i < $scope.sampleFileactions.length; i++) {
                            if ($scope.sampleFileactions[i].fileType === val.fileType) {
                                $scope.sampleFileactions[i] = val;
                            }
                        }
            });
            res.fileActions = $scope.sampleFileactions;
            /*var d = new Date(res.lastModified);
            res.modifiedDate =  d.getDate() + '/' + (d.getMonth()+1) + '/' + d.getFullYear();*/
            console.log("fetched Data Successfully in malwarepolicy");
            $scope.policyListPromise = true;
            $scope.policyData = res;
            renderData();
        }, function(err) {
            console.log("getting Malware policy details failes with" + err);
            $scope.policyListPromise = true;
            $scope.policyData = '';
            renderData();
        });
        function renderData(){
            if($scope.policyListPromise && $scope.tenantsListCompleted){
                _.each($scope.tenantsList, function(value) {
                        if (value.id === $scope.policyData.tenantId) {
                            $scope.TenantFromAPI = value;
                        }
                });
                $scope.malwarePolicyBasedId = $scope.policyData;
                if($scope.TenantFromAPI){
                    $scope.malwarePolicyBasedId.tenantName = $scope.TenantFromAPI.name;    
                    $scope.selectedTenantsValue = JSON.stringify($scope.TenantFromAPI); 
                    $scope.tenantSelected = true;
                }
            }
        }
        $scope.callUpdatePolicyData = function(data) {
            console.log("clicked on update malware policy");
            var postdata = angular.copy(data.fileActions);
            if($scope.selectedTenantObj){
                data.tenantId = $scope.selectedTenantObj.id;    
            }
            var validata = [];
            _.each(postdata, function(value, key) {
                if (value.blockingThreshold !== "" && value.alertingThreshold !== "" && value.blackListingThreshold !== "") {
                    validata.push(value);
                }
            });
            var date = new Date();
            data.lastModified = date.getTime();
            data.fileActions = validata;
            // objData.tenantId = $scope.selectedTenantObj.id;
            var path = "policy/malwarepolicy";
            toastparam = {
                'heading': 'Malware Policy update inprogress',
                'subHeading': 'Malware Policy update Intiated with name ' + data.name,
                'type': 'progress',
                'timeout': 15000
            };
            showToast(toastparam);
            policyService.updateExistingPolicyData(path, data).then(function(res) {
                // console.log(data);
                toastparam = {
                    'heading': 'Malware Policy updated Successfully',
                    'subHeading': 'Malware Policy updated with name ' + data.name,
                    'type': 'success',
                    'timeout': 5000
                };
                showToast(toastparam);

            }, function(err) {
                toastparam = {
                    'heading': 'Malware Policy update  failed',
                    'subHeading': 'Malware Policy update failed with' + err.message,
                    'type': 'fail',
                    'timeout': 5000
                };
                showToast(toastparam);
                //concole.log(data);
            }).finally(function() {
                $state.reload();
            });
        };
        $scope.editTenant = function(event) {
            $mdDialog.show({
                skipHide: true,
                preserveScope: true,
                controller: tenantListCtr,
                bindToController: true,
                templateUrl: 'core/components/administration/policy/tenants.html',
                parent: angular.element(document.body),
                targetEvent: event,
                fullscreen: false,
                scope: $scope,
                openFrom: { top: 1100, height: 0 },
                closeTo: { left: 1500 }
            }).then(function() {

            });
        };

        function tenantListCtr($scope, $mdDialog, policyService) {
            //$scope.tenantselected = false;
           
            $scope.canceltenantDialogue = function() {
                $mdDialog.cancel();
            };
        
            $scope.tenants = $scope.tenantsList;
            $scope.onSelectTenantChanged = function() {
                console.log(" onSelectionChanged >> ");
                $scope.tenantSelected = true;
            };
            $scope.tenantdone = function(value) {
                $scope.tenantselected = true;
                $scope.selectedTenantObj = JSON.parse(value);
                $scope.detailsForm.$dirty = true;
                $mdDialog.hide();
            };
        }
        $scope.$on('$viewContentLoaded', function(event){ 
            console.log(event);
            fixContainerHeight(1);
        });
    }

    angular.module('shieldxApp').controller('malwarePolicyDetailCtr', malwarePolicyDetailCtrl);
})();

(function() {
	function InventoryofMicroServicesCtr($scope,dataVisualizationService,$timeout,$location) {
		console.log('InventoryofMicroServicesCtr initialised');
		var parentScope = $scope.$parent.$parent;
		$scope.selected = [];
		var dataOnWidget = angular.copy(parentScope.drilldowndata);
		
		$scope.title = widgetConfig.list.InventoryofMicroServices.title;
		
	/*	function getKeysForDrillDown (list) {
			if(Array.isArray(list)) {
				var tempArray = [];
				_.forEach(list, function(value, key){
					tempArray.push(value.Letter);
				});
				return tempArray;
			}
		}*/
		$scope.$emit('listenHeaderText', { headerText: "System Health tools > Inventory of Microservices" });
		$scope.url = $location.absUrl().split('#')[1];
		$scope.getAllDrillDownData = function(){
			if( $scope.url.indexOf(WidgetName.InventoryofMicroServices) > 0 ){

				var dataWidgetConfig = new DataWidgetConfig(widgetConfig.list[WidgetName.InventoryofMicroServices].widgetType, WidgetName.InventoryofMicroServices);
				dataWidgetConfig.nValue = 50;
				//dataWidgetConfigArray.push(dataWidgetConfig);	
				var dataWidgetConfigArray = [];
				dataWidgetConfigArray.push(dataWidgetConfig);
				dataVisualizationService.getFilteredDataForWidgets(dataWidgetConfigArray).then(function(responseData){
					console.log("data for main query in drilldowndata");
					console.log(responseData);
					dataOnWidget = responseData.InventoryofMicroServices;
				}).finally(function(){
					loadDrillDownDataFromServer(WidgetName.InventoryofMicroServices, ChartTypes.table).then(function(data){
						$scope.tableData = data;
						getminimumMaximumValues(data);
		     		$scope.masterData = angular.copy($scope.tableData);
					});
				});
			}else{
				loadDrillDownDataFromServer(WidgetName.InventoryofMicroServices, ChartTypes.table).then(function(data){
					$scope.tableData = data;
					getminimumMaximumValues(data);
		     		$scope.masterData = angular.copy($scope.tableData);
				});
			}
		};
		$scope.updateDirllDownInterval = function(interval){
			$scope.timeInteval = interval;
			$scope.getAllDrillDownData();
		};
		$scope.intervalOptions = WidgetDataUtil.drillDownIntervaloptions;
		function loadDrillDownDataFromServer(widgetType,chartType) {
			var args = [];
			for (var i = 3; i < arguments.length; i++) {
                 args.push(arguments[i]);
            }
            console.log("loadDrillDownDataFromServer args "+args);
            console.dir(args);
			var interval = ($scope.timeInteval)?($scope.timeInteval):30;
			var dataWidgetConfig = new DataWidgetConfig(chartType, widgetType,interval,args);
			return dataVisualizationService.getDrillDownDataForWidget(dataWidgetConfig).then(function (chartData) {
				return chartData;
			});
		}
		$scope.getSelectedText = function(receivedData,totalength){
            if(typeof receivedData === 'undefined' || receivedData.length == totalength || receivedData.length === 0){
                     $scope.tableData = angular.copy($scope.masterData);
                     return "ALL";
            }else{
	    	    if($scope.masterData !== undefined && $scope.masterData.length ){
					var output = [];
					_.each($scope.masterData,function(item){
						_.each(receivedData,function(res){
							if(item.name === res){
								output.push(item);
							}
						});
						
					});
					$scope.tableData = output;
				}
				 return receivedData.length + " Selected";
            }
           
        };
		$scope.query = {
			order: 'name',
			limit: 10,
			page: 1
		};

		var getminimumMaximumValues = function(data){
			$scope.distinctNames = [];
			_.each(data,function(item){
				if($scope.distinctNames.length >0){
					var findItem = _.find($scope.distinctNames,function(distinctName){
						return distinctName.name === item.name;
					});
					if(findItem === undefined){
						$scope.distinctNames.push(item);	
					}
				}else{
					$scope.distinctNames.push(item);
				}
			});	
			$scope.maxvalues = angular.copy($scope.distinctNames);
			_.each(data,function(totalListItems){
				var minValue = _.find($scope.distinctNames,function(mindistItem){
					return (mindistItem.name === totalListItems.name &&  mindistItem.count > totalListItems.count);
				});
				if(minValue !== undefined){
					minValue.count = totalListItems.count;
				}
				var maxValue = _.find($scope.maxvalues,function(maxItem){
					return (maxItem.name === totalListItems.name &&  maxItem.count < totalListItems.count);
				});
				if(maxValue !== undefined){
					maxValue.count = totalListItems.count;
				}
			});
			$scope.minItemValue = function(minItem){
				return _.find($scope.distinctNames,function(distminvalue){
					return distminvalue.name === minItem;
				});
			};
			$scope.maxItemValue = function(maxGetItem){
				return _.find($scope.maxvalues,function(distmaxvalue){
					return distmaxvalue.name === maxGetItem;
				});
			};
		};

		/*, getKeysForDrillDown(dataOnWidget)*/
		/*loadDrillDownDataFromServer(WidgetName.InventoryofMicroServices, ChartTypes.table).then(function(data){
			$scope.tableData = data;
			getminimumMaximumValues(data);
     		$scope.masterData = angular.copy($scope.tableData);
		});*/
		$scope.getAllDrillDownData();
		$timeout(function() {
	            fixContainerHeight(1);
		},0);
	}
	angular.module('shieldxApp').controller('InventoryofMicroServicesCtr', InventoryofMicroServicesCtr);
})();


(function() {
	function IOPCtr($scope,dataVisualizationService,$timeout, $location) {
		console.log('Iop DrillDown initialised');
		var parentScope = $scope.$parent.$parent;
		$scope.selected = [];
		var dataOnWidget = angular.copy(parentScope.drilldowndata);
		$scope.tableData = [];
		$scope.title = widgetConfig.list.IOP.title;
		$scope.query = {
			order: 'val1',
			limit: 10,
			page: 1
		};

		$scope.$emit('listenHeaderText', { headerText: "Security Analysis tools > Indicator of Pivot" });
		$scope.url = $location.absUrl().split('#')[1];
		$scope.getAllDrillDownData = function(){
			if( $scope.url.indexOf(WidgetName.IOP) > 0 ){
				$scope.$emit('listenHeaderText', { headerText: "Security Analysis > Indicator of Pivot" });
				var dataWidgetConfig = new DataWidgetConfig(widgetConfig.list[WidgetName.IOP].widgetType, WidgetName.IOP);
				dataWidgetConfig.nValue = 50;
				//dataWidgetConfigArray.push(dataWidgetConfig);	
				var dataWidgetConfigArray = [];
				dataWidgetConfigArray.push(dataWidgetConfig);
				dataVisualizationService.getFilteredDataForWidgets(dataWidgetConfigArray).then(function(responseData){
					console.log("data for main query in drilldowndata");
					console.log(responseData);
					dataOnWidget = responseData.IOP;
				}).finally(function(){
					loadDrillDownDataFromServer(WidgetName.IOP, ChartTypes.barChart,  getKeysForDrillDown(dataOnWidget)).then(function(data){
						console.log('Data for this drilldown from server', data);
						$scope.tableData = data;
						renderExportData(data);
					});
				});
			}else{
				loadDrillDownDataFromServer(WidgetName.IOP, ChartTypes.barChart,  getKeysForDrillDown(dataOnWidget)).then(function(data){
						console.log('Data for this drilldown from server', data);
						$scope.tableData = data;
						renderExportData(data);
					});
				}
		};
		renderExportData = function(data){
			$scope.exportData = []; 
			$scope.csvData = [];
			_.each(data,function(dataItem,i){
				$scope.exportData = $scope.exportData.concat(dataItem.val);
				console.log(dataItem);
			});
			var date,datex,timex;
			_.each($scope.exportData,function(singeleItem,i){
				date = new Date(singeleItem.iopThreatTimeStamp);
				datex = ('0' + date.getDate()).slice(-2) + '/' + ('0' + (date.getMonth() + 1)).slice(-2) + '/' + date.getFullYear();
				timex = ('0' + date.getHours()).slice(-2) + ':' + ('0' + date.getMinutes()).slice(-2);
				/*datex = dataUnixTemp.format("dd.mm.yyyy"); 
				timex = dataUnixTemp.format("hh:MM:ss");*/
				$scope.csvData.push({val0:singeleItem.iopHop,val1:singeleItem.appId,val2:datex,val3:timex,val4:singeleItem.dstIpAddress,val5:singeleItem.dstPort,val6:singeleItem.iopDetectionId,val7:singeleItem.iopThreatName,val8:singeleItem.protocol,val9:singeleItem.protocolName,val10:singeleItem.srcIpAddress,val11:singeleItem.srcPort,val12:singeleItem.threatName});
			});
			$scope.csvData = _.sortBy( $scope.csvData, 'val0');
			console.log($scope.csvData);
		};
		console.log("url " + $scope.url);
		/*$scope.updateDirllDownInterval = function(interval){
			$scope.timeInteval = interval;
			$scope.getAllDrillDownData();
		};
		$scope.intervalOptions =  [
				{ value : 5, text: 'Past 5 mins'},
				{ value : 10, text: 'Past 10 mins'},
				{ value : 15, text: 'Past 15 mins'},
				];*/
		function getKeysForDrillDown (list) {
			console.log(list);
			//if(Array.isArray(list.rowData)) {
				var tempArray = [];
				_.forEach(list.rowData, function(value, key){
					tempArray.push(value.id);
				});
				console.log("getKeysForDrillDown ");
				console.dir(tempArray);
				return tempArray;
			//}
		}
		function loadDrillDownDataFromServer(widgetType,chartType,args) {
			console.log(" TopNDetectedAppsCtr loadDrillDownDataFromServer args "+args);
            console.dir(args);
           var interval = ($scope.timeInteval)?($scope.timeInteval):30;
			var dataWidgetConfig = new DataWidgetConfig(chartType, widgetType,interval,args);
			
			return dataVisualizationService.getDrillDownDataForWidget(dataWidgetConfig).then(function (chartData) {
	        	console.log(" TopNDetectedAppsCtr getDrillDownDataForWidget args "+chartData);
	        	console.dir(chartData);
				return chartData;
			});
		}

		$scope.getAllDrillDownData();
		/*$scope.tableData = {
			headers : [
				{title: 'title 1'},
				{title: 'title 2'},
				{title: 'title 3'},
				{title: 'title 4'},
				{title: 'title 5'}
			],
			rowData: [
				{ val1: 'abc', val2: 'def', val3: 'ghi', val4: 'jkl', val5: 'mno'},
				{ val1: 'abc', val2: 'def', val3: 'ghi', val4: 'jkl', val5: 'mno'},
				{ val1: 'abc', val2: 'def', val3: 'ghi', val4: 'jkl', val5: 'mno'},
				{ val1: 'abc', val2: 'def', val3: 'ghi', val4: 'jkl', val5: 'mno'},
				{ val1: 'abc', val2: 'def', val3: 'ghi', val4: 'jkl', val5: 'mno'},
				{ val1: 'abc', val2: 'def', val3: 'ghi', val4: 'jkl', val5: 'mno'},
				{ val1: 'abc', val2: 'def', val3: 'ghi', val4: 'jkl', val5: 'mno'},
				{ val1: 'abc', val2: 'def', val3: 'ghi', val4: 'jkl', val5: 'mno'},
				{ val1: 'abc', val2: 'def', val3: 'ghi', val4: 'jkl', val5: 'mno'},
				{ val1: 'abc', val2: 'def', val3: 'ghi', val4: 'jkl', val5: 'mno'}
			]			
		};*/
       // $scope.tableData = {};
/*		$scope.query = {
			order: 'name',
			limit: 5,
			page: 1
		};*/
		$timeout(function() {
	            fixContainerHeight(1);
		},0);
		
	}
	angular.module('shieldxApp').controller('IOPCtr', IOPCtr);
})();
(function() {

	function NewApplicationsCtr($scope,dataVisualizationService,$timeout,$filter,$location) {
		console.log('NewApplicationsCtr initialised');
		var parentScope = $scope.$parent.$parent;
		$scope.selected = [];
		var dataOnWidget = angular.copy(parentScope.drilldowndata);
		
		$scope.title = widgetConfig.list.NewApplications.title;
		$scope.url = $location.absUrl().split('#')[1];
		$scope.$emit('listenHeaderText', { headerText: "Security Analysis > New Applications" });
			$scope.getAllDrillDownData = function(){
				loadDrillDownDataFromServer(WidgetName.NewApplications, ChartTypes.table).then(function(data){
					console.log('Data for this drilldown from server', data);
					$scope.tableData = data;
				});
			};

		function loadDrillDownDataFromServer(widgetType,chartType) {
			var args = [];
			for (var i = 2; i < arguments.length; i++) {
                 args.push(arguments[i]);
            }
            var interval = ($scope.timeInteval)?($scope.timeInteval):30;
            console.log("loadDrillDownDataFromServer args "+args);
            console.dir(args);
			var dataWidgetConfig = new DataWidgetConfig(chartType, widgetType,interval,args);
			
			return dataVisualizationService.getDrillDownDataForWidget(dataWidgetConfig).then(function (chartData) {
				return chartData;
			});
		}
		$scope.getSelectedText = function(receivedData,totalength){
            if(typeof receivedData === 'undefined' || receivedData.length == totalength)
                return "ALL";
            return receivedData.length + " Selected";
        };
        $scope.updateDirllDownInterval = function(interval){
			$scope.timeInteval = interval;
			$scope.getAllDrillDownData();
		};
		$scope.intervalOptions =  WidgetDataUtil.drillDownIntervaloptions;
		$scope.query = {
			order: 'name',
			limit: 10,
			page: 1
		};

		$timeout(function() {
	            fixContainerHeight(1);
		},0);

		$scope.getAllDrillDownData();

		$scope.onReorder = function(order){
            $scope.tableData =  $filter('orderBy')($scope.tableData,order);
            $timeout(function(){
                angular.element(document.querySelectorAll(".md-sort.md-active md-icon")).removeClass("ng-hide");
            }, 0);
            
        };

		/*, getKeysForDrillDown(dataOnWidget)*/
		/*loadDrillDownDataFromServer(WidgetName.NewApplications, ChartTypes.table, 30).then(function(data){
			console.log('Data for this drilldown from server', data);
			$scope.tableData = data;
		});*/
		

	}
	angular.module('shieldxApp').controller('NewApplicationsCtr', NewApplicationsCtr);
})();
(function() {
	function TopNAttackerResourceGroupsCtr($scope,dataVisualizationService,$timeout,$location,$filter) {
		console.log('TopNAttackerResourceGroups initialised');
		var parentScope = $scope.$parent.$parent;
		$scope.selected = [];
		var dataOnWidget = angular.copy(parentScope.drilldowndata);
		
		$scope.title = widgetConfig.list.TopNAttackerResourceGroups.title;
		$scope.updateDirllDownInterval = function(interval){
			$scope.timeInteval = interval;
			$scope.getAllDrillDownData();
		};
		$scope.intervalOptions =  WidgetDataUtil.drillDownIntervaloptions;

		$scope.$emit('listenHeaderText', { headerText: "Security Analysis tools > Top N Attacker Resource Groups" });
		$scope.url = $location.absUrl().split('#')[1];
		$scope.getAllDrillDownData = function(){
		if( $scope.url.indexOf(WidgetName.TopNAttackerResourceGroups) > 0 ){
			
			var dataWidgetConfig = new DataWidgetConfig(widgetConfig.list[WidgetName.TopNAttackerResourceGroups].widgetType, WidgetName.TopNAttackerResourceGroups);
			dataWidgetConfig.nValue = 50;
			//dataWidgetConfigArray.push(dataWidgetConfig);	
			var dataWidgetConfigArray = [];
			dataWidgetConfigArray.push(dataWidgetConfig);
			dataVisualizationService.getFilteredDataForWidgets(dataWidgetConfigArray).then(function(responseData){
				console.log("data for main query in drilldowndata");
				console.log(responseData);
				dataOnWidget = responseData.TopNAttackerResourceGroups;
			}).finally(function(){
				loadDrillDownDataFromServer(WidgetName.TopNAttackerResourceGroups, ChartTypes.barChart,  getKeysForDrillDown(dataOnWidget)).then(function(data){
					console.log('Data for this drilldown from server', data);
					$scope.tableData = data;
				});
			});
		}else{
			loadDrillDownDataFromServer(WidgetName.TopNAttackerResourceGroups, ChartTypes.barChart, getKeysForDrillDown(dataOnWidget)).then(function(data){
				console.log('Data for this drilldown from server', data);
				$scope.tableData = data;
			});
		}
	};
		function getKeysForDrillDown (list) {
			if(Array.isArray(list)) {
				var tempArray = [];
				_.forEach(list, function(value, key){
					tempArray.push(value.Letter);
				});
				console.log("getKeysForDrillDown ");
				console.dir(tempArray);
				return tempArray;
			}
		}
		function loadDrillDownDataFromServer(widgetType,chartType,args) {
			console.log(" TopNAttackerResourceGroups loadDrillDownDataFromServer args "+args);
            console.dir(args);
            var interval = ($scope.timeInteval)?($scope.timeInteval):30;
			var dataWidgetConfig = new DataWidgetConfig(chartType, widgetType,interval,args);
			
			return dataVisualizationService.getDrillDownDataForWidget(dataWidgetConfig).then(function (chartData) {
	        	console.log(" TopNAttackerResourceGroups getDrillDownDataForWidget args "+chartData);
	        	console.dir(chartData);
				return chartData;
			});
		}
		$scope.query = {
			order: 'name',
			limit: 10,
			page: 1
		};
		$timeout(function() {
	            fixContainerHeight(1);
		},0);
		$scope.getAllDrillDownData();
		/*$scope.sortBasedOnID = function(id){
			$scope.tableData = WidgetDataUtil.sortEachTableBasedOnId($scope.tableData,id);
		};*/
		 $scope.onReorder = function(order){
            $scope.tableData =  $filter('orderBy')($scope.tableData,order);
            $timeout(function(){
                angular.element(document.querySelectorAll(".md-sort.md-active md-icon")).removeClass("ng-hide");
            }, 0);
            
        };
		/*loadDrillDownDataFromServer(WidgetName.TopNAttackerResourceGroups, ChartTypes.barChart, getKeysForDrillDown(dataOnWidget)).then(function(data){
			console.log('Data for this drilldown from server', data);
			$scope.tableData = data;
		});*/
	}
	angular.module('shieldxApp').controller('TopNAttackerResourceGroupsCtr', TopNAttackerResourceGroupsCtr);
})();
(function() {
	function TopNAttackersCtr($scope,dataVisualizationService,$location,$timeout,$filter) {
		console.log('TopNAttackersCtr initialised');
		var parentScope = $scope.$parent.$parent;
		$scope.selected = [];
		var dataOnWidget = angular.copy(parentScope.drilldowndata);
		
		$scope.title = widgetConfig.list.TopNAttackers.title;
		$scope.$emit('listenHeaderText', { headerText: "Security Analysis tools > Top N Attackers" });
		$scope.url = $location.absUrl().split('#')[1];
		$scope.getAllDrillDownData = function(){
			if( $scope.url.indexOf(WidgetName.TopNAttackers) > 0 ){
				
				var dataWidgetConfig = new DataWidgetConfig(widgetConfig.list[WidgetName.TopNAttackers].widgetType, WidgetName.TopNAttackers);
				dataWidgetConfig.nValue = 50;
				//dataWidgetConfigArray.push(dataWidgetConfig);	
				var dataWidgetConfigArray = [];
				dataWidgetConfigArray.push(dataWidgetConfig);
				dataVisualizationService.getFilteredDataForWidgets(dataWidgetConfigArray).then(function(responseData){
					console.log("data for main query in drilldowndata");
					console.log(responseData);
					dataOnWidget = responseData.TopNAttackers;
				}).finally(function(){
					loadDrillDownDataFromServer(WidgetName.TopNAttackers, ChartTypes.barChart,  getKeysForDrillDown(dataOnWidget)).then(function(data){
						console.log('Data for this drilldown from server', data);
						$scope.tableData = data;
					});
				});
			}else{
				loadDrillDownDataFromServer(WidgetName.TopNAttackers, ChartTypes.barChart,  getKeysForDrillDown(dataOnWidget)).then(function(data){
						console.log('Data for this drilldown from server', data);
						$scope.tableData = data;
					});
			}
		};

		$scope.updateDirllDownInterval = function(interval){
			$scope.timeInteval = interval;
			$scope.getAllDrillDownData();
		};
		$scope.intervalOptions = WidgetDataUtil.drillDownIntervaloptions;
		function getKeysForDrillDown (list) {
			if(Array.isArray(list)) {
				var tempArray = [];
				_.forEach(list, function(value, key){
					tempArray.push(value.Letter);
				});
				console.log("getKeysForDrillDown ");
				console.dir(tempArray);
				return tempArray;
			}
		}
		function loadDrillDownDataFromServer(widgetType,chartType,args) {
			console.log(" TopNAttackersCtr loadDrillDownDataFromServer args "+args);
            console.dir(args);
            var interval = ($scope.timeInteval)?($scope.timeInteval):30;
			var dataWidgetConfig = new DataWidgetConfig(chartType, widgetType,interval,args);
			
			return dataVisualizationService.getDrillDownDataForWidget(dataWidgetConfig).then(function (chartData) {
	        	console.log(" TopNAttackersCtr getDrillDownDataForWidget args "+chartData);
	        	console.dir(chartData);
				return chartData;
			});
		}
		$scope.getAllDrillDownData();
        $scope.tableData = {};
		$scope.query = {
			order: 'name',
			limit: 10,
			page: 1
		};
		$timeout(function() {
	            fixContainerHeight(1);
		},0);
		$scope.onReorder = function(order){
            $scope.tableData.rowData =  $filter('orderBy')($scope.tableData.rowData,order);
            $timeout(function(){
                angular.element(document.querySelectorAll(".md-sort.md-active md-icon")).removeClass("ng-hide");
            }, 0);
            
        };
		/*loadDrillDownDataFromServer(WidgetName.TopNAttackers, ChartTypes.barChart, 30, getKeysForDrillDown(dataOnWidget)).then(function(data){
			console.log('Data for this drilldown from server', data);
			$scope.tableData = data;
		});*/
	}
	angular.module('shieldxApp').controller('TopNAttackersCtr', TopNAttackersCtr);
})();
(function() {
	function TopNBadCertificatesCtr($scope,dataVisualizationService,$location,$timeout,$filter) {
		console.log('TopNDetectedAppsCtr initialised');
		var parentScope = $scope.$parent.$parent;
		$scope.selected = [];
		var dataOnWidget = angular.copy(parentScope.drilldowndata);
		
		$scope.title = widgetConfig.list.TopNBadCertificates.title;
		$scope.updateDirllDownInterval = function(interval,nValue){
			$scope.timeInteval = interval;
			$scope.navalue= nValue;
			$scope.getAllDrillDownData();
			renderMainData();
		};
		$scope.intervalOptions = WidgetDataUtil.drillDownIntervaloptions;
		renderMainData = function(){
			var dataWidgetConfig = new DataWidgetConfig(widgetConfig.list[WidgetName.TopNBadCertificates].widgetType, WidgetName.TopNBadCertificates);
				dataWidgetConfig.nValue = ($scope.navalue)?parseInt($scope.navalue):50;
				var dataWidgetConfigArray = [];
				dataWidgetConfigArray.push(dataWidgetConfig);
				dataVisualizationService.getFilteredDataForWidgets(dataWidgetConfigArray).then(function(responseData){
					console.log("data for main query in drilldowndata");
					console.log(responseData);
					dataOnWidget = responseData.TopNBadCertificates;
				}).finally(function(){
					renderDrillDownData();
					
				});
		};

		$scope.$emit('listenHeaderText', { headerText: "Security Analysis tools > Top N Bad Certificates" });
		$scope.url = $location.absUrl().split('#')[1];
		$scope.getAllDrillDownData = function(){
			if( $scope.url.indexOf(WidgetName.TopNBadCertificates) > 0 ){
				
				renderMainData();
			}else{
				renderDrillDownData();
			/*	loadDrillDownDataFromServer(WidgetName.TopNBadCertificates, ChartTypes.barChart,  getKeysForDrillDown(dataOnWidget)).then(function(data){
						console.log('Data for this drilldown from server', data);
						$scope.tableData = data;
					});*/
			}
		};
		renderDrillDownData = function(){
			$scope.mainQueryData = dataOnWidget;
			$scope.drillDownDataPresent = false;
			$scope.mainCerticicatesAvaliable = true;

		};
		$scope.getListBasedOnCertficate = function(fiterItem){
			$scope.drillDownDataPresent = true;
			$scope.mainCerticicatesAvaliable = false;
			$scope.itemToBeFiltered = fiterItem;
			$scope.getDrillDownForTisItem = [];
			$scope.tableData = [];
			_.each(dataOnWidget,function(item){
				if(item.Letter === fiterItem){
					$scope.getDrillDownForTisItem.push(item);
				}
			});
			loadDrillDownDataFromServer(WidgetName.TopNBadCertificates, ChartTypes.barChart,  getKeysForDrillDown($scope.getDrillDownForTisItem)).then(function(data){
				console.log('Data for this drilldown from server', data);
				$scope.tableData = data;
			});
		};

		function getKeysForDrillDown (list) {
			if(Array.isArray(list)) {
				var tempArray = [];
				_.forEach(list, function(value, key){
					tempArray.push(value.Letter);
				});
				console.log("getKeysForDrillDown ");
				console.dir(tempArray);
				return tempArray;
			}
		}
		function loadDrillDownDataFromServer(widgetType,chartType,args) {
			console.log("loadDrillDownDataFromServer args "+args);
            console.dir(args);
            var interval = ($scope.timeInteval)?($scope.timeInteval):30;
			var dataWidgetConfig = new DataWidgetConfig(chartType, widgetType,interval,args);
			
			return dataVisualizationService.getDrillDownDataForWidget(dataWidgetConfig).then(function (chartData) {
				return chartData;
			});
		}
		/*$scope.tableData = {
			headers : [
				{title: 'title 1'},
				{title: 'title 2'},
				{title: 'title 3'},
				{title: 'title 4'},
				{title: 'title 5'}
			],
			rowData: [
				{ val1: 'abc', val2: 'def', val3: 'ghi', val4: 'jkl', val5: 'mno'},
				{ val1: 'abc', val2: 'def', val3: 'ghi', val4: 'jkl', val5: 'mno'},
				{ val1: 'abc', val2: 'def', val3: 'ghi', val4: 'jkl', val5: 'mno'},
				{ val1: 'abc', val2: 'def', val3: 'ghi', val4: 'jkl', val5: 'mno'},
				{ val1: 'abc', val2: 'def', val3: 'ghi', val4: 'jkl', val5: 'mno'},
				{ val1: 'abc', val2: 'def', val3: 'ghi', val4: 'jkl', val5: 'mno'},
				{ val1: 'abc', val2: 'def', val3: 'ghi', val4: 'jkl', val5: 'mno'},
				{ val1: 'abc', val2: 'def', val3: 'ghi', val4: 'jkl', val5: 'mno'},
				{ val1: 'abc', val2: 'def', val3: 'ghi', val4: 'jkl', val5: 'mno'},
				{ val1: 'abc', val2: 'def', val3: 'ghi', val4: 'jkl', val5: 'mno'}
			]			
		};*/
        $scope.tableData = {};
		$scope.query = {
			order: 'name',
			limit: 10,
			page: 1
		};
		$timeout(function() {
	            fixContainerHeight(1);
		},0);
		$scope.getAllDrillDownData();
		$scope.onReorder = function(order){
            $scope.tableData.rowData =  $filter('orderBy')($scope.tableData.rowData,order);
            $timeout(function(){
                angular.element(document.querySelectorAll(".md-sort.md-active md-icon")).removeClass("ng-hide");
            }, 0);
            
        };
        $scope.onMainReorder = function(order){
        	$scope.mainQueryData =  $filter('orderBy')($scope.mainQueryData,order);
            $timeout(function(){
                angular.element(document.querySelectorAll(".md-sort.md-active md-icon")).removeClass("ng-hide");
            }, 0);
        };
		/*loadDrillDownDataFromServer(WidgetName.TopNBadCertificates, ChartTypes.barChart, 30, getKeysForDrillDown(dataOnWidget)).then(function(data){
			console.log('Data for this drilldown from server', data);
			$scope.tableData = data;
		});*/
	}
	angular.module('shieldxApp').controller('TopNBadCertificatesCtr', TopNBadCertificatesCtr);
})();
(function() {
	function TopNBlockedClientsCtr($scope,dataVisualizationService,$timeout,$location,$filter) {
		console.log('TopNDetectedAppsCtr initialised');
		var parentScope = $scope.$parent.$parent;
		$scope.selected = [];
		var dataOnWidget = angular.copy(parentScope.drilldowndata);
		
		$scope.title = widgetConfig.list.TopNBlockedClients.title;

		$scope.url = $location.absUrl().split('#')[1];
		function getKeysForDrillDown (list) {
			if(Array.isArray(list)) {
				var tempArray = [];
				_.forEach(list, function(value, key){
					tempArray.push(value.Letter);
				});
				console.log("getKeysForDrillDown ");
				console.dir(tempArray);
				return tempArray;
			}
		}
		$scope.updateDirllDownInterval = function(interval){
			$scope.timeInteval = interval;
			$scope.getAllDrillDownData();
		};
		$scope.intervalOptions = WidgetDataUtil.drillDownIntervaloptions;
		$scope.$emit('listenHeaderText', { headerText: "Security Analysis tools > Top N Blocked Clients" });
		$scope.getAllDrillDownData = function(){
			if( $scope.url.indexOf(WidgetName.TopNBlockedClients) > 0 ){
				
				var dataWidgetConfig = new DataWidgetConfig(widgetConfig.list[WidgetName.TopNBlockedClients].widgetType, WidgetName.TopNBlockedClients);
				dataWidgetConfig.nValue = 50;
				//dataWidgetConfigArray.push(dataWidgetConfig);	
				var dataWidgetConfigArray = [];
				dataWidgetConfigArray.push(dataWidgetConfig);
				dataVisualizationService.getFilteredDataForWidgets(dataWidgetConfigArray).then(function(responseData){
					console.log("data for main query in drilldowndata");
					console.log(responseData);
					dataOnWidget = responseData.TopNBlockedClients;
				}).finally(function(){
					loadDrillDownDataFromServer(WidgetName.TopNBlockedClients, ChartTypes.barChart,  getKeysForDrillDown(dataOnWidget)).then(function(data){
						console.log('Data for this drilldown from server', data);
						$scope.tableData = data;
					});
				});
			}else{
				loadDrillDownDataFromServer(WidgetName.TopNBlockedClients, ChartTypes.barChart, getKeysForDrillDown(dataOnWidget)).then(function(data){
					console.log('Data for this drilldown from server', data);
					$scope.tableData = data;
				});
				}
		};
		function loadDrillDownDataFromServer(widgetType,chartType,args) {
			console.log("loadDrillDownDataFromServer args "+args);
            console.dir(args);
            var interval = ($scope.timeInteval)?($scope.timeInteval):30;
			var dataWidgetConfig = new DataWidgetConfig(chartType, widgetType,interval,args);
			
			return dataVisualizationService.getDrillDownDataForWidget(dataWidgetConfig).then(function (chartData) {
				return chartData;
			});
		}
		/*$scope.tableData = {
			headers : [
				{title: 'title 1'},
				{title: 'title 2'},
				{title: 'title 3'},
				{title: 'title 4'},
				{title: 'title 5'}
			],
			rowData: [
				{ val1: 'abc', val2: 'def', val3: 'ghi', val4: 'jkl', val5: 'mno'},
				{ val1: 'abc', val2: 'def', val3: 'ghi', val4: 'jkl', val5: 'mno'},
				{ val1: 'abc', val2: 'def', val3: 'ghi', val4: 'jkl', val5: 'mno'},
				{ val1: 'abc', val2: 'def', val3: 'ghi', val4: 'jkl', val5: 'mno'},
				{ val1: 'abc', val2: 'def', val3: 'ghi', val4: 'jkl', val5: 'mno'},
				{ val1: 'abc', val2: 'def', val3: 'ghi', val4: 'jkl', val5: 'mno'},
				{ val1: 'abc', val2: 'def', val3: 'ghi', val4: 'jkl', val5: 'mno'},
				{ val1: 'abc', val2: 'def', val3: 'ghi', val4: 'jkl', val5: 'mno'},
				{ val1: 'abc', val2: 'def', val3: 'ghi', val4: 'jkl', val5: 'mno'},
				{ val1: 'abc', val2: 'def', val3: 'ghi', val4: 'jkl', val5: 'mno'}
			]			
		};*/
        $scope.tableData = {};
		$scope.query = {
			order: 'name',
			limit: 10,
			page: 1
		};
		$scope.getAllDrillDownData();
		$timeout(function() {
	            fixContainerHeight(1);
		},0);
		$scope.onReorder = function(order){
            $scope.tableData.rowData =  $filter('orderBy')($scope.tableData.rowData,order);
            $timeout(function(){
                angular.element(document.querySelectorAll(".md-sort.md-active md-icon")).removeClass("ng-hide");
            }, 0);
            
        };
		
	}
	angular.module('shieldxApp').controller('TopNBlockedClientsCtr', TopNBlockedClientsCtr);
})();

(function() {
	function TopNConversationsCtr($scope,dataVisualizationService,$timeout,$location,$filter) {
		console.log('TopNConversationsCtr initialised');
		var parentScope = $scope.$parent.$parent;
		$scope.selected = [];
		var dataOnWidget = angular.copy(parentScope.drilldowndata);
		
		$scope.title = widgetConfig.list.TopNConversations.title;

		$scope.url = $location.absUrl().split('#')[1];
		function getKeysForDrillDown (list) {
			if(Array.isArray(list)) {
				var tempArray = [];
				_.forEach(list, function(value, key){
					tempArray.push({"source":value.source,"victim":value.victim});
				});
				console.log("getKeysForDrillDown ");
				console.dir(tempArray);
				return tempArray;
			}
		}
		$scope.updateDirllDownInterval = function(interval,nValue){
			$scope.timeInteval = interval;
			$scope.navalue= nValue;
			$scope.getAllDrillDownData();
			renderMainData();
			$scope.drillDownSearchData = false;
		};
		renderMainData = function(){
			var dataWidgetConfig = new DataWidgetConfig(widgetConfig.list[WidgetName.TopNConversations].widgetType, WidgetName.TopNConversations);
				dataWidgetConfig.nValue = ($scope.navalue)?parseInt($scope.navalue):50;
				//dataWidgetConfigArray.push(dataWidgetConfig);	
				var dataWidgetConfigArray = [];
				dataWidgetConfigArray.push(dataWidgetConfig);
				dataVisualizationService.getFilteredDataForWidgets(dataWidgetConfigArray).then(function(responseData){
					console.log("data for main query in drilldowndata");
					console.log(responseData);
					dataOnWidget = responseData.TopNConversations;
				}).finally(function(){
					renderDrillDownData();	
				});
		};
		$scope.intervalOptions = WidgetDataUtil.drillDownIntervaloptions;
		$scope.$emit('listenHeaderText', { headerText: "Security Analysis tools > Top N VMs by Data Transferred (measured in bytes)" });
		$scope.getAllDrillDownData = function(){
			if( $scope.url.indexOf(WidgetName.TopNConversations) > 0 ){
				
				renderMainData();
			}else{
					renderDrillDownData();
				}
		};
		function loadDrillDownDataFromServer(widgetType,chartType,args) {
			console.log("loadDrillDownDataFromServer args "+args);
            console.dir(args);
            var interval = ($scope.timeInteval)?($scope.timeInteval):30;
			var dataWidgetConfig = new DataWidgetConfig(chartType, widgetType,interval,args);
			
			return dataVisualizationService.getDrillDownDataForWidget(dataWidgetConfig).then(function (chartData) {
				return chartData;
			});
		}

		renderDrillDownData = function(){
			$scope.mainQueryData = dataOnWidget;
			$scope.drillDownDataPresent = false;
			$scope.mainCerticicatesAvaliable = true;

		};
		$scope.getListBasedOnCertficate = function(fiterItem){
			$scope.drillDownDataPresent = true;
			$scope.mainCerticicatesAvaliable = false;
			$scope.itemToBeFiltered = fiterItem;
			$scope.getDrillDownForTisItem = [];
			$scope.tableData = [];
			$scope.getDrillDownForTisItem.push(fiterItem);
			/*_.each(dataOnWidget,function(item){
				if(item.source === fiterItem.source){
					$scope.getDrillDownForTisItem.push(item);
				}
			});*/
			loadDrillDownDataFromServer(WidgetName.TopNConversations, ChartTypes.barChart, getKeysForDrillDown($scope.getDrillDownForTisItem)).then(function(data){
				console.log('Data for this drilldown from server', data);
				$scope.drillDownSearchData = true;
				$scope.tableData = data;
			});
		};

        //$scope.tableData = {};
		$scope.query = {
			order: 'name',
			limit: 10,
			page: 1
		};
		$scope.getAllDrillDownData();
		$timeout(function() {
	            fixContainerHeight(1);
		},0);
		$scope.onReorder = function(order){
            $scope.tableData.rowData =  $filter('orderBy')($scope.tableData.rowData,order);
            $timeout(function(){
                angular.element(document.querySelectorAll(".md-sort.md-active md-icon")).removeClass("ng-hide");
            }, 0);
            
        };
        $scope.onMainReorder = function(order){
        	$scope.mainQueryData =  $filter('orderBy')($scope.mainQueryData,order);
            $timeout(function(){
                angular.element(document.querySelectorAll(".md-sort.md-active md-icon")).removeClass("ng-hide");
            }, 0);
        };
		
	}
	angular.module('shieldxApp').controller('TopNConversationsCtr', TopNConversationsCtr);
})();

(function() {
	function TopNDetectedAppsCtr($scope,dataVisualizationService,$timeout, $location,$filter) {
		console.log('TopNDetectedAppsCtr initialised');
		var parentScope = $scope.$parent.$parent;
		$scope.selected = [];
		var dataOnWidget = angular.copy(parentScope.drilldowndata);
		
		$scope.title = widgetConfig.list.TopNDetectedApps.title;
		$scope.query = {
			order: 'val1',
			limit: 10,
			page: 1
		};
		$scope.$emit('listenHeaderText', { headerText: "Security Analysis tools > Top N Detected Apps" });
		$scope.url = $location.absUrl().split('#')[1];
		$scope.getAllDrillDownData = function(){
		if( $scope.url.indexOf(WidgetName.TopNDetectedApps) > 0 ){
			
			var dataWidgetConfig = new DataWidgetConfig(widgetConfig.list[WidgetName.TopNDetectedApps].widgetType, WidgetName.TopNDetectedApps);
			dataWidgetConfig.nValue = 50;
			//dataWidgetConfigArray.push(dataWidgetConfig);	
			var dataWidgetConfigArray = [];
			dataWidgetConfigArray.push(dataWidgetConfig);
			dataVisualizationService.getFilteredDataForWidgets(dataWidgetConfigArray).then(function(responseData){
				console.log("data for main query in drilldowndata");
				console.log(responseData);
				dataOnWidget = responseData.TopNDetectedApps;
			}).finally(function(){
				loadDrillDownDataFromServer(WidgetName.TopNDetectedApps, ChartTypes.barChart,  getKeysForDrillDown(dataOnWidget)).then(function(data){
					console.log('Data for this drilldown from server', data);
					$scope.tableData = data;
				});
			});
		}else{
			loadDrillDownDataFromServer(WidgetName.TopNDetectedApps, ChartTypes.barChart,  getKeysForDrillDown(dataOnWidget)).then(function(data){
					console.log('Data for this drilldown from server', data);
					$scope.tableData = data;
				});
		}
	};
		console.log("url " + $scope.url);
		$scope.updateDirllDownInterval = function(interval){
			$scope.timeInteval = interval;
			$scope.getAllDrillDownData();
		};
		$scope.intervalOptions = WidgetDataUtil.drillDownIntervaloptions;
		function getKeysForDrillDown (list) {
			if(Array.isArray(list)) {
				var tempArray = [];
				_.forEach(list, function(value, key){
					tempArray.push(value.Letter);
				});
				console.log("getKeysForDrillDown ");
				console.dir(tempArray);
				return tempArray;
			}
		}
		function loadDrillDownDataFromServer(widgetType,chartType,args) {
			console.log(" TopNDetectedAppsCtr loadDrillDownDataFromServer args "+args);
            console.dir(args);
            var interval = ($scope.timeInteval)?($scope.timeInteval):30;
			var dataWidgetConfig = new DataWidgetConfig(chartType, widgetType,interval,args);
			
			return dataVisualizationService.getDrillDownDataForWidget(dataWidgetConfig).then(function (chartData) {
	        	console.log(" TopNDetectedAppsCtr getDrillDownDataForWidget args "+chartData);
	        	console.dir(chartData);
				return chartData;
			});
		}
		$scope.getAllDrillDownData();
		/*$scope.tableData = {
			headers : [
				{title: 'title 1'},
				{title: 'title 2'},
				{title: 'title 3'},
				{title: 'title 4'},
				{title: 'title 5'}
			],
			rowData: [
				{ val1: 'abc', val2: 'def', val3: 'ghi', val4: 'jkl', val5: 'mno'},
				{ val1: 'abc', val2: 'def', val3: 'ghi', val4: 'jkl', val5: 'mno'},
				{ val1: 'abc', val2: 'def', val3: 'ghi', val4: 'jkl', val5: 'mno'},
				{ val1: 'abc', val2: 'def', val3: 'ghi', val4: 'jkl', val5: 'mno'},
				{ val1: 'abc', val2: 'def', val3: 'ghi', val4: 'jkl', val5: 'mno'},
				{ val1: 'abc', val2: 'def', val3: 'ghi', val4: 'jkl', val5: 'mno'},
				{ val1: 'abc', val2: 'def', val3: 'ghi', val4: 'jkl', val5: 'mno'},
				{ val1: 'abc', val2: 'def', val3: 'ghi', val4: 'jkl', val5: 'mno'},
				{ val1: 'abc', val2: 'def', val3: 'ghi', val4: 'jkl', val5: 'mno'},
				{ val1: 'abc', val2: 'def', val3: 'ghi', val4: 'jkl', val5: 'mno'}
			]			
		};*/
        $scope.tableData = {};
/*		$scope.query = {
			order: 'name',
			limit: 5,
			page: 1
		};*/
		$scope.onReorder = function(order){
            $scope.tableData.rowData =  $filter('orderBy')($scope.tableData.rowData,order);
            $timeout(function(){
                angular.element(document.querySelectorAll(".md-sort.md-active md-icon")).removeClass("ng-hide");
            }, 0);
            
        };
		$timeout(function() {
	            fixContainerHeight(1);
		},0);
		
	}
	angular.module('shieldxApp').controller('TopNDetectedAppsCtr', TopNDetectedAppsCtr);
})();
(function() {
	function TopNDetectedThreatsCtr($scope,dataVisualizationService,$location,$timeout,$filter) {
		console.log('TopNDetectedAppsCtr initialised');
		var parentScope = $scope.$parent.$parent;
		$scope.selected = [];
		var dataOnWidget = angular.copy(parentScope.drilldowndata);
		
		$scope.title = widgetConfig.list.TopNDetectedThreats.title;
		$scope.updateDirllDownInterval = function(interval){
			$scope.timeInteval = interval;
			$scope.getAllDrillDownData();
		};
		$scope.intervalOptions = WidgetDataUtil.drillDownIntervaloptions;
		function getKeysForDrillDown (list) {
			if(Array.isArray(list)) {
				var tempArray = [];
				_.forEach(list, function(value, key){
					tempArray.push(value.Letter);
				});
				console.log("getKeysForDrillDown ");
				console.dir(tempArray);
				return tempArray;
			}
		}
		function loadDrillDownDataFromServer(widgetType,chartType,args) {
			console.log("loadDrillDownDataFromServer args "+args);
            console.dir(args);
            var interval = ($scope.timeInteval)?($scope.timeInteval):30;
			var dataWidgetConfig = new DataWidgetConfig(chartType, widgetType,interval,args);
			
			return dataVisualizationService.getDrillDownDataForWidget(dataWidgetConfig).then(function (chartData) {
				return chartData;
			});
		}

		$scope.$emit('listenHeaderText', { headerText: "Security Analysis tools > Top N Detected Threats " });
		$scope.url = $location.absUrl().split('#')[1];
		$scope.getAllDrillDownData = function(){
			if( $scope.url.indexOf(WidgetName.TopNDetectedThreats) > 0 ){
				
				var dataWidgetConfig = new DataWidgetConfig(widgetConfig.list[WidgetName.TopNDetectedThreats].widgetType, WidgetName.TopNDetectedThreats);
				dataWidgetConfig.nValue = 50;
				var dataWidgetConfigArray = [];
				dataWidgetConfigArray.push(dataWidgetConfig);
				dataVisualizationService.getFilteredDataForWidgets(dataWidgetConfigArray).then(function(responseData){
					console.log("data for main query in drilldowndata");
					console.log(responseData);
					dataOnWidget = responseData.TopNDetectedThreats;
				}).finally(function(){
					loadDrillDownDataFromServer(WidgetName.TopNDetectedThreats, ChartTypes.barChart,  getKeysForDrillDown(dataOnWidget)).then(function(data){
						console.log('Data for this drilldown from server', data);
						$scope.tableData = data;
					});
				});
			}else{
				loadDrillDownDataFromServer(WidgetName.TopNDetectedThreats, ChartTypes.barChart,  getKeysForDrillDown(dataOnWidget)).then(function(data){
						console.log('Data for this drilldown from server', data);
						$scope.tableData = data;
					});
			}
		};
		/*$scope.tableData = {
			headers : [
				{title: 'title 1'},
				{title: 'title 2'},
				{title: 'title 3'},
				{title: 'title 4'},
				{title: 'title 5'}
			],
			rowData: [
				{ val1: 'abc', val2: 'def', val3: 'ghi', val4: 'jkl', val5: 'mno'},
				{ val1: 'abc', val2: 'def', val3: 'ghi', val4: 'jkl', val5: 'mno'},
				{ val1: 'abc', val2: 'def', val3: 'ghi', val4: 'jkl', val5: 'mno'},
				{ val1: 'abc', val2: 'def', val3: 'ghi', val4: 'jkl', val5: 'mno'},
				{ val1: 'abc', val2: 'def', val3: 'ghi', val4: 'jkl', val5: 'mno'},
				{ val1: 'abc', val2: 'def', val3: 'ghi', val4: 'jkl', val5: 'mno'},
				{ val1: 'abc', val2: 'def', val3: 'ghi', val4: 'jkl', val5: 'mno'},
				{ val1: 'abc', val2: 'def', val3: 'ghi', val4: 'jkl', val5: 'mno'},
				{ val1: 'abc', val2: 'def', val3: 'ghi', val4: 'jkl', val5: 'mno'},
				{ val1: 'abc', val2: 'def', val3: 'ghi', val4: 'jkl', val5: 'mno'}
			]			
		};*/
		$scope.getAllDrillDownData();
        $scope.tableData = {};
		$scope.query = {
			order: 'name',
			limit: 10,
			page: 1
		};
		$timeout(function() {
	            fixContainerHeight(1);
		},0);
		$scope.onReorder = function(order){
            $scope.tableData.rowData =  $filter('orderBy')($scope.tableData.rowData,order);
            $timeout(function(){
                angular.element(document.querySelectorAll(".md-sort.md-active md-icon")).removeClass("ng-hide");
            }, 0);
            
        };
		/*loadDrillDownDataFromServer(WidgetName.TopNDetectedThreats, ChartTypes.barChart, 30, getKeysForDrillDown(dataOnWidget)).then(function(data){
			console.log('WidgetName.TopNDetectedThreats', data);
			$scope.tableData = data;
		});*/
	}
	angular.module('shieldxApp').controller('TopNDetectedThreatsCtr', TopNDetectedThreatsCtr);
})();
(function() {
	function TopNMalwareDetectionsCtr($scope,dataVisualizationService,$location,$timeout,$filter) {
		console.log('TopNAttackerResourceGroups initialised');
		var parentScope = $scope.$parent.$parent;
		$scope.selected = [];
		var dataOnWidget = angular.copy(parentScope.drilldowndata);
		
		$scope.title = widgetConfig.list.TopNMalwareDetections.title;
		$scope.updateDirllDownInterval = function(interval){
			$scope.timeInteval = interval;
			$scope.getAllDrillDownData();
		};
		$scope.intervalOptions = WidgetDataUtil.drillDownIntervaloptions;

		$scope.$emit('listenHeaderText', { headerText: "Security Analysis tools > Top N Malware Detections" });
		$scope.url = $location.absUrl().split('#')[1];
		$scope.getAllDrillDownData = function(){
			if( $scope.url.indexOf(WidgetName.TopNMalwareDetections) > 0 ){
				
				var dataWidgetConfig = new DataWidgetConfig(widgetConfig.list[WidgetName.TopNMalwareDetections].widgetType, WidgetName.TopNMalwareDetections);
				dataWidgetConfig.nValue = 50;
				//dataWidgetConfigArray.push(dataWidgetConfig);	
				var dataWidgetConfigArray = [];
				dataWidgetConfigArray.push(dataWidgetConfig);
				dataVisualizationService.getFilteredDataForWidgets(dataWidgetConfigArray).then(function(responseData){
					console.log("data for main query in drilldowndata");
					console.log(responseData);
					dataOnWidget = responseData.TopNMalwareDetections;
				}).finally(function(){
					loadDrillDownDataFromServer(WidgetName.TopNMalwareDetections, ChartTypes.barChart,  getKeysForDrillDown(dataOnWidget)).then(function(data){
						console.log('Data for this drilldown from server', data);
						$scope.tableData = data;
					});
				});
			}else{
				loadDrillDownDataFromServer(WidgetName.TopNMalwareDetections, ChartTypes.barChart, getKeysForDrillDown(dataOnWidget)).then(function(data){
					console.log('Data for this drilldown from server', data);
					$scope.tableData = data;
				});
			}
		};
		function getKeysForDrillDown (list) {
			if(Array.isArray(list)) {
				var tempArray = [];
				_.forEach(list, function(value, key){
					tempArray.push(value.Letter);
				});
				console.log("getKeysForDrillDown ");
				console.dir(tempArray);
				return tempArray;
			}
		}
		function loadDrillDownDataFromServer(widgetType,chartType,args) {
			console.log(" TopNMalwareDetections loadDrillDownDataFromServer args "+args);
            console.dir(args);
            var interval = ($scope.timeInteval)?($scope.timeInteval):30;
			var dataWidgetConfig = new DataWidgetConfig(chartType, widgetType,interval,args);
			
			return dataVisualizationService.getDrillDownDataForWidget(dataWidgetConfig).then(function (chartData) {
	        	console.log(" TopNMalwareDetections getDrillDownDataForWidget args "+chartData);
	        	console.dir(chartData);
				return chartData;
			});
		}
		/*$scope.tableData = {
			headers : [
				{title: 'title 1'},
				{title: 'title 2'},
				{title: 'title 3'},
				{title: 'title 4'},
				{title: 'title 5'}
			],
			rowData: [
				{ val1: 'abc', val2: 'def', val3: 'ghi', val4: 'jkl', val5: 'mno'},
				{ val1: 'abc', val2: 'def', val3: 'ghi', val4: 'jkl', val5: 'mno'},
				{ val1: 'abc', val2: 'def', val3: 'ghi', val4: 'jkl', val5: 'mno'},
				{ val1: 'abc', val2: 'def', val3: 'ghi', val4: 'jkl', val5: 'mno'},
				{ val1: 'abc', val2: 'def', val3: 'ghi', val4: 'jkl', val5: 'mno'},
				{ val1: 'abc', val2: 'def', val3: 'ghi', val4: 'jkl', val5: 'mno'},
				{ val1: 'abc', val2: 'def', val3: 'ghi', val4: 'jkl', val5: 'mno'},
				{ val1: 'abc', val2: 'def', val3: 'ghi', val4: 'jkl', val5: 'mno'},
				{ val1: 'abc', val2: 'def', val3: 'ghi', val4: 'jkl', val5: 'mno'},
				{ val1: 'abc', val2: 'def', val3: 'ghi', val4: 'jkl', val5: 'mno'}
			]			
		};*/
        //$scope.tableData = {};
        $scope.getAllDrillDownData();
		$scope.query = {
			order: 'name',
			limit: 10,
			page: 1
		};
		$timeout(function() {
	            fixContainerHeight(1);
		},0);
		$scope.onReorder = function(order){
            $scope.tableData.rowData =  $filter('orderBy')($scope.tableData.rowData,order);
            $timeout(function(){
                angular.element(document.querySelectorAll(".md-sort.md-active md-icon")).removeClass("ng-hide");
            }, 0);
            
        };
		
	}
	angular.module('shieldxApp').controller('TopNMalwareDetectionsCtr', TopNMalwareDetectionsCtr);
})();
(function() {
	function TopNMalwareDomainsCtr($scope,dataVisualizationService,$location,$timeout,$filter) {
		console.log('TopNDetectedAppsCtr initialised');
		var parentScope = $scope.$parent.$parent;
		$scope.selected = [];
		var dataOnWidget = angular.copy(parentScope.drilldowndata);
		
		$scope.title = widgetConfig.list.TopNMalwareDomains.title;

		$scope.$emit('listenHeaderText', { headerText: "Security Analysis tools > Top N Malware Domains" });
		$scope.url = $location.absUrl().split('#')[1];
		$scope.getAllDrillDownData = function(){
			if( $scope.url.indexOf(WidgetName.TopNMalwareDomains) > 0 ){
				
				var dataWidgetConfig = new DataWidgetConfig(widgetConfig.list[WidgetName.TopNMalwareDomains].widgetType, WidgetName.TopNMalwareDomains);
				dataWidgetConfig.nValue = 50;
				//dataWidgetConfigArray.push(dataWidgetConfig);	
				var dataWidgetConfigArray = [];
				dataWidgetConfigArray.push(dataWidgetConfig);
				dataVisualizationService.getFilteredDataForWidgets(dataWidgetConfigArray).then(function(responseData){
					console.log("data for main query in drilldowndata");
					console.log(responseData);
					dataOnWidget = responseData.TopNMalwareDomains;
				}).finally(function(){
					loadDrillDownDataFromServer(WidgetName.TopNMalwareDomains, ChartTypes.barChart,  getKeysForDrillDown(dataOnWidget)).then(function(data){
						console.log('Data for this drilldown from server', data);
						$scope.tableData = data;
					});
				});
			}else{
				loadDrillDownDataFromServer(WidgetName.TopNMalwareDomains, ChartTypes.barChart,  getKeysForDrillDown(dataOnWidget)).then(function(data){
						console.log('Data for this drilldown from server', data);
						$scope.tableData = data;
					});
			}
		};
		console.log("url " + $scope.url);
		$scope.updateDirllDownInterval = function(interval){
			$scope.timeInteval = interval;
			$scope.getAllDrillDownData();
		};
		$scope.intervalOptions = WidgetDataUtil.drillDownIntervaloptions;
		function getKeysForDrillDown (list) {
			if(Array.isArray(list)) {
				var tempArray = [];
				_.forEach(list, function(value, key){
					tempArray.push(value.Letter);
				});
				console.log("getKeysForDrillDown ");
				console.dir(tempArray);
				return tempArray;
			}
		}
		function loadDrillDownDataFromServer(widgetType,chartType,args) {
			console.log("loadDrillDownDataFromServer args "+args);
            console.dir(args);
           var interval = ($scope.timeInteval)?($scope.timeInteval):30;
			var dataWidgetConfig = new DataWidgetConfig(chartType, widgetType,interval,args);
			
			return dataVisualizationService.getDrillDownDataForWidget(dataWidgetConfig).then(function (chartData) {
				return chartData;
			});
		}
		/*$scope.tableData = {
			headers : [
				{title: 'title 1'},
				{title: 'title 2'},
				{title: 'title 3'},
				{title: 'title 4'},
				{title: 'title 5'}
			],
			rowData: [
				{ val1: 'abc', val2: 'def', val3: 'ghi', val4: 'jkl', val5: 'mno'},
				{ val1: 'abc', val2: 'def', val3: 'ghi', val4: 'jkl', val5: 'mno'},
				{ val1: 'abc', val2: 'def', val3: 'ghi', val4: 'jkl', val5: 'mno'},
				{ val1: 'abc', val2: 'def', val3: 'ghi', val4: 'jkl', val5: 'mno'},
				{ val1: 'abc', val2: 'def', val3: 'ghi', val4: 'jkl', val5: 'mno'},
				{ val1: 'abc', val2: 'def', val3: 'ghi', val4: 'jkl', val5: 'mno'},
				{ val1: 'abc', val2: 'def', val3: 'ghi', val4: 'jkl', val5: 'mno'},
				{ val1: 'abc', val2: 'def', val3: 'ghi', val4: 'jkl', val5: 'mno'},
				{ val1: 'abc', val2: 'def', val3: 'ghi', val4: 'jkl', val5: 'mno'},
				{ val1: 'abc', val2: 'def', val3: 'ghi', val4: 'jkl', val5: 'mno'}
			]			
		};*/
        $scope.tableData = {};
		$scope.query = {
			order: 'name',
			limit: 10,
			page: 1
		};
		$timeout(function() {
	            fixContainerHeight(1);
		},0);
		$scope.getAllDrillDownData();
		$scope.onReorder = function(order){
            $scope.tableData.rowData =  $filter('orderBy')($scope.tableData.rowData,order);
            $timeout(function(){
                angular.element(document.querySelectorAll(".md-sort.md-active md-icon")).removeClass("ng-hide");
            }, 0);
            
        };
		/*loadDrillDownDataFromServer(WidgetName.TopNMalwareDomains, ChartTypes.barChart, 30, getKeysForDrillDown(dataOnWidget)).then(function(data){
			console.log('Data for this drilldown from server', data);
			$scope.tableData = data;
		});*/
	}
	angular.module('shieldxApp').controller('TopNMalwareDomainsCtr', TopNMalwareDomainsCtr);
})();
(function() {
	function TopNServedDomainsCtr($scope,dataVisualizationService,$timeout,$location,$filter) {
		console.log('TopNDetectedAppsCtr initialised');
		var parentScope = $scope.$parent.$parent;
		$scope.selected = [];
		var dataOnWidget = angular.copy(parentScope.drilldowndata);
		
		$scope.title = widgetConfig.list.TopNServedDomains.title;
		$scope.updateDirllDownInterval = function(interval){
			$scope.timeInteval = interval;
			$scope.getAllDrillDownData();
		};
		$scope.intervalOptions = WidgetDataUtil.drillDownIntervaloptions;
		function getKeysForDrillDown (list) {
			if(Array.isArray(list)) {
				var tempArray = [];
				_.forEach(list, function(value, key){
					tempArray.push(value.Letter);
				});
				console.log("getKeysForDrillDown ");
				console.dir(tempArray);
				return tempArray;
			}
		}
		function loadDrillDownDataFromServer(widgetType,chartType,args) {
			console.log("loadDrillDownDataFromServer args "+args);
            console.dir(args);
            var interval = ($scope.timeInteval)?($scope.timeInteval):30;
			var dataWidgetConfig = new DataWidgetConfig(chartType, widgetType,interval,args);
			
			return dataVisualizationService.getDrillDownDataForWidget(dataWidgetConfig).then(function (chartData) {
				return chartData;
			});
		}

		$scope.$emit('listenHeaderText', { headerText: "Security Analysis tools > Top N Server Domains" });
		$scope.url = $location.absUrl().split('#')[1];
		$scope.getAllDrillDownData = function(){
			if( $scope.url.indexOf(WidgetName.TopNServedDomains) > 0 ){
				
				var dataWidgetConfig = new DataWidgetConfig(widgetConfig.list[WidgetName.TopNServedDomains].widgetType, WidgetName.TopNServedDomains);
				dataWidgetConfig.nValue = 50;
				//dataWidgetConfigArray.push(dataWidgetConfig);	
				var dataWidgetConfigArray = [];
				dataWidgetConfigArray.push(dataWidgetConfig);
				dataVisualizationService.getFilteredDataForWidgets(dataWidgetConfigArray).then(function(responseData){
					console.log("data for main query in drilldowndata");
					console.log(responseData);
					dataOnWidget = responseData.TopNServedDomains;
				}).finally(function(){
					loadDrillDownDataFromServer(WidgetName.TopNServedDomains, ChartTypes.barChart,  getKeysForDrillDown(dataOnWidget)).then(function(data){
						console.log('Data for this drilldown from server', data);
						$scope.tableData = data;
					});
				});
			}else{
				loadDrillDownDataFromServer(WidgetName.TopNServedDomains, ChartTypes.barChart,getKeysForDrillDown(dataOnWidget)).then(function(data){
					console.log('Data for this drilldown from server', data);
					$scope.tableData = data;
				});
			}
		};

		/*$scope.tableData = {
			headers : [
				{title: 'title 1'},
				{title: 'title 2'},
				{title: 'title 3'},
				{title: 'title 4'},
				{title: 'title 5'}
			],
			rowData: [
				{ val1: 'abc', val2: 'def', val3: 'ghi', val4: 'jkl', val5: 'mno'},
				{ val1: 'abc', val2: 'def', val3: 'ghi', val4: 'jkl', val5: 'mno'},
				{ val1: 'abc', val2: 'def', val3: 'ghi', val4: 'jkl', val5: 'mno'},
				{ val1: 'abc', val2: 'def', val3: 'ghi', val4: 'jkl', val5: 'mno'},
				{ val1: 'abc', val2: 'def', val3: 'ghi', val4: 'jkl', val5: 'mno'},
				{ val1: 'abc', val2: 'def', val3: 'ghi', val4: 'jkl', val5: 'mno'},
				{ val1: 'abc', val2: 'def', val3: 'ghi', val4: 'jkl', val5: 'mno'},
				{ val1: 'abc', val2: 'def', val3: 'ghi', val4: 'jkl', val5: 'mno'},
				{ val1: 'abc', val2: 'def', val3: 'ghi', val4: 'jkl', val5: 'mno'},
				{ val1: 'abc', val2: 'def', val3: 'ghi', val4: 'jkl', val5: 'mno'}
			]			
		};*/
        $scope.tableData = {};
		$scope.query = {
			order: 'name',
			limit: 10,
			page: 1
		};
		$scope.getAllDrillDownData();
		$timeout(function() {
	            fixContainerHeight(1);
		},0);
		$scope.onReorder = function(order){
            $scope.tableData.rowData =  $filter('orderBy')($scope.tableData.rowData,order);
            $timeout(function(){
                angular.element(document.querySelectorAll(".md-sort.md-active md-icon")).removeClass("ng-hide");
            }, 0);
            
        };

	}
	angular.module('shieldxApp').controller('TopNServedDomainsCtr', TopNServedDomainsCtr);
})();
(function() {
	function TopNTalkersbyResourceGroupCtr($scope,dataVisualizationService,$timeout,$filter,$location) {
		console.log('TopNTalkersbyResourceGroup initialised');
		var parentScope = $scope.$parent.$parent;
		$scope.selected = [];
		var dataOnWidget = angular.copy(parentScope.drilldowndata);
		
		$scope.title = widgetConfig.list.TopNTalkersbyResourceGroup.title;
		//$scope.title = widgetConfig.list[parentScope.widgetname].title;
		/*$scope.updateDirllDownInterval = function(interval){
			$scope.timeInteval = interval;
		};*/
		$scope.url = $location.absUrl().split('#')[1];
		$scope.intervalOptions = WidgetDataUtil.drillDownIntervaloptions;
		function getKeysForDrillDown (list) {
			if(Array.isArray(list)) {
				var tempArray = [];
				_.forEach(list, function(value, key){
					tempArray.push({"source":value.source,"victim":value.victim});
				});
				console.log("getKeysForDrillDown ");
				console.dir(tempArray);
				return tempArray;
			}
		}
		$scope.updateDirllDownInterval = function(interval,nValue){
			if(interval === 'showMainData'){
				renderDrillDownData();
			}else{
				$scope.timeInteval = interval;
				$scope.navalue= nValue;
				$scope.getAllDrillDownData();	
				renderMainData();
				$scope.drillDownSearchData = false;
			}
		};
		$scope.getAllDrillDownData = function(){
			if( $scope.url.indexOf(WidgetName.TopNTalkersbyVMname) > 0 ){
				
				renderMainData();
			}else{
					renderDrillDownData();
				}
		};
		$scope.$emit('listenHeaderText', { headerText: "Security Analysis tools > Top N Resource Groups by Number of Connections" });
		
		function loadDrillDownDataFromServer(widgetType,chartType,args) {
			console.log(" TopNTalkersbyResourceGroup loadDrillDownDataFromServer args "+args);
            console.dir(args);
            var interval = ($scope.timeInteval)?($scope.timeInteval):30;
			var dataWidgetConfig = new DataWidgetConfig(chartType, widgetType,interval,args);
			
			return dataVisualizationService.getDrillDownDataForWidget(dataWidgetConfig).then(function (chartData) {
	        	console.log(" TopNTalkersbyResourceGroup getDrillDownDataForWidget args "+chartData);
	        	console.dir(chartData);
	        	$scope.filterData = chartData;
				return chartData;
			});
		}
		$scope.query = {
			order: 'name',
			limit: 10,
			page: 1
		};
		renderMainData = function(){
			var dataWidgetConfig = new DataWidgetConfig(widgetConfig.list[WidgetName.TopNTalkersbyResourceGroup].widgetType, WidgetName.TopNTalkersbyResourceGroup);
				dataWidgetConfig.nValue = ($scope.navalue)?parseInt($scope.navalue):50;
				//dataWidgetConfigArray.push(dataWidgetConfig);	
				var dataWidgetConfigArray = [];
				dataWidgetConfigArray.push(dataWidgetConfig);
				dataVisualizationService.getFilteredDataForWidgets(dataWidgetConfigArray).then(function(responseData){
					console.log("data for main query in drilldowndata");
					console.log(responseData);
					dataOnWidget = responseData.TopNTalkersbyResourceGroup;
				}).finally(function(){
					renderDrillDownData();	
				});
		};
		
		renderDrillDownData = function(){
			$scope.mainQueryData = dataOnWidget;
			$scope.drillDownDataPresent = false;
			$scope.mainCerticicatesAvaliable = true;

		};
		$scope.getListBasedOnCertficate = function(fiterItem){
			$scope.drillDownDataPresent = true;
			$scope.mainCerticicatesAvaliable = false;
			$scope.itemToBeFiltered = fiterItem;
			$scope.getDrillDownForTisItem = [];
			$scope.tableData = [];
			$scope.getDrillDownForTisItem.push(fiterItem);
			/*_.each(dataOnWidget,function(item){
				if(item.source === fiterItem.source){
					$scope.getDrillDownForTisItem.push(item);
				}
			});*/
			loadDrillDownDataFromServer(WidgetName.TopNTalkersbyResourceGroup, ChartTypes.barChart, getKeysForDrillDown($scope.getDrillDownForTisItem)).then(function(data){
				console.log('Data for this drilldown from server', data);
				$scope.drillDownSearchData = true;
				$scope.tableData = data;
			});
		};
		$scope.filterData = null;
         $scope.selectedRG = null;
		/* dataVisualizationService.getWidgetDrillDownFilteredData(WidgetName.TopNTalkersbyResourceGroup).then(function(filtterData){
		 	console.log(" TopNTalkersbyResourceGroup getWidgetDrillDownFilteredData ");
		 	console.dir(filtterData);
		 	$scope.filterData = filtterData;
		 });
*/
		 $scope.rgSelecttionChanged = function(){

		 };

		/* $scope.updateDirllDownInterval = function(){

		 	console.log("updateDirllDownInterval  ");
		 	console.dir($scope.selectedVM);

		 	loadDrillDownDataFromServer(WidgetName.TopNTalkersbyResourceGroup, ChartTypes.barChart, [$scope.selectedRG]).then(function(data){
			console.log(' TopNTalkersbyResourceGroup Data for this drilldown from server', data);
			$scope.tableData = data;
		});

		 };*/
		$timeout(function() {
	            fixContainerHeight(1);
		},0);
		$scope.onReorder = function(order){
            $scope.tableData.rowData =  $filter('orderBy')($scope.tableData.rowData,order);
            $timeout(function(){
                angular.element(document.querySelectorAll(".md-sort.md-active md-icon")).removeClass("ng-hide");
            }, 0);
            
        };
        $scope.getAllDrillDownData();
		/*loadDrillDownDataFromServer(WidgetName.TopNTalkersbyResourceGroup, ChartTypes.barChart, getKeysForDrillDown(dataOnWidget)).then(function(data){
			console.log('Data for this drilldown from server', data);
			$scope.tableData = data;
		}); */
	}
	angular.module('shieldxApp').controller('TopNTalkersbyResourceGroupCtr', TopNTalkersbyResourceGroupCtr);
})();
(function() {
	function TopNTalkersbyVMnameCtr($scope,dataVisualizationService,$timeout,$filter,$location) {
		console.log('TopNAttackerResourceGroups initialised');
		var parentScope = $scope.$parent.$parent;
		$scope.selected = [];
		var dataOnWidget = angular.copy(parentScope.drilldowndata);

		console.log(" TopNTalkersbyVMnameCtr  >>>> data");
		console.dir(dataOnWidget);
		
		$scope.title = widgetConfig.list.TopNTalkersbyVMname.title;
		$scope.updateDirllDownInterval = function(interval){
			$scope.timeInteval = interval;
		};
		$scope.updateDirllDownInterval = function(interval,nValue){
			if(interval === 'showMainData'){
				renderDrillDownData();
			}else{
				$scope.timeInteval = interval;
				$scope.navalue= nValue;
				$scope.getAllDrillDownData();	
				renderMainData();
				$scope.drillDownSearchData = false;
			}
		};
		$scope.url = $location.absUrl().split('#')[1];
		$scope.intervalOptions = WidgetDataUtil.drillDownIntervaloptions;
		function getKeysForDrillDown (list) {
			if(Array.isArray(list)) {
				var tempArray = [];
				_.forEach(list, function(value, key){
					tempArray.push({"source":value.source,"victim":value.victim});
				});
				console.log("getKeysForDrillDown ");
				console.dir(tempArray);
				return tempArray;
			}
		}
		
		$scope.$emit('listenHeaderText', { headerText: "Security Analysis tools > Top N VMs by Number of Connections" });
		$scope.getAllDrillDownData = function(){
			if( $scope.url.indexOf(WidgetName.TopNTalkersbyVMname) > 0 ){
				
				renderMainData();
			}else{
					renderDrillDownData();
				}
		};
		renderMainData = function(){
			var dataWidgetConfig = new DataWidgetConfig(widgetConfig.list[WidgetName.TopNTalkersbyVMname].widgetType, WidgetName.TopNTalkersbyVMname);
				dataWidgetConfig.nValue = ($scope.navalue)?parseInt($scope.navalue):50;
				//dataWidgetConfigArray.push(dataWidgetConfig);	
				var dataWidgetConfigArray = [];
				dataWidgetConfigArray.push(dataWidgetConfig);
				dataVisualizationService.getFilteredDataForWidgets(dataWidgetConfigArray).then(function(responseData){
					console.log("data for main query in drilldowndata");
					console.log(responseData);
					dataOnWidget = responseData.TopNTalkersbyVMname;
				}).finally(function(){
					renderDrillDownData();	
				});
		};
		renderDrillDownData = function(){
			$scope.mainQueryData = dataOnWidget;
			$scope.drillDownDataPresent = false;
			$scope.mainCerticicatesAvaliable = true;

		};
		$scope.getListBasedOnCertficate = function(fiterItem){
			$scope.drillDownDataPresent = true;
			$scope.mainCerticicatesAvaliable = false;
			$scope.itemToBeFiltered = fiterItem;
			$scope.getDrillDownForTisItem = [];
			$scope.tableData = [];
			$scope.getDrillDownForTisItem.push(fiterItem);
			/*_.each(dataOnWidget,function(item){
				if(item.source === fiterItem.source){
					$scope.getDrillDownForTisItem.push(item);
				}
			});*/
			loadDrillDownDataFromServer(WidgetName.TopNTalkersbyVMname, ChartTypes.barChart, getKeysForDrillDown($scope.getDrillDownForTisItem)).then(function(data){
				console.log('Data for this drilldown from server', data);
				$scope.drillDownSearchData = true;
				$scope.tableData = data;
			});
		};
		function loadDrillDownDataFromServer(widgetType,chartType,args) {
			console.log(" TopNTalkersbyVMname loadDrillDownDataFromServer args "+args);
            console.dir(args);
            var interval = ($scope.timeInteval)?($scope.timeInteval):30;
			var dataWidgetConfig = new DataWidgetConfig(chartType, widgetType,interval,args);
			
			return dataVisualizationService.getDrillDownDataForWidget(dataWidgetConfig).then(function (chartData) {
	        	console.log(" TopNTalkersbyVMname getDrillDownDataForWidget args "+chartData);
	        	console.dir(chartData);
				return chartData;
			});
		}
		/*$scope.tableData = {
			headers : [
				{title: 'title 1'},
				{title: 'title 2'},
				{title: 'title 3'},
				{title: 'title 4'},
				{title: 'title 5'}
			],
			rowData: [
				{ val1: 'abc', val2: 'def', val3: 'ghi', val4: 'jkl', val5: 'mno'},
				{ val1: 'abc', val2: 'def', val3: 'ghi', val4: 'jkl', val5: 'mno'},
				{ val1: 'abc', val2: 'def', val3: 'ghi', val4: 'jkl', val5: 'mno'},
				{ val1: 'abc', val2: 'def', val3: 'ghi', val4: 'jkl', val5: 'mno'},
				{ val1: 'abc', val2: 'def', val3: 'ghi', val4: 'jkl', val5: 'mno'},
				{ val1: 'abc', val2: 'def', val3: 'ghi', val4: 'jkl', val5: 'mno'},
				{ val1: 'abc', val2: 'def', val3: 'ghi', val4: 'jkl', val5: 'mno'},
				{ val1: 'abc', val2: 'def', val3: 'ghi', val4: 'jkl', val5: 'mno'},
				{ val1: 'abc', val2: 'def', val3: 'ghi', val4: 'jkl', val5: 'mno'},
				{ val1: 'abc', val2: 'def', val3: 'ghi', val4: 'jkl', val5: 'mno'}
			]			
		};*/
        //$scope.tableData = {};
		$scope.query = {
			order: 'name',
			limit: 10,
			page: 1
		};
		$timeout(function() {
	            fixContainerHeight(1);
		},0);

		/*loadDrillDownDataFromServer(WidgetName.TopNTalkersbyVMname, ChartTypes.barChart, getKeysForDrillDown(dataOnWidget)).then(function(data){
			console.log('Data for this drilldown from server', data);
			$scope.tableData = data;
		}); */
         $scope.filterData = null;
         $scope.selectedVM = null;
		/* dataVisualizationService.getWidgetDrillDownFilteredData(WidgetName.TopNTalkersbyVMname).then(function(filtterData){
		 	console.log(" TopNTalkersbyVMnameCtr getWidgetDrillDownFilteredData ");
		 	console.dir(filtterData);
		 	$scope.filterData = filtterData;
		 });*/

		 $scope.vmSelecttionChanged = function(){

		 };
		 $scope.onReorder = function(order){
            $scope.tableData.rowData =  $filter('orderBy')($scope.tableData.rowData,order);
            $timeout(function(){
                angular.element(document.querySelectorAll(".md-sort.md-active md-icon")).removeClass("ng-hide");
            }, 0);
            
        };

		 /*$scope.updateDirllDownInterval = function(){

		 	console.log("updateDirllDownInterval  ");
		 	console.dir($scope.selectedVM);

		 	loadDrillDownDataFromServer(WidgetName.TopNTalkersbyVMname, ChartTypes.barChart, [$scope.selectedVM]).then(function(data){
			console.log(' TopNTalkersbyVMnameCtr Data for this drilldown from server', data);
			$scope.tableData = data;
		});

		 };*/
		 $scope.getAllDrillDownData();
	}
	angular.module('shieldxApp').controller('TopNTalkersbyVMnameCtr', TopNTalkersbyVMnameCtr);
})();
(function() {
	function TopNVictimResourceGroupsCtr($scope,dataVisualizationService,$location,$timeout,$filter) {
		console.log('TopNVictimResourceGroupsCtr initialised');
		var parentScope = $scope.$parent.$parent;
		$scope.selected = [];
		var dataOnWidget = angular.copy(parentScope.drilldowndata);
		
		$scope.title = widgetConfig.list.TopNVictimResourceGroups.title;
		$scope.updateDirllDownInterval = function(interval){
			$scope.timeInteval = interval;
			$scope.getAllDrillDownData();
		};

		$scope.$emit('listenHeaderText', { headerText: "Security Analysis tools > Top N Victim Resource Groups" });
		$scope.url = $location.absUrl().split('#')[1];
		$scope.getAllDrillDownData = function(){
			if( $scope.url.indexOf(WidgetName.TopNVictimResourceGroups) > 0 ){
				
				var dataWidgetConfig = new DataWidgetConfig(widgetConfig.list[WidgetName.TopNVictimResourceGroups].widgetType, WidgetName.TopNVictimResourceGroups);
				dataWidgetConfig.nValue = 50;
				//dataWidgetConfigArray.push(dataWidgetConfig);	
				var dataWidgetConfigArray = [];
				dataWidgetConfigArray.push(dataWidgetConfig);
				dataVisualizationService.getFilteredDataForWidgets(dataWidgetConfigArray).then(function(responseData){
					console.log("data for main query in drilldowndata");
					console.log(responseData);
					dataOnWidget = responseData.TopNVictimResourceGroups;
				}).finally(function(){
					loadDrillDownDataFromServer(WidgetName.TopNVictimResourceGroups, ChartTypes.barChart,  getKeysForDrillDown(dataOnWidget)).then(function(data){
						console.log('Data for this drilldown from server', data);
						$scope.tableData = data;
					});
				});
			}else{
					loadDrillDownDataFromServer(WidgetName.TopNVictimResourceGroups, ChartTypes.barChart, getKeysForDrillDown(dataOnWidget)).then(function(data){
						console.log('Data for this drilldown from server', data);
						$scope.tableData = data;
					});
				}
		};
		$scope.intervalOptions = WidgetDataUtil.drillDownIntervaloptions;
		function getKeysForDrillDown (list) {
			if(Array.isArray(list)) {
				var tempArray = [];
				_.forEach(list, function(value, key){
					tempArray.push(value.Letter);
				});
				console.log("getKeysForDrillDown ");
				console.dir(tempArray);
				return tempArray;
			}
		}
		function loadDrillDownDataFromServer(widgetType,chartType,args) {
			console.log(" TopNVictimResourceGroupsCtr loadDrillDownDataFromServer args "+args);
            console.dir(args);
            var interval = ($scope.timeInteval)?($scope.timeInteval):30;
			var dataWidgetConfig = new DataWidgetConfig(chartType, widgetType,interval,args);
			
			return dataVisualizationService.getDrillDownDataForWidget(dataWidgetConfig).then(function (chartData) {
	        	console.log(" TopNVictimResourceGroupsCtr getDrillDownDataForWidget args "+chartData);
	        	console.dir(chartData);
				return chartData;
			});
		}
		/*$scope.tableData = {
			headers : [
				{title: 'title 1'},
				{title: 'title 2'},
				{title: 'title 3'},
				{title: 'title 4'},
				{title: 'title 5'}
			],
			rowData: [
				{ val1: 'abc', val2: 'def', val3: 'ghi', val4: 'jkl', val5: 'mno'},
				{ val1: 'abc', val2: 'def', val3: 'ghi', val4: 'jkl', val5: 'mno'},
				{ val1: 'abc', val2: 'def', val3: 'ghi', val4: 'jkl', val5: 'mno'},
				{ val1: 'abc', val2: 'def', val3: 'ghi', val4: 'jkl', val5: 'mno'},
				{ val1: 'abc', val2: 'def', val3: 'ghi', val4: 'jkl', val5: 'mno'},
				{ val1: 'abc', val2: 'def', val3: 'ghi', val4: 'jkl', val5: 'mno'},
				{ val1: 'abc', val2: 'def', val3: 'ghi', val4: 'jkl', val5: 'mno'},
				{ val1: 'abc', val2: 'def', val3: 'ghi', val4: 'jkl', val5: 'mno'},
				{ val1: 'abc', val2: 'def', val3: 'ghi', val4: 'jkl', val5: 'mno'},
				{ val1: 'abc', val2: 'def', val3: 'ghi', val4: 'jkl', val5: 'mno'}
			]			
		};*/
        //$scope.tableData = {};
        $scope.getAllDrillDownData();
		$scope.query = {
			order: 'name',
			limit: 10,
			page: 1
		};
		$timeout(function() {
	            fixContainerHeight(1);
		},0);
		$scope.onReorder = function(order){
            $scope.tableData.rowData =  $filter('orderBy')($scope.tableData.rowData,order);
            $timeout(function(){
                angular.element(document.querySelectorAll(".md-sort.md-active md-icon")).removeClass("ng-hide");
            }, 0);
            
        };

	}
	angular.module('shieldxApp').controller('TopNVictimResourceGroupsCtr', TopNVictimResourceGroupsCtr);
})();
(function() {
	function TopNVictimsCtr($scope,dataVisualizationService,$location,$timeout,$filter) {
		console.log('TopNVictimsCtr initialised');
		var parentScope = $scope.$parent.$parent;
		$scope.selected = [];
		var dataOnWidget = angular.copy(parentScope.drilldowndata);
		
		$scope.title = widgetConfig.list.TopNVictims.title;

		$scope.$emit('listenHeaderText', { headerText: "Security Analysis tools > Top N Victims" });
		$scope.url = $location.absUrl().split('#')[1];
		$scope.getAllDrillDownData = function(){
			if( $scope.url.indexOf(WidgetName.TopNVictims) > 0 ){
				
				var dataWidgetConfig = new DataWidgetConfig(widgetConfig.list[WidgetName.TopNVictims].widgetType, WidgetName.TopNVictims);
				dataWidgetConfig.nValue = 50;
				//dataWidgetConfigArray.push(dataWidgetConfig);	
				var dataWidgetConfigArray = [];
				dataWidgetConfigArray.push(dataWidgetConfig);
				dataVisualizationService.getFilteredDataForWidgets(dataWidgetConfigArray).then(function(responseData){
					console.log("data for main query in drilldowndata");
					console.log(responseData);
					dataOnWidget = responseData.TopNVictims;
				}).finally(function(){
					loadDrillDownDataFromServer(WidgetName.TopNVictims, ChartTypes.barChart,  getKeysForDrillDown(dataOnWidget)).then(function(data){
						console.log('Data for this drilldown from server', data);
						$scope.tableData = data;
					});
				});
			}else{
				loadDrillDownDataFromServer(WidgetName.TopNVictims, ChartTypes.barChart,  getKeysForDrillDown(dataOnWidget)).then(function(data){
						console.log('Data for this drilldown from server', data);
						$scope.tableData = data;
					});
			}
		};
		$scope.updateDirllDownInterval = function(interval){
			$scope.timeInteval = interval;
			$scope.getAllDrillDownData();
		};
		$scope.intervalOptions = WidgetDataUtil.drillDownIntervaloptions;
		function getKeysForDrillDown (list) {
			if(Array.isArray(list)) {
				var tempArray = [];
				_.forEach(list, function(value, key){
					tempArray.push(value.Letter);
				});
				console.log("getKeysForDrillDown ");
				console.dir(tempArray);
				return tempArray;
			}
		}
		function loadDrillDownDataFromServer(widgetType,chartType,args) {
			console.log(" TopNVictimsCtr loadDrillDownDataFromServer args "+args);
            console.dir(args);
            var interval = ($scope.timeInteval)?($scope.timeInteval):30;
			var dataWidgetConfig = new DataWidgetConfig(chartType, widgetType,interval,args);
	
			return dataVisualizationService.getDrillDownDataForWidget(dataWidgetConfig).then(function (chartData) {
	        	console.log(" TopNVictimsCtr getDrillDownDataForWidget args "+chartData);
	        	console.dir(chartData);
				return chartData;
			});
		}
		$scope.getAllDrillDownData();
        $scope.tableData = {};
		$scope.query = {
			order: 'name',
			limit: 10,
			page: 1
		};
		$timeout(function() {
	            fixContainerHeight(1);
		},0);
		$scope.onReorder = function(order){
            $scope.tableData.rowData =  $filter('orderBy')($scope.tableData.rowData,order);
            $timeout(function(){
                angular.element(document.querySelectorAll(".md-sort.md-active md-icon")).removeClass("ng-hide");
            }, 0);
            
        };
		/*loadDrillDownDataFromServer(WidgetName.TopNVictims, ChartTypes.barChart, 30, getKeysForDrillDown(dataOnWidget)).then(function(data){
			console.log('Data for this drilldown from server', data);
			$scope.tableData = data;
		});*/
	}
	angular.module('shieldxApp').controller('TopNVictimsCtr', TopNVictimsCtr);
})();
/*
 ShieldX Networks Inc. CONFIDENTIAL
 ----------------------------------
 *
 Copyright (c) 2016 ShieldX Networks Inc.
 All Rights Reserved.
 *
 NOTICE: All information contained herein is, and remains
 the property of ShieldX Networks Incorporated and its suppliers,
 if any. The intellectual and technical concepts contained
 herein are proprietary to ShieldX Networks Incorporated
 and its suppliers and may be covered by U.S. and Foreign Patents,
 patents in process, and are protected by trade secret or copyright law.
 Dissemination of this information or reproduction of this material
 is strictly forbidden unless prior written permission is obtained
 from ShieldX Networks Incorporated.
 */

(function () {
    function ManagmentNetworkDialogCtr($scope, $mdDialog, ipPoolServices, title, selectedNetworkID) {


        $scope.selectedNetworkID = selectedNetworkID;
        $scope.title = title;
        $scope.networkFetched = false;
        $scope.newtworks = [];
        $scope.numberOfNetwork = $scope.newtworks.length;

        $scope.selectEnableState = false;
         $scope.methodBridge = new MethodBridge();
        ipPoolServices.getNetworksFromCache({success: function (data) {
                console.log("data recived &&&& ");
                console.dir(data);
                $scope.newtworks = [];
                for (var i in data) {
                    $scope.newtworks.push({id: data[i].id, label: data[i].name, data: ""});
                }
                // console.dir($scope.managmentNetworks); 
                $scope.numberOfNetwork = $scope.newtworks.length;
                $scope.methodBridge.call($scope.newtworks);
                $scope.networkFetched = true;
            }
        });

        $scope.onSelectionChanged = function () {
            console.log(" onSelectionChanged >> ");
            $scope.selectEnableState = true;
        };

        $scope.hide = function () {
            $mdDialog.hide();
        };
        $scope.closeDialog = function () {
            $mdDialog.cancel();
        };
        $scope.closeDialogWithAnswer = function (answer) {
            console.log(" answer " + answer);
            var returnVal = {selectedVal: answer, newtworks: $scope.newtworks};
            $mdDialog.hide(returnVal);
        };
    }
    angular.module('shieldxApp').controller('managmentNetworkDialogCtr', ManagmentNetworkDialogCtr);

    function BackPaneNetworkDialogCtr($scope, $mdDialog, ipPoolServices, title, selectedNetworkID) {
        console.log(" BackPaneNetworkDialogCtr ");
        $scope.title = title;

        $scope.selectedNetworkID = selectedNetworkID;
        $scope.newtworks = [];
        $scope.numberOfNetwork = $scope.newtworks.length;
        $scope.networkFetched = false;

        $scope.selectEnableState = false;

        ipPoolServices.getNetworksFromCache({success: function (data) {
                console.log("data recived &&&& ");
                console.dir(data);
                $scope.newtworks = [];
                for (var i in data) {
                    $scope.newtworks.push({id: data[i].id, label: data[i].name, data: ""});
                }
                // console.dir($scope.managmentNetworks); 
                $scope.numberOfNetwork = $scope.newtworks.length;
                $scope.networkFetched = true;
            }
        });

        $scope.onSelectionChanged = function () {
            $scope.selectEnableState = true;
        };

        $scope.hide = function () {
            $mdDialog.hide();
        };
        $scope.closeDialog = function () {
            $mdDialog.cancel();
        };
        $scope.closeDialogWithAnswer = function (answer) {
            var returnVal = {selectedVal: answer, newtworks: $scope.newtworks};
            $mdDialog.hide(returnVal);
        };
    }
    angular.module('shieldxApp').controller('backPaneNetworkDialogCtr', BackPaneNetworkDialogCtr);
})();
(function () {
 
    function AnimationDialogCtr($scope, $mdDialog) {
        console.log(" AnimationDialogCtr ");
        
        $scope.closButtonClicked = function () {
            console.log(" closButtonClicked ");
            $mdDialog.hide();
        };
        
    }
    angular.module('shieldxApp').controller('AnimationDialogCtr', AnimationDialogCtr);
})();